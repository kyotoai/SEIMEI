["MODULE GKV_freq\n!-------------------------------------------------------------------------------\n!\n!    Module for evaluating linear growth rate and real frequency\n!    (without shearflows)\n!\n!    Update history of gkvp_freq.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - nxfrq=min(5,nx,nx0) to avoid zero division when nx0=0.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  real(kind=DP), parameter :: eps_omega = 1.d-2, &\n                              eps_gamma = 1.d-2, &\n                              eps_ineq  = 1.d-2\n\n  integer, save :: nxfrq = nx\n  real(kind=DP), save :: time0 = 0._DP\n  complex(kind=DP), allocatable, save, dimension(:,:,:) :: phi0\n  complex(kind=DP), allocatable, save, dimension(:,:) :: omega0\n  real(kind=DP), allocatable, save, dimension(:,:) :: phi0_norm2\n\n  complex(kind=DP), allocatable, save, dimension(:,:) :: omega_g\n  complex(kind=DP), allocatable, save, dimension(:,:) :: diff_g\n  real(kind=DP), allocatable, save, dimension(:,:) :: ineq_g\n  logical, allocatable, save, dimension(:,:) :: freq_conv\n\n  public :: freq_set, freq_write_frq, freq_write_dsp, freq_conv\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE freq_set ( time )\n!--------------------------------------\n\n    real(kind=DP), intent(in)           :: time\n\n    integer :: mx, my\n\n\n      nxfrq = min( 5, nx, nx0 )\n      time0 = time\n  \n      allocate( phi0(-nxfrq:nxfrq,0:ny,-nz:nz-1) )\n      allocate( omega0(-nxfrq:nxfrq,0:ny) )\n      allocate( phi0_norm2(-nxfrq:nxfrq,0:ny) )\n      allocate( omega_g(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n      allocate( diff_g(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n      allocate( ineq_g(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n      allocate( freq_conv(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n  \n      phi0(:,:,:) = ( 0._DP, 0._DP )\n      omega0(:,:) = ( 0._DP, 0._DP )\n      phi0_norm2(:,:) = 0._DP\n      omega_g(:,:) = ( 0._DP, 0._DP )\n      diff_g(:,:) = ( 0._DP, 0._DP )\n      ineq_g(:,:) = 0._DP\n      freq_conv(:,:) =.false.\n      \n!- write hst/*.frq.* -\n      if ( rankg == 0 ) then\n        write(ofrq, fmt=\"(a)\") \"#  Re[omega], Im[omega] for (kx,ky)\"\n        write(ofrq, fmt=\"(99a17)\", advance=\"no\") \"#            time\"\n        do mx = 0, nxfrq\n          do my = 1, global_ny\n            write(ofrq, \"(a,f7.3,a,f7.3,a)\", advance=\"no\")  &\n                \"(\", kx(mx), \",\", ky(1) * real(my, kind=DP), \")\"\n            write(ofrq, \"(a17)\", advance=\"no\") \" \"\n          end do\n        end do\n        if (nxfrq > 0) then\n          do mx = -nxfrq, -1\n            do my = 1, global_ny\n              write(ofrq, \"(a,f7.3,a,f7.3,a)\", advance=\"no\")  &\n                  \"(\", kx(mx), \",\", ky(1) * real(my, kind=DP), \")\"\n              write(ofrq, \"(a17)\", advance=\"no\") \" \"\n            end do\n          end do\n        end if\n        write(ofrq, *)\n      end if\n\n  END SUBROUTINE freq_set\n\n\n!--------------------------------------\n  SUBROUTINE freq_reset\n!--------------------------------------\n\n\n      deallocate( phi0 )\n      deallocate( omega0 )\n      deallocate( phi0_norm2 )\n      deallocate( omega_g )\n      deallocate( diff_g )\n      deallocate( ineq_g )\n      deallocate( freq_conv )\n                                     !%%% For debug %%%\n                                     !write(olog,*) \"freq_reset\"\n                                     !%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE freq_reset\n\n\n!--------------------------------------\n  SUBROUTINE freq_write_frq ( time, phi )\n!--------------------------------------\n\n    real(kind=DP), intent(in)           :: time\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)   :: phi\n\n    complex(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: phi0phi, omega_l, diff_l\n    real(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: phi_norm2, ineq_l\n    complex(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: wc3\n    real(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: wr3\n    integer :: mx, my, iz\n\n    integer, save ::  iflg\n    data iflg / 0 /\n\n\n      if( iflg == 0 ) then\n        iflg = 1\n        phi0(-nxfrq:nxfrq,:,:) = phi(-nxfrq:nxfrq,:,:)\n        phi0_norm2(:,:) = 0._DP\n        wr3(:,:) = 0._DP\n        do iz = -nz, nz-1\n          do my = ist1_y, iend_y\n            do mx = -nxfrq, nxfrq\n              wr3(mx,my) = wr3(mx,my) + abs( phi(mx,my,iz) )**2\n            end do\n          end do\n        end do\n        call MPI_Allreduce( wr3, phi0_norm2, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n        return\n      end if\n\n\n!- calculate interior products -\n      phi0phi(:,:) = (0._DP, 0._DP)\n      wc3(:,:) = (0._DP, 0._DP)\n      do iz = -nz, nz-1\n        do my = ist1_y, iend_y\n          do mx = -nxfrq, nxfrq\n            wc3(mx,my) = wc3(mx,my) + conjg( phi0(mx,my,iz) ) * phi(mx,my,iz)\n          end do\n        end do\n      end do\n      call MPI_Allreduce( wc3, phi0phi, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n      phi_norm2(:,:) = 0._DP\n      wr3(:,:) = 0._DP\n      do iz = -nz, nz-1\n        do my = ist1_y, iend_y\n          do mx = -nxfrq, nxfrq\n            wr3(mx,my) = wr3(mx,my) + abs( phi(mx,my,iz) )**2\n          end do\n        end do\n      end do\n      call MPI_Allreduce( wr3, phi_norm2, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n!- calculate frequency -\n      omega_l(:,:) = (0._DP, 0._DP)\n      do my = ist1_y, iend_y\n        do mx = -nxfrq, nxfrq\n          omega_l(mx,my) = log( phi0phi(mx,my) / phi0_norm2(mx,my) )  &\n                                      / ( ui * ( time0 - time ) )\n        end do\n      end do\n      call MPI_Allgather( omega_l, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          omega_g, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          fft_comm_world, ierr_mpi )\n\n!- convergence check -\n      diff_l(:,:) = (0._DP, 0._DP)\n      do my = ist1_y, iend_y\n        do mx = -nxfrq, nxfrq\n          diff_l(mx,my) = abs(real(omega_l(mx,my) - omega0(mx,my), kind=DP)  &\n                                      / real(omega_l(mx,my), kind=DP)) / (time - time0) &\n                        + ui * abs(aimag(omega_l(mx,my) - omega0(mx,my))     &\n                                      / aimag(omega_l(mx,my)) ) / (time - time0)\n        end do\n      end do\n      call MPI_Allgather( diff_l, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          diff_g, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          fft_comm_world, ierr_mpi )\n\n      ineq_l(:,:) = 0._DP\n      do my = ist1_y, iend_y\n        do mx = -nxfrq, nxfrq\n          ineq_l(mx,my) = sqrt(abs(phi0phi(mx,my))**2 / (phi0_norm2(mx,my) * phi_norm2(mx,my)))\n        end do\n      end do\n      call MPI_Allgather( ineq_l, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                          ineq_g, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                          fft_comm_world, ierr_mpi )\n\n      do my = 1, global_ny\n        do mx = -nxfrq, nxfrq\n          if ( real( diff_g(mx,my), kind=DP ) < eps_omega.and.  &\n               aimag( diff_g(mx,my) ) < eps_gamma.and.          &\n               abs(1._DP - ineq_g(mx,my)) < eps_ineq ) then\n            freq_conv(mx,my) =.true.\n          else\n            freq_conv(mx,my) =.false.\n          end if\n        end do\n      end do\n\n      freq_conv(:,0) =.true.\n      if ( global_ny < (ny+1)*nprocw-1 ) then\n        do my = global_ny+1, (ny+1)*nprocw-1\n          diff_g(:,my) = ( 0._DP, 0._DP )\n          omega_g(:,my) = ( 0._DP, 0._DP )\n          ineq_g(:,my) = 0._DP\n          freq_conv(:,my) =.true.\n        end do\n      end if\n\n!- remember the values -\n      time0 = time\n      phi0(-nxfrq:nxfrq,:,:) = phi(-nxfrq:nxfrq,:,:)\n      omega0(:,:) = omega_l(:,:)\n      phi0_norm2(:,:) = phi_norm2(:,:)\n\n!- write hst/*.frq.* -\n      if ( rankg == 0 ) then\n       !write( ofrq, '(9999G17.7e3)' ) time, (omega_g(0,my), my=1,global_ny)\n         write( ofrq, '(9999G17.7e3)' ) time, ((omega_g(mx,my), my=1,global_ny), mx=0,nxfrq)\n      end if\n                                     !%%% For debug %%%\n                                     !write(olog,*) \"freq_write_frq at t=\",time\n                                     !%%%%%%%%%%%%%%%%%\n\nEND SUBROUTINE freq_write_frq\n\n\n!--------------------------------------\n  SUBROUTINE freq_write_dsp\n!--------------------------------------\n\n    integer :: mx, my\n\n\n      if ( rankg == 0 ) then\n        write( odsp, '(99A17)' ) \"#              kx\",\"ky\",\"frequency\",\"growthrate\",&\n                                           \"diff(freq)\",\"diff(grow)\",\"1-ineq\"\n        do mx = -nxfrq, nxfrq\n          do my = 1, global_ny\n            if ( freq_conv(mx,my) ) then\n              write( odsp, '(9999G17.7e3)' ) kx(mx), ky(1) * real( my, kind=DP ),       &\n                         real( omega_g(mx,my), kind=DP ), aimag( omega_g(mx,my) ),    &\n                         real( diff_g(mx,my), kind=DP ), aimag( diff_g(mx,my) ),      &\n                         abs(1._DP - ineq_g(mx,my))\n            else\n              write( odsp, '(A2,9999G17.7e3)' ) \"# \", kx(mx), ky(1) * real( my, kind=DP ),&\n                         real( omega_g(mx,my), kind=DP ), aimag( omega_g(mx,my) ),      &\n                         real( diff_g(mx,my), kind=DP ), aimag( diff_g(mx,my) ),        &\n                         abs(1._DP - ineq_g(mx,my))\n            end if\n          end do\n          write( odsp, * )\n        end do\n\n      end if\n  \n      call freq_reset\n                                     !%%% For debug %%%\n                                     !write(olog,*) \"freq_write_dsp\"\n                                     !%%%%%%%%%%%%%%%%%\n\n\n  END SUBROUTINE freq_write_dsp\n\n\nEND MODULE GKV_freq\n", "MODULE GKV_vmecin\n!-------------------------------------------------------------------------------\n!\n!    Calculate the magnetic field components and metric coefficients\n!      from the VMEC equilibrium\n!\n!      GKV-plus r0.6 ( T.-H.Watanabe and M. Nunami, Dec 2011 )\n!\n!      This module utilizes subroutines developed by M. Nunami\n!         for the GKV-X code\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public :: vmecin_fileopen, vmecin_coeff, vmecin_read\n\n\n!*****************************************************************************************\n!****************                                                         ****************\n!********                    shot# 088343   t = 1.833 [s]                         ********\n!****************                                                         ****************\n!*****************************************************************************************\n\n!== Paramters at rho=0.65 ======I N W A R D============================================\n!-*** common parameter at rho=0.65 ***------------------------------------------------\n!   real(kind=DP), parameter :: Ln_unit =-4.230701_DP                      ! Ln [m]\n!   real(kind=DP), parameter :: Lt_unit = 0.3135611_DP                     ! Lt [m]\n!-------------------------------------------------------------------------------------\n\n!-- For inward-LHD vacuum\" -----------------------------------------------------------\n!   real(kind=DP), parameter :: R0_unit = 3.599858_DP                      ! R0 [m]\n!   real(kind=DP), parameter :: r_edge  = 0.6362872D0                      ! r_edge [m]\n!   real(kind=DP), parameter :: b0b00   = 2.88846853946973647d0/2.940307D0 ! b00mode/B0\n!-------------------------------------------------------------------------------------\n\n\n!========================================================================\n!==  MODULES variables FOR VMEC                                                            \n!========================================================================\n\n!!!!! === MODULE NEWBOZ\n! ... originally contained param.\n  integer(kind=4), parameter :: NBZMIN = -20,NBZMAX = 20, MBZMAX = 100, &\n                                IBHAR  = ( NBZMAX - NBZMIN + 1 )*MBZMAX \n! ... from pmnsd\n  integer(kind=4), parameter :: NSD_MAX=501\n\n! ... from pmims\n! integer(kind=4), parameter :: KMSH_MAX=NSD_MAX-1, MDMX_MAX=101\n! ... from newboz\n  real(kind=8), save, dimension(IBHAR,NSD_MAX) :: BBOZH,RBOZH,ZBOZH,PBOZH\n  real(kind=8), save, dimension(NSD_MAX)       :: PSIBZ,EOTBZ,CUIBZ,CUGBZ\n  integer(kind=4), save, dimension(IBHAR)      :: MBOZ,NBOZ\n  integer(kind=4), save                        :: NFP,NMBOZ\n\n!!!!! === MODULE bcoef\n  real(kind=8), save, dimension(:,:), allocatable :: BCO,C1BF,C2BF,C3BF\n  real(kind=8), save, dimension(:),   allocatable :: CM,CN,SPOS,PSIB,    &\n       EOT,C1ET,C2ET,C3ET,CUI,C1I,C2I,C3I,CUG,C1G,C2G,C3G,         &\n       TXI,C1TI,C2TI,C3TI,TXE,C1TE,C2TE,C3TE,DXI,C1DI,C2DI,C3DI,   &\n       DLN,C1LN,C2LN,C3LN     \n  real(kind=8), save, dimension(:,:), allocatable :: bco0\n  real(kind=8), save, dimension(:),   allocatable :: spos0\n\n!!!!! === MODULE xcoef\n  real(kind=8), save, dimension(:,:), allocatable :: RCO,ZCO,PCO,        &\n                               C1R,C2R,C3R,C1Z,C2Z,C3Z,C1P,C2P,C3P\n  real(kind=8), save, dimension(:,:), allocatable :: rco0,zco0,pco0\n\n!!!!! === MODULE pcoef\n  real(kind=8), save, dimension(0:10) :: dn0,ti0,te0\n\n!!!!! === MODULE param1\n  integer(kind=4), save :: kmsh, kmsh1, nsd, mdmx, itype\n!\n!!!!! === MODULE bpara\n  real(kind=8), save    :: bb0,psia,sa,rmaj0,zi,nmass\n\n  real(kind=DP), save   :: ss, cug1, cui1\n\n  integer, save :: jp0\n\n!========================================================================\n\n  integer :: ndiskc = inbz\n!!!  integer :: ndiskc = 14\n!!!  integer :: ivmc = 15, ovmc = olog  ! move to GKV_header\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE vmecin_fileopen\n!--------------------------------------\n\n    implicit none\n\n    character(512) :: f_nbz, f_vmc\n\n    namelist /vmecf/ f_nbz, f_vmc\n\n\n      read(inml,nml=vmecf)\n\n      write(olog,*) \"# newboz and vmec input files : \"\n      write(olog,*) trim(f_nbz), trim(f_vmc)\n\n      open( inbz, file=trim(f_nbz), form=\"unformatted\", &\n                  status=\"old\", action=\"read\" )\n      open( ivmc, file=trim(f_vmc), &\n                  status=\"old\", action=\"read\" )\n\n\n  END SUBROUTINE vmecin_fileopen\n\n\n!--------------------------------------\n  SUBROUTINE vmecin_coeff( rad_a, R0_unit, rho2R_0, q_input, theta, alpha_fix, &\n                           r_0, r_minor, s_hat,                                &\n                           gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz,           &\n                           gupss, guptt, gupzz, gupst, gupsz, guptz,           &\n                           babs, Bs, Bth, Bzt, dBds, dBdt, dBdz,               &\n                           dBdt_mir, rootg, rootgft, rootgbz )\n!--------------------------------------\n    implicit none\n\n! --- arguments\n\n    real(kind=DP), intent(in)  :: rad_a, R0_unit, rho2R_0, q_input, theta, alpha_fix\n    real(kind=DP), intent(out) :: r_0, r_minor, s_hat \n    real(kind=DP), intent(out) ::                          &\n                 gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz, &\n                 gupss, guptt, gupzz, gupst, gupsz, guptz, &\n                 babs, Bs  , Bth , Bzt , dBds, dBdt, dBdz, &\n                 dBdt_mir, rootg, rootgft, rootgbz\n\n\n! -- For read_VMEC routine -------------------------------------\n!!!    integer, parameter :: npmax=100\n!!!    real(kind=DP)  :: ssi(npmax)\n    real(kind=DP), dimension(:), allocatable  :: ssi\n\n    integer, save  :: npsi=0,ntheta,nzeta\n\n    real(kind=DP)  :: zeta,rmaj,ph,cx,sx\n    real(kind=DP)  :: dRds,dZds,dPds\n    real(kind=DP)  :: dRdt,dZdt,dPdt\n    real(kind=DP)  :: dRdz,dZdz,dPdz\n    real(kind=DP)  :: bci, rci, zci, pci\n    real(kind=DP)  :: dbci,drci,dzci,dpci\n\n    real(kind=DP)  :: rg2inv\n\n!!!12.22    real(kind=DP)  :: Bs, Bth, Bzt\n\n    real(kind=DP)  :: B00mode, dB00mode\n    real(kind=DP)  :: Bm1_0mode,   dBm1_0mode\n    real(kind=DP)  :: Bm1_10mode,   B0_10mode,  Bp1_10mode\n    real(kind=DP)  :: dBm1_10mode,  dB0_10mode, dBp1_10mode\n\n    real(kind=DP)  :: ds, ss, r_a\n    real(kind=DP)  :: q_00, dq00, eot0, diff_q, q_vmec\n    real(kind=DP)  :: dq_0, eot1, cug1, cui1\n    real(kind=DP)  :: dsfix\n    integer        :: inm, is, iis, jp, jp0\n\n    real(kind=DP)  :: q_0\n\n!!!12.22    real(kind=DP)  :: rho_unit, L_n, L_t, rho2R_0  ! nunami (10.04.15)\n\n\n    integer, save :: isw = 0\n  \n\n    namelist /zahyoin/npsi,ntheta,nzeta\n\n\n    if( isw == 0 ) then\n      read(inml,nml=zahyoin)\n    end if\n\n    allocate ( ssi(npsi+1) )\n\n\n    r_a      = rad_a * rho2R_0             ! --- rad_a / R_0\n\n    do iis=1,npsi+1\n      ssi(iis) = dble(iis-1)/dble(npsi)\n      ss       = ssi(iis)\n      jp0      = int(ss*dble(kmsh))+1\n      ds       = ss - spos(jp0)\n\n! -- For Safety Factor----------------------------------------------------------------------\n      eot0  =   eot(jp0)+(c1et(jp0)+(c2et(jp0)+c3et(jp0)*ds)*ds)*ds          ! rotational transform\n      q_00  =   1.d0/eot0                                                    ! safety factor\n      dq00  = - q_00 * q_00 * (c1et(jp0)+(2.d0*c2et(jp0)+3.d0*c3et(jp0)*ds)*ds)  ! dq/ds\n! ------------------------------------------------------------------------------------------\n\n      diff_q  = q_input - q_00\n\n      if(abs(diff_q) < 0.02d0 ) then\n        q_0   = q_input\n        q_vmec= q_00\n        eot1  = eot0\n        is    = iis\n        dq_0  = dq00\n        jp    = jp0\n        dsfix = ds\n      endif\n\n    enddo\n\n    ss = ssi(is)\n    ds = dsfix\n\n! This is to adjust to Nunami's version (Dec 2011)\n! It should be confirmed how q is determined in consistent with r_minor\n    r_minor  = rad_a * ss                       ! in unit of rho\n\n    s_hat    = (ss / q_0) * dq_0\n\n    r_0  = r_minor * rho2R_0    !! by nunami (10.04.18)\n\n!!!    s_hat0   = (r_0 / q_0) * dq_0\n\n! -- troidal & poloidal current ------------------------------------------------------------\n    cug1  = cug(jp) + ( c1g(jp) + ( c2g(jp) + c3g(jp) * ds ) * ds ) * ds   ! G : poloidal\n    cui1  = cui(jp) + ( c1i(jp) + ( c2i(jp) + c3i(jp) * ds ) * ds ) * ds   ! I : toroidal\n! ------------------------------------------------------------------------------------------\n\n\n\n! ======================================================================================\n\n!!!    th_shift = -alpha_fix / q_0\n\n!!!      theta = zz(iz)                   ! theta\n      zeta  = theta * q_0 + alpha_fix  ! from alpha = zeta - q*theta = 0\n\n      rmaj = 0.0d0\n      babs = 0.0d0\n\n      dBds = 0.0d0\n      dRds = 0.0d0\n      dZds = 0.0d0\n      dPds = 0.0d0\n\n      dBdt = 0.0d0\n      dRdt = 0.0d0\n      dZdt = 0.0d0\n      dPdt = 0.0d0\n\n      dBdt_mir = 0.0d0\n\n      dBdz = 0.0d0\n      dRdz = 0.0d0\n      dZdz = 0.0d0\n      dPdz = 1.0d0   ! !!should be 1.0, not 0.0!!\n\n! --- Summation of Fourier components ---\n      do inm=1, mdmx+1\n        bci  = bco(jp,inm) + ( c1bf(jp,inm)+ ( c2bf(jp,inm) + c3bf(jp,inm) * ds ) * ds ) * ds\n        rci  = rco(jp,inm) + ( c1r(jp,inm) + ( c2r(jp,inm)  + c3r(jp,inm)  * ds ) * ds ) * ds\n        zci  = zco(jp,inm) + ( c1z(jp,inm) + ( c2z(jp,inm)  + c3z(jp,inm)  * ds ) * ds ) * ds\n        pci  = pco(jp,inm) + ( c1p(jp,inm) + ( c2p(jp,inm)  + c3p(jp,inm)  * ds ) * ds ) * ds\n        dbci = c1bf(jp,inm)+ ( 2.d0 * c2bf(jp,inm) + 3.d0 * c3bf(jp,inm) * ds ) * ds \n        drci = c1r(jp,inm) + ( 2.d0 * c2r(jp,inm)  + 3.d0 * c3r(jp,inm)  * ds ) * ds\n        dzci = c1z(jp,inm) + ( 2.d0 * c2z(jp,inm)  + 3.d0 * c3z(jp,inm)  * ds ) * ds\n        dpci = c1p(jp,inm) + ( 2.d0 * c2p(jp,inm)  + 3.d0 * c3p(jp,inm)  * ds ) * ds\n\n        if(cn(inm)==0 .and. cm(inm)==0) then\n          B00mode = bci !bco(jp,inm)               ! (m,n)=(0,0) component of B\n          dB00mode = dbci\n        endif\n\n        if(cn(inm)==0) then\n          if(cm(inm)==-1) then\n             Bm1_0mode  =  bci\n            dBm1_0mode  = dbci\n          endif\n        endif\n\n\n        if(cn(inm)==-10) then\n          if(cm(inm)==-2) then                 ! (m,n)=(0,10) mode\n             B0_10mode  =  bci\n            dB0_10mode  = dbci\n          elseif(cm(inm)==-3) then\n             Bm1_10mode =  bci\n            dBm1_10mode = dbci\n          elseif(cm(inm)==-1) then\n             Bp1_10mode =  bci\n            dBp1_10mode = dbci\n          endif\n        endif\n\n        ph = cn(inm) * zeta - cm(inm) * theta\n        cx = cos(ph)                          ! cos(n*zeta - m*theta)\n        sx = sin(ph)                          ! sin(n*zeta - m*theta)\n\n        rmaj =  rci * cx + rmaj               ! R in (R,Phi,Z)\n        babs =  bci * cx + babs               ! Absolute of B \n\n        dBds =  dbci * cx + dBds              ! dB/ds\n        dRds =  drci * cx + dRds              ! dR/ds\n        dZds =  dzci * sx + dZds              ! dZ/ds\n        dPds =  dpci * sx + dPds              ! d(phi)/ds\n\n        dBdt =  bci  * sx * cm(inm) + dBdt    ! dB/d(theta)\n        dRdt =  rci  * sx * cm(inm) + dRdt    ! dR/d(theta)\n        dZdt = -zci  * cx * cm(inm) + dZdt    ! dZ/d(theta)\n        dPdt = -pci  * cx * cm(inm) + dPdt    ! d(phi)/d(theta)\n\n!-- dB/d(theta) for mirror term \"mir\"  --- 100109 nunami -----------------\n        dBdt_mir =  bci  * sx * (cm(inm)-cn(inm)*q_0) + dBdt_mir\n!-------------------------------------------------------------------------\n\n        dBdz = -bci  * sx * cn(inm) + dBdz    ! dB/d(zeta)\n        dRdz = -rci  * sx * cn(inm) + dRdz    ! dR/d(zeta)\n        dZdz =  zci  * cx * cn(inm) + dZdz    ! dZ/d(zeta)\n        dPdz =  pci  * cx * cn(inm) + dPdz    ! d(phi)/d(zeta)\n      end do\n! ------------------------------------------------------------------------\n!\n! ---- Covariant componets of the metric tensor --------------------------------------\n      gdwss  = dRds**2   + dZds**2   + (rmaj*dPds)**2         ! g_s_s\n      gdwtt  = dRdt**2   + dZdt**2   + (rmaj*dPdt)**2         ! g_theta_theta\n      gdwzz  = dRdz**2   + dZdz**2   + (rmaj*dPdz)**2         ! g_zeta_zeta\n      gdwst  = dRds*dRdt + dZds*dZdt + (rmaj**2)*dPds*dPdt    ! g_s_theta\n      gdwsz  = dRds*dRdz + dZds*dZdz + (rmaj**2)*dPds*dPdz    ! g_s_zeta\n      gdwtz  = dRdt*dRdz + dZdt*dZdz + (rmaj**2)*dPdt*dPdz    ! g_theta_zeta\n! ------------------------------------------------------------------------------------\n!\n! ---- For Jacobian in (s,theta,zeta) coordinates ------------------------------------\n      rootg  = (2.d0 * ss * psia) * ( cug1 + eot1 * cui1 ) /  babs / babs  ! sqrt(g)\n      rg2inv = 1.0d0 / rootg / rootg                          ! 1/g\n\n!!! THW (Dec 7, 2011)\n!!!      jcob(iz) = rootg\n!!! THW (Dec 7, 2011)\n\n! ------------------------------------------------------------------------------------\n!\n! ---- Contravariant componets of the metric tensor ----------------------------------\n      gupss  = rg2inv * ( gdwtt * gdwzz - gdwtz * gdwtz )     ! g^s^s\n      guptt  = rg2inv * ( gdwss * gdwzz - gdwsz * gdwsz )     ! g^theta^theta\n      gupzz  = rg2inv * ( gdwss * gdwtt - gdwst * gdwst )     ! g^zeta^zeta \n      gupst  = rg2inv * ( gdwtz * gdwsz - gdwst * gdwzz )     ! g^s^theta\n      gupsz  = rg2inv * ( gdwst * gdwtz - gdwtt * gdwsz )     ! g^s^zeta\n      guptz  = rg2inv * ( gdwst * gdwsz - gdwss * gdwtz )     ! g^theta^zeta\n! ------------------------------------------------------------------------------------\n!\n! ---- Covariant componets of B ------------------------------------------------------\n      Bs   = ( gdwsz + eot1 * gdwst ) / rootg                 ! B_s\n      Bth  = cui1                                             ! B_theta\n      Bzt  = cug1                                             ! B_zeta\n! ------------------------------------------------------------------------------------\n!\n\n! *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*= Edit by nunami 10.04.15 =*=*=*=*=*=*=*=*\n! ---- Normalization for length with R_0 ---------------------------------------------\n      rmaj  = rmaj  / R0_unit\n!     ---------------------------------\n      gdwss = gdwss / R0_unit / R0_unit\n      gdwtt = gdwtt / R0_unit / R0_unit\n      gdwzz = gdwzz / R0_unit / R0_unit\n      gdwst = gdwst / R0_unit / R0_unit\n      gdwsz = gdwsz / R0_unit / R0_unit\n      gdwtz = gdwtz / R0_unit / R0_unit\n!     ---------------------------------\n      gupss = gupss * R0_unit * R0_unit\n      guptt = guptt * R0_unit * R0_unit\n      gupzz = gupzz * R0_unit * R0_unit\n      gupst = gupst * R0_unit * R0_unit\n      gupsz = gupsz * R0_unit * R0_unit\n      guptz = guptz * R0_unit * R0_unit\n! ------------------------------------------------------------------------------------\n!\n!\n! ---- Normalization for B componets etc. --------------------------------------------\n      babs  = babs / B00mode\n      Bs    = Bs   / B00mode / R0_unit\n      Bth   = Bth  / B00mode / R0_unit\n      Bzt   = Bzt  / B00mode / R0_unit\n      dBds  = dBds / B00mode\n      dBdt  = dBdt / B00mode\n      dBdz  = dBdz / B00mode\n\n      dBdt_mir  = dBdt_mir / B00mode\n! ------------------------------------------------------------------------------------\n\n! *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*= Edit by nunami 10.04.15 =*=*=*=*=*=*=*=*\n\n\n! --- Normalization for rootg with R_0 -- by nunami 10.04.15 -------------------------\n      rootg = rootg / R0_unit / R0_unit / R0_unit\n\n! ---- sqrt(g) in (x,y,z), i.e. flux tube coordinates --------------------------------\n      rootgft   = ( q_0 / (r_0 * r_a) ) * rootg  ! sqrt(g_ft)\n\n! ---- sqrt(g) in (r,theta,zeta), i.e. Boozer coordinates ----------------------------\n      rootgbz   = rootg / r_a\n\n\n! ======================================================================================\n\n\n      if( isw == 0 ) then\n\n        write( olog, * ) \"================= \"\n        write( olog, * ) \" #  B00mode     = \",  B00mode\n        write( olog, * ) \" #  Bm1_0mode   = \",  Bm1_0mode\n        write( olog, * ) \" #  B0_10mode   = \",  B0_10mode\n        write( olog, * ) \" #  Bm1_10mode  = \",  Bm1_10mode\n        write( olog, * ) \" #  Bp1_10mode  = \",  Bp1_10mode\n        write( olog, * ) \" # dB00mode     = \", dB00mode\n        write( olog, * ) \" # dBm1_0mode   = \", dBm1_0mode\n        write( olog, * ) \" # dB0_10mode   = \", dB0_10mode\n        write( olog, * ) \" # dBm1_10mode  = \", dBm1_10mode\n        write( olog, * ) \" # dBp1_10mode  = \", dBp1_10mode\n        write( olog, * ) \"=================\"\n\n        write( olog, * ) \"\"\n\n        write( olog, * ) \"================= \"\n        write( olog, * ) \" # eps_t        = \",  - Bm1_0mode  / B00mode\n        write( olog, * ) \" # eps_h/eps_t  = \",  - B0_10mode  / Bm1_0mode\n        write( olog, * ) \" # eps_-/eps_t  = \",  - Bp1_10mode / Bm1_0mode\n        write( olog, * ) \" # eps_+/eps_t  = \",  - Bm1_10mode / Bm1_0mode\n        write( olog, * ) \" # rdeps00/eps_t= \",  ss * dB00mode    / Bm1_0mode\n        write( olog, * ) \" # rdeps_t/eps_t= \",  ss * dBm1_0mode  / Bm1_0mode\n        write( olog, * ) \" # rdeps_h/eps_t= \",  -ss * dB0_10mode  / Bm1_0mode\n        write( olog, * ) \" # rdeps_-/eps_t= \",  -ss * dBp1_10mode / Bm1_0mode\n        write( olog, * ) \" # rdeps_+/eps_t= \",  -ss * dBm1_10mode / Bm1_0mode\n        write( olog, * ) \"=================\"\n\n      end if\n\n      isw = 1\n\n\n    deallocate ( ssi )\n\n\n  END SUBROUTINE vmecin_coeff\n\n\n\n!--------------------------------------\n  SUBROUTINE vmecin_read\n!--------------------------------------\n\n! +------------------------------------------------------------------------+\n! |    Read VMEC equiblium                                                 |\n! |    (programme for interface vmec(newboz))                              | \n! |                                                                        |\n! |                                  by M. Nunami (Nov. 2009)              |\n! +------------------------------------------------------------------------+\n\n\n! --- read vmec-nwboz field ----------\n    call iodisk\n\n! --- calculate spline coeff ---------\n    call setfld\n\n\n  END SUBROUTINE vmecin_read\n\n\n!--------------------------------------\n  ", "SUBROUTINE iodisk\n!--------------------------------------\n\n! +-------------------------------------------------------------------------+\n! |   iodisk ; read input data from newboz                                  |\n! |                                                                         |\n! |   nsd          number of vmec grid points                               |\n! |   mbzmax       number of boozer theta harmonics desired                 |\n! |   nbzmin       number of negative boozer zeta harmonics desired         |\n! |   nbzmax       number of positive boozer zeta harmonics desired         |\n! |                                                                         |\n! |   bbozh : mod b spectrum in boozer coordinates                          |\n! |                                                                         |\n! |         b(i,t,z) =     sum bbozh(m,i) cos(-t*mboz(m) + z*nboz(m) )      |\n! |                                                                         |\n! |   note   bco(i,m) = bbozh(m,i)                                          |\n! |                                                                         |\n! |   transformation from boozer to cylindrical coordinates                 |\n! |                                                                         |\n! |       ( psi, theta, zeta ) -> ( r, phi, z )                             |\n! |                                                                         |\n! |         r(i,t,z) =     sum rbozh(m,i) cos(-t*mboz(m) + z*nboz(m) )      |\n! |         p(i,t,z) = z + sum pbozh(m,i) sin(-t*mboz(m) + z*nboz(m) )      |\n! |         z(i,t,z) =     sum zbozh(m,i) sin(-t*mboz(m) + z*nboz(m) )      |\n! |                                                                         |\n! |   surface quantities ( after renormalized )                             |\n! |                                                                         |\n! |         psib   : toroidal flux within a flux surface / ( 2*pi )         |\n! |         eot    : rotational transform                                   |\n! |         cui    : toroidal current within a flux surface                 |\n! |         cug    : poloidal current without a flux surface                |\n! |                                                                         |\n! |   ---------------------------------------------------------------       |\n! |                                                                         |\n! |  Input Parameters                                                       |\n! |  NEWBZ:                                                                 |\n! |   mdmx : number of important modes extracted from nmboz modes           |\n! |              ( nmboz - 1 >= mdmx is required )                          |\n! |            Note : total mode is mdmx+1 (including B_(0,0) mode)         |\n! |   nlim : if nlim/=0, |n|>nlim modes are skipped.                        |\n! |                                                                         |\n! |   kmsh : number of radial mesh of field data for FORTEC-3D              |\n! |            Note : total mesh is kmsh+1 (including rho=0.0)              |\n! |   dcheck : if TRUE, original data from NEWBOZ is put out.               |\n! |   lrchk  : if TRUE, check and adjust the coordinate system to RHS.      |\n! |   bmag  : magnification factor of the magnetic field strength.          |\n! +-------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n  logical dcheck,lrchk\n!\n  dimension ifsel(ibhar)\n  dimension bmax(nsd_max), bmin(nsd_max)\n  dimension bsel(ibhar),icont(ibhar), msel(ibhar)\n!\n!!  COMMON/BPARA/BB0,psia,sa,rmaj0,zi,nmass\n!!  common/param1/kmsh,kmsh1,nsd,mdmx,itype\n  namelist/newbz/dcheck,lrchk,mdmx,kmsh,nlim,bmag\n! ----------------------------------------------------------------------------- !\n!\n!\n  read(inml,nml=newbz)\n  if ( rank == 0 ) then\n    write(ovmc,nml=newbz)\n  endif\n!\n!\n! ... Read input data (the same file used to make input data for VMEC) for density and temp.\n! ... The density and temperature profiles -> given by subroutine \"ntfunc0\" or \"ntfunc1\"\n! ... Choose input type ( Satake's exponential style      : itype=0, \n! ...                     expansion in rho like in GSRAKE : itype=1, \n! ...                     Idomura's style                 : itype=2 )\n!\n  read(ivmc,*)\n  read(ivmc,*) itype\n  if(itype==0) len=4\n  if(itype==1) len=10\n  if(itype==2) len=3\n!\n  read(ivmc,*)\n  read(ivmc,*)dn0(0:len)\n  read(ivmc,*)\n  read(ivmc,*)ti0(0:len)\n  read(ivmc,*)\n  read(ivmc,*)te0(0:len)\n  read(ivmc,*)\n  read(ivmc,*)dummy\n  read(ivmc,*)\n  read(ivmc,*)dummy,R0,dummy,a0,zi,nmass\n!\n  if(itype==2) then \n    dn0(2)=dn0(1)*dn0(2)*a0/R0\n    ti0(2)=ti0(1)*ti0(2)*a0/R0\n    te0(2)=te0(1)*te0(2)*a0/R0\n  end if\n!\n!!    dn0: ni(0) [m^(-3)]\n!!    ti0, te0: temperature at the axis [keV]\n!!    zi:  ion charge number\n!!    nmass : relative mass of the ion species to proton\n!\n!!    BB0:  toroidal field strength at the magnetic axis  [T]\n!!    Rmaj0 and a0 : major and minor radius [m]\n!\n! --- constant parameters --------\n  pi2    = twopi\n  cmu0   = 4.0d0*pi*1.0d-7\n!\n! --- Read newboz data ------------- \n  read(ndiskc) nmboz, nsd, nfp\n  read(ndiskc) Rmaj0, BB0\n!\n  if ( rank == 0 ) then\n    write(ovmc,6001) nmboz, nsd, nfp\n  endif\n!\n  nsd=nsd+1\n  kmsh1=kmsh+1\n  mmx1=mdmx+1\n!\n  if(nmboz-1.lt.mdmx) then\n    if ( rank == 0 ) then\n      write(ovmc,9001) nmboz - 1, mdmx\n    endif\n    stop\n  else\n    if ( rank == 0 ) then\n      write(ovmc,9003) nmboz - 1, mdmx\n    endif\n  endif\n!\n  if ( rank == 0 ) then\n    write(ovmc,9004)nsd,kmsh\n  endif\n!\n  allocate(CUI(kmsh1), CUG(kmsh1), TXI(kmsh1), TXE(kmsh1), DXI(kmsh1), DLN(kmsh1),    &\n           C1I(kmsh1), C2I(kmsh1), C3I(kmsh1), C1G(kmsh1), C2G(kmsh1), C3G(kmsh1),    &\n           C1TI(kmsh1),C2TI(kmsh1),C3TI(kmsh1),C1TE(kmsh1),C2TE(kmsh1),C3TE(kmsh1),   &\n           C1DI(kmsh1),C2DI(kmsh1),C3DI(kmsh1),SPOS(kmsh1),PSIB(kmsh1),EOT(kmsh1),    &\n           C1ET(kmsh1),C2ET(kmsh1),C3ET(kmsh1),C1LN(kmsh1),C2LN(kmsh1),C3LN(kmsh1))\n  allocate(BCO(kmsh1,MMX1),C1BF(kmsh1,MMX1),C2BF(kmsh1,MMX1),C3BF(kmsh1,MMX1),        &\n           CM(MMX1),CN(MMX1))\n  allocate(RCO(kmsh1,MMX1),ZCO(kmsh1,MMX1),PCO(kmsh1,MMX1),                           &\n           C1R(kmsh1,MMX1),C2R(kmsh1,MMX1),C3R(kmsh1,MMX1),                           &\n           C1Z(kmsh1,MMX1),C2Z(kmsh1,MMX1),C3Z(kmsh1,MMX1),                           &\n           C1P(kmsh1,MMX1),C2P(kmsh1,MMX1),C3P(kmsh1,MMX1))\n  allocate(bco0(nsd,mmx1),rco0(nsd,mmx1),zco0(nsd,mmx1),pco0(nsd,mmx1),               &\n           spos0(nsd))\n!\n!\n! --- Read newboz data ----------------------\n  READ(ndiskc) (PSIBZ(i), i = 2, NSD)\n  READ(ndiskc) (EOTBZ(i), i = 2, NSD)\n!\n  READ(ndiskc) (CUIBZ(i), i = 2, NSD)\n  READ(ndiskc) (CUGBZ(i), i = 2, NSD)\n!\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (BBOZH(M,I), I = 2, NSD)\n  END DO\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (RBOZH(M,I), I = 2, NSD)\n  END DO\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (ZBOZH(M,I), I = 2, NSD)\n  END DO\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (PBOZH(M,I), I = 2, NSD)\n  END DO\n!\n!\n! --- magnetic field magnification -------------------------------------\n  if(bmag/=1.0d0) then\n    if( rank == 0 ) then\n      write(ovmc,\"(a,f8.3,a)\")'** bfield is magnified by ',bmag,' **'\n    endif\n    BB0=BB0*bmag\n    PSIBZ=PSIBZ*bmag\n    CUIBZ=CUIBZ*bmag\n    CUGBZ=CUGBZ*bmag\n    BBOZH=BBOZH*bmag\n  end if\n!\n! --- check of LHS or RHS ----------------------------------------------\n  if ( .not.lrchk ) goto  999 !check lhs or rhs if lrchk = .true.\n!\n  ichk = nsd/2\n  chi = pi2/90.0d0\n  zsum  =  0.0d0\n  do i = 1, nmboz\n    zsum  =  zsum + zbozh(i,ichk)*dsin(-mboz(i)*chi)\n  end do\n!\n  if( zsum .gt. 0.0d0 ) then\n!  ....   counterclockwise\n    drthta =  1.0d0\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'     LHS ( theta is counterclockwise ) '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  else\n!  ....   clockwise\n    drthta = -1.0d0\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'       RHS ( theta is clockwise )      '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  endif\n!\n!\n!+++++ updated on  9/29 94 by N^2 : for left -> right start\n!\n!      - theta -> theta in VMEC\n!\n! irtchg = 0\n  if( drthta .gt. 0.0d0 ) then\n!   irtchg = 1\n    do i = 2, nsd\n!      change of sign of psi is due to miss-interface\n      PSIBZ(i) = - PSIBZ(i)\n      EOTBZ(i) = - EOTBZ(i)\n      CUIBZ(i) = - CUIBZ(i)\n    end do\n!\n    do m = 1, nmboz\n      mboz(m) = - mboz(m)\n    end do\n!\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'     LHS -> RHS ( theta is clockwise ) '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n    drthta = -1.0d0\n  endif\n!\n!..... psi > 0 must be ensured in the usual Boozer coordinates\n!\n!      - curpol -> curpol\n!      - curtor -> curtor in VMEC\n!\n! ipschg = 0\n  if( psibz(2) .lt. 0.0d0 ) then\n!   ipschg = 1\n    do i = 2, nsd\n      PSIBZ(i) = - PSIBZ(i)\n      CUIBZ(i) = - CUIBZ(i)\n      CUGBZ(i) = - CUGBZ(i)\n    end do\n!\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'                    psi < 0 -> psi > 0 '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  endif\n!\n!      winding law is inverted\n!      - curtor -> curtor\n!\n  if( eotbz(nsd) .lt. 0.0d0 ) then\n    sgniot =-1.0d0\n  else\n    sgniot = 1.0d0\n  endif\n! iitchg = 0\n! if( litchg .and. sgniot .lt. 0.0d0 ) then\n  if(sgniot .lt. 0.0d0 ) then\n!   iitchg = 1\n    do i = 2, nsd\n      EOTBZ(i) = - EOTBZ(i)\n      CUIBZ(i) = - CUIBZ(i)\n    end do\n    do m = 1, nmboz\n      nboz(m) = - nboz(m)\n      do i = 2, nsd\n        pbozh(m,i) = - pbozh(m,i)\n      end do\n    end do\n    sgniot = 1.0d0\n!\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'                  iota < 0 -> iota > 0 '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  endif\n!\n!...  transpose LHS --> RHS end \n!\n999 continue\n!     \n!.... from half mesh to integer mesh\n!\n  do i = 2, nsd-1\n    psibz(i)   = ( psibz(i) + psibz(i+1) )/2.0d0\n    eotbz(i)   = ( eotbz(i) + eotbz(i+1) )/2.0d0\n    cuibz(i)   = ( cuibz(i) + cuibz(i+1) )/2.0d0\n    cugbz(i)   = ( cugbz(i) + cugbz(i+1) )/2.0d0\n    do j = 1, nmboz\n      bbozh(j,i) = ( bbozh(j,i) + bbozh(j,i+1) )/2.0d0\n      rbozh(j,i) = ( rbozh(j,i) + rbozh(j,i+1) )/2.0d0\n      zbozh(j,i) = ( zbozh(j,i) + zbozh(j,i+1) )/2.0d0\n      pbozh(j,i) = ( pbozh(j,i) + pbozh(j,i+1) )/2.0d0\n    enddo\n  enddo\n\n!     \n!+++++ extrapolation of the values at the magnetic axis\n!\n  do j = 1, nmboz\n    if( mboz(j) .eq. 0 ) then\n      bbozh(j,1) = 3.0d0*bbozh(j,2) - 3.0d0*bbozh(j,3) + bbozh(j,4)\n      rbozh(j,1) = 3.0d0*rbozh(j,2) - 3.0d0*rbozh(j,3) + rbozh(j,4)\n      zbozh(j,1) = 3.0d0*zbozh(j,2) - 3.0d0*zbozh(j,3) + zbozh(j,4)\n      pbozh(j,1) = 3.0d0*pbozh(j,2) - 3.0d0*pbozh(j,3) + pbozh(j,4)\n    else\n      bbozh(j,1) = 0.0d0\n      rbozh(j,1) = 0.0d0\n      zbozh(j,1) = 0.0d0\n      pbozh(j,1) = 0.0d0\n    endif\n  enddo\n\n  if( psibz(nsd-1) .gt. 0.0d0 ) then\n    psisgn   =  1.0d0\n  else\n    psisgn   = -1.0d0\n  endif\n  psibz(  1) = 1.0d-18*psisgn\n  eotbz(  1) = 3.0d0*eotbz(  2) - 3.0d0*eotbz(  3) + eotbz(  4)\n  cuibz(  1) = 3.0d0*cuibz(  2) - 3.0d0*cuibz(  3) + cuibz(  4)\n  cugbz(  1) = 3.0d0*cugbz(  2) - 3.0d0*cugbz(  3) + cugbz(  4)\n!\n!+++++ extrapolation of the values at the boundary\n!\n  do j = 1, nmboz\n    bbozh(j,nsd) = 3.0d0*bbozh(j,nsd-1)-3.0d0*bbozh(j,nsd-2)+bbozh(j,nsd-3)\n    rbozh(j,nsd) = 3.0d0*rbozh(j,nsd-1)-3.0d0*rbozh(j,nsd-2)+rbozh(j,nsd-3)\n    zbozh(j,nsd) = 3.0d0*zbozh(j,nsd-1)-3.0d0*zbozh(j,nsd-2)+zbozh(j,nsd-3)\n    pbozh(j,nsd) = 3.0d0*pbozh(j,nsd-1)-3.0d0*pbozh(j,nsd-2)+pbozh(j,nsd-3)\n  enddo\n!\n  psibz(nsd) = 3.0d0*psibz(nsd-1)-3.0d0*psibz(nsd-2)+psibz(nsd-3)\n  eotbz(nsd) = 3.0d0*eotbz(nsd-1)-3.0d0*eotbz(nsd-2)+eotbz(nsd-3)\n  cuibz(nsd) = 3.0d0*cuibz(nsd-1)-3.0d0*cuibz(nsd-2)+cuibz(nsd-3)\n  cugbz(nsd) = 3.0d0*cugbz(nsd-1)-3.0d0*cugbz(nsd-2)+cugbz(nsd-3)\n!     \n!.... normalization to vmec calculation\n!\n  cnorm  = rmaj0*bb0/cugbz(nsd)\n  do i = 1, nsd\n    cuibz(i)   = cuibz(i)*cnorm\n    cugbz(i)   = cugbz(i)*cnorm\n    psibz(i)   = psibz(i)*cnorm\n    do j = 1, nmboz\n      bbozh(j,i) = bbozh(j,i)*cnorm\n    enddo\n  enddo\n\n  psia = psibz(nsd)\n  sa    = sqrt(psia*2.d0/bb0)\n  if( rank == 0 ) then\n    write(ovmc,305) rmaj0,bb0,psia,sa\n    write(ovmc,306) cnorm\n  endif\n305 format(' rmaj0= ',d15.7,' , bb0 = ',d15.7,' , psia = ',d15.7,' , sa = ',d15.7)\n306 format(' cnom =',d15.7)\n!\n  if( rank == 0 ) then\n    write(ovmc,6002)\n    write(ovmc,6003) (i, psibz(i), eotbz(i), cuibz(i), cugbz(i), i = 1, nsd)\n  endif\n!\n  if( dcheck ) then                            !check bbozh\n    nout  = 5\n    nprt  = nsd/nout\n    if( mod(nsd,nout) .ne. 0 ) nprt = nprt + 1\n!     \n    do ii=1,nprt\n      iis  =(ii-1)*nout+1\n      iie  = ii   *nout\n      if( iie .gt. nsd) iie=nsd \n      if( rank == 0 ) then\n        write(ovmc,6011)         ( kk , kk = iis, iie )\n      endif\n!     \n      do j = 1, nmboz\n        if( rank == 0 ) then\n          write(ovmc,6012) j, mboz(j), nboz(j),( bbozh(j,kk), kk = iis, iie )\n        endif\n      enddo\n    enddo\n  endif\n!\n!        modified by Satake 2004/02/26\n!\n!..... assuming ijf = 1 correponds to mboz = 0 and nboz = 0.\n!\n!\n!..... initialization of labels of fourier modes for each surface\n!\n  do ijf = 2, nmboz\n    bsel(ijf) = -1.0d0\n    msel(ijf) = 0\n    icont(ijf)= 0\n  end do\n  icont(1)=1\n  imttl   =1\n!\n!..... remove |n|>nlim modes \n  if(nlim.ne.0) then\n    if( rank == 0 ) then\n      write(ovmc,*)\n!     write(ovmc,'(\"***    |n|>\",i3,\" modes are skipped.   ***\")'),nlim\n    endif\n    do ijf = 2, nmboz\n      if(abs(nboz(ijf))>nlim) then\n        bbozh(ijf,:)=0.0d0\n      end if\n    end do\n  end if\n!\n!..... selection of modes for each surface\n!\n  do is = 1, nsd\n!\n    bmax(is)  = -100.0*bb0\n    bmin(is)  =  100.0*bb0\n    do ijf = 2, nmboz\n      bmax(is)  = dmax1( bbozh(ijf,is), bmax(is) )\n      bmin(is)  = dmin1( bbozh(ijf,is), bmin(is) )\n    end do\n!     \n    bamax = dmax1( dabs(bmax(is)), dabs(bmin(is)) )\n!     \n    do ijf = 2, nmboz\n      asel = dabs(bbozh(ijf,is))/bamax\n      if (asel.ge.bsel(ijf)) then\n        bsel(ijf) = asel\n        msel(ijf) = is\n      end if\n    end do\n  end do\n!     \n!.. selection of modes \n!.. search major modes of mag. field spectrum (total mdmx+1 modes)\n!.. b(m=0,n=0) mode is always comes first.\n!\n  do ijf = 2, nmboz\n    igt = 0\n    do ijf2 = 2, nmboz\n      if (ijf==ijf2) cycle\n      if (bsel(ijf2).gt.bsel(ijf)) then\n        igt = igt+1\n        cycle\n      end if\n      if (bsel(ijf2)==1.0d0.and.bsel(ijf)==1.0d0) then\n        if (dabs( bbozh(ijf2,msel(ijf2))).gt.dabs( bbozh(ijf,msel(ijf)))) then\n          igt = igt+1\n        end if\n      end if\n    end do\n!     \n    if (igt.lt.mdmx) then \n      icont(ijf) = igt+2\n      imttl=imttl+1\n    end if\n  end do\n!\n  if( rank == 0 ) then\n    write(ovmc,6035) \n  endif\n!\n  do i=1,imttl\n    do ijf = 1, nmboz\n      if (icont(ijf)==i) then\n        bmax1=-100.0*bb0\n        do is=1,nsd\n          bmax1=dmax1(dsqrt(bbozh(ijf,is)**2),bmax1)\n        end do\n        if( rank == 0 ) then\n          write(ovmc,6036) i,mboz(ijf),nboz(ijf),icont(ijf),msel(ijf),bsel(ijf),bmax1\n        endif\n        do is = 1, nsd\n          bco0(is,i) = bbozh(ijf,is)\n          rco0(is,i) = rbozh(ijf,is)\n          zco0(is,i) = zbozh(ijf,is)\n          pco0(is,i) = pbozh(ijf,is)\n        end do\n        cm(i) = dble(mboz(ijf))\n        cn(i) = dble(nboz(ijf))\n        cycle\n      end if\n    end do\n  end do\n!\n  ", "if (imttl.ne.mmx1) then\n    if( rank == 0 ) then\n      write(ovmc,*) 'imttl diff. from mmx1. abort! '\n    endif\n    stop\n  end if\n!\n  if( rank == 0 ) then\n    write(ovmc,*)\n    write(ovmc,*)' selected fourier spectrum of b '\n    write(ovmc,*)\n  endif\n!\n  nout  = 5\n  nprt  = nsd/nout\n  if( mod(nsd,nout) .ne. 0 ) nprt = nprt + 1\n!     \n  do ii=1,nprt\n    iis  =(ii-1)*nout+1\n    iie  = ii   *nout\n    if( ii .eq. nprt ) iie  = nsd\n    if( rank == 0 ) then\n      write(ovmc,6033)  ( kk , kk = iis, iie )\n    endif\n!\n    do j = 1, imttl\n      if( rank == 0 ) then\n        write(ovmc,6034) j, idint(cm(j)), idint(cn(j)),( bco0(kk,j), kk = iis, iie )\n      endif\n    end do\n  end do\n!\n6033 format(//4x,' j',2x,'(   m,   n)',5(5x,'b _',i4)/)\n6034 format(  2x,i4,2x,'(',i4,',',i4,')',5(1x,1pd11.4))\n6035 format(/2x,'selected mode j   (   m,   n)_j','  rank   most significant on', &\n     &       '   b_max(rel.)     b_max(abs.)')\n6036 format(10x,i4,'      (',i4,',',i4,')',4x,i4,8x,i6,8x,1p,2e13.5)\n!\n6001 format(//9x,'nmboz  = ',i4,' : nsd - 1 = ',i4,' : nfp    =',i4,//)\n6002 format(//6x,'i',11x,'psi',10x,'iota',13x,'i',13x,'g'/)\n6003 format(/(2x,i5,4(2x,1pd12.5)))\n6011 format(//3x,' j',3x,'(   m,   n)',5(5x,'b _',i4)/)\n6012 format(  2x,i4,2x,'(',i4,',',i4,')',5(1x,1pd11.4))\n9001 format(//10x,'!err! nmboz - 1 = ',i4,', mdmx  = ',i4//)\n9003 format(//10x,'nmboz - 1 = ',i4,' >= mdmx  = ',i4//)\n!!c 9002 format(//10x,'!err! nsd   - 1 = ',i4,' =/ kmsh = ',i4//)\n9004 format(//10x,'nsd = ',i4,', kmsh = ',i4//)\n\n  return\n\n\n  END SUBROUTINE iodisk\n\n\n\n!\n!\n!\n!--------------------------------------\n  SUBROUTINE setfld\n!--------------------------------------\n\n! +-------------------------------------------------------------------------+\n! |   Set field data                                                        |\n! |                                                                         |\n! |   Modified 2004/3/9: Spline tables are in s_bar=psi/psia coordinate.    |\n! |   Modified 2005/10/24: kmsh can be taken to be different from nsd.      |\n! +-------------------------------------------------------------------------+\n!********************************************************************************\n! ----------------------------------------------------------------------------- !\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n!\n  real(KIND=8), dimension(kmsh1) :: wkbf,wkc1,wkc2,wkc3,ds,dsl\n  real(KIND=8), dimension(nsd) :: wkbf0,wkc10,wkc20,wkc30\n  integer(kind=4), dimension(kmsh1) :: jpl\n  real(KIND=8) dy(2),fu(0:3)\n!!  COMMON/BPARA/bb0,psia,sa,rmaj0,zi,nmass\n!!  common/param1/kmsh,kmsh1,nsd,mdmx,itype\n! ----------------------------------------------------------------------------- !\n!\n!\n!------  radial position -----\n!\n  spos0(1) = 0.0d0\n  spos(1)  = 0.0d0\n  psib(1)  = psibz(1)\n  do j=2,nsd\n    spos0(j) = sqrt( psibz(j)/psia ) ! normalized minor radius\n  end do\n!\n  dsp=1.0d0/dble(kmsh)\n  do j=2,kmsh1\n    spos(j)  = dsp*dble(j-1)\n    psib(j)  = psia*spos(j)**2\n    ds(j-1)  = spos(j)-spos(j-1)\n  end do\n  ds(kmsh1)=ds(kmsh)\n!... relation between spos0 and spos\n  dsl(1)=0.0d0\n  jpl(1)=1\n  do j=2,kmsh1\n    sp = spos(j)\n    jpl(j)=nsd\n    do k=2,nsd\n      if(sp<spos0(k)) then\n        jpl(j)=k-1\n        exit\n      end if\n    end do\n    sj     = spos0(jpl(j))\n    dsl(j) = sp - sj\n  end do\n!\n!------  make n,t,ln_lambda tables on spos ---!\n!\n  do j=1,kmsh1\n    select case(itype)\n    case(0)\n      call ntfunc0(spos(j),txe(j),txi(j),dxi(j))\n    case(1)\n      call ntfunc1(spos(j),txe(j),txi(j),dxi(j))\n    case(2)\n      call ntfunc2(spos(j),txe(j),txi(j),dxi(j))\n    end select\n    dln(j)=32.2d0+1.15d0*dlog10(txe(j)**2*1.0d6/dxi(j)/zi)\n  end do\n!\n!--------------------------------------------!\n!\n!   make the spline table for magnetic field and (r,phi,z)\n!   \n!--------------------------------------------!\n!\n  do i=1,mdmx+1\n!... first, make spline table on spos0\n    do j=1,nsd\n      wkbf0(j)=bco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!... second, interporate value at spos\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!... last, make spline table on spos\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh\n      bco (j,i) =  wkbf(j)\n      c1bf(j,i) =  wkc1(j)\n      c2bf(j,i) =  wkc2(j)\n      c3bf(j,i) =  wkc3(j)\n    end do\n!.. on the outer edge\n    bco (kmsh1,i) = fu(0)\n    c1bf(kmsh1,i) = fu(1)\n    c2bf(kmsh1,i) = fu(2)\n    c3bf(kmsh1,i) = fu(3)\n!!\n    do j=1,nsd\n      wkbf0(j)=rco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh\n      rco(j,i) =  wkbf(j)\n      c1r(j,i) =  wkc1(j)\n      c2r(j,i) =  wkc2(j)\n      c3r(j,i) =  wkc3(j)\n    end do\n    rco(kmsh1,i) = fu(0)\n    c1r(kmsh1,i) = fu(1)\n    c2r(kmsh1,i) = fu(2)\n    c3r(kmsh1,i) = fu(3)\n!!\n    do j=1,nsd\n      wkbf0(j)=zco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh1\n      zco(j,i) =  wkbf(j)\n      c1z(j,i) =  wkc1(j)\n      c2z(j,i) =  wkc2(j)\n      c3z(j,i) =  wkc3(j)\n    end do\n    zco(kmsh1,i) = fu(0)\n    c1z(kmsh1,i) = fu(1)\n    c2z(kmsh1,i) = fu(2)\n    c3z(kmsh1,i) = fu(3)\n!!\n    do j=1,nsd\n      wkbf0(j)=pco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh1\n      pco(j,i) =  wkbf(j)\n      c1p(j,i) =  wkc1(j)\n      c2p(j,i) =  wkc2(j)\n      c3p(j,i) =  wkc3(j)\n    end do\n    pco(kmsh1,i) = fu(0)\n    c1p(kmsh1,i) = fu(1)\n    c2p(kmsh1,i) = fu(2)\n    c3p(kmsh1,i) = fu(3)\n!\n  end do\n!\n!...\n!\n!!$if( rank == 0 ) then\n!!$  write(8,*)'### spline coefficients for B ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### bco          c1bf           c2bf           c3bf            (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    do j=1,kmsh1\n!!$      write(8,7002)bco(j,i),c1bf(j,i),c2bf(j,i),c3bf(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$  write(8,*)'### spline coefficients for R ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### rco          c1r            c2r            c3r             (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    write(8,7000)int(cm(i)),int(cn(i))\n!!$    do j=1,kmsh1\n!!$      write(8,7002)rco(j,i),c1r(j,i),c2r(j,i),c3r(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$  write(8,*)'### spline coefficients for Z ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### zco          c1z            c2z            c3z             (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    do j=1,kmsh1\n!!$      write(8,7002)zco(j,i),c1z(j,i),c2z(j,i),c3z(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$  write(8,*)'### spline coefficients for PHI ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### pco          c1p            c2p            c3p             (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    do j=1,kmsh1\n!!$      write(8,7002)pco(j,i),c1p(j,i),c2p(j,i),c3p(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$endif\n!!\n7000 format(4x,'cm = ',i4,' , cn = ',i4)\n7001 format(6x,i4,4x,i4)\n7002 format(4(1x,d14.6),1x,2i4)\n!\n!--------------------------------------------!\n!\n!     make the spline table for the flux functions;\n!     eot, cui, cug, txi, txe, dxi, dln\n!     Note that dT/dx, dn/dx (at x=0) = 0 are assumed. \n!--------------------------------------------!\n!\n!!!   eot\n  call fit_x3(spos0(1:4),eotbz(1:4),1,dy(1),fu)\n  call fit_x3(spos0(nsd-3:nsd),eotbz(nsd-3:nsd),2,dy(2),fu)\n  call spline_fit2(spos0,eotbz,dy,nsd,wkc10,wkc20,wkc30)\n!\n  call val_intp(jpl,dsl,eotbz,wkc10,wkc20,wkc30,kmsh1,nsd,eot)\n!\n  call fit_x3(spos(1:4),eot(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),eot(kmsh-2:kmsh1) ,2,dy(2),fu)\n  call spline_fit2(spos,eot,dy,kmsh1,c1et,c2et,c3et)\n!.. on the outer edge\n  eot (kmsh1) = fu(0)\n  c1et(kmsh1) = fu(1)\n  c2et(kmsh1) = fu(2)\n  c3et(kmsh1) = fu(3)\n!!!   cui\n  call fit_x3(spos0(1:4),cuibz(1:4),1,dy(1),fu)\n  call fit_x3(spos0(nsd-3:nsd),cuibz(nsd-3:nsd),2,dy(2),fu)\n  call spline_fit2(spos0,cuibz,dy,nsd,wkc10,wkc20,wkc30)\n!\n  call val_intp(jpl,dsl,cuibz,wkc10,wkc20,wkc30,kmsh1,nsd,cui)\n!\n  call fit_x3(spos(1:4),cui(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),cui(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,cui,dy,kmsh1,c1i,c2i,c3i)\n  cui(kmsh1) = fu(0)\n  c1i(kmsh1) = fu(1)\n  c2i(kmsh1) = fu(2)\n  c3i(kmsh1) = fu(3)\n!!!  cug\n  call fit_x3(spos0(1:4),cugbz(1:4),1,dy(1),fu)\n  call fit_x3(spos0(nsd-3:nsd),cugbz(nsd-3:nsd),2,dy(2),fu)\n  call spline_fit2(spos0,cugbz,dy,nsd,wkc10,wkc20,wkc30)\n!\n  call val_intp(jpl,dsl,cugbz,wkc10,wkc20,wkc30,kmsh1,nsd,cug)\n!\n  call fit_x3(spos(1:4),cug(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),cug(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,cug,dy,kmsh1,c1g,c2g,c3g)\n  cug(kmsh1) = fu(0)\n  c1g(kmsh1) = fu(1)\n  c2g(kmsh1) = fu(2)\n  c3g(kmsh1) = fu(3)\n!!!  txi\n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),txi(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),txi(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,txi,dy,kmsh1,c1ti,c2ti,c3ti)\n  txi(kmsh1) = fu(0)\n  c1ti(kmsh1) = fu(1)\n  c2ti(kmsh1) = fu(2)\n  c3ti(kmsh1) = fu(3)\n!!!  txe\n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),txe(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),txe(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,txe,dy,kmsh1,c1te,c2te,c3te)\n  txe(kmsh1) = fu(0)\n  c1te(kmsh1) = fu(1)\n  c2te(kmsh1) = fu(2)\n  c3te(kmsh1) = fu(3)\n!!!  dxi \n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),dxi(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),dxi(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,dxi,dy,kmsh1,c1di,c2di,c3di)\n  dxi(kmsh1) = fu(0)\n  c1di(kmsh1) = fu(1)\n  c2di(kmsh1) = fu(2)\n  c3di(kmsh1) = fu(3)\n!!!  dln\n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),dln(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),dln(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,dln,dy,kmsh1,c1ln,c2ln,c3ln)\n  dln(kmsh1) = fu(0)\n  c1ln(kmsh1) = fu(1)\n  c2ln(kmsh1) = fu(2)\n  c3ln(kmsh1) = fu(3)\n!\n!\n!!$  write(8,*)'### spline coefficients for flux-surface funcs. ###'\n!!$  write(8,*)'### eot         c1et           c2et            c3et'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)eot(j),c1et(j),c2et(j),c3et(j),j\n!!$  end do\n!!$  write(8,*)'### cui         c1i            c2i             c3i '\n!!$  do j=1,kmsh1\n!!$    write(8,7003)cui(j),c1i(j),c2i(j),c3i(j),j\n!!$  end do\n!!$  write(8,*)'### cug         c1g            c2g             c3g '\n!!$  do j=1,kmsh1\n!!$    write(8,7003)cug(j),c1g(j),c2g(j),c3g(j),j\n!!$  end do\n!!$  write(8,*)'### txi         c1ti           c2ti            c3ti'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)txi(j),c1ti(j),c2ti(j),c3ti(j),j\n!!$  end do\n!!$  write(8,*)'### txe         c1te           c2te            c3te'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)txe(j),c1te(j),c2te(j),c3te(j),j\n!!$  end do\n!!$  write(8,*)'### dxi         c1di           c2di            c3di'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)dxi(j),c1di(j),c2di(j),c3di(j),j\n!!$  end do\n!!$  write(8,*)'### dln         c1ln           c2ln            c3ln'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)dln(j),c1ln(j),c2ln(j),c3ln(j),j\n!!$  end do\n!!$!     \n!!$  write(8,*)'### psib        spos           spos0           ds &\n!!$     &           jp  jpl    dsl   ###'\n!!$  write(8,7004)psib(1),spos(1),spos0(1),0.0d0,1,jpl(1),dsl(1)\n!!$  do j=2,kmsh1\n!!$    jp=jpl(j)\n!!$    write(8,7004)psib(j),spos(j),spos0(jp),spos(j)-spos(j-1),j,jp,dsl(j)\n!!$  end do\n!\n7003 format(4(1x,d14.6),i4)\n7004 format(4(1x,d14.6),2i4,d14.6)\n!\n  deallocate(bco0,rco0,zco0,pco0,spos0)\n!\n  return\n!\n\n  END SUBROUTINE setfld\n\n\n\n!\n!\n!********************************************************************************\nSUBROUTINE val_intp(jpl,dsl,c0,c1,c2,c3,kmsh1,nsd,cval)\n!********************************************************************************\n  IMPLICIT REAL(KIND=8) (A-H,O-Z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n  integer(kind=4) :: kmsh1,nsd,jpl(kmsh1)\n  real(kind=8), dimension(nsd) :: c0,c1,c2,c3\n  real(kind=8), dimension(kmsh1) ::dsl,cval\n! ----------------------------------------------------------------------------- !\n!\n  do j=1,kmsh1\n    jp=jpl(j)\n    ds=dsl(j)\n    cval(j)=c0(jp)+(c1(jp) +(c2(jp) +c3(jp)*ds)*ds)*ds\n  end do\n\n  return\n\nEND SUBROUTINE val_intp\n\n\n!\n!********************************************************************************\nSUBROUTINE  spline_fit2(X,Y,DY,N,C,D,E)\n!********************************************************************************\n  IMPLICIT REAL(KIND=8) (A-H,O-Z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n  real(kind=8) ::  X(N),Y(N),DY(2),C(N),D(N),E(N)\n! ----------------------------------------------------------------------------- !\n!\n  N1 = N - 1\n!!! dy/dx on edges are specified by dy\n!\n  d(1)=6.0d0*((y(2)-y(1))/(x(2)-x(1))-dy(1))\n  d(n)=6.0d0*(dy(2)-(y(n)-y(n1))/(x(n)-x(n1)))\n  c(1)=2.0d0*(x(2)-x(1)) !u(1,1)!\n  do i=2,n1\n    d(i)=6.0d0*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))\n  end do\n!\n  do i=1,n-2\n    e(i)=(x(i+1)-x(i))/c(i)   !l(i+1,i)!\n    c(i+1)=2.0d0*(x(i+2)-x(i))-e(i)*(x(i+1)-x(i))   !u(i+1,i+1)!\n  end do\n  e(n1)=(x(n)-x(n1))/c(n1)\n  c(n)=2.0d0*(x(n)-x(n1))-e(n1)*(x(n)-x(n1))   \n!\n  do i=2,n\n    d(i)=d(i)-e(i-1)*d(i-1)\n  end do\n!\n  d(n)=d(n)/c(n)\n  do i=n-1,1,-1\n    d(i)=(d(i)-(x(i+1)-x(i))*d(i+1))/c(i)\n  end do\n!\n  do i=1,n1\n    xh=(x(i+1)-x(i))\n    c(i)=(y(i+1)-y(i))/xh-xh*(2.0d0*d(i)+d(i+1))/6.0d0\n    e(i)=(d(i+1)-d(i))/6.0d0/xh\n    d(i)=0.5d0*d(i)\n  end do\n  xh=(x(n)-x(n1))\n  c(n)=(y(n)-y(n1))/xh+xh*(2.0d0*d(n)+d(n1))/6.0d0\n  e(n)=(d(n)-d(n1))/6.0d0/xh\n  d(n)=0.5d0*d(n)\n!\n  return\n\nEND SUBROUTINE spline_fit2\n\n\n\n!\n!********************************************************************************\n", "SUBROUTINE fit_x3(x,y,icon,dy,fu)\n!-------------------------------------------\n  implicit real(kind=8) (a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n  real(kind=8) :: x(4),y(4),fu(0:3)\n  integer(kind=4) :: icon\n! -----------------------------------------------------------------------------!\n!\n! evaluate dy/dx on x=x(1) (icon==1) or x=x(4) (icon/=1)\n!\n  x1=x(1)\n  x2=x(2)\n  x3=x(3)\n  x4=x(4)\n  y1=y(1)\n  y2=y(2)\n  y3=y(3)\n  y4=y(4)\n!\n  a=y4/(x4-x1)/(x4-x2)/(x4-x3)\n  b=y1/(x1-x2)/(x1-x3)/(x1-x4)\n  c=y2/(x2-x3)/(x2-x4)/(x2-x1)\n  d=y3/(x3-x4)/(x3-x1)/(x3-x2)\n!\n  if(icon==1) then     ! factor at x=x1\n    dy=a*(x1-x2)*(x1-x3)+c*(x1-x3)*(x1-x4)+d*(x1-x4)*(x1-x2)\n    dy=dy+y1*(1.0d0/(x1-x2)+1.0d0/(x1-x3)+1.0d0/(x1-x4))\n    fu(0)=y1\n    fu(1)=dy\n    fu(2)=a*(2.0d0*x1-x2-x3)+b*(3.0d0*x1-x2-x3-x4)+c*(2.0d0*x1-x3-x4)+d*(2.0d0*x1-x4-x2)\n    fu(3)=a+b+c+d\n  else                 ! factor at x=x4\n    dy=b*(x4-x2)*(x4-x3)+c*(x4-x3)*(x4-x1)+d*(x4-x1)*(x4-x2)\n    dy=dy+y4*(1.0d0/(x4-x1)+1.0d0/(x4-x2)+1.0d0/(x4-x3))\n    fu(0)=y4\n    fu(1)=dy\n    fu(2)=a*(3.0d0*x4-x1-x2-x3)+b*(2.0d0*x4-x2-x3)+c*(2.0d0*x4-x3-x1)+d*(2.0d0*x4-x1-x2)\n    fu(3)=a+b+c+d\n  end if\n!... Here, fu(i) is the coefficient if y(x) is written in the forrowings\n!    y(x)=fu(0)+fu(1)(x-xa)+fu(2)(x-xa)**2+fu(3)(x-xa)**3 where xa= x1 or x4.\n\n  return\n\nEND SUBROUTINE fit_x3\n\n\n\n!\n!********************************************************************************\nSUBROUTINE ntfunc0(xx,te,ti,dni)\n! +---------------------------------------------------------------------------+\n! |  xx = sqrt (psib/psia) : label of flux surface, psib = toroidal flux      |\n! |  answer ion temp ti, electron temp. te, and ion density dni               |\n! |         as functions of xx.                                               |\n! |                                                                           |\n! |   == satake's way ==                                                      |\n! +---------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n! -----------------------------------------------------------------------------!\n!\n  dni=dn0(0)*(dn0(1)+dn0(2)*dexp(-dn0(3)*xx**dn0(4)))\n  ti =ti0(0)*(ti0(1)+ti0(2)*dexp(-ti0(3)*xx**ti0(4)))\n  te =te0(0)*(te0(1)+te0(2)*dexp(-te0(3)*xx**te0(4)))\n!\n  return\n\nEND SUBROUTINE ntfunc0\n\n\n\n!\n!********************************************************************************\nSUBROUTINE ntfunc1(xx,te,ti,dni)\n! +---------------------------------------------------------------------------+\n! |   == GSRAKE input type ==                                                 |\n! +---------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n! -----------------------------------------------------------------------------!\n!\n  te =0.0d0\n  ti =0.0d0\n  dni=0.0d0\n  do i=10,1,-1\n    dni=(dni+dn0(i))*xx\n    ti =(ti +ti0(i))*xx\n    te =(te +te0(i))*xx\n  end do\n!\n  dni=dni+dn0(0)\n  ti =ti +ti0(0)\n  te =te +te0(0)\n!\n  return\n\nEND SUBROUTINE ntfunc1\n\n\n\n!\n!********************************************************************************\nSUBROUTINE ntfunc2(xx,te,ti,dni)\n! +---------------------------------------------------------------------------+\n! |   ==??? input type ==                                                    |\n! +---------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n  integer, parameter :: n=10\n! -----------------------------------------------------------------------------!\n!\n  dni=dn0(0)*exp(-dn0(2)*tanh((xx-dn0(3))/dn0(1)))\n  ti =ti0(0)*exp(-ti0(2)*tanh((xx-ti0(3))/ti0(1)))\n  te =te0(0)*exp(-te0(2)*tanh((xx-te0(3))/te0(1)))\n!\n  return\n\nEND SUBROUTINE ntfunc2\n\n\nEND MODULE GKV_vmecin\n", "MODULE GKV_bndry\n!-------------------------------------------------------------------------------\n!\n!    Some useful tools and tips\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   bndry_zvm_bound_f, bndry_bound_e,  &\n      bndry_bound_f_buffin, bndry_bound_f_sendrecv, bndry_bound_f_buffout,  &\n      bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout,  &\n      bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout, &\n      bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n      bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout, &\n      bndry_vm_sendrecv_v2, bndry_zv_buffin_v2, bndry_zv_sendrecv_v2, bndry_zv_buffout_v2\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zvm_bound_f( ff )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n    integer :: im\n\n      allocate( zb1_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n\n!$OMP parallel default (none) &\n!$OMP shared(ff,zb1_bottom,zb1_top,zb2_bottom,zb2_top,vb1,vb2,mb1,mb2) &\n!$OMP private(im)\n      do im = 0, nm\n        call bndry_bound_f_buffin ( ff(:,:,:,:,im), zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_bound_f_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                      zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_bound_f_buffout ( zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      do im = 0, nm\n        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!$OMP barrier\n!$OMP master\n      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!$OMP end master\n!$OMP barrier\n      call bndry_shifts_m_buffout ( mb2, ff )\n!$OMP end parallel\n\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n      deallocate( vb1 )\n      deallocate( vb2 )\n      deallocate( mb1 )\n      deallocate( mb2 )\n\n  END SUBROUTINE bndry_zvm_bound_f\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffin( ff, zb1_bottom, zb1_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                zb1_bottom(mx,my,iz,iv) = ff(mx,my,-nz+iz  ,iv)\n                zb1_top   (mx,my,iz,iv) = ff(mx,my, nz-nzb+iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_bound_f_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffout ( zb2_bottom, zb2_top, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffout\n\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_buffin( ff, vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1, vb2\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1361)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1361,1)\n!$OMP end master\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do iv = 1, 2*nvb\n!$OMP do schedule (dynamic)\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                vb1(mx,my,iz,iv    ) = ff(mx,my,iz,         iv)\n                vb1(mx,my,iz,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv)\n!              vb1(mx,my,iz,1) = ff(mx,my,iz,     1)\n!              vb1(mx,my,iz,2) = ff(mx,my,iz,     2)\n!              vb1(mx,my,iz,3) = ff(mx,my,iz,     3)\n!              vb1(mx,my,iz,4) = ff(mx,my,iz,2*nv-2)\n!              vb1(mx,my,iz,5) = ff(mx,my,iz,2*nv-1)\n!              vb1(mx,my,iz,6) = ff(mx,my,iz,2*nv  )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1361,1)\n                                           call clock_end(1361)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_sendrecv( vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    integer  ::  slngv\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1362)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1362,1)\n!      call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n!                         vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n!                         vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1362,1)\n                                           call clock_end(1362)\n\n\n  END SUBROUTINE bndry_shifts_v_sendrecv\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_shifts_v_buffout( vb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1363)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1363,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                ff(mx,my,iz,-nvb+iv) = vb2(mx,my,iz,iv    )\n                ff(mx,my,iz,2*nv+iv) = vb2(mx,my,iz,iv+nvb)\n!              ff(mx,my,iz,    -2) = vb2(mx,my,iz,1)\n!              ff(mx,my,iz,    -1) = vb2(mx,my,iz,2)\n!              ff(mx,my,iz,     0) = vb2(mx,my,iz,3)\n!              ff(mx,my,iz,2*nv+1) = vb2(mx,my,iz,4)\n!              ff(mx,my,iz,2*nv+2) = vb2(mx,my,iz,5)\n!              ff(mx,my,iz,2*nv+3) = vb2(mx,my,iz,6)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1363,1)\n                                           call clock_end(1363)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffin( ff, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1, mb2\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do im = 1, 2*nvb\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mb2(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                mb1(mx,my,iz,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n                mb1(mx,my,iz,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n!              mb1(mx,my,iz,iv,1) = ff(mx,my,iz,iv,   0)\n!              mb1(mx,my,iz,iv,2) = ff(mx,my,iz,iv,   1)\n!              mb1(mx,my,iz,iv,3) = ff(mx,my,iz,iv,   2)\n!              mb1(mx,my,iz,iv,4) = ff(mx,my,iz,iv,nm-2)\n!              mb1(mx,my,iz,iv,5) = ff(mx,my,iz,iv,nm-1)\n!              mb1(mx,my,iz,iv,6) = ff(mx,my,iz,iv,nm  )\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_sendrecv( mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    integer  ::  slngm\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngm = (2*nx+1)*(ny+1)*(2*nz)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n!                         mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n!                         mb2(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n\n  END SUBROUTINE bndry_shifts_m_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffout( mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iz,iv,im+nvb)\n!              ff(mx,my,iz,iv,  -3) = mb2(mx,my,iz,iv,1)\n!              ff(mx,my,iz,iv,  -2) = mb2(mx,my,iz,iv,2)\n!              ff(mx,my,iz,iv,  -1) = mb2(mx,my,iz,iv,3)\n!              ff(mx,my,iz,iv,nm+1) = mb2(mx,my,iz,iv,4)\n!              ff(mx,my,iz,iv,nm+2) = mb2(mx,my,iz,iv,5)\n!              ff(mx,my,iz,iv,nm+3) = mb2(mx,my,iz,iv,6)\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_e ( ew )\n!--------------------------------------\n!  Impose the modified periodic boundary condition \n!    in the z-direction for the electric field\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)   :: ew\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb1e_bottom, zb1e_top\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb2e_bottom, zb2e_top\n    integer  ::  mx, my, iz, im, mwn, mwp\n    integer  ::  slngze\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      allocate( zb1e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb1e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n\n      slngze  = (2*nx+1)*(ny+1)*(nm+1) * nzb\n\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP private(mx,my,iz,im)\n!$OMP master\n                                           call clock_sta(1381)\n                                         ! call fapp_start(\"literm_bounde_bufferin\",1381,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2e_bottom(mx,my,iz,im) = ( 0._DP, 0._DP )\n              zb2e_top   (mx,my,iz,im) = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb1e_bottom(mx,my,iz,im) = ew(mx,my,-nz+iz  ,im)\n              zb1e_top   (mx,my,iz,im) = ew(mx,my, nz-nzb+iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferin\",1381,1)\n                                           call clock_end(1381)\n!$OMP end master\n!$OMP end parallel\n\n                                           call clock_sta(1382)\n                                         ! call fapp_start(\"literm_bounde_sendrecv\",1382,1)\n!      call MPI_sendrecv( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_bounde_sendrecv\",1382,1)\n                                           call clock_end(1382)\n\n! --- substitution\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP shared(rankz,z_bound,ck,dj) &\n!$OMP private(mx,my,iz,im,mwp,mwn)\n!$OMP master\n                                           call clock_sta(1383)\n                                         ! call fapp_start(\"literm_bounde_bufferout\",1383,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,-nz-nzb+iz,im) = zb2e_bottom(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-1,im)   =   ew(mx,my,-nz  ,im)\n                    ew(mx,my,-nz-2,im)   = - ew(mx,my,-nz+1,im) + 2._DP * ew(mx,my,-nz  ,im)\n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-nzb+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,nz+iz,im) = zb2e_top(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz  ,im)   =   ew(mx,my,nz-1,im)\n                    ew(mx,my,nz+1,im)   = - ew(mx,my,nz-2,im) + 2._DP * ew(mx,my,nz-1,im) \n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferout\",1383,1)\n                                           call clock_end(1383)\n!$OMP end master\n!$OMP end parallel\n\n      deallocate( zb1e_bottom )\n      deallocate( zb1e_top )\n      deallocate( zb2e_bottom )\n      deallocate( zb2e_top )\n\n\n  END SUBROUTINE bndry_bound_e\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_zv_buffin( ff, zb1_bottom, zb1_top, vb1 )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n\n    integer :: iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            zb1_bottom(:,:,iz,iv) = ff(:,:,-nz+iz  ,iv)\n            zb1_top   (:,:,iz,iv) = ff(:,:, nz-nzb+iz,iv)\n          end do\n        end do\n!$OMP end do nowait\n\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!!$OMP do schedule(dynamic)\n!          do iz = -nz, nz-1\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!          end do\n!!$OMP end do nowait\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            vb1(:,:,iz,iv    ) = ff(:,:,iz,         iv)\n            vb1(:,:,iz,iv+nvb) = ff(:,:,iz,2*nv-nvb+iv)\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top, vb1, vb2 )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n\n    integer :: slngz, slngv\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n     !call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n     !                   zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n     !                   zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n     !                   vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n     !                   vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_zv_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_buffout ( zb2_bottom, zb2_top, vb2, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer :: mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,-nz-nzb+iz,iv) = zb2_bottom(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,nz+iz,iv) = zb2_top(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n\n        if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = (0._DP, 0._DP)\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = (0._DP, 0._DP)\n            end do\n          end do\n!$OMP end do nowait\n        else\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffin( iz, ff, vb1, mb1 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    integer :: mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!        do im = 0, nm\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,im,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im)\n                vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do im = 1, 2*nvb\n!        do iv = 1, 2*nv\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                mb2(mx,my,iv,im) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffin\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_vm_sendrecv ( vb1, vb2, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n\n    integer :: slngv, slngm\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(nm+1) * nvb\n      slngm = (2*nx+1)*(ny+1)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n     !call MPI_sendrecv( vb1(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n     !                   vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n     !                   vb2(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n     !                   mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n     !                   mb2(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n  END SUBROUTINE bndry_vm_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffout ( iz, vb2, mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iv, im\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = (0._DP, 0._DP)\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = (0._DP, 0._DP)\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_sendrecv_v2 ( vb1, vb2, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n!mae> modify\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb,0:nm) :: vb1\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb,0:nm) :: vb2\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb,0:nm) :: mb1\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb,0:nm) :: mb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n!<\n\n    integer :: slngv, slngm\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(2*nz)*(nm+1) * nvb\n      slngm = (2*nx+1)*(ny+1)*(2*nz)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n     !call MPI_sendrecv( vb1(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n     !                   vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n     !                   vb2(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n     !                   mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n     !                   mb2(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n  END SUBROUTINE bndry_vm_sendrecv_v2\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_buffin_v2( ff, zb1_bottom, zb1_top, vb1 )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n\n    integer :: iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            zb1_bottom(:,:,iz,iv,im) = ff(:,:,-nz+iz    ,iv,im)\n            zb1_top   (:,:,iz,iv,im) = ff(:,:, nz-nzb+iz,iv,im)\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!!$OMP do schedule(dynamic)\n!          do iz = -nz, nz-1\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!          end do\n!!$OMP end do nowait\n!      end do\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n        do im = 0, nm\n          do iz = -nz, nz-1\n            vb1(:,:,iz,im,iv    ) = ff(:,:,iz,         iv,im)\n            vb1(:,:,iz,im,iv+nvb) = ff(:,:,iz,2*nv-nvb+iv,im)\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffin_v2\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_sendrecv_v2 ( zb1_bottom, zb1_top, zb2_bottom, zb2_top, vb1, vb2 )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &     \n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n\n    integer :: slngz, slngv\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngz = (2*nx+1)*(ny+1)*(2*nv)*(nm+1) * nzb\n      slngv = (2*nx+1)*(ny+1)*(2*nz)*(nm+1) * nvb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n     !call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n     !                   zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n     !                   zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n     !                   vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n     !                   vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_zv_sendrecv_v2\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_zv_buffout_v2 ( zb2_bottom, zb2_top, vb2, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iz, iv, im, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                        ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,-nz-nzb+iz,iv,im) = zb2_bottom(:,:,iz,iv,im)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n      else ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\".OR. trim(z_bound) == \"mixed\") then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv,im) = ( 0._DP, 0._DP )\n                      end do\n                    else                      ! outflow\n                      ff(mx,my,-nz-1,iv,im) =   ff(mx,my,-nz ,iv,im)\n                      ff(mx,my,-nz-2,iv,im) = - ff(mx,my,-nz+1,iv,im) + 2._DP * ff(mx,my,-nz ,iv,im)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv,im) = ck(my) * zb2_bottom(mwn,my,iz,iv,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv,im) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv,im) = ck(my) * zb2_bottom(mwn,my,iz,iv,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,nz+iz,iv,im) = zb2_top(:,:,iz,iv,im)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n      else! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\".OR. trim(z_bound) == \"mixed\") then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then! outflow\n                      ff(mx,my,nz ,iv,im) =   ff(mx,my,nz-1,iv,im)\n                      ff(mx,my,nz+1,iv,im) = - ff(mx,my,nz-2,iv,im) + 2._DP * ff(mx,my,nz-1,iv,im)\n                    else                      ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv,im) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv,im) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv,im) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv,im) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n\n        if ( rankv == 0 ) then\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n          do im = 0, nm\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv,im) = (0._DP, 0._DP)\n              ff(:,:,iz,2*nv+iv,im) = vb2(:,:,iz,im,iv+nvb)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n        else if ( rankv == nprocv-1 ) then\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n          do im = 0, nm\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv,im) = vb2(:,:,iz,im,iv    )\n              ff(:,:,iz,2*nv+iv,im) = (0._DP, 0._DP)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n        else\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n          do im = 0, nm\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv,im) = vb2(:,:,iz,im,iv    )\n              ff(:,:,iz,2*nv+iv,im) = vb2(:,:,iz,im,iv+nvb)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n        end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffout_v2\n\n\nEND MODULE GKV_bndry\n", "MODULE GKV_out\n!-------------------------------------------------------------------------------\n!\n!    Data writing\n!\n!    Update history of gkvp_out.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Use fileio module to switch Fortran/NetCDF binary output.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Frequency analysis is applied only when calc_type=\"lin_freq\".\n!        - menegy=0 when beta=0.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_intgrl, only: intgrl_thet, intgrl_fsrf, &\n                        intgrl_v0_moment, intgrl_v2_moment\n  use GKV_fld, only: fld_emfield_hh\n  use GKV_trans, only: trans_sum, trans_triad\n  use GKV_freq, only: freq_write_frq, freq_write_dsp\n  use GKV_advnc, only: caldlt_rev\n  use GKV_colliimp, only: colliimp_colli\n  use GKV_dtc,   only: flag_time_advnc, flag_time_split\n  use GKV_tips,  only: tips_flush, tips_rescale_for_linear_runs\n  !fj start 202010\n  use GKV_fileio\n  !fj end 202010\n\n  implicit none\n\n  private\n\n  public   out_cntrl, out_contnu\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE out_cntrl( ff, phi, Al, hh, time, id )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    real(kind=DP), intent(in) :: time\n    integer, intent(in) :: id\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dh, cf, ef\n    real(kind=DP), save :: tout_fxv, tout_ptn, tout_eng\n    integer :: flag_updated\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      flag_updated = 0\n\n      if( id == 0 ) then\n\n        if ( time == 0._DP ) then\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 0 )\n          call wrt ( ff, phi, Al, dh, cf, time, 1 )\n          call wrt ( ff, phi, Al, dh, cf, time, 2 )\n        end if\n\n        tout_fxv  = ( int( ( time + eps )/dtout_fxv ) + 1 ) * dtout_fxv\n        tout_ptn  = ( int( ( time + eps )/dtout_ptn ) + 1 ) * dtout_ptn\n        tout_eng  = ( int( ( time + eps )/dtout_eng ) + 1 ) * dtout_eng\n \n      else if( id == 1 ) then\n\n        if ( time >= tout_fxv - eps ) then\n          tout_fxv   = tout_fxv + dtout_fxv\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 0 )\n          write( olog, * ) \" # delta-f data output at time = \", time\n        end if\n\n        if ( time >= tout_ptn - eps ) then\n          tout_ptn   = tout_ptn + dtout_ptn\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 1 )\n          write( olog, * ) \" # field data output at time = \", time\n        end if\n\n        if ( time >= tout_eng - eps ) then\n          tout_eng   = tout_eng + dtout_eng\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 2 )\n        end if\n\n      else if( id == 2 ) then\n\n        if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n        call out_contnu ( ff, time )\n        !- OUTPUT ascii data hst/*.dsp.* for linear runs\n        if ( trim(calc_type) == \"lin_freq\" ) then\n           call freq_write_dsp\n        end if\n\n      end if\n\n      if (flag_time_split == 0) then\n        if ( trim(calc_type) == \"linear\" .or. &\n             trim(calc_type) == \"lin_freq\" ) then\n          call tips_rescale_for_linear_runs(ff, phi, Al, hh, time)\n        end if\n      end if\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n\n  END SUBROUTINE out_cntrl\n\n\n!--------------------------------------\nSUBROUTINE update_dh( ff, phi, Al, hh, dh, cf, ef, flag_updated )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh, cf, ef\n    integer, intent(out) :: flag_updated\n\n    character(15) :: colliflag\n\n\n      if (flag_time_advnc == 1) then ! Operator split + implicit collision\n        if (flag_time_split == 1) then ! dt/2 integration for 2nd-order split\n          call colliimp_colli(0.5_DP*dt, ff, phi, al, hh)\n                                               !%%% For debug %%%\n                                               ! if (rankg==0) write(olog,*) &\n                                               !       \"half-step for output\"\n                                               !%%%%%%%%%%%%%%%%%\n        end if\n        flag_time_split = 0 ! flag_time_split==0 means you have physical quantities at time\n      end if\n\n      colliflag = \"collisional\"\n      call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n      flag_updated = 1\n\nEND SUBROUTINE update_dh\n\n\n!--------------------------------------\n  SUBROUTINE out_contnu ( ff, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    real(kind=DP), intent(in) :: time\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    integer ::mx, my, iz, iv, im\n\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n!$OMP parallel workshare\n      wf(:,:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      !fj start 202010\n      !rewind ocnt\n      !write( unit=ocnt ) time, wf\n      call fileio_write_cnt( wf, time )\n      !fj end time202010\n\n      deallocate( wf )\n\n\n  END SUBROUTINE out_contnu\n\n\n!--------------------------------------\n  SUBROUTINE wrt ( ff, phi, Al, dh, cf, time, id )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh, cf\n    real(kind=DP), intent(in) :: time\n    integer, intent(in) :: id\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: fout\n    real(kind=DP), dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy,          &\n                                             peint, pmint, neint, nmint, dcd, &\n                                             pflux_es, pflux_em, eflux_es, eflux_em\n    real(kind=DP), dimension(0:(ny+1)*nprocw-1) :: mode_y\n    real(kind=DP) :: totl\n    integer :: mx, my, iv, im\n\n\n      if( id == 0 ) then\n\n        allocate( fout(-nx:nx,0:ny,1:2*nv,0:nm) )\n\n        !- OUTPUT binary data fxv/*.fxv.* -\n!$OMP parallel workshare\n        fout(:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n!$OMP parallel do collapse(2) private(mx,my,iv,im)\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                fout(mx,my,iv,im) = ff(mx,my,-nz  ,iv,im)\n              end do\n            end do\n          end do\n        end do\n        !fj start 202010\n        !write( unit=ofxv ) time, fout\n        call fileio_write_fxv( fout, time )\n        !fj end 202010\n\n        deallocate( fout )\n\n      else if( id == 1 ) then\n\n        !- OUTPUT binary data phi/*.phi.* and phi/*.Al.*\n        !fj start 202011\n        !if ( ranks == 0 .AND. vel_rank == 0 ) then\n          !write( unit=ophi ) time, phi\n          !write( unit=oAl  ) time, Al\n        !end if\n        call fileio_write_phi( phi, time )\n        call fileio_write_Al ( Al,  time )\n        !fj end 202011\n\n        !- OUTPUT binary data phi/*.mom.*\n        call write_moments ( ff, time )\n\n        !- OUTPUT binary data phi/*.tri.*\n        if( trim(calc_type) == \"nonlinear\" ) then\n          if ( num_triad_diag > 0 ) then\n            call trans_triad ( time, ff, phi, Al )\n          end if\n        end if\n\n      else if( id == 2 ) then\n\n        !- OUTPUT ascii data hst/*.bln.*\n        call balance ( ff, phi, Al, dh, cf, time,                          &\n                       entrpy, fenegy, menegy, peint, pmint, neint, nmint, &\n                       dcd, pflux_es, pflux_em, eflux_es, eflux_em )\n\n        !- OUTPUT binary data phi/*.trn.*\n        !fj start 202011\n        !if ( zsp_rank == 0 .and. vel_rank == 0 ) then\n          !write( unit=otrn ) time, entrpy, fenegy, menegy,    &\n          !                   peint, pmint, neint, nmint, dcd, &\n          !                   pflux_es, pflux_em, eflux_es, eflux_em\n        !end if\n        call fileio_write_trn( entrpy, fenegy, menegy,    &\n             peint, pmint, neint, nmint, dcd, &\n             pflux_es, pflux_em, eflux_es, eflux_em, time )\n        !fj end 202011\n\n        !- OUTPUT ascii data hst/*.eng.*, *.men.*, *.wes.*, *.wem.*,\n        !                        *.ges.*, *.gem.*, *.qes.*, *.qem.*\n        call mode_energy ( phi, totl, mode_y )\n        if( rankg == 0 ) then\n          write( unit=oeng, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call mode_energy ( Al, totl, mode_y )\n        if ( rankg == 0 ) then\n          write( unit=omen, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( fenegy, totl, mode_y )\n        if ( rankg == 0 ) then\n          write( unit=owes, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( menegy, totl, mode_y )\n        if ( rankg == 0 ) then\n          write( unit=owem, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( pflux_es, totl, mode_y )\n        if ( rank == 0 ) then\n          write( unit=oges, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( pflux_em, totl, mode_y )\n        if ( rank == 0 ) then\n          write( unit=ogem, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( eflux_es, totl, mode_y )\n        if ( rank == 0 ) then\n          write( unit=oqes, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n        call calc_kyspectrum ( eflux_em, totl, mode_y )\n\n        if ( rank == 0 ) then\n          write( unit=oqem, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        !- OUTPUT ascii data hst/*.frq.* for linear runs\n        if ( trim(calc_type) == \"lin_freq\" ) then\n          call freq_write_frq ( time, phi )\n        end if\n\n      end if\n\n\n  END SUBROUTINE wrt\n\n\n!--------------------------------------\n  SUBROUTINE mode_energy ( phi, totl, mode_y )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    real(kind=DP), intent(out), &\n      dimension(0:(ny+1)*nprocw-1)    :: mode_y\n    real(kind=DP), intent(out)        :: totl\n\n    real(kind=DP), dimension(:,:,:), allocatable :: wr3\n    real(kind=DP), dimension(-nx:nx,0:ny)        :: wr2\n    real(kind=DP), dimension(0:ny)               :: mode_wk\n    integer  ::  mx, my, iz\n\n      allocate( wr3(-nx:nx,0:ny,-nz:nz-1) )\n\n      totl    = 0._DP\n      mode_y  = 0._DP\n      mode_wk = 0._DP\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            wr3(mx,my,iz) = real( phi(mx,my,iz) * conjg( phi(mx,my,iz) )  &\n                                 , kind=DP )\n          end do\n        end do\n      end do\n\n      call intgrl_thet ( wr3, wr2 )\n\n!$OMP parallel do reduction(+:mode_wk)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          mode_wk(my) = mode_wk(my) + wr2(mx,my)\n        end do\n      end do\n\n      if( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            mode_wk(my) = mode_wk(my) + wr2(mx,my)\n          end do\n      endif\n\n      call MPI_Gather( mode_wk, ny+1, MPI_DOUBLE_PRECISION, &\n                       mode_y,  ny+1, MPI_DOUBLE_PRECISION, &\n                       0, fft_comm_world, ierr_mpi )\n\n      do my = 0, global_ny\n        totl = totl + mode_y(my)\n      end do\n\n      deallocate( wr3 )\n\n  END SUBROUTINE mode_energy\n\n\n!--------------------------------------\n  SUBROUTINE calc_kyspectrum ( fenegy, totl, mode_y )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny)          :: fenegy\n    real(kind=DP), intent(out), &\n      dimension(0:(ny+1)*nprocw-1)    :: mode_y\n    real(kind=DP), intent(out)        :: totl\n\n    real(kind=DP), dimension(0:ny) :: mode_wk\n    integer :: mx, my\n\n\n      totl    = 0._DP\n      mode_y  = 0._DP\n      mode_wk = 0._DP\n\n!$OMP parallel do reduction(+:mode_wk)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          mode_wk(my) = mode_wk(my) + fenegy(mx,my)\n        end do\n      end do\n\n      if( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            mode_wk(my) = mode_wk(my) + fenegy(mx,my)\n          end do\n      endif\n\n      call MPI_Gather( mode_wk, ny+1, MPI_DOUBLE_PRECISION, &\n                       mode_y,  ny+1, MPI_DOUBLE_PRECISION, &\n                       0, fft_comm_world, ierr_mpi )\n\n      mode_y(:) = 2._DP * mode_y(:)\n      do my = 0, global_ny\n        totl = totl + mode_y(my)\n      end do\n\n\n  END SUBROUTINE calc_kyspectrum\n\n\n!--------------------------------------\n  ", "SUBROUTINE balance ( ff, phi, Al, dh, cf, time,                    &\n                       entrpy, fenegy, menegy, peint, pmint, neint, nmint, &\n                       dcd, pflux_es, pflux_em, eflux_es, eflux_em )\n!--------------------------------------\n!     Check the entropy balance equation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh, cf\n    real(kind=DP), intent(in) :: time\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy, peint, pmint, neint, nmint, dcd, &\n                                pflux_es, pflux_em, eflux_es, eflux_em\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: dens, upara, pres, qpara, ni, wc3\n    complex(kind=DP), dimension(-nx:nx,0:ny)            :: wc2\n    complex(kind=DP), dimension(-nx:nx)                 :: zf\n    real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1)      :: wr3\n    real(kind=DP) :: entrpy_nz, entrpy_zf, fenegy_nz, fenegy_zf, menegy_nz, menegy_zf, &\n                     peint_nz, peint_zf, pmint_nz, pmint_zf, neint_nz, neint_zf, nmint_nz, nmint_zf, &\n                     dcd_nz, dcd_zf, dgp_es, dgp_em, dqp_es, dqp_em\n    real(kind=DP) :: entrpy_wk, fenegy_wk, menegy_wk, peint_wk, pmint_wk, neint_wk, nmint_wk, dcd_wk, dgp_wk, dqp_wk\n    integer :: mx, my, iz, iv, im\n\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate(  dens(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( upara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  pres(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( qpara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(    ni(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(   wc3(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel workshare\n      wc3(:,:,:) = ( 0._DP, 0._DP )\n      wr3(:,:,:) =   0._DP\n      wc2(:,:)   = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, dens )\n      call intgrl_v2_moment( wf, pres )\n     \n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = vl(iv) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, upara )\n      call intgrl_v2_moment( wf, qpara )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n             dens(mx,my,iz) = fcs(ranks) / Znum(ranks) * dens(mx,my,iz)\n            upara(mx,my,iz) = fcs(ranks) / Znum(ranks)  &\n                            * sqrt( tau(ranks) / Anum(ranks) ) * upara(mx,my,iz)\n             pres(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks) * pres(mx,my,iz)\n            qpara(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks)  &\n                            * sqrt( tau(ranks) / Anum(ranks) ) * qpara(mx,my,iz)\n          end do\n        end do\n      end do\n\n\n! --- \\begin{entropy_calculation}\n\n      entrpy(:,:) = 0._DP\n      entrpy_nz   = 0._DP\n      entrpy_zf   = 0._DP\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) =                                     &\n                        ff(mx,my,iz,iv,im) * conjg( ff(mx,my,iz,iv,im) ) &\n                        / fmx(iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          entrpy(mx,my) = 0.5_DP * fcs(ranks) * tau(ranks) / Znum(ranks) * real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n!$OMP parallel do reduction(+:entrpy_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          entrpy_nz = entrpy_nz + entrpy(mx,my)\n        end do\n      end do\n      entrpy_wk  =   0._DP\n      call MPI_Allreduce( entrpy_nz, entrpy_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      entrpy_nz = 2._DP * entrpy_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            entrpy_zf = entrpy_zf + entrpy(mx,my)\n          end do\n      endif\n      entrpy_zf = 2._DP * entrpy_zf\n\n! --- \\end{entropy_calculation}\n\n\n! --- \\begin{electric_energy_calculation}\n\n      fenegy_nz   = 0._DP\n      fenegy_zf   = 0._DP\n\n      if ( ns == 1 ) then    ! --- for ITG-ae, ETG-ai\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = 0.5_DP * real( phi(mx,my,iz) * conjg( phi(mx,my,iz) )  &\n                             , kind=DP ) * ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )\n            end do\n          end do\n        end do\n      else                   ! --- for multi-species\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = 0.5_DP * fct_e_energy(mx,my,iz)  &\n                            * real( phi(mx,my,iz) * conjg( phi(mx,my,iz) ), kind=DP )\n            end do\n          end do\n        end do\n      end if\n\n      call intgrl_thet ( wr3, fenegy )\n\n!$OMP parallel do reduction(+:fenegy_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          fenegy_nz   = fenegy_nz + fenegy(mx,my)\n        end do\n      end do\n      fenegy_wk  =   0._DP\n      call MPI_Allreduce( fenegy_nz, fenegy_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      fenegy_nz = 2._DP * fenegy_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            fenegy_zf = fenegy_zf + fenegy(mx,my)\n          end do\n      endif\n\n      if ( ns == 1 .and. sgn(0) > 0._DP ) then ! --- for ITG-ae\n\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n  \n        call intgrl_v0_moment( wf, ni )\n  \n        if( rankw == 0 )  then\n          do iz = -nz, nz-1\n            ni(0,0,iz) = ( 0._DP, 0._DP )\n          end do\n        endif\n  \n        zf = ( 0._DP, 0._DP )\n\n        if( rankw == 0 ) then\n\n          my   = 0\n!$OMP parallel do\n            do iz = -nz, nz-1\n              do mx = -nx, -1\n                wc3(mx,my,iz)   = ni(mx,my,iz)                                    &\n                                 / ( (  1._DP - g0(mx,my,iz) + tau(0)*tau_ad ) * fctgt(mx) )\n              end do\n              mx = 0\n                wc3(mx,my,iz) = (0._DP, 0._DP)\n              do mx = 1, nx\n                wc3(mx,my,iz)   = ni(mx,my,iz)                                    &\n                                 / ( (  1._DP - g0(mx,my,iz) + tau(0)*tau_ad ) * fctgt(mx) )\n              end do\n            end do\n  \n          call intgrl_fsrf ( wc3, zf )\n  \n          zf(0)   = ( 0._DP, 0._DP )\n\n          do mx = 0, nx\n            fenegy_zf   = fenegy_zf - 0.5_DP * real( zf(mx) * conjg( zf(mx) ), kind=DP) * tau(0)*tau_ad\n          end do\n\n        end if\n\n      end if\n      fenegy_zf = 2._DP * fenegy_zf\n\n! --- \\end{electric_energy_calculation}\n\n\n! --- \\begin{magnetic_energy_calculation}\n\n      menegy_nz   = 0._DP\n      menegy_zf   = 0._DP\n\n      if ( beta .ne. 0._DP ) then\n\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = 0.5_DP * fct_m_energy(mx,my,iz)  &\n                            * real( Al(mx,my,iz) * conjg( Al(mx,my,iz) ), kind=DP )\n            end do\n          end do\n        end do\n  \n        call intgrl_thet ( wr3, menegy )\n  \n!$OMP parallel do reduction(+:menegy_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            menegy_nz = menegy_nz + menegy(mx,my)\n          end do\n        end do\n        menegy_wk  =   0._DP\n        call MPI_Allreduce( menegy_nz, menegy_wk, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, fft_comm_world, ierr_mpi )\n        menegy_nz = 2._DP * menegy_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n            do mx = 0, nx\n              menegy_zf = menegy_zf + menegy(mx,my)\n            end do\n        endif\n        menegy_zf = 2._DP * menegy_zf\n\n      else\n        menegy(:,:) = 0._DP\n      end if\n\n! --- \\end{magnetic_energy_calculation}\n\n\n! --- \\begin{particle_field_interaction}\n\n      peint(:,:) = 0._DP\n      peint_nz   = 0._DP\n      peint_zf   = 0._DP\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, wc3 )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            wr3(mx,my,iz) = - real( conjg( phi(mx,my,iz) ) * wc3(mx,my,iz), kind=DP )\n          end do\n        end do\n      end do\n\n      call intgrl_thet ( wr3, peint )\n\n!$OMP parallel do reduction(+:peint_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          peint_nz = peint_nz + peint(mx,my)\n        end do\n      end do\n      peint_wk  =   0._DP\n      call MPI_Allreduce( peint_nz, peint_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      peint_nz = 2._DP * peint_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            peint_zf = peint_zf + peint(mx,my)\n          end do\n      endif\n      peint_zf = 2._DP * peint_zf\n\n\n      pmint(:,:) = 0._DP\n      pmint_nz   = 0._DP\n      pmint_zf   = 0._DP\n\n      ", "if ( beta.ne. 0._DP ) then\n\n        call fld_emfield_hh ( dh, wc3 )\n  \n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = - real( conjg( upara(mx,my,iz) )  &\n                    * sgn(ranks) * Znum(ranks) * wc3(mx,my,iz), kind=DP )\n            end do\n          end do\n        end do\n  \n        call intgrl_thet ( wr3, pmint )\n  \n!$OMP parallel do reduction(+:pmint_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            pmint_nz = pmint_nz + pmint(mx,my)\n          end do\n        end do\n        pmint_wk  =   0._DP\n        call MPI_Allreduce( pmint_nz, pmint_wk, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, fft_comm_world, ierr_mpi )\n        pmint_nz = 2._DP * pmint_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n            do mx = 0, nx\n              pmint_zf = pmint_zf + pmint(mx,my)\n            end do\n        endif\n        pmint_zf = 2._DP * pmint_zf\n\n      end if\n\n! --- \\begin{particle_field_interaction}\n\n\n! --- \\begin{nonlinear_interaction}\n\n      neint(:,:) = 0._DP\n      nmint(:,:) = 0._DP\n      neint_nz   = 0._DP\n      neint_zf   = 0._DP\n      nmint_nz   = 0._DP\n      nmint_zf   = 0._DP\n\n      if( trim(calc_type) == \"nonlinear\" ) then\n\n        call trans_sum ( ff, phi, Al, neint, nmint )\n\n!$OMP parallel do reduction(+:neint_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            neint_nz = neint_nz + neint(mx,my)\n          end do\n        end do\n        neint_wk = 0._DP\n        call MPI_Allreduce( neint_nz, neint_wk, 1, MPI_DOUBLE_PRECISION, &\n                              MPI_SUM, fft_comm_world, ierr_mpi )\n        neint_nz = 2._DP * neint_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n!$OMP parallel do reduction(+:neint_zf)\n            do mx = 0, nx\n              neint_zf = neint_zf + neint(mx,my)\n            end do\n        endif\n        neint_zf = 2._DP * neint_zf\n  \n!$OMP parallel do reduction(+:nmint_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            nmint_nz = nmint_nz + nmint(mx,my)\n          end do\n        end do\n        nmint_wk = 0._DP\n        call MPI_Allreduce( nmint_nz, nmint_wk, 1, MPI_DOUBLE_PRECISION, &\n                              MPI_SUM, fft_comm_world, ierr_mpi )\n        nmint_nz = 2._DP * nmint_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n            do mx = 0, nx\n              nmint_zf = nmint_zf + nmint(mx,my)\n            end do\n        endif\n        nmint_zf = 2._DP * nmint_zf\n\n      end if\n\n! --- \\end{nonlinear_interaction}\n\n\n! --- \\begin{flux_calculation}\n\n      call calc_flux ( dens, phi, pflux_es )\n      dgp_es = 0._DP\n!$OMP parallel do reduction(+:dgp_es)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dgp_es = dgp_es + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_es(mx,my)\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dgp_es = dgp_es + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_es(mx,my)\n          end do\n      endif\n      dgp_wk = 0._DP\n      call MPI_Allreduce( dgp_es, dgp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dgp_es = 2._DP * dgp_wk\n\n      call calc_flux ( upara, -Al, pflux_em )\n      dgp_em = 0._DP\n!$OMP parallel do reduction(+:dgp_em)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dgp_em = dgp_em + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_em(mx,my)\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dgp_em = dgp_em + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_em(mx,my)\n          end do\n      endif\n      dgp_wk = 0._DP\n      call MPI_Allreduce( dgp_em, dgp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dgp_em = 2._DP * dgp_wk\n\n      call calc_flux ( pres, phi, eflux_es )\n      dqp_es = 0._DP\n!$OMP parallel do reduction(+:dqp_es)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dqp_es = dqp_es + R0_Lt(ranks) * ( eflux_es(mx,my) - 2.5_DP * tau(ranks) * pflux_es(mx,my) )\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dqp_es = dqp_es + R0_Lt(ranks) * ( eflux_es(mx,my) - 2.5_DP * tau(ranks) * pflux_es(mx,my) )\n          end do\n      endif\n      dqp_wk = 0._DP\n      call MPI_Allreduce( dqp_es, dqp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dqp_es = 2._DP * dqp_wk\n\n      call calc_flux ( qpara, -Al, eflux_em )\n      dqp_em = 0._DP\n!$OMP parallel do reduction(+:dqp_em)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dqp_em = dqp_em + R0_Lt(ranks) * ( eflux_em(mx,my) - 2.5_DP * tau(ranks) * pflux_em(mx,my) )\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dqp_em = dqp_em + R0_Lt(ranks) * ( eflux_em(mx,my) - 2.5_DP * tau(ranks) * pflux_em(mx,my) )\n          end do\n      endif\n      dqp_wk = 0._DP\n      call MPI_Allreduce( dqp_em, dqp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dqp_em = 2._DP * dqp_wk\n\n! --- \\end{flux_calculation}\n\n\n! --- \\begin{collisionaldissipation_calculation}\n\n      dcd(:,:) = 0._DP\n      dcd_nz   = 0._DP\n      dcd_zf   = 0._DP\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im)   = fcs(ranks) / Znum(ranks) * cf(mx,my,iz,iv,im)  &\n                      * ( tau(ranks) * conjg( ff(mx,my,iz,iv,im) ) / fmx(iz,iv,im)    &\n                        + sgn(ranks) * Znum(ranks) * j0(mx,my,iz,im) * conjg( phi(mx,my,iz) ) )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment ( wf, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          dcd(mx,my) = real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n!$OMP parallel do reduction(+:dcd_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dcd_nz = dcd_nz + dcd(mx,my)\n        end do\n      end do\n      dcd_wk = 0._DP\n      call MPI_Allreduce( dcd_nz, dcd_wk, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, fft_comm_world, ierr_mpi )\n      dcd_nz = 2._DP * dcd_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            dcd_zf = dcd_zf + dcd(mx,my)\n          end do\n      endif\n      dcd_zf = 2._DP * dcd_zf\n\n! --- \\end{collisionaldissipation_calculation}\n\n\n      if ( rank == 0 ) then\n        write( unit=obln, fmt=\"(f15.8, SP, 256ES24.15e3)\" ) &\n             time,      &! [ 1] Time\n             entrpy_nz, &! [ 2] Entropy S_s (ky/=0)\n             entrpy_zf, &! [ 3] Entropy S_s (ky==0)\n             fenegy_nz, &! [ 4] Electrostatic field energy W_E (ky/=0)\n             fenegy_zf, &! [ 5] Electrostatic field energy W_E (ky/=0)\n             menegy_nz, &! [ 6] Magnetic field energy W_M (ky/=0)\n             menegy_zf, &! [ 7] Magnetic field energy W_M (ky/=0)\n             peint_nz,  &! [ 8] W_E to S_s interaction R_sE (ky/=0)\n             peint_zf,  &! [ 9] W_E to S_s interaction R_sE (ky==0)\n             pmint_nz,  &! [10] W_M to S_s interaction R_sM (ky/=0)\n             pmint_zf,  &! [11] W_M to S_s interaction R_sM (ky==0)\n             neint_nz,  &! [12] S_s(ky==0) to S_s(ky/=0) entropy transfer via ExB nonlinearity -I_sE^(z) (ky/=0)\n             neint_zf,  &! [13] S_s(ky/=0) to S_s(ky==0) entropy transfer via ExB nonlinearity  I_sE^(z) (ky==0)\n             nmint_nz,  &! [14] S_s(ky==0) to S_s(ky/=0) entropy transfer via magnetic nonlinearity -I_sM^(z) (ky/=0)\n             nmint_zf,  &! [15] S_s(ky==0) to S_s(ky/=0) entropy transfer via magnetic nonlinearity  I_sM^(z) (ky==0)\n             dcd_nz,    &! [16] Collisional dissipation D_s (ky/=0)\n             dcd_zf,    &! [17] Collisional dissipation D_s (ky==0)\n             dgp_es,    &! [18] Particle flux term by ExB flows T_s*G_sE/L_ps\n             dgp_em,    &! [19] Particle flux term by magnetic flutters T_s*G_sM/L_ps\n             dqp_es,    &! [20] Heat flux term by ExB flows Theta_sE/L_Ts\n             dqp_em      ! [21] Heat flux term by magnetic flutters Theta_sM/L_Ts\n      end if\n\n      deallocate( wf )\n      deallocate(  dens )\n      deallocate( upara )\n      deallocate(  pres )\n      deallocate( qpara )\n      deallocate(    ni )\n      deallocate(   wc3 )\n\n! --- divergence trap\n        if( trim(calc_type) == \"nonlinear\" ) then\n          if ( entrpy_nz > 1.d100 ) then \n            write(olog,*) \"DIVERGE!! at \", time, entrpy_nz\n            call tips_flush\n            call MPI_Abort(MPI_COMM_WORLD, ierr_mpi)\n            stop \"STOPPED at DIVERGENCE trap!\"\n          end if\n        end if\n! --- \n\n\n  END SUBROUTINE balance\n\n\n!--------------------------------------\n  SUBROUTINE calc_flux ( mom, phi, flux )\n!--------------------------------------\n!     Calculate turbulent flux\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: mom, phi\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny) :: flux\n\n    real(kind=DP), dimension(:,:,:), allocatable :: wr3\n    integer  ::  mx, my, iz\n\n      allocate( wr3(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            wr3(mx,my,iz) = real( - ui * ky(my) * phi(mx,my,iz)  &\n                                * conjg( mom(mx,my,iz) ), kind=DP )\n          end do\n        end do\n      end do\n\n      call intgrl_thet ( wr3, flux )\n\n      deallocate( wr3 )\n\n  END SUBROUTINE calc_flux\n\n\n!--------------------------------------\n  SUBROUTINE write_moments ( ff, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    real(kind=DP), intent(in) :: time\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: dens, upara, ppara, pperp, qlpara, qlperp\n    integer :: mx, my, iz, iv, im\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate(   dens(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  upara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  ppara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  pperp(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( qlpara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( qlperp(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, dens )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = vl(iv) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, upara )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = 0.5_DP * vl(iv)**2 * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, ppara )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = mu(im) * omg(iz) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, pperp )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = 0.5_DP * vl(iv)**3 * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, qlpara )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = vl(iv) * mu(im) * omg(iz) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, qlperp )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n              dens(mx,my,iz) = fcs(ranks) / Znum(ranks) * dens(mx,my,iz)\n             upara(mx,my,iz) = fcs(ranks) / Znum(ranks)  &\n                             * sqrt( tau(ranks) / Anum(ranks) ) * upara(mx,my,iz)\n             ppara(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks) * ppara(mx,my,iz)\n             pperp(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks) * pperp(mx,my,iz)\n            qlpara(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks)  &\n                             * sqrt( tau(ranks) / Anum(ranks) ) * qlpara(mx,my,iz)\n            qlperp(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks)  &\n                             * sqrt( tau(ranks) / Anum(ranks) ) * qlperp(mx,my,iz)\n          end do\n        end do\n      end do\n\n     !fj start 202011\n     !if ( vel_rank == 0 ) then\n       !write( unit=omom ) time, dens, upara, ppara, pperp, qlpara, qlperp\n     !end if\n      call fileio_write_mom( dens, upara, ppara, &\n                             pperp, qlpara, qlperp, time )\n     !fj end 202011\n\n      deallocate( wf )\n      deallocate(   dens )\n      deallocate(  upara )\n      deallocate(  ppara )\n      deallocate(  pperp )\n      deallocate( qlpara )\n      deallocate( qlperp )\n\n  END SUBROUTINE write_moments\n\n\nEND MODULE GKV_out\n", "MODULE GKV_mpienv\n!-------------------------------------------------------------------------------\n!\n!    Header and settings for using MPI\n!\n!    Update history of gkvp_mpienv.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n!--------------------------------------\n!  Variables for MPI parallilization\n!--------------------------------------\n  use GKV_header\n  implicit none\n\n  public\n\n  include \"mpif.h\"\n\n  integer :: rankg, nproc\n  integer :: sizedouble_c, ierr_mpi\n  integer, dimension(MPI_STATUS_SIZE)  :: status\n\n!fj> add\n  integer :: rankw\n!fj<\n  integer :: rankz, rankv, rankm, ranks\n  integer :: izup, izdn, ivup, ivdn, imup, imdn\n\n  integer ::  sendzdn, sendzup, recvzdn, recvzup\n  integer ::  sendvdn, sendvup, recvvdn, recvvup\n  integer ::  sendmdn, sendmup, recvmdn, recvmup\n\n  integer ::  vel_comm_world, zsp_comm_world, vcolor, zcolor\n  integer ::  spc_comm_world, sub_comm_world, scolor\n  integer ::  col_comm_world, ccolor\n  integer ::  vel_rank, vel_nproc\n  integer ::  zsp_rank, zsp_nproc\n  integer ::  spc_rank, spc_nproc\n  integer ::  col_rank, col_nproc\n  integer ::      rank, sub_nproc\n!fj> add\n  integer ::  fft_comm_world, wcolor\n  integer ::  fft_rank, fft_nproc\n!fj<\n  \n  integer :: ornk \n\nCONTAINS\n\n!--------------------------------------\n!fj>\n!cc  SUBROUTINE mpienv_init( nprocz, nprocv, nprocm )\n  SUBROUTINE mpienv_init( nprocw, nprocz, nprocv, nprocm, nprocs )\n!fj<\n!--------------------------------------\n\n!fj>\n!cc  integer, intent(in) :: nprocz, nprocv, nprocm\n  integer, intent(in) :: nprocw, nprocz, nprocv, nprocm, nprocs\n!fj<\n\n  integer :: ny_size, nxw_sz, nwk\n\n\n!--- begin MPI settings\n\n    call MPI_Init ( ierr_mpi )\n\n    call MPI_Comm_rank ( MPI_COMM_WORLD, rankg, ierr_mpi )\n\n    call MPI_Comm_size ( MPI_COMM_WORLD, nproc, ierr_mpi )\n\n    call MPI_Type_size ( MPI_DOUBLE_COMPLEX, sizedouble_c, ierr_mpi )\n\n! --- for multispecies \n    ranks  = rankg / ( nprocz * nprocv * nprocm * nprocw ) \n\n    call MPI_Comm_split ( MPI_COMM_WORLD, ranks, rankg, sub_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( sub_comm_world, rank, ierr_mpi )\n    call MPI_Comm_size ( sub_comm_world, sub_nproc, ierr_mpi )\n\n! --- additional comunicator for integration over species\n    scolor  = mod(rankg, nprocz*nprocw)\n    call MPI_Comm_split ( MPI_COMM_WORLD, scolor, rankg, spc_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( spc_comm_world, spc_rank, ierr_mpi )\n    call MPI_Comm_size ( spc_comm_world, spc_nproc, ierr_mpi )\n\n\n! --- process allocation to domain\n!fj> mod\n!cc    rankz = mod( rank,          nprocz )\n!cc    rankv = mod( rank / nprocz, nprocv )\n!cc    rankm = rank / ( nprocz * nprocv )\n    rankw = mod( rank,                      nprocw )\n    rankz = mod( rank / nprocw,             nprocz )\n    rankv = mod( rank / ( nprocw * nprocz), nprocv )\n    rankm = rank / ( nprocw * nprocz * nprocv )\n\n\n                            ! rank of the targets\n!cc    izup  = rank + 1\n!cc    izdn  = rank - 1\n!cc    ivup  = rank + nprocz\n!cc    ivdn  = rank - nprocz\n!cc    imup  = rank + nprocz * nprocv\n!cc    imdn  = rank - nprocz * nprocv\n    izup  = rank + nprocw\n    izdn  = rank - nprocw\n    ivup  = rank + nprocw * nprocz\n    ivdn  = rank - nprocw * nprocz\n    imup  = rank + nprocw * nprocz * nprocv\n    imdn  = rank - nprocw * nprocz * nprocv\n\n!cc    if ( rankz == nprocz-1 ) izup  = rank - nprocz + 1\n!cc    if ( rankz == 0        ) izdn  = rank + nprocz - 1\n    if ( rankz == nprocz-1 ) izup  = rank - nprocw * (nprocz - 1)\n    if ( rankz == 0        ) izdn  = rank + nprocw * (nprocz - 1)\n!fj<\n    if ( rankv == nprocv-1 ) ivup  = MPI_PROC_NULL\n    if ( rankv == 0        ) ivdn  = MPI_PROC_NULL\n    if ( rankm == nprocm-1 ) imup  = MPI_PROC_NULL\n    if ( rankm == 0        ) imdn  = MPI_PROC_NULL\n\n! --- generating sub-worlds\n\n!fj> mod\n!cc    vcolor   = rankz\n!cc    zcolor   = rank / nprocz\n!cc\n!cc    call MPI_Comm_split ( sub_comm_world, vcolor, rank, vel_comm_world, ierr_mpi )\n!cc    call MPI_Comm_rank ( vel_comm_world, vel_rank, ierr_mpi )\n!cc    call MPI_Comm_size ( vel_comm_world, vel_nproc, ierr_mpi )\n!cc\n!cc    call MPI_Comm_split ( sub_comm_world, zcolor, rank, zsp_comm_world, ierr_mpi )\n!cc    call MPI_Comm_rank ( zsp_comm_world, zsp_rank, ierr_mpi )\n!cc    call MPI_Comm_size ( zsp_comm_world, zsp_nproc, ierr_mpi )\n!cc\n!cc\n!cc      if ( nproc /= nprocz * nprocv * nprocm ) then\n\n    wcolor   = rank / nprocw\n    zcolor   = ( rank / (nprocw*nprocz) ) * nprocw + rankw\n    vcolor   = rankz*nprocw  +  rankw\n\n    call MPI_Comm_split ( sub_comm_world, wcolor, rankw, fft_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( fft_comm_world, fft_rank, ierr_mpi )\n    call MPI_Comm_size ( fft_comm_world, fft_nproc, ierr_mpi )\n\n    call MPI_Comm_split ( sub_comm_world, zcolor, rankz, zsp_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( zsp_comm_world, zsp_rank, ierr_mpi )\n    call MPI_Comm_size ( zsp_comm_world, zsp_nproc, ierr_mpi )\n\n    call MPI_Comm_split ( sub_comm_world, vcolor, (rankv+nprocv*rankm), vel_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( vel_comm_world, vel_rank, ierr_mpi )\n    call MPI_Comm_size ( vel_comm_world, vel_nproc, ierr_mpi )\n\n! --- additional communicator for inter-species comm. for field particle part collision\n    if ( rank == scolor ) then\n      ccolor = mod(rankg, sub_nproc)\n    else\n      ccolor = 99  ! dummy color\n    end if\n\n    call MPI_Comm_split ( MPI_COMM_WORLD, ccolor, rankg, col_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( col_comm_world, col_rank, ierr_mpi )\n    call MPI_Comm_size ( col_comm_world, col_nproc, ierr_mpi )\n\n    if ( vel_rank > 0 ) then \n      col_rank = MPI_PROC_NULL\n    end if\n! ---\n\n\n!cc    write( 6, * ) '##### Debug rank=',rank, &\n!cc          'wcolor,rankw=',wcolor,rankw,'zcolor, rankz=',zcolor, rankz, &\n!cc          'vcolor,(rankv+nprocv*rankm)=',vcolor,(rankv+nprocv*rankm)\n\n      if ( nproc /= nprocw * nprocz * nprocv * nprocm * nprocs ) then\n!fj<\n        write( 6, * ) &\n           \" # proccesor assigment is invalid, nproc = \", nproc\n        call MPI_Finalize ( ierr_mpi )\n        stop\n      end if\n\n!! --- for debug\n!      ornk = 1000+rankg\n!      write( ornk, \"(A25)\" ) \"# rank config., nproc = \", nproc\n!      write( ornk, \"(A3)\" ) \"#  \"\n!      write( ornk, \"(A3)\" ) \"#  \"\n!      write( ornk, \"(A9,I3)\" ) \"rankg\", rankg\n!      write( ornk, \"(A9,I3)\" ) \"ranks\", ranks\n!      write( ornk, \"(A9,I3)\" ) \"rank\", rank\n!      write( ornk, \"(A9,I3)\" ) \"rankw\", rankm\n!      write( ornk, \"(A9,I3)\" ) \"rankz\", rankz\n!      write( ornk, \"(A9,I3)\" ) \"rankv\", rankv\n!      write( ornk, \"(A9,I3)\" ) \"rankm\", rankm\n!      write( ornk, \"(A9,I3)\" ) \"vel_rank\", vel_rank\n!      write( ornk, \"(A9,I3)\" ) \"zsp_rank\", zsp_rank\n!      write( ornk, \"(A9,I3)\" ) \"spc_rank\", spc_rank\n!      write( ornk, \"(A9,I3)\" ) \"fft_rank\", fft_rank\n!      write( ornk, \"(A9,I3)\" ) \"col_rank\", col_rank\n!      write( ornk, \"(A9,I3)\" ) \"zcolor\", zcolor\n!      write( ornk, \"(A9,I3)\" ) \"vcolor\", vcolor\n!      write( ornk, \"(A9,I3)\" ) \"scolor\", scolor\n!      write( ornk, \"(A9,I3)\" ) \"ccolor\", ccolor\n\n\n! ---- set y range --------------------------\n    ny_size = global_ny + 1 \n    if( mod(ny_size,nprocw) == 0 )  then\n      nwk    = ny_size / nprocw\n    else\n      nwk    = ny_size / nprocw + 1\n    endif\n   !--- global index range ---------------- \n    ist_y_g  = nwk*rankw\n    iend_y_g = min( nwk*(rankw+1)-1, (ny_size-1) )\n    nsize_y  = iend_y_g - ist_y_g + 1\n   !--- local index range ---------------- \n    ist_y    = 0\n    iend_y   = iend_y_g - ist_y_g\n\n    if( rankw == 0 )   then\n       ist1_y    = 1\n    else \n       ist1_y    = 0\n    endif\n\n! ---- set xw range ---------------------\n    nxw_sz = 2*nxw\n    if( mod(nxw_sz,nprocw) == 0 )  then\n      nwk    = nxw_sz / nprocw\n    else\n      nwk    = nxw_sz / nprocw + 1\n    endif\n   !--- global index range ----------------\n    ist_xw_g  = nwk*rankw\n    iend_xw_g = min( nwk*(rankw+1)-1, (nxw_sz-1) )\n    nsize_xw  = iend_xw_g - ist_xw_g + 1\n   !--- local index range ----------------\n    ist_xw    = 0\n    iend_xw   = iend_xw_g - ist_xw_g\n\n\n  END SUBROUTINE mpienv_init\n\n\nEND MODULE GKV_mpienv\n", "MODULE GKV_tips\n!-------------------------------------------------------------------------------\n!\n!    Some useful tools and tips\n!\n!    Update history of gkvp_tips.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - flush for binary is removed, for the usage of NetCDF.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public   tips_reality, tips_flush, tips_rescale_for_linear_runs\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE tips_reality( wrk )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wrk\n\n    integer :: mx\n\n      if( rankw == 0 )  then\n        do mx = 0, nx\n          wrk(-mx,0,:,:,:) = conjg( wrk(mx,0,:,:,:) )\n        end do\n      endif\n\n\n  END SUBROUTINE tips_reality\n\n\n!--------------------------------------\n  SUBROUTINE tips_flush\n!--------------------------------------\n\n        call flush(olog)\n       !fj start 202010\n       !call flush(ocnt)\n       !call flush(ofxv)\n       !if ( vel_rank == 0 ) then\n       !  call flush(omom)\n       !end if\n       !if ( ranks == 0.AND. vel_rank == 0 ) then\n       !  call flush(ophi)\n       !  call flush(oAl)\n       !end if\n       !if ( zsp_rank == 0.AND. vel_rank == 0 ) then\n       !  call flush(otrn)\n       !end if\n       !fj end 202010\n        if( rankg == 0 ) then\n          call flush(odtc)\n          call flush(oeng)\n          call flush(omen)\n          call flush(owes)\n          call flush(owem)\n          if ( trim(calc_type) == \"lin_freq\" ) then\n            call flush(ofrq)\n          end if\n        end if\n        if( rank == 0 ) then\n          call flush(obln)\n          call flush(oges)\n          call flush(ogem)\n          call flush(oqes)\n          call flush(oqem)\n        end if\n\n  END SUBROUTINE tips_flush\n\n\n!--------------------------------------\n  SUBROUTINE tips_rescale_for_linear_runs(ff, phi, Al, hh, time)\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: rescale_max_num = 10\n    real(kind=DP) :: ff_max_l, ff_max, wr1\n    real(kind=DP), dimension(-nx:nx,0:ny) :: phi_max_l, phi_max, scale_factor\n    integer :: mx, my, mxw\n    integer, save :: iflg\n    data iflg / 0 /\n\n\n    ff_max_l = maxval(abs(ff))\n    call MPI_Allreduce(ff_max_l, ff_max, 1, MPI_DOUBLE_PRECISION, &\n                       MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n\n    if (ff_max > 1.d50) then! If ff is too large, rescale ff, phi, Al, hh\n\n      write( olog, * ) \" # Rescale linear run at time = \", time\n      call tips_flush\n\n     !== Determine rescale factor for each linear mode ==\n      phi_max_l(:,:) = 0._DP\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          phi_max_l(mx,my) = maxval(abs(phi(mx,my,:)))\n        end do\n      end do\n      call MPI_Allreduce(phi_max_l, phi_max, (2*nx+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                         MPI_MAX, zsp_comm_world, ierr_mpi )\n\n      scale_factor(:,:) = 1._DP\n      do my = ist_y, iend_y\n\n        if (dj(my) == 0) then ! dj==0, no mode connection in mx\n\n          do mx = -nx, nx\n            if (phi_max(mx,my).ne. 0.d0) then\n              scale_factor(mx,my) = 1.d-10 / phi_max(mx,my)\n            end if\n          end do\n\n        else                  ! dj/=0, mode connection in mxw=mx+-dj\n\n          do mx = -nx, -nx+abs(dj(my))-1\n            wr1 = 0.d0\n            do mxw = mx, nx, abs(dj(my))\n              if (wr1 < phi_max(mxw,my)) wr1 = phi_max(mxw,my)\n            end do\n            if (wr1.ne. 0.d0) then\n              do mxw = mx, nx, abs(dj(my))\n                scale_factor(mxw,my) = 1.d-10 / wr1\n              end do\n            end if\n          end do\n\n        end if\n\n      end do\n\n     !== Rescale ==\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          ff(mx,my,:,:,:) = scale_factor(mx,my) * ff(mx,my,:,:,:)\n          hh(mx,my,:,:,:) = scale_factor(mx,my) * hh(mx,my,:,:,:)\n          phi(mx,my,:) = scale_factor(mx,my) * phi(mx,my,:)\n          Al(mx,my,:) = scale_factor(mx,my) * Al(mx,my,:)\n        end do\n      end do\n\n      iflg = iflg + 1\n\n    end if\n\n    if (iflg > rescale_max_num) then\n      write( olog, * ) \" # Reach max number of rescale:\", iflg\n      call tips_flush\n      call MPI_Finalize(ierr_mpi)\n      stop\n    end if\n\n  END SUBROUTINE tips_rescale_for_linear_runs\n\n\nEND MODULE GKV_tips\n", "MODULE GKV_fileio\n!-------------------------------------------------------------------------------\n!\n!    File I/O interface for Fortran binary output\n!\n!    Update history of gkvp_fileio_fortran.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Fortran binary I/O interface by Fujitsu.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit  none\n\n  private\n\n  public    fileio_open_icnt,fileio_close_icnt, &\n            fileio_open_cnt, fileio_close_cnt, &\n            fileio_open_fxv, fileio_close_fxv, &\n            fileio_open_phi, fileio_close_phi, &\n            fileio_open_Al,  fileio_close_Al, &\n            fileio_open_mom, fileio_close_mom, &\n            fileio_open_trn, fileio_close_trn, &\n            fileio_open_tri, fileio_close_tri, &\n            \n            fileio_read_cnt,  fileio_write_cnt, &\n            fileio_write_fxv, fileio_write_phi, fileio_write_Al, &\n            fileio_write_mom, fileio_write_trn, fileio_write_tri\n\nCONTAINS\n\n!--------------------------------------\n  SUBROUTINE fileio_open_icnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(3)   :: cold\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( cold,  fmt=\"(i3.3)\" ) inum-1\n\n    open( icnt, file=path//crank//\".cnt.\"//cold, &\n          form=\"unformatted\", status=\"old\", action=\"read\" )\n\n  END SUBROUTINE fileio_open_icnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_icnt\n!--------------------------------------\n\n     close( icnt )\n\n  END SUBROUTINE fileio_close_icnt\n\n \n!--------------------------------------\n  SUBROUTINE fileio_open_cnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(3)   :: cnew\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( ocnt, file=path//crank//\".cnt.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_cnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_cnt\n!--------------------------------------\n\n     close( ocnt )\n\n  END SUBROUTINE fileio_close_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_fxv ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( ofxv, file=path//crank//\".\"//srank//\".fxv.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_fxv\n\n!--------------------------------------\n  SUBROUTINE fileio_close_fxv\n!--------------------------------------\n\n     close( ofxv )\n\n  END SUBROUTINE fileio_close_fxv\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_phi ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( ophi, file=path//crank//\".\"//srank//\".phi.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_phi\n\n!--------------------------------------\n  SUBROUTINE fileio_close_phi\n!--------------------------------------\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    close( ophi )\n\n  END SUBROUTINE fileio_close_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_Al ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( oAl, file=path//crank//\".\"//srank//\".Al.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_Al\n\n!--------------------------------------\n  SUBROUTINE fileio_close_Al\n!--------------------------------------\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    close( oAl )\n\n  END SUBROUTINE fileio_close_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_mom ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( vel_rank /= 0 ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( omom, file=path//crank//\".\"//srank//\".mom.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_mom\n\n!--------------------------------------\n  SUBROUTINE fileio_close_mom\n!--------------------------------------\n\n    if ( vel_rank /= 0 ) return\n\n    close( omom )\n\n  END SUBROUTINE fileio_close_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_trn ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( (zsp_rank /= 0).OR. (vel_rank /= 0) ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( otrn, file=path//crank//\".\"//srank//\".trn.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_trn\n\n!--------------------------------------\n  SUBROUTINE fileio_close_trn\n!--------------------------------------\n\n    if ( (zsp_rank /= 0).OR. (vel_rank /= 0) ) return\n\n    close( otrn )\n\n  END SUBROUTINE fileio_close_trn\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_tri ( path, cmx, cmy, replace )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n    character(*), intent(in) :: cmx, cmy\n    logical, intent(in) :: replace\n\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( rank /= 0 ) return\n\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( replace ) then\n       open( otri, file=path//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, &\n             form=\"unformatted\", status=\"replace\" )\n    else\n       open( otri, file=path//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, &\n             form=\"unformatted\", status=\"unknown\", position=\"append\" )\n    end if\n\n  END SUBROUTINE fileio_open_tri\n\n!--------------------------------------\n  SUBROUTINE fileio_close_tri\n!--------------------------------------\n\n    if ( rank /= 0 ) return\n\n    close( otri )\n\n  END SUBROUTINE fileio_close_tri\n\n\n\n!--------------------------------------\n  SUBROUTINE fileio_read_cnt ( wf, time, istatus )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(out) :: time\n    integer, optional, intent(out) :: istatus\n\n    integer :: input_status\n\n    read( unit=icnt, iostat=input_status ) time, wf\n    if ( present(istatus) ) then\n       istatus = input_status\n    endif\n\n  END SUBROUTINE fileio_read_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_cnt ( wf, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(in) :: time\n\n    rewind ocnt\n    write( unit=ocnt ) time, wf\n\n    call flush(ocnt)\n\n  END SUBROUTINE fileio_write_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_fxv ( fout, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,1:2*nv,0:nm) :: fout\n    real(kind=DP), intent(in) :: time\n\n    write( unit=ofxv ) time, fout\n\n    call flush(ofxv)\n\n  END SUBROUTINE fileio_write_fxv\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_phi ( phi, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    real(kind=DP), intent(in) :: time\n\n   !- OUTPUT binary data phi/\"*.phi.*\"\n    if ( ranks == 0.AND. vel_rank == 0 ) then\n       write( unit=ophi ) time, phi\n\n       call flush(ophi)\n    end if\n\n\n  END SUBROUTINE fileio_write_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_Al ( Al, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n    real(kind=DP), intent(in) :: time\n\n   !- OUTPUT binary data phi/\"*.Al.*\"\n    if ( ranks == 0.AND. vel_rank == 0 ) then\n       write( unit=oAl  ) time, Al\n\n       call flush(oAl)\n    end if\n\n  END SUBROUTINE fileio_write_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_mom ( dens, upara, ppara, pperp, qlpara, qlperp, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) ::  dens, upara, ppara, pperp, qlpara, qlperp\n    real(kind=DP), intent(in) :: time\n\n    if ( vel_rank /= 0 ) return\n\n    write( unit=omom ) time, dens, upara, ppara, pperp, qlpara, qlperp\n\n    call flush(omom)\n\n  END SUBROUTINE fileio_write_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_trn ( entrpy, fenegy, menegy, peint, pmint, &\n                                neint, nmint, dcd, pflux_es, pflux_em, &\n                                eflux_es, eflux_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy, peint, pmint, neint, nmint, dcd, &\n         pflux_es, pflux_em, eflux_es, eflux_em\n    real(kind=DP), intent(in) :: time\n\n    if ( (zsp_rank /= 0).OR. (vel_rank /= 0) ) return\n\n    write( unit=otrn ) time, entrpy, fenegy, menegy,    &\n         peint, pmint, neint, nmint, dcd, &\n         pflux_es, pflux_em, eflux_es, eflux_em\n\n    call flush(otrn)\n\n  END SUBROUTINE fileio_write_trn\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_tri ( jkpq_es, jpqk_es, jqkp_es, &\n                                jkpq_em, jpqk_em, jqkp_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,-global_ny:global_ny) :: jkpq_es, jpqk_es, jqkp_es, &\n         jkpq_em, jpqk_em, jqkp_em\n    real(kind=DP), intent(in) :: time\n\n    if ( rank /= 0 ) return\n\n    write( unit=otri ) time, jkpq_es, jpqk_es, jqkp_es, jkpq_em, jpqk_em, jqkp_em\n\n  END SUBROUTINE fileio_write_tri\n\nEND MODULE GKV_fileio\n", "MODULE GKV_intgrl\n!-------------------------------------------------------------------------------\n!\n!    Flux-surface and field-line averages, velocity-space integrals\n!\n!    Update history of gkvp_intgrl.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - real(ww)=complex(0,0) is modified to real(ww)=real(0).\n!        - Initialization at padding iend_y<my is added.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public   intgrl_fsrf, intgrl_thet, intgrl_v0_moment, intgrl_v1_moment, intgrl_v2_moment, &\n           intgrl_v0_moment_ms\n\n\n    INTERFACE intgrl_fsrf\n      module procedure  intgrl_fsrf_r, intgrl_fsrf_z\n    END INTERFACE\n\n    INTERFACE intgrl_thet\n      module procedure  intgrl_thet_r, intgrl_thet_z\n    END INTERFACE\n\n\nCONTAINS\n\n\n!note(fsrf does not require my dependence.)\n!--------------------------------------\n  SUBROUTINE intgrl_fsrf_r ( wn, wa )\n!--------------------------------------\n!     Flux-surface average of a real variable wn\n\n    real(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: wn\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx)                 :: wa\n\n    real(kind=DP), dimension(-nx:nx)    :: ww\n    integer  ::  mx, my, iz\n\n          do mx = -nx, nx\n            ww(mx)   = 0._DP\n          end do\n\n      if ( rankw == 0 ) then\n\n\n        my = 0\n!$OMP parallel do reduction(+:ww)\n          do iz = -nz, nz-1\n            do mx = 0, nx\n!              ww(mx)   = ww(mx) + wn(mx,my,iz) / omg(iz)\n              ww(mx)   = ww(mx) + wn(mx,my,iz) * rootg(iz)\n            end do\n          end do\n\n\n        call MPI_Allreduce( ww, wa, 2*nx+1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n\n!note(This procedure can be merged into upper one, \n!     since cfsrf does not have process dependence.)\n        do mx = 0, nx\n          wa(mx)   = wa(mx) / cfsrf\n        end do\n\n! --- reality condition\n        do mx = 0, nx\n          wa(-mx) = wa(mx)\n        end do\n\n      end if\n\n\n  END SUBROUTINE intgrl_fsrf_r\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_fsrf_z ( wn, wa )\n!--------------------------------------\n!     Flux-surface average of a complex variable wn\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: wn\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx)                 :: wa\n\n    complex(kind=DP), dimension(-nx:nx) :: ww\n    integer  ::  mx, my, iz\n\n\n          do mx = -nx, nx\n            ww(mx)   = ( 0._DP, 0._DP )\n          end do\n\n      if ( rankw == 0 ) then\n\n        my = 0\n!$OMP parallel do reduction(+:ww)\n          do iz = -nz, nz-1\n            do mx = 0, nx\n!              ww(mx)   = ww(mx) + wn(mx,my,iz) / omg(iz)\n              ww(mx)   = ww(mx) + wn(mx,my,iz) * rootg(iz)\n            end do\n          end do\n\n\n        call MPI_Allreduce( ww, wa, 2*nx+1, MPI_DOUBLE_COMPLEX, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n\n        do mx = 0, nx\n          wa(mx)   = wa(mx) / cfsrf\n        end do\n\n! --- reality condition\n        do mx = 0, nx\n          wa(-mx) = conjg( wa(mx) )\n        end do\n\n      end if\n\n\n  END SUBROUTINE intgrl_fsrf_z\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_thet_r ( wn, wa )\n!--------------------------------------\n!     average of a real variable wn in the theta space\n\n    real(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1)     :: wn\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny)              :: wa\n\n    real(kind=DP), dimension(-nx:nx,0:ny) :: ww\n    integer  ::  mx, my, iz\n\n      ww(:,:) = 0._DP\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n\n        do iz = -nz, nz-1\n          do mx = -nx, nx\n!            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) / omg(iz)\n            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) * rootg(iz)\n          end do\n        end do\n\n      end do\n\n      call MPI_Allreduce( ww, wa, nxy, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          wa(mx,my)   = wa(mx,my) / cfsrf\n        end do\n      end do\n\n! --- reality condition\n      if ( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            wa(-mx,my) = wa(mx,my)\n          end do\n      end if\n\n\n  END SUBROUTINE intgrl_thet_r\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_thet_z ( wn, wa )\n!--------------------------------------\n!     average of a complex variable wn in the theta space\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1)        :: wn\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny)                 :: wa\n\n    complex(kind=DP), dimension(-nx:nx,0:ny) :: ww\n    integer  ::  mx, my, iz\n\n      ww(:,:) = ( 0._DP, 0._DP )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n\n        do iz = -nz, nz-1\n          do mx = -nx, nx\n!            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) / omg(iz)\n            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) * rootg(iz)\n          end do\n        end do\n\n      end do\n\n      call MPI_Allreduce( ww, wa, nxy, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          wa(mx,my)   = wa(mx,my) / cfsrf\n        end do\n      end do\n\n! --- reality condition\n      if ( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            wa(-mx,my) = conjg( wa(mx,my) )\n          end do\n      end if\n\n\n  END SUBROUTINE intgrl_thet_z\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_v0_moment ( wf, wn )\n!--------------------------------------\n!     Calculate the zeroth order velocity moment of wf\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz) = ww(mx,my,iz)                         &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n          ! for edge compensation\n            im = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz) = ww(mx,my,iz)                             &\n                        - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                          + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                            - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                            ) * 11._DP / 720._DP                          &\n                          ) * cef * dvp(iz)\n                end do\n              end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz) = ww(mx,my,iz)                         &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, vel_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n\n  END SUBROUTINE intgrl_v0_moment\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_v2_moment ( wf, wn )\n!--------------------------------------\n!     Calculate the second order velocity moment of wf\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    real(kind=DP) :: v2a, v2b\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im,v2a,v2b)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * ( vl(iv)**2 + vp(iz,im)**2 ) * 0.5_DP\n                end do\n              end do\n            end do\n\n          ! for edge compensation\n            im   = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  v2a   = ( vl(iv)**2 + vp(iz,im  )**2 ) * 0.5_DP\n                  v2b   = ( vl(iv)**2 + vp(iz,im+1)**2 ) * 0.5_DP\n                  ww(mx,my,iz)   = ww(mx,my,iz)                           &\n                        - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                                * v2a                                     &\n                          + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                                * v2b                                     &\n                            - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                                * v2a                                     &\n                            ) * 11._DP / 720._DP                          &\n                          ) * cef * dvp(iz)\n                end do\n              end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * ( vl(iv)**2 + vp(iz,im)**2 ) * 0.5_DP\n                end do\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, vel_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n  END SUBROUTINE intgrl_v2_moment\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_v1_moment ( wf, wn )\n!--------------------------------------\n!     Calculate the second order velocity moment of wf\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * vl(iv)\n                end do\n              end do\n            end do\n\n          ! for edge compensation\n            im   = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                           &\n                        - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                                * vl(iv)                                  &\n                          + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                                * vl(iv)                                  &\n                            - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                                * vl(iv)                                  &\n                            ) * 11._DP / 720._DP                          &\n                          ) * cef * dvp(iz)\n                end do\n              end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * vl(iv)\n                end do\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, vel_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n  END SUBROUTINE intgrl_v1_moment\n\n\n!--------------------------------------\n  ", "SUBROUTINE intgrl_v0_moment_ms ( wf, wn )\n!--------------------------------------\n!     Calculate the zeroth order velocity moment of wf over species\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                    ww(mx,my,iz) = ww(mx,my,iz)                         &\n                          + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n         ! for edge compensation\n            im = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                    ww(mx,my,iz) = ww(mx,my,iz)                             &\n                          - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                            + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                              - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                              ) * 11._DP / 720._DP                          &\n                            ) * cef * dvp(iz)\n                end do\n              end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                    ww(mx,my,iz) = ww(mx,my,iz)                         &\n                          + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, spc_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n  END SUBROUTINE intgrl_v0_moment_ms\n\n\nEND MODULE GKV_intgrl\n", "MODULE GKV_advnc\n!-------------------------------------------------------------------------------\n!\n!    Flux surface and field line averages\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fld,   only: fld_esfield, fld_emfield_hh, fld_hh2ff\n  use GKV_exb,   only: exb_NL_term\n  use GKV_colli, only: colli_LB!, colli_full\n  use GKV_colliimp, only: colliimp_calc_colli_full\n  use GKV_bndry, only: bndry_bound_e,  &\n                       bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout, &\n                       bndry_zv_buffin_v2, bndry_zv_sendrecv_v2, bndry_zv_buffout_v2\n  use GKV_clock, only: clock_sta, clock_end\n  use GKV_zfilter, only: zfilter\n  use GKV_tips,  only: tips_reality\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_zv = 1, nchunk_yzv = 1, nchunk_yz = 1\n\n  public   advnc_rkgsteps_rev, caldlt_rev\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n!--------------------------------------\n!     time integration of GK equation using RKG method\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    complex(kind=DP), save,  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: qh\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dh, cf, ef\n    integer :: mx, my, iz, iv, im, istep\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  qh(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zv = ((2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yzv = ((iend_y-ist_y+1)*(2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yz = ((iend_y-ist_y+1)*(2*nz)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      do istep = 1, 4\n\n        call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n                                           call clock_sta(11)\n                                         ! call fapp_start(\"rkg\",11,1)\n        call rkg( hh, dh, qh, istep )\n                                         ! call fapp_stop(\"rkg\",11,1)\n                                           call clock_end(11)\n\n        call tips_reality ( hh )\n\n                                           call clock_sta(12)\n                                         ! call fapp_start(\"esfield\",12,1)\n        if ( beta > 0._DP ) then\n          call fld_emfield_hh( hh, Al )\n        end if\n        call fld_hh2ff( hh, Al, ff )\n        call fld_esfield( ff, phi )\n                                         ! call fapp_stop(\"esfield\",12,1)\n                                           call clock_end(12)\n      end do\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n\n  END SUBROUTINE advnc_rkgsteps_rev\n\n\n!--------------------------------------\n  SUBROUTINE rkg( hh, dh, qh, istep )\n!--------------------------------------\n!     Runge-Kutta-Gill\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh, qh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n    integer, intent(in) :: istep\n\n    real(kind=DP) :: c1, c2, cq, c0\n    integer :: mx, my, iz, iv, im\n\n\n      if      ( istep == 1 ) then\n        c1   =  0.5_DP\n        c2   = -1._DP\n        cq   = -2._DP\n        c0   =  1._DP\n      else if ( istep == 2 ) then\n        c1   =  1._DP - sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 3 ) then\n        c1   =  1._DP + sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 4 ) then\n        c1   =  1._DP / 6._DP\n        c2   = -1._DP / 3._DP\n        cq   =  0._DP\n        c0   =  0._DP\n      end if\n\n!$OMP parallel do collapse(3)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                hh(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im)           &\n                                   + c1 * dt * dh(mx,my,iz,iv,im) &\n                                   + c2 * qh(mx,my,iz,iv,im)\n                qh(mx,my,iz,iv,im) = cq * qh(mx,my,iz,iv,im) &\n                                   + c0 * dt * dh(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n\n  END SUBROUTINE rkg\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: dh, cf, ef\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi\n    integer :: mx, my, iz, iv, im\n\n      allocate( psi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n\n!$OMP parallel do collapse(2)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n              chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n            end do\n          end do\n        end do\n      end do\n\n                                           call clock_sta(13)\n                                         ! call fapp_start(\"literm\",13,1)\n     !%%% Linear collisionless term %%%\n      call caldlt_linear( ff, psi, chi, dh )\n\n     !%%% Collision term %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n\n        if ( trim(col_type) == \"LB\" ) then\n          call colli_LB( ff, phi, cf )\n        else if ( trim(col_type) == \"full\" .or. &\n                  trim(col_type) == \"lorentz\" ) then\n          !call colli_full( ff, phi, cf )\n          call colliimp_calc_colli_full( ff, phi, cf )\n        else \n          write(olog,*) \"## Illegal choice for col_type!! ---> stop\"\n          call flush(olog)\n          call MPI_Finalize(ierr_mpi)\n          stop\n        end if\n\n      else if ( trim(colliflag) == \"collisionless\" ) then\n\n!!$OMP parallel workshare\n!        cf(:,:,:,:,:) = (0._DP, 0._DP)\n!!$OMP end parallel workshare\n\n      else \n\n        write(olog,*) \"## Illegal choice for colliflag:\", colliflag\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n                                         ! call fapp_stop(\"literm\",13,1)\n                                           call clock_end(13)\n\n                                           call clock_sta(14)\n                                         ! call fapp_start(\"nlterm\",14,1)\n     !%%% Nonlinear term %%%\n      call exb_NL_term( hh, psi, chi, ef )\n                                         ! call fapp_stop(\"nlterm\",14,1)\n                                           call clock_end(14)\n\n     !%%% dh/dt = (Linear collisionless) + (Collision) - (Nonlinear) %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     + cf(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      else if ( trim(colliflag) == \"collisionless\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      end if\n                                           call clock_sta(15)\n                                         ! call fapp_start(\"zfilter\",15,1)\n      if ( trim(z_filt) == \"on\" ) then\n        call zfilter( dh )\n      end if                                \n                                         ! call fapp_stop(\"zfilter\",15,1)\n                                           call clock_end(15)\n\n      deallocate( psi )\n      deallocate( chi )\n\n  END SUBROUTINE caldlt_rev\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_linear( ff, psi, chi, dh )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: &\n                         zb1be, zb1te, zb2be, zb2te, zb1bo, zb1to, zb2bo, zb2to\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    integer :: im\n\n\n      allocate( zb1be(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb1te(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2be(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2te(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n!     allocate( zb1bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n!     allocate( zb1to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n!     allocate( zb2bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n!     allocate( zb2to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( vb1e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n!     allocate( vb1o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n!     allocate( vb2o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n\n      call bndry_bound_e( psi )\n\n      call literm_k_rev( ff, psi, chi, dh )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,psi,chi,dh) &\n!$OMP shared(zb1be,zb1te,zb2be,zb2te,zb1bo,zb1to,zb2bo,zb2to,vb1e,vb2e,vb1o,vb2o) &\n!$OMP private(im)\n\n!!%%% Without overlap %%%\n      call bndry_zv_buffin_v2( ff, zb1be, zb1te, vb1e )\n      call bndry_zv_sendrecv_v2( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n      call bndry_zv_buffout_v2( zb2be, zb2te, vb2e, ff )\n      call literm_zv_v2( ff, psi, dh )\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!!%%% With overlap %%%\n!      do im = 0, nm+3\n!        if (mod(im,2) == 0) then ! even\n!!$OMP master\n!          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1bo, zb1to, zb2bo, zb2to, vb1o, vb2o )\n!!$OMP end master\n!          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1be, zb1te, vb1e )\n!          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2be, zb2te, vb2e, ff(:,:,:,:,im-2) )\n!          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n!        else                     ! odd\n!!$OMP master\n!          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n!!$OMP end master\n!          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1bo, zb1to, vb1o )\n!          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2bo, zb2to, vb2o, ff(:,:,:,:,im-2) )\n!          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n!        end if\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( zb1be )\n      deallocate( zb1te )\n      deallocate( zb2be )\n      deallocate( zb2te )\n!     deallocate( zb1bo )\n!     deallocate( zb1to )\n!     deallocate( zb2bo )\n!     deallocate( zb2to )\n      deallocate( vb1e )\n      deallocate( vb2e )\n!     deallocate( vb1o )\n!     deallocate( vb2o )\n\n\n  END SUBROUTINE caldlt_linear\n\n\n!--------------------------------------\n  SUBROUTINE literm_k_rev ( ff, psi, chi, lf )\n!--------------------------------------\n!     z-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: lf\n\n    real(kind=DP) :: cs1, cs2, kvd, kvs\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1320)\n                                         ! call fapp_start(\"literm_perp\",1320,1)\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      cs2    = sqrt( tau(ranks) / Anum(ranks) )\n\n!$OMP parallel do collapse(3) private(kvd,kvs)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im)\n                kvs = ky(my) * vsy(iz,iv,im)\n                lf(mx,my,iz,iv,im) =                  &\n                   - ui * kvd * ff(mx,my,iz,iv,im)    &\n                   - cs1 * fmx(iz,iv,im) * (          &\n                       + ui * kvd * psi(mx,my,iz,im)  &\n                       - ui * kvs                     &\n                            * ( psi(mx,my,iz,im) - cs2 * vl(iv) * chi(mx,my,iz,im) ) )\n              end do\n            end do\n          end do\n        end do\n      end do\n                                         ! call fapp_stop(\"literm_perp\",1320,1)\n                                           call clock_end(1320)\n\n\n  END SUBROUTINE literm_k_rev\n\n\n!--------------------------------------\n  ", "SUBROUTINE literm_zv ( ff, psi, im, lf )\n!--------------------------------------\n!     (z,v)-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb)            :: psi\n    integer, intent(in) :: im\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)             :: lf\n\n    real(kind=DP), dimension(-nz:nz-1) :: cefz, cefz2\n    real(kind=DP) :: cefv, cs1\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1330)\n                                        ! call fapp_start(\"literm_para\",1330,1)\n!$OMP end master\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      do iz = -nz, nz-1\n        cefz(iz)   = 1._DP / ( 12._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n        cefz2(iz)  = 1._DP / ( 60._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n      end do\n      cefv   = 1._DP / ( 12._DP * dv ) * sqrt( tau(ranks) / Anum(ranks) )\n\n      if (trim(z_calc) == \"cf4\") then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_zv)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                 - vl(iv) * cefz(iz) * (              &\n                     -         ff(mx,my,iz+2,iv)      &\n                     + 8._DP * ff(mx,my,iz+1,iv)      &\n                     - 8._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )    &\n                 + mir(iz,im) * cefv * (              &\n                     -         ff(mx,my,iz,iv+2)      &\n                     + 8._DP * ff(mx,my,iz,iv+1)      &\n                     - 8._DP * ff(mx,my,iz,iv-1)      &\n                     +         ff(mx,my,iz,iv-2) )    &\n                 - cs1 * fmx(iz,iv,im) * (            &\n                       vl(iv) * cefz(iz) * (          &\n                         -         psi(mx,my,iz+2)    &\n                         + 8._DP * psi(mx,my,iz+1)    &\n                         - 8._DP * psi(mx,my,iz-1)    &\n                         +         psi(mx,my,iz-2) ) )&\n                 - art_diff * (                       &\n                     +         ff(mx,my,iz+2,iv)      &\n                     - 4._DP * ff(mx,my,iz+1,iv)      &\n                     + 6._DP * ff(mx,my,iz ,iv)      &\n                     - 4._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      else if (trim(z_calc) == \"up5\") then\n\n        do iv = 1, 2*nv\n          if ( vl(iv) > 0._DP ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         - 3._DP * ff(mx,my,iz+2,iv)      &\n                         +30._DP * ff(mx,my,iz+1,iv)      &\n                         +20._DP * ff(mx,my,iz ,iv)      &\n                         -60._DP * ff(mx,my,iz-1,iv)      &\n                         +15._DP * ff(mx,my,iz-2,iv)      &\n                         - 2._DP * ff(mx,my,iz-3,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          else\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         + 2._DP * ff(mx,my,iz+3,iv)      &\n                         -15._DP * ff(mx,my,iz+2,iv)      &\n                         +60._DP * ff(mx,my,iz+1,iv)      &\n                         -20._DP * ff(mx,my,iz ,iv)      &\n                         -30._DP * ff(mx,my,iz-1,iv)      &\n                         + 3._DP * ff(mx,my,iz-2,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          end if\n        end do\n\n      else\n\n        write(olog,*) \"## Illegal choice for z_calc!! ---> stop\"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_para\",1330,1)\n                                           call clock_end(1330)\n!$OMP end master\n\n\n  END SUBROUTINE literm_zv\n\n\n!--------------------------------------\n  SUBROUTINE literm_zv_v2 ( ff, psi, lf )\n!--------------------------------------\n!     (z,v)-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)            :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)             :: lf\n\n    real(kind=DP), dimension(-nz:nz-1) :: cefz, cefz2\n    real(kind=DP) :: cefv, cs1\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1330)\n                                        ! call fapp_start(\"literm_para\",1330,1)\n!$OMP end master\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      do iz = -nz, nz-1\n        cefz(iz)   = 1._DP / ( 12._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n        cefz2(iz)  = 1._DP / ( 60._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n      end do\n      cefv   = 1._DP / ( 12._DP * dv ) * sqrt( tau(ranks) / Anum(ranks) )\n\n      if (trim(z_calc) == \"cf4\") then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zv)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              lf(mx,my,iz,iv,im) = lf(mx,my,iz,iv,im)       &\n                 - vl(iv) * cefz(iz) * (              &\n                     -         ff(mx,my,iz+2,iv,im)      &\n                     + 8._DP * ff(mx,my,iz+1,iv,im)      &\n                     - 8._DP * ff(mx,my,iz-1,iv,im)      &\n                     +         ff(mx,my,iz-2,iv,im) )    &\n                 + mir(iz,im) * cefv * (              &\n                     -         ff(mx,my,iz,iv+2,im)      &\n                     + 8._DP * ff(mx,my,iz,iv+1,im)      &\n                     - 8._DP * ff(mx,my,iz,iv-1,im)      &\n                     +         ff(mx,my,iz,iv-2,im) )    &\n                 - cs1 * fmx(iz,iv,im) * (            &\n                       vl(iv) * cefz(iz) * (          &\n                         -         psi(mx,my,iz+2,im)    &\n                         + 8._DP * psi(mx,my,iz+1,im)    &\n                         - 8._DP * psi(mx,my,iz-1,im)    &\n                         +         psi(mx,my,iz-2,im) ) )&\n                 - art_diff * (                       &\n                     +         ff(mx,my,iz+2,iv,im)      &\n                     - 4._DP * ff(mx,my,iz+1,iv,im)      &\n                     + 6._DP * ff(mx,my,iz ,iv,im)      &\n                     - 4._DP * ff(mx,my,iz-1,iv,im)      &\n                     +         ff(mx,my,iz-2,iv,im) )\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!!!$OMP end do nowait\n\n      else if (trim(z_calc) == \"up5\") then\n\n        do im = 0, nm\n        do iv = 1, 2*nv\n          if ( vl(iv) > 0._DP ) then\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv,im) = lf(mx,my,iz,iv,im)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         - 3._DP * ff(mx,my,iz+2,iv,im)      &\n                         +30._DP * ff(mx,my,iz+1,iv,im)      &\n                         +20._DP * ff(mx,my,iz ,iv,im)      &\n                         -60._DP * ff(mx,my,iz-1,iv,im)      &\n                         +15._DP * ff(mx,my,iz-2,iv,im)      &\n                         - 2._DP * ff(mx,my,iz-3,iv,im) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2,im)      &\n                         + 8._DP * ff(mx,my,iz,iv+1,im)      &\n                         - 8._DP * ff(mx,my,iz,iv-1,im)      &\n                         +         ff(mx,my,iz,iv-2,im) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2,im)    &\n                             + 8._DP * psi(mx,my,iz+1,im)    &\n                             - 8._DP * psi(mx,my,iz-1,im)    &\n                             +         psi(mx,my,iz-2,im) ) )\n                end do\n              end do\n            end do\n!!TBI!!!$OMP end do nowait\n          else\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv,im) = lf(mx,my,iz,iv,im)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         + 2._DP * ff(mx,my,iz+3,iv,im)      &\n                         -15._DP * ff(mx,my,iz+2,iv,im)      &\n                         +60._DP * ff(mx,my,iz+1,iv,im)      &\n                         -20._DP * ff(mx,my,iz ,iv,im)      &\n                         -30._DP * ff(mx,my,iz-1,iv,im)      &\n                         + 3._DP * ff(mx,my,iz-2,iv,im) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2,im)      &\n                         + 8._DP * ff(mx,my,iz,iv+1,im)      &\n                         - 8._DP * ff(mx,my,iz,iv-1,im)      &\n                         +         ff(mx,my,iz,iv-2,im) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2,im)    &\n                             + 8._DP * psi(mx,my,iz+1,im)    &\n                             - 8._DP * psi(mx,my,iz-1,im)    &\n                             +         psi(mx,my,iz-2,im) ) )\n                end do\n              end do\n            end do\n!!TBI!!!$OMP end do nowait\n          end if\n        end do\n        end do\n\n      else\n\n        write(olog,*) \"## Illegal choice for z_calc!! ---> stop\"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_para\",1330,1)\n                                           call clock_end(1330)\n!$OMP end master\n\n\n  END SUBROUTINE literm_zv_v2\n\n\nEND MODULE GKV_advnc\n", "MODULE GKV_colli\n!-------------------------------------------------------------------------------\n!\n!    Collision term\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only : clock_sta, clock_end\n  use GKV_bndry, only : bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n           bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout, &\n           bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout, &\n           bndry_vm_sendrecv_v2\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_xy = 1, nchunk_yvb = 1, nchunk_ymb = 1\n\n  public   colli_set_param, colli_LB!, colli_full\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE colli_set_param (q0, eps_r, nust)\n!-------------------------------------------------------------------------------\n!\n!    Set parameters for GK collision term\n!\n!    by M. Nakata and M. Nunami, April 2014\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), parameter :: mp      = 1.67262178d-24, & ! proton mass in g\n                                ee      = 4.80320425d-10, & ! elementary charge in esu\n                                ev2erg  = 1.60217657d-12    ! erg/eV  (cf. 1J = 10^7 erg)\n    \n    real(kind=DP),                    intent(in)  :: q0, eps_r\n    real(kind=DP), dimension(0:ns-1,0:ns-1), intent(out) :: nust\n\n    real(kind=DP), dimension(0:ns-1)        :: tmpr, dens, freq_factor\n    real(kind=DP), dimension(0:ns-1,0:ns-1) :: log_lambda\n!    real(kind=DP)                           :: cph, dph, cgg\n\n    integer :: is, is1, is2\n  \n! --- temperature [in eV] and density [in cm^(-3)]\n    do is = 0, ns-1\n      tmpr(is) = tau(is) * Tref*1.d3\n      dens(is) = Nref*1.d-6 * fcs(is)/Znum(is)\n    end do\n\n! --- factor for collision frequencies\n    do is = 0, ns-1\n      freq_factor(is)  = (dens(is) * ee**4 * Lref*1.d2) / (Tref*1.d3*ev2erg)**2 \n    end do\n\n\n! --- Coulomb logarithm in cm^(-3) and eV units (see NRL plasma Formulary)  \n    do is1 = 0, ns-1\n      if (sgn(is1) < 0.d0) then  !! For is1 = electron\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! e-e case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23.5_DP - dlog( dsqrt( dens(is1) ) * tmpr(is1)**(-1.25_DP) )  &\n                                            - dsqrt( 1.d-5 + (( dlog(tmpr(is1)) - 2._DP )**2 )/16._DP )\n            end if\n          else                        !! e-i case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is1) ) / tmpr(is1) )\n            end if\n          end if\n        end do\n\n      else                     !! For is1 = ions\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! i-e case\n            if (dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is2) ) / tmpr(is2) )\n            end if\n          else                       !! i-i case\n            if (dens(is1) == 0.d0 .and. dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23._DP &\n                - dlog( Znum(is1)*Znum(is2)*(Anum(is1)+Anum(is2))/(Anum(is1)*tmpr(is2)+Anum(is2)*tmpr(is1)) &\n                        * dsqrt( (dens(is1) * Znum(is1)**2)/tmpr(is1)                                       &\n                               + (dens(is2) * Znum(is2)**2)/tmpr(is2) ) )\n            end if\n          end if\n        end do\n\n      end if\n    end do\n\n! --- Constant parameters\n    do is1 = 0, ns-1\n      do is2 = 0, ns-1 \n\n         ctauiv(is1,is2) = freq_factor(is2) * (8._DP*dsqrt(pi)/3._DP/dsqrt(2._DP))*log_lambda(is1,is2)  & \n                                   * ( Znum(is1)**2*Znum(is2)**2/dsqrt(Anum(is1))/tau(is1)**1.5 )\n\n         calpha(is1,is2) = dsqrt( tau(is1) * Anum(is2) / ( tau(is2) * Anum(is1) ) )\n         ctheta(is1,is2) = dsqrt( tau(is1) * ( Anum(is1) + Anum(is2) ) / ( tau(is1) * Anum(is2) + tau(is2) * Anum(is1) ) )\n\n         cgamma(is1,is2) = - Anum(is1) * calpha(is1,is2)                                      &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**1.5_DP \n\n         ceta(is1,is2)   = - tau(is1) * 3._DP * calpha(is1,is2)                               &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**2.5_DP\n\n          cxi(is1,is2)   =  calpha(is1,is2) * ( ctheta(is1,is2) - 1._DP ) * ctauiv(is1,is2)   &\n                             / dsqrt(1._DP + calpha(is1,is2)**2) \n\n         nust(is1,is2)   = q0*(ctauiv(is1,is2)/dsqrt(2._DP))/(eps_r**1.5*dsqrt(tau(is1)/Anum(is1)))\n\n      end do\n    end do\n\n!!!%%% Parameters for colli_full %%%\n!!!! --- xxa = v/vta/sqrt(2), where vta = sqrt(Ta/ma)\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1\n!!!          xxa(iz,iv,im) = dsqrt(vl(iv)**2 + vp(iz,im)**2)/dsqrt(2._DP) \n!!!        end do \n!!!      end do\n!!!    end do\n!!!\n!!!! --- collision frequencies and v-space functions\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1 \n!!!          do is1 = 0, ns-1\n!!!            do is2 = 0, ns-1 \n!!!\n!!!              cph = derf(calpha(is1,is2)*xxa(iz,iv,im))\n!!!              dph = 2._DP/dsqrt(pi)*dexp(-calpha(is1,is2)**2*xxa(iz,iv,im)**2)\n!!!              cgg = (cph - calpha(is1,is2)*xxa(iz,iv,im)*dph)/(calpha(is1,is2)**2*xxa(iz,iv,im)**2)*0.5_DP\n!!!\n!!!              nu_d(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*(cph-cgg)/xxa(iz,iv,im)**3\n!!!              nu_p(iz,iv,im,is1,is2) = 1.50_DP*dsqrt(pi)*ctauiv(is1,is2)*(  cgg  )/xxa(iz,iv,im)**3\n!!!              nu_h(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*calpha(is1,is2)*dph/xxa(iz,iv,im)**2\n!!!              nu_g(iz,iv,im,is1,is2) = nu_p(iz,iv,im,is1,is2)*xxa(iz,iv,im)**2*(1._DP-calpha(is1,is2)**2)\n!!!\n!!!              c_t0(iz,iv,im,is1,is2,1)  = - (1._DP + calpha(is1,is2)**2)*fmx(iz,iv,im)*nu_p(iz,iv,im,is1,is2)               &\n!!!                                             * xxa(iz,iv,im)**2*vl(iv)\n!!!              c_t0(iz,iv,im,is1,is2,2)  = - 1.5_DP*dsqrt(pi)*ctauiv(is1,is2)*fmx(iz,iv,im)                                  & \n!!!                                             * ( cph - calpha(is1,is2)*xxa(iz,iv,im)*(1._DP + calpha(is1,is2)**2)*dph )     & \n!!!                                             / calpha(is1,is2)**2 / xxa(iz,iv,im)\n!!!\n!!!              x_tst(1,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*fmx(iz,iv,im)*vl(iv)\n!!!              x_tst(2,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv) \n!!!              x_tst(3,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)/vl(iv)\n!!!              x_tst(4,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,1)                              &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)           &\n!!!                                                              * fmx(iz,iv,im)*vl(iv)/dsqrt(1._DP + calpha(is1,is2)**2) )\n!!!              x_tst(5,iz,iv,im,is1,is2) =  x_tst(4,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              x_tst(6,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,2)*2._DP/3._DP                &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)         &\n!!!                                                              * fmx(iz,iv,im)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)*2._DP     &\n!!!                                                               / (1._DP + calpha(is1,is2)**2)**1.5 )\n!!!\n!!!              y_fld(1,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))*calpha(is1,is2)*Anum(is1)             & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/tau(is1)/cgamma(is1,is2)     &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,1) - cxi(is1,is2)*fmx(iz,iv,im)*vl(iv) ) \n!!!              y_fld(2,iz,iv,im,is1,is2) = y_fld(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              y_fld(3,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))                                     & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/ceta(is1,is2)              &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,2)                                          &\n!!!                                                           - cxi(is1,is2)/(1._DP+calpha(is1,is2)**2)*fmx(iz,iv,im)        &\n!!!                                                               *(2._DP*xxa(iz,iv,im)**2 - 3._DP) ) \n!!!              y_fld(4,iz,iv,im,is1,is2) = - y_fld(1,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(5,iz,iv,im,is1,is2) = - y_fld(2,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(6,iz,iv,im,is1,is2) = - y_fld(3,iz,iv,im,is1,is2)*2._DP*cxi(is2,is1)/(1._DP+calpha(is2,is1)**2) \n!!!\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do\n!!!    end do \n!!!\n!!!! --- summation of collision frequencies with respect to is2, and adiabatic term (used in colli_GK_CT)\n!!!    nu_hs = 0._DP \n!!!    nu_gs = 0._DP \n!!!    nu_ds = 0._DP \n!!!    nu_ps = 0._DP \n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1 \n!!!            do is2 = 0, ns-1 \n!!!                nu_hs(iz,iv,im) = nu_hs(iz,iv,im) + nu_h(iz,iv,im,is1,is2)\n!!!                nu_gs(iz,iv,im) = nu_gs(iz,iv,im) + nu_g(iz,iv,im,is1,is2)\n!!!                nu_ds(iz,iv,im) = nu_ds(iz,iv,im) + nu_d(iz,iv,im,is1,is2)\n!!!                nu_ps(iz,iv,im) = nu_ps(iz,iv,im) + nu_p(iz,iv,im,is1,is2)\n!!!            end do \n!!!          end do \n!!!        end do\n!!!      end do \n!!!\n!!!    if (trim(col_type) == \"lorentz\") then\n!!!      nu_hs(:,:,:) = 0._DP\n!!!      nu_ps(:,:,:) = 0._DP\n!!!      x_tst(:,:,:,:,:,:) = 0._DP\n!!!      y_fld(:,:,:,:,:,:) = 0._DP\n!!!      nu_gs(:,:,:) = - nu_ds(:,:,:)\n!!!    end if\n!!!\n!!!! --- adiabatic part (used in colli_GK_CT)\n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!\n!!!        if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                               - ( nu_ds(iz,iv,im)*vl(iv)**2                           &\n!!!                                     * ksq(mx,my,iz)*Anum(is1)/Znum(is1)/omg(iz)**2    &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        else\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                                 ( -( nu_ds(iz,iv,im)*vl(iv)**2                        &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2                     &\n!!!                                     * (j0(mx,my,iz,im) - j2(mx,my,iz,im))             &\n!!!                                   -( nu_hs(iz,iv,im)*vp(iz,im)                        &\n!!!                                       - 0.5_DP*nu_ps(iz,iv,im)*vp(iz,im)              &\n!!!                                               *(1._DP-vl(iv)**2-vp(iz,im)**2)         &\n!!!                                       + 0.5_DP*nu_ds(iz,iv,im)                        &\n!!!                                               *(vl(iv)**2/vp(iz,im)-vp(iz,im)) )      &\n!!!                                     * dsqrt(ksq(mx,my,iz)*Anum(is1)/tau(is1))/omg(iz) &\n!!!                                     * j1(mx,my,iz,im)                                 &\n!!!                                   -( nu_ds(iz,iv,im)                                  &\n!!!                                               *(2._DP*vl(iv)**2+vp(iz,im)**2)         &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2 * j0(mx,my,iz,im)   &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        end if\n!!!\n!!!      end do\n!!!\n!!!\n!!!! --- set v-space functions used in colli_moment\n!!!\n!!!    vfunc(:,:,:,:,:) = 0._DP\n!!!    jfunc(:,:,:,:,:) = 0._DP\n!!!\n!!!    ", "if ( iFLR == 1 ) then\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = & \n!!!      !                              j1(mx,my,iz,im)*vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = j0(mx,my,iz,im)*vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = j1(mx,my,iz,im)*vp(iz,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = j0(mx,my,iz,im)*(xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = vp(iz,im)\n!!!                vfunc(iz,iv,im,is2,6) = xxa(iz,iv,im)**2-1.5_DP\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,2) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,3) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,4) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,5) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,6) = j0(mx,my,iz,im)\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!   \n!!!    else \n!!!\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = 0._DP\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = 0._DP\n!!!                vfunc(iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = 1._DP\n!!!              jfunc(mx,my,iz,im,2) = 0._DP\n!!!              jfunc(mx,my,iz,im,3) = 1._DP\n!!!              jfunc(mx,my,iz,im,4) = 1._DP\n!!!              jfunc(mx,my,iz,im,5) = 0._DP\n!!!              jfunc(mx,my,iz,im,6) = 1._DP\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!\n!!!    end if\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n! -----------------------------------\n! --- Output constants\n    if ( rankg == nprocz/2 ) then\n\n      do is1 = 0, ns-1\n        do is2 = 0, ns-1 \n          write(unit=ocst,fmt=\"(2I3,SP,256ES24.15e3)\") is1, is2, ctheta(is1,is2), calpha(is1,is2), &\n                                                                 fcs(is1)/Znum(is1)*ceta(is1,is2), &\n                                                               fcs(is1)/Znum(is1)*cgamma(is1,is2), & \n                                                                    cxi(is1,is2), ctauiv(is1,is2), &\n                                                                              log_lambda(is1,is2)\n! --- Note that, for ns >=3, cgamma(is1,is2) /= cgamma(is2,is1), but dens(is1)*cgamma(is1,is2) = dense(is2)*cgamma(is2,is1)\n! ---  due to normalizartion with dens(is). \n        end do\n      end do\n\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=4000,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_h(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_g(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_d(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_p(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=4000,fmt=*)\n!        write (unit=4001,fmt=*)\n!        write (unit=4002,fmt=*)\n!        write (unit=4003,fmt=*)\n!        write (unit=4004,fmt=*)\n!        write (unit=4005,fmt=*)\n!      end do\n!\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=5001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=5001,fmt=*)\n!        write (unit=5002,fmt=*)\n!        write (unit=5003,fmt=*)\n!        write (unit=5004,fmt=*)\n!        write (unit=5005,fmt=*)\n!        write (unit=5006,fmt=*)\n!        write (unit=6001,fmt=*)\n!        write (unit=6002,fmt=*)\n!        write (unit=6003,fmt=*)\n!        write (unit=6004,fmt=*)\n!        write (unit=6005,fmt=*)\n!        write (unit=6006,fmt=*)\n!      end do\n\n    end if\n\n    return\n\n   END SUBROUTINE colli_set_param\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB( ff, phi, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: gge, ggo\n    integer :: iz\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_xy = ((2*nx+1)*(ny+1)-1) / (nthreads-1) + 1\n!$      nchunk_yvb = ((ny+1)*(2*nv)*(2*nvb)-1) / (nthreads-1) + 1\n!$      nchunk_ymb = ((ny+1)*(nm+1)*(2*nvb)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( vb1e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n      allocate( mb1e(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      allocate( mb2e(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      !!!allocate( gge(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny,-nz:nz-1) )\n      ! mod by M.Nakata 20200928\n      allocate( gge(-nx:nx,0:ny,-nz:nz-1,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!     allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!     allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!     allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!     allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!     allocate( ggo(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,phi,cf,vb1e,vb2e,mb1e,mb2e,gge) &\n!$OMP shared(vb1o,vb2o,mb1o,mb2o,ggo) &\n!$OMP private(iz)\n\n!$OMP workshare\n      vb1e(:,:,:,:,:) = (0._DP, 0._DP)\n      vb2e(:,:,:,:,:) = (0._DP, 0._DP)\n      mb1e(:,:,:,:,:) = (0._DP, 0._DP)\n      mb2e(:,:,:,:,:) = (0._DP, 0._DP)\n       gge(:,:,:,:,:) = (0._DP, 0._DP)\n!     vb1o(:,:,:,:) = (0._DP, 0._DP)\n!     vb2o(:,:,:,:) = (0._DP, 0._DP)\n!     mb1o(:,:,:,:) = (0._DP, 0._DP)\n!     mb2o(:,:,:,:) = (0._DP, 0._DP)\n!      ggo(:,:,:,:) = (0._DP, 0._DP)\n      cf(:,:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n!!%%% Without overlap %%%\n      call colli_LB_buffin_v2(ff, phi, vb1e, mb1e)\n      call bndry_vm_sendrecv_v2(vb1e, vb2e, mb1e, mb2e)\n      !!!call colli_LB_buffout_v2(ff, phi, vb2e, mb2e, gge)\n      !!!call colli_LB_calc_v2(gge, cf)\n      ! mod by M.Nakata 20200928\n      call colli_LB_buffout_v3_sx(ff, phi, vb2e, mb2e, gge)   \n      call colli_LB_calc_v3_sx(gge, cf)\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n!      do iz = -nz, nz-1+3\n!        if (mod(iz+nz,2) == 0) then ! even\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1e, mb1e)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2e, mb2e, gge)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, ggo, cf)\n!        else                        ! odd\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1o, mb1o)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2o, mb2o, ggo)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, gge, cf)\n!        end if\n!!$OMP barrier\n!      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( vb1e )\n      deallocate( vb2e )\n      deallocate( mb1e )\n      deallocate( mb2e )\n      deallocate( gge )\n!     deallocate( vb1o )\n!     deallocate( vb2o )\n!     deallocate( mb1o )\n!     deallocate( mb2o )\n!     deallocate( ggo )\n\n  END SUBROUTINE colli_LB\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_buffin( iz, ff, phi, vb1, mb1 )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    real(kind=DP) :: cs1\n    integer :: mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_ymb)\n      do iv = 1, nvb\n        do im = 0, nm\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im) &\n                                  + cs1 * fmx(iz,         iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n              vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im) &\n                                  + cs1 * fmx(iz,2*nv-nvb+iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_yvb)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1) &\n                                  + cs1 * fmx(iz,iv,     im-1) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im) &\n                                  + cs1 * fmx(iz,iv,nm-nvb+im) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffin\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout( iz, ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          do im = 0, nm\n            do iv = 1, 2*nv\n              gg(iv,im,mx,my) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = (0._DP, 0._DP)\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = (0._DP, 0._DP)\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc( iz, gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                         ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n      cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n      cef4 = nu_s / ( 12._DP * dvp(iz) )\n      cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                  / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n\n      if ( rankm /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                           ) * cef1                                    &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &      \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankm == 0\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            im = 0\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            -          gg(iv,im+2,mx,my)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            im = 1\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im  ,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im  ,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &   \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            do im = 2, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                    ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc\n\n\n\n!!--------------------------------------\n!  SUBROUTINE colli_LB( ff, phi, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n!    integer :: iz\n!\n!      allocate( vb1e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!\n!!$OMP parallel default(none) &\n!!$OMP shared(ff,cf,vb1e,vb2e,mb1e,mb2e) &\n!!$OMP shared(vb1o,vb2o,mb1o,mb2o) &\n!!$OMP private(iz)\n!\n!!!%%% Without overlap %%%\n!!      do iz = -nz, nz-1\n!!        call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!!!$OMP barrier\n!!!$OMP master\n!!        call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!!$OMP end master\n!!!$OMP barrier\n!!        call bndry_vm_buffout(iz, vb2e, mb2e, ff)\n!!!$OMP barrier\n!!        call colli_LB_model_rev(iz, ff, cf)\n!!!$OMP barrier\n!!      end do\n!!!%%%%%%%%%%%%%%%%%%%%%%%\n!\n!\n!!%%% With overlap %%%\n!      do iz = -nz, nz-1+3\n!        if (mod(iz+nz,2) == 0) then ! even\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2e, mb2e, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        else                        ! odd\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1o, mb1o)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2o, mb2o, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        end if\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%\n!\n!!$OMP end parallel\n!\n!      deallocate( vb1e )\n!      deallocate( vb2e )\n!      deallocate( mb1e )\n!      deallocate( mb2e )\n!      deallocate( vb1o )\n!      deallocate( vb2o )\n!      deallocate( mb1o )\n!      deallocate( mb2o )\n!\n!  END SUBROUTINE colli_LB\n!\n!\n!!--------------------------------------\n!  ", "SUBROUTINE colli_LB_model_rev( iz, ff, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    integer, intent(in) :: iz\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4\n!    integer  ::  mx, my, iv, im\n!\n!\n!!$OMP master\n!                                           call clock_sta(1311)\n!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!$OMP end master\n!\n!! --- Note that nu(ranks) is a bias factor \n!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!      nu_s = 1.d-3\n!\n!      cef1   = nu_s / ( 12._DP * dv * dv )\n!      cef2   = nu_s / ( 12._DP * dv )\n!      cef3   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!      cef4   = nu_s / ( 12._DP * dvp(iz) )\n!\n!      if( rankm /= 0  ) then\n!\n!        do im = 0, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!                              -          ff(mx,my,iz,iv-2,im)                 &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                               * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      else\n!\n!        im = 0\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -          ff(mx,my,iz,iv,im+2)                &\n!                             ) * cef3 * 2._DP                                 &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        im = 1\n!\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        do im = 2, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      end if\n!\n!!$OMP master\n!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!                                      call clock_end(1311)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE colli_LB_model_rev\n\n\n\n\n!!!!%%% Subroutines for colli_LB (old version) %%%\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_LB( ff, phi, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    integer :: im\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(ff,cf,vb1,vb2,mb1,mb2) &\n!!!!$OMP private(im)\n!!!\n!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!$OMP barrier\n!!!\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!      call colli_zeroset( cf )\n!!!!$OMP barrier\n!!!\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_m_buffout ( mb2, ff )\n!!!!$OMP barrier\n!!!\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!      call colli_LB_model( ff, nm-1, cf(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!      call colli_LB_model( ff, nm, cf(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!\n!!!  END SUBROUTINE colli_LB\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_LB_model( ff, im, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    real(kind=DP) :: nu_s, cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3, cef4\n!!!    integer  ::  mx, my, iz, iv\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1311)\n!!!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!! --- Note that nu(ranks) is a bias factor \n!!!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!!!      nu_s = 1.d-3\n!!!\n!!!      cef1   = nu_s / ( 12._DP * dv * dv )\n!!!      cef2   = nu_s / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!        cef4(iz)   = nu_s / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!      if( rankm /= 0  ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                           &\n!!!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!!!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!!!                              -          ff(mx,my,iz,iv-2,im)                 &\n!!!                             ) * cef1                                         &\n!!!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                               +          ff(mx,my,iz,iv-2,im)                &\n!!!                             ) * cef2 * vl(iv)                                &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               -          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef3(iz)                                     &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!!!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!!$OMP end do nowait\n!!!          end do\n!!!\n!!!      else\n!!!\n!!!          if ( im == 0 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -          ff(mx,my,iz,iv,im+2)                &\n!!!                               ) * cef3(iz) * 2._DP                             &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else if ( im == 1 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else  ! 2=<im=<nm\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          end if\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_LB_model\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_zeroset( cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    zero clear for collision terms \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)    :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv,im) = ( 0._DP, 0._DP )     \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_zeroset\n\n\n!!!%%% Subroutines for colli_full %%%\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 4th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 12._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 32._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -  2._DP * ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 31._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[2,nm] nm for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( -          ff(mx,my,iz,iv,im-2)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT6( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 6th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 90._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 60._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 90._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 270._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               -   27_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +   2._DP * ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 135._DP  * ff(mx,my,iz,iv,im-1)                   &\n!!!                               - 258.5_DP * ff(mx,my,iz,iv,im  )                   &\n!!!                               + 136._DP  * ff(mx,my,iz,iv,im+1)                   &\n!!!                               - 13.5_DP  * ff(mx,my,iz,iv,im+2)                   &\n!!!                               +            ff(mx,my,iz,iv,im+3)                   &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 2 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 136._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[3,nm] for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( +           ff(mx,my,iz,iv,im-3)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_DT( moment_ab_wk, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Non-isothermal terms of test particle part and field particle part \n!!!!                                                      in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1312)\n!!!                                    ! call fapp_start(\"literm_colli_dt\",1312,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dt\",1312,1)\n!!!                                      call clock_end(1312)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_GK_CF_DT(moment_ba_wk, moment_ab_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle and non-isothermal parts in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk, moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CF(moment_ba_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle part in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)         \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_calc( hh, phi, ww )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: local velocity moment part \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!\n!!!    !complex(kind=DP), intent(out), &\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!\n!!!    real(kind=DP) :: v2a, v2b, dflg\n!!!    complex(kind=DP) :: wf1, wf2\n!!!    integer :: mx, my, iz, iv, im, is1, is2, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1314)\n!!!                                    ! call fapp_start(\"literm_colli_mom\",1314,1)\n!!!!$OMP end master\n!!!\n!!!      if ( rankm == 0 ) then\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii,v2a,v2b,wf1,wf2)\n!!!      do ii = 1, 6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!\n!!!! for edge compensation\n!!!!         im  = 1\n!!!          do im = 1, 1\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !v2a = vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    !v2b = vfunc(mx,my,iz,iv,im+1,is2,ii)\n!!!                    v2a = jfunc(mx,my,iz,im,ii)  *vfunc(iz,iv,im,is2,ii)\n!!!                    v2b = jfunc(mx,my,iz,im+1,ii)*vfunc(iz,iv,im+1,is2,ii)\n!!!                    wf1 = hh(mx,my,iz,iv,im)   \n!!!                    wf2 = hh(mx,my,iz,iv,im+1)\n!!!                    ww(mx,my,iz,is2,ii)  = ww(mx,my,iz,is2,ii)            &\n!!!                          - ( - wf1/12._DP*v2a + ( wf2*v2b - wf1*2._DP*v2a )*11._DP/720._DP ) \n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      else\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii)\n!!!      do ii=1,6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_mom\",1314,1)\n!!!                                      call clock_end(1314)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_calc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_redc( ww, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: All_reduce_part\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww\n!!! \n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: wn\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1315)\n!!!                                         ! call fapp_start(\"literm_colli_ar\",1315,1)\n!!!!$OMP end master\n!!!\n!!!      call MPI_Allreduce( ww, wn, nxyz*ns*6, MPI_DOUBLE_COMPLEX, &\n!!!                          MPI_SUM, vel_comm_world, ierr_mpi )\n!!!\n!!!!$OMP master\n!!!                                         ! call fapp_stop(\"literm_colli_ar\",1315,1)\n!!!                                           call clock_end(1315)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_redc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_comm_alltoall( wm, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Inter-species communication of moment quantities for field particle part\n!!!!       with MPI_AlltoAll\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wm\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wn\n!!!\n!!!    complex(kind=DP),              & \n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:6,0:ns-1)  :: send_buff, recv_buff\n!!!\n!!!    integer :: mx, my, iz, is, ii\n!!!    integer :: datasize, datasize_ns\n!!!\n!!!\n!!!!$OMP master\n!!!                                       call clock_sta(1316)\n!!!                                     ! call fapp_start(\"literm_colli_com\",1316,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      datasize = (2*nx+1)*(ny+1)*(2*nz)*6\n!!!      datasize_ns = (2*nx+1)*(ny+1)*(2*nz)*6*ns\n!!!\n!!!      if ( vel_rank == 0 ) then\n!!!\n!!!        do ii = 1, 6\n!!!          do is = 0, ns-1\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!!                  send_buff(mx,my,iz,ii,is)  = real(ranks,kind=DP) + ii ! for debug\n!!!                  send_buff(mx,my,iz,ii,is)  = wm(mx,my,iz,is,ii)\n!!!                end do\n!!!              end do \n!!!            end do\n!!!          end do\n!!!        end do\n!!!\n!!!\n!!!          call MPI_Alltoall( send_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  &\n!!!                             recv_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  & \n!!!                             col_comm_world, ierr_mpi  )\n!!! \n!!!!! --- for debug \n!!!!        write(unit=8000+ranks,fmt=\"(I3,SP,6ES24.15e3)\") ranks, real(recv_buff(0,1,1,1,0)), real(recv_buff(0,1,1,6,0)), &\n!!!!                                                           real(recv_buff(0,1,1,1,1)), real(recv_buff(0,1,1,6,1)), &\n!!!!                                                           real(recv_buff(0,1,1,1,2)), real(recv_buff(0,1,1,6,2))\n!!!!        write(unit=8000+ranks,fmt=*)\n!!!\n!!!      end if\n!!!\n!!!\n!!!      call MPI_Bcast( recv_buff(-nx,ist_y,-nz,1,0), datasize_ns, MPI_DOUBLE_COMPLEX, & \n!!!                      0, vel_comm_world, ierr_mpi  ) \n!!!\n!!!\n!!!      do is = 0, ns-1\n!!!        do ii = 1, 6\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wn(mx,my,iz,is,ii) = recv_buff(mx,my,iz,ii,is)\n!!!              end do\n!!!            end do \n!!!          end do\n!!!        end do         \n!!!      end do         \n!!!\n!!!!$OMP master\n!!!                                     ! call fapp_stop(\"literm_colli_com\",1316,1)\n!!!                                       call clock_end(1316)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_comm_alltoall\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_dfdvp( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 4th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im  )                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!        do im = 2, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!\n!!!      else   \n!!!\n!!!        do im = 0, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_dfdvp6( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 6th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 60._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 44._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 2\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 46._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 3, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!\n!!!      else   \n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_hhset(hh,phi,ff)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    real(kind=DP) :: dflg\n!!!    integer :: mx, my, iz, iv, im, is1\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!     !dflg = real(1-icheck,kind=DP)\n!!!      dflg = real(1-icheck,kind=DP) * real(iFLR,kind=DP)\n!!!\n!!!      is1 = ranks\n!!!!$OMP do collapse(2) private(mx,my,iz,iv,im)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                hh(mx,my,iz,iv,im) = ( ff(mx,my,iz,iv,im) + dflg*sgn(is1)*j0(mx,my,iz,im)*phi(mx,my,iz)   &\n!!!                                                                * fmx(iz,iv,im)*Znum(is1)/tau(is1) )      &\n!!!                                    * vp(iz,im) * dvp(iz) * dv * twopi\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_hhset\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_wwset(ww)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!    integer :: mx, my, iz, is1, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,is1,ii)\n!!!    do ii = 1, 6\n!!!      do is1 = 0, ns-1\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx, nx\n!!!              ww(mx,my,iz,is1,ii) = ( 0._DP, 0._DP )\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!    end do \n!!!!$OMP end do\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_wwset\n!!!\n!!!\n!!!!!--------------------------------------\n!!!!  ", "SUBROUTINE colli_full( ff, phi, cf ) ! Analytic derivative of J0*phi\n!!!!!--------------------------------------\n!!!!!   Sugama collision operator\n!!!!\n!!!!    complex(kind=DP), intent(inout), &\n!!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!!    complex(kind=DP), intent(in), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!!    complex(kind=DP), intent(out), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!!\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!!\n!!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff,phi,dfdvp) &\n!!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP private(im,ii) \n!!!!\n!!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!      call colli_hhset(hh2,phi,ff)\n!!!!      call colli_wwset(wrkm)\n!!!!!$OMP barrier\n!!!!\n!!!!!----------------------------------------------------- ovlp1\n!!!!!$OMP master\n!!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!!$OMP end master\n!!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!!      call colli_zeroset( cff )\n!!!!\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      call bndry_shifts_m_buffout ( mb2, ff )\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp2\n!!!!!$OMP master\n!!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!!$OMP end master\n!!!!\n!!!!!!!      call colli_dfdvp6( ff, dfdvp )  ! 6th-order CFD\n!!!!      call colli_dfdvp( ff, dfdvp )  ! 4th-order CFD\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp3\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!! ! --- No calculations appear here in f0.52 (Nakata July2015)\n!!!! !!!      call colli_zeroset( cdt )\n!!!!\n!!!!!$OMP barrier\n!!!!\n!!!!      do im = 1, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!!\n!!!!!-----------------------------------------------------\n!!!!!$OMP end parallel\n!!!!\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP shared(phi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!!\n!!!!!----------------------------------------------------- ovlp4\n!!!!!$OMP master\n!!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!!$OMP end master\n!!!!\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!!do nn = 0, ns-1\n!!!!  do iz = -nz, nz-1\n!!!!    do my = ist_y, iend_y\n!!!!      do mx = -nx, nx\n!!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!!\n!!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!!      enddo\n!!!!    enddo\n!!!!  enddo\n!!!!enddo\n!!!!!$OMP enddo\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp5\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp6\n!!!!      im = 1\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp7\n!!!!      im = 2\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD \n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp8\n!!!!      do im = 3, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD\n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!!----------------------------------------------------- \n!!!!\n!!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!!$OMP barrier\n!!!!\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP end parallel\n!!!!\n!!!!!$OMP parallel workshare\n!!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!!$OMP end parallel workshare\n!!!!\n!!!!      deallocate( vb1 )\n!!!!      deallocate( vb2 )\n!!!!      deallocate( mb1 )\n!!!!      deallocate( mb2 )\n!!!!      deallocate( cft )\n!!!!      deallocate( cff )\n!!!!      deallocate( wrkm )\n!!!!      deallocate( moment_ab )\n!!!!      deallocate( moment_ba )\n!!!!      deallocate( moment_ab_wk )\n!!!!      deallocate( moment_ba_wk )\n!!!!      deallocate( dfdvp )\n!!!!      deallocate( hh2 )\n!!!!\n!!!!  END SUBROUTINE colli_full\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_full( ff, phi, cf ) ! Finite difference of J0*phi\n!!!!--------------------------------------\n!!!!   Sugama collision operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: wff\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: wphi\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!\n!!!!$OMP parallel do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wff(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n!!!                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n!!!                                                                     * real(iFLR, kind=DP)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!      wphi(:,:,:) = (0._DP, 0._DP)\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(ff,wff,phi,dfdvp) &\n!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP private(im,ii) \n!!!\n!!!      call bndry_shifts_m_buffin ( wff, mb1, mb2 )\n!!!      call colli_hhset(hh2,phi,ff)\n!!!      call colli_wwset(wrkm)\n!!!!$OMP barrier\n!!!\n!!!!----------------------------------------------------- ovlp1\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!      call colli_zeroset( cff )\n!!!\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      call bndry_shifts_m_buffout ( mb2, wff )\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp2\n!!!!$OMP master\n!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!$OMP end master\n!!!\n!!!!!!      call colli_dfdvp6( ff, dfdvp )  ! 6th-order CFD\n!!!      call colli_dfdvp( wff, dfdvp )  ! 4th-order CFD\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp3\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!! ! --- No calculations appear here in f0.52 (Nakata July2015)\n!!! !!!      call colli_zeroset( cdt )\n!!!\n!!!!$OMP barrier\n!!!\n!!!      do im = 1, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!\n!!!!-----------------------------------------------------\n!!!!$OMP end parallel\n!!!\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(wff) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP shared(wphi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!\n!!!!----------------------------------------------------- ovlp4\n!!!!$OMP master\n!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!$OMP end master\n!!!\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( wff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!do nn = 0, ns-1\n!!!  do iz = -nz, nz-1\n!!!    do my = ist_y, iend_y\n!!!      do mx = -nx, nx\n!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!\n!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!      enddo\n!!!    enddo\n!!!  enddo\n!!!enddo\n!!!!$OMP enddo\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp5\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp6\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp7\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD \n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp8\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD\n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!!----------------------------------------------------- \n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), wff(:,:,:,:,nm) )\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!!$OMP parallel workshare\n!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!$OMP end parallel workshare\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!      deallocate( cft )\n!!!      deallocate( cff )\n!!!      deallocate( wrkm )\n!!!      deallocate( moment_ab )\n!!!      deallocate( moment_ba )\n!!!      deallocate( moment_ab_wk )\n!!!      deallocate( moment_ba_wk )\n!!!      deallocate( dfdvp )\n!!!      deallocate( hh2 )\n!!!\n!!!  END SUBROUTINE colli_full\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_buffin_v2( ff, phi, vb1, mb1 )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n\n    real(kind=DP) :: cs1\n    integer :: mx, my, iz, iv, im\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!!TBI!! !$OMP do collapse(3) schedule(dynamic,nchunk_ymb)\n      do iv = 1, nvb\n        do im = 0, nm\n         do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vb1(mx,my,iz,im,iv    ) = ff(mx,my,iz,         iv,im) &\n                                  + cs1 * fmx(iz,         iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n              vb1(mx,my,iz,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im) &\n                                  + cs1 * fmx(iz,2*nv-nvb+iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n         end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n!!TBI!! !$OMP do collapse(3) schedule(dynamic,nchunk_yvb)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n         do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iz,iv,im    ) = ff(mx,my,iz,iv,     im-1) &\n                                  + cs1 * fmx(iz,iv,     im-1) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,     im-1)\n              mb1(mx,my,iz,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im) &\n                                  + cs1 * fmx(iz,iv,nm-nvb+im) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,nm-nvb+im)\n            end do\n          end do\n         end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffin_v2\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout_v2( ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny,-nz:nz-1) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iz, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do iz = -nz, nz-1\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          do im = 0, nm\n            do iv = 1, 2*nv\n              gg(iv,im,mx,my,iz) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my,iz) = (0._DP, 0._DP)\n                gg(2*nv+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv    )\n                gg(2*nv+iv,im,mx,my,iz) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv    )\n                gg(2*nv+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my,iz) = (0._DP, 0._DP)\n                gg(iv,nm+im    ,mx,my,iz) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my,iz) = mb2(mx,my,iz,iv,im    )\n                gg(iv,nm+im    ,mx,my,iz) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my,iz) = mb2(mx,my,iz,iv,im    )\n                gg(iv,nm+im    ,mx,my,iz) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout_v2\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout_v3_sx( ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n!  This is for SX-Aurora TSUBASA (mod by M. Nakata, 20200928)\n!  DO NOT use overlap with OMP \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iz, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              gg(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 0, nm\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,-nvb+iv,im) = (0._DP, 0._DP)\n                gg(mx,my,iz,2*nv+iv,im) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 0, nm\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,-nvb+iv,im) = vb2(mx,my,iz,im,iv    )\n                gg(mx,my,iz,2*nv+iv,im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 0, nm\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,-nvb+iv,im) = vb2(mx,my,iz,im,iv    )\n                gg(mx,my,iz,2*nv+iv,im) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 1, nvb\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,-nvb-1+im) = (0._DP, 0._DP)\n                gg(mx,my,iz,iv,nm+im) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 1, nvb\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                gg(mx,my,iz,iv,nm+im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 1, nvb\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                gg(mx,my,iz,iv,nm+im ) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout_v3_sx\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc_v3_sx( gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                         ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n\n\n      if ( rankm /= 0 ) then\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                           ) * cef1                                    &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im-1)               &\n                            -          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef3                                     &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            +  8._DP * gg(mx,my,iz,iv,im+1)               &\n                            -  8._DP * gg(mx,my,iz,iv,im-1)               &\n                            +          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &      \n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n              end do\n            end do\n\n          end do\n        end do\n\n        end do\n!!TBI!! !$OMP end do nowait\n\n      else ! rankm == 0\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n          do iv = 1, 2*nv\n\n            im = 0\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef1                                     &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            -          gg(mx,my,iz,iv,im+2)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &\n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n              end do\n            end do\n\n            im = 1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef1                                     &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im-1)               &\n                            -          gg(mx,my,iz,iv,im  )               &\n                          ) * cef3                                     &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            +  8._DP * gg(mx,my,iz,iv,im+1)               &\n                            -  8._DP * gg(mx,my,iz,iv,im-1)               &\n                            +          gg(mx,my,iz,iv,im  )               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &   \n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n              end do\n            end do\n\n            do im = 2, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef1                                     &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im-1)               &\n                            -          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef3                                     &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            +  8._DP * gg(mx,my,iz,iv,im+1)               &\n                            -  8._DP * gg(mx,my,iz,iv,im-1)               &\n                            +          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &\n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n\n          end do\n\n        end do\n!!TBI!! !$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                    ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc_v3_sx\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc_v2( gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny,-nz:nz-1) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                        ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n\n\n      if ( rankm /= 0 ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                           ) * cef1                                    &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im-1,mx,my,iz)               &\n                            -          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            +  8._DP * gg(iv,im+1,mx,my,iz)               &\n                            -  8._DP * gg(iv,im-1,mx,my,iz)               &\n                            +          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &      \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n            end do\n\n          end do\n        end do\n\n        end do\n!!TBI!!!$OMP end do nowait\n\n      else! rankm == 0\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            im = 0\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            -          gg(iv,im+2,mx,my,iz)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n\n            im = 1\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im-1,mx,my,iz)               &\n                            -          gg(iv,im ,mx,my,iz)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            +  8._DP * gg(iv,im+1,mx,my,iz)               &\n                            -  8._DP * gg(iv,im-1,mx,my,iz)               &\n                            +          gg(iv,im ,mx,my,iz)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &   \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n\n            do im = 2, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im-1,mx,my,iz)               &\n                            -          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            +  8._DP * gg(iv,im+1,mx,my,iz)               &\n                            -  8._DP * gg(iv,im-1,mx,my,iz)               &\n                            +          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n            end do\n\n          end do\n        end do\n\n        end do\n!!TBI!!!$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                   ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc_v2\n\n\nEND MODULE GKV_colli\n", "MODULE GKV_igs\n!-------------------------------------------------------------------------------\n!\n!    Calculate the magnetic field components and metric coefficients\n!      from the MEUDAS or G-EQDSK equilibrium by using IGS code. \n!\n!    Notes\n!    -----\n!      1D and 2D equilibrium profiles, e.g., q(Psi), Psi(R,Z), \n!        from a free-boundary 2D Grad-shafranov solver MEUDAS or from G-EQDSK \n!          are converted to SFL magnetic coordinates (Axisym/Boozer/Hamada) \n!            by the interface code IGS developed by A. Matsuyama and M. Nakata. \n!\n!    Update history of gkvp_igs.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!      gkvp_r1.3 (M. Nakata, May 2013)\n!        - First implementation.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public :: igs_read, igs_coeff\n\n  real(kind=DP), dimension(:),       allocatable   :: ss_mc, q_mc, shat_mc, eps_mc, bsq_mc\n  real(kind=DP), dimension(:),       allocatable   :: theta_mc\n  real(kind=DP), dimension(:,:,:,:), allocatable   :: ggup_mc, ggdn_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: Bupt_mc, Bupz_mc, Bdns_mc, Bdnt_mc, Bdnz_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: dBdt_mc, dBds_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: B_mc, rootg_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: real2axi_mc, axi2mag_mc\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE igs_read(mc_type, nss, ntheta)\n!--------------------------------------\n\n    implicit none\n\n    integer, intent(in)        :: mc_type, nss, ntheta\n    integer                    :: is, jj, ierr, imds\n    character(512) :: f_igs\n\n    namelist /igsf/ f_igs\n\n    allocate(ss_mc(1:nss),q_mc(1:nss),shat_mc(1:nss),eps_mc(1:nss),bsq_mc(1:nss))\n    allocate(theta_mc(1:ntheta))\n    allocate(ggup_mc(1:ntheta,1:nss,1:3,1:3),ggdn_mc(1:ntheta,1:nss,1:3,1:3))\n    allocate(Bupt_mc(1:ntheta,1:nss),Bupz_mc(1:ntheta,1:nss))\n    allocate(Bdns_mc(1:ntheta,1:nss),Bdnt_mc(1:ntheta,1:nss),Bdnz_mc(1:ntheta,1:nss))\n    allocate(dBdt_mc(1:ntheta,1:nss),dBds_mc(1:ntheta,1:nss))\n    allocate(B_mc(1:ntheta,1:nss),rootg_mc(1:ntheta,1:nss))\n    allocate(real2axi_mc(1:ntheta,1:nss),axi2mag_mc(1:ntheta,1:nss))\n\n      read(inml,nml=igsf)\n      imds = 5000\n    \n      if ( mc_type == 0 ) then\n\n        open( imds, file=trim(f_igs)//\"METRIC_axi.OUT\", status=\"old\", action=\"read\" )\n        write(olog,*) \"# mag.coord.(IGS) input files : \"\n        write(olog,*) trim(f_igs)//\"METRIC_axi.OUT\"\n        write( olog, * ) \n\n      else if ( mc_type == 1 ) then\n\n        open( imds, file=trim(f_igs)//\"METRIC_boz.OUT\", status=\"old\", action=\"read\" )\n        write(olog,*) \" # mag.coord.(IGS) input files : \"\n        write(olog,*) trim(f_igs)//\"METRIC_boz.OUT\"\n        write( olog, * ) \n\n      else if ( mc_type == 2 ) then\n\n        open( imds, file=trim(f_igs)//\"METRIC_ham.OUT\", status=\"old\", action=\"read\" )\n        write(olog,*) \" # mag.coord.(IGS) input files : \"\n        write(olog,*) trim(f_igs)//\"METRIC_ham.OUT\"\n        write( olog, * ) \n\n      else \n\n        write(*,*) \"## Invalid mc_type setting!!\" \n        call MPI_Finalize(ierr)\n        stop \n\n      end if  \n\n! --- read B-field and metric components\n      do is = 1, nss\n        do jj = 1, ntheta\n          read(imds,fmt=\"(2f15.8, SP, 27ES24.15e3)\")   ss_mc(is), theta_mc(jj),   &\n                    q_mc(is),           shat_mc(is),            eps_mc(is),   &\n                 B_mc(jj,is),            bsq_mc(is),       rootg_mc(jj,is),   &\n          ggdn_mc(jj,is,1,1),    ggdn_mc(jj,is,1,2),    ggdn_mc(jj,is,1,3),   &\n          ggdn_mc(jj,is,2,2),    ggdn_mc(jj,is,2,3),    ggdn_mc(jj,is,3,3),   &\n          ggup_mc(jj,is,1,1),    ggup_mc(jj,is,1,2),    ggup_mc(jj,is,1,3),   &\n          ggup_mc(jj,is,2,2),    ggup_mc(jj,is,2,3),    ggup_mc(jj,is,3,3),   &\n              Bupt_mc(jj,is),        Bupz_mc(jj,is),        Bdnt_mc(jj,is),   &  \n              Bdnz_mc(jj,is),        Bdns_mc(jj,is),        dBds_mc(jj,is),   &\n              dBdt_mc(jj,is),    real2axi_mc(jj,is),     axi2mag_mc(jj,is)\n        end do\n        read(imds,fmt=*) \n      end do\n\n      return \n\n  END SUBROUTINE igs_read\n\n\n!----------------------------------------------------------------------------------\n  SUBROUTINE igs_coeff( isw,  mc_type,  nss,  ntheta,  s_input,  zz,  lz_l, & ! input \n                                   s_0,       q_0,    s_hat,   eps_r,   theta,   & ! output\n                                   omg,     rootg,   domgdx,  domgdz,  domgdy,   &\n                                  gg11,      gg12,     gg13,    gg22,            &\n                                  gg23,      gg33  )\n!----------------------------------------------------------------------------------\n\n    integer, intent(in)        :: isw, mc_type, nss, ntheta\n    real(kind=DP), intent(in)  :: s_input, zz, lz_l\n\n    real(kind=DP), intent(inout) :: s_0, q_0, s_hat, eps_r, theta\n    real(kind=DP), intent(out) :: omg, rootg, domgdx, domgdz, domgdy\n    real(kind=DP), intent(out) :: gg11, gg12, gg13, gg22, gg23, gg33\n\n! --- local variables \n    integer                    :: is0, iz0, nz0, jj0\n    real(kind=DP)              :: eps_a\n\n\n    is0 = nint(s_input*(nss-1))+1\n    \n    if (mc_type == 0 ) then \n      axi2mag_mc(:,:) = 0._DP \n    end if\n\n    if ( isw == 0 ) then \n\n      s_0   =   ss_mc(is0)\n      q_0   =    q_mc(is0)\n      s_hat = shat_mc(is0)\n      eps_r =  eps_mc(is0)\n\n    else if ( isw == 1 ) then\n\n      s_0   =   ss_mc(is0)\n\n      iz0 = nint(nz*zz/lz_l) ! get global_iz\n      nz0 = nint(pi*nz/lz_l)       ! get grid number on z=[0,pi)\n\n      if ( mod(iz0,nz0) /= 0.AND. mod(iz0/nz0,2) == 0 ) then \n   \n        jj0 = mod(iz0,nz0) + (nz0+1)\n\n      else if ( mod(iz0,nz0) /= 0.AND. mod(iz0/nz0,2) /= 0 ) then    \n\n        jj0 = mod(iz0,nz0) - (mod(iz0,nz0)/abs(mod(iz0,nz0)))*nz0 + (nz0+1)\n\n      else if ( mod(iz0,nz0) == 0.AND. mod(iz0/nz0,2) == 0 ) then    \n\n        jj0 = 0 + (nz0+1)\n\n      else if ( mod(iz0,nz0) == 0.AND. mod(iz0/nz0,2) /= 0 ) then    \n\n        jj0 = 1\n\n      end if\n              \n! --- for debug\n!      write(2000+rankg,*) iz0, jj0, nz0, zz\n\n      eps_a =  eps_mc(nss)\n     \n      theta  =  zz - real2axi_mc(jj0,is0) - axi2mag_mc(jj0,is0)\n      omg    =  B_mc(jj0,is0)\n      rootg  =  (eps_a**(-2))*q_0/s_0*rootg_mc(jj0,is0)\n      domgdx =  dBds_mc(jj0,is0)/eps_a\n      domgdz =  dBdt_mc(jj0,is0)\n      domgdy =  0._DP\n\n      gg11   =  eps_a**2 * ggup_mc(jj0,is0,1,1)\n\n      gg12   =  eps_a**2 * (  s_hat*zz*ggup_mc(jj0,is0,1,1)   &\n                             +     s_0*ggup_mc(jj0,is0,1,2)   &\n                             - s_0/q_0*ggup_mc(jj0,is0,1,3) )\n\n      gg13   =  eps_a*ggup_mc(jj0,is0,1,2)\n\n      gg22   =  eps_a**2 * (            (s_hat*zz)**2*ggup_mc(jj0,is0,1,1)   &\n                             +                 s_0**2*ggup_mc(jj0,is0,2,2)   &\n                             +           (s_0/q_0)**2*ggup_mc(jj0,is0,3,3)   & \n                             +     2._DP*s_0*s_hat*zz*ggup_mc(jj0,is0,1,2)   & \n                             -       2._DP*s_0**2/q_0*ggup_mc(jj0,is0,2,3)   & \n                             - 2._DP*s_0/q_0*s_hat*zz*ggup_mc(jj0,is0,1,3) )\n\n      gg23   =     eps_a * (  s_hat*zz*ggup_mc(jj0,is0,1,2)   &\n                             +     s_0*ggup_mc(jj0,is0,2,2)   &\n                             - s_0/q_0*ggup_mc(jj0,is0,2,3) )\n\n      gg33   =  ggup_mc(jj0,is0,2,2)\n\n    end if\n\n    return\n    \n  END SUBROUTINE igs_coeff\n\n\nEND MODULE GKV_igs\n", "MODULE GKV_colliimp\n!-------------------------------------------------------------------------------\n!\n!    Collision term by implicit solver\n!\n!    Update history of gkvp_colliimp.f90\n!    --------------\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - Treat tracer particles (fcs=0), that has no field-particle collision.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Bias factor nu is modified.\n!        - Initialization of padding iend_y<my is added.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only : clock_sta, clock_end\n  use GKV_math, only : math_j0, math_j1, math_j2\n  use GKV_fld, only : fld_esfield, fld_emfield_hh, fld_hh2ff\n\n\n  implicit none\n\n  private\n\n  integer, parameter :: nprocvms = nprocv * nprocm * nprocs\n  integer, parameter :: nbuff = ((2*nx+1)*(ny+1) - 1)/nprocvms + 1\n                        !%%% NOTE %%%\n                        ! if (mod((2*nx+1)*(ny+1),nprocvms)==0) then\n                        !   nbuff = ((2*nx+1)*(ny+1))/nprocvms \n                        ! else\n                        !   nbuff = ((2*nx+1)*(ny+1))/nprocvms + 1\n                        ! end if\n                        !%%%%%%%%%%%%\n  real(kind=DP), save :: gvl(1:2*global_nv)\n  real(kind=DP), save :: gmu(0:global_nm)\n  real(kind=DP), save :: gvp(0:global_nm,-nz:nz-1)\n  real(kind=DP), save :: gfmx(1:2*global_nv,0:global_nm,-nz:nz-1)\n  real(kind=DP), save, &\n    dimension(0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) :: gj0, gj1\n  real(kind=DP), save, &\n    dimension(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1) :: gnu_ds, gnu_ps, &\n                                                            gnu_hs, gnu_gs\n  real(kind=DP), save, &\n    dimension(1:6,1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) &\n                                             :: gvfunc, gx_tst, gy_fld\n\n  integer, parameter :: iter_max = 100\n  real(kind=DP), parameter :: res_error_max = 1.d-12\n\n  public   colliimp_set_param, colliimp_colli, colliimp_calc_colli_full, &\n           gvl, gvp, gnu_ds, gnu_ps, gnu_hs, gnu_gs\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE colliimp_set_param\n!--------------------------------------\n!   Set parameters for GK collision term\n\n    real(kind=DP), dimension(:,:,:,:,:), allocatable :: gnu_d, gnu_p, gnu_h, gnu_g\n    real(kind=DP) :: dm, kmo, gxxa, cph, dph, cgg, &\n                     gc_t01, gc_t02, cintgrl\n    integer :: mx, my, iz, iv, im, is, mxy, ibuff, ia, ib\n                                      !%%% For debug %%%\n                                      ! integer :: iproc\n                                      !%%%%%%%%%%%%%%%%%\n                                      call clock_sta(1700)\n\n      allocate( gnu_d(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n      allocate( gnu_p(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n      allocate( gnu_h(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n      allocate( gnu_g(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n\n      if ( ns == 1 ) then\n        write(olog,*) \"# Adiabatic model (ns==1) is not supported in imp_colli\"\n        call flush(olog)\n        call MPI_finalize(ierr_mpi)\n        stop\n      end if\n\n\n      do iv = 1, 2*global_nv\n        gvl(iv) = dv * ( real( iv - nv * nprocv - 1, kind=DP ) + 0.5_DP )\n      end do\n\n      dm = vmax / real( nprocm * ( nm+1 ) - 1, kind=DP )\n      do im = 0, global_nm\n        gmu(im) = 0.5_DP * ( dm * real( im, kind=DP ) )**2\n      end do\n\n      do iz = -nz, nz-1\n        do im = 0, global_nm\n          gvp(im,iz)  = sqrt( 2._DP * gmu(im) * omg(iz) )\n        end do\n      end do\n\n      do iz = -nz, nz-1\n        do im = 0, global_nm\n          do iv = 1, 2*global_nv\n            gfmx(iv,im,iz) = exp( - 0.5_DP * gvl(iv)**2 - omg(iz) * gmu(im) ) &\n                           / sqrt( twopi**3 )\n          end do\n        end do\n      end do\n\n      do ibuff = 0, nbuff-1\n        mxy = ibuff + nbuff * spc_rank\n        if (mxy <= (2*nx+1)*(ny+1)-1) then\n          mx = mod(mxy,2*nx+1) - nx\n          my = mxy / (2*nx+1)\n          do iz = -nz, nz-1\n            do is = 0, ns-1\n              do im = 0, global_nm\n                kmo = sqrt( 2._DP * ksq(mx,my,iz) * gmu(im) / omg(iz) ) &\n                    * sqrt( tau(is)*Anum(is) ) / Znum(is)\n                call math_j0( kmo, gj0(im,is,iz,ibuff) )\n                call math_j1( kmo, gj1(im,is,iz,ibuff) )\n              end do\n            end do\n          end do\n        else\n          gj0(:,:,:,ibuff) = 0._DP\n          gj1(:,:,:,ibuff) = 0._DP\n        end if\n      end do\n\n      do iz = -nz, nz-1\n        do ib = 0, ns-1\n          do ia = 0, ns-1\n            do im = 0, global_nm\n              do iv = 1, 2*global_nv\n\n                gxxa = dsqrt(gvl(iv)**2 + gvp(im,iz)**2) / dsqrt(2._DP)\n                cph = derf(calpha(ia,ib) * gxxa)\n                dph = 2._DP / dsqrt(pi) * dexp(- calpha(ia,ib)**2 * gxxa**2)\n                cgg = (cph - calpha(ia,ib) * gxxa * dph)/(calpha(ia,ib)**2 * gxxa**2) * 0.5_DP\n\n                gnu_d(iv,im,ia,ib,iz) = 0.75_DP*dsqrt(pi)*ctauiv(ia,ib)*(cph-cgg)/gxxa**3\n                gnu_p(iv,im,ia,ib,iz) = 1.50_DP*dsqrt(pi)*ctauiv(ia,ib)*(  cgg  )/gxxa**3\n               !gnu_h(iv,im,ia,ib,iz) = 0.75_DP*dsqrt(pi)*ctauiv(ia,ib)*calpha(ia,ib)*dph/gxxa**2\n                gnu_h(iv,im,ia,ib,iz) = 0.75_DP*dsqrt(pi)*ctauiv(ia,ib)*calpha(ia,ib)*dph\n                gnu_g(iv,im,ia,ib,iz) = gnu_p(iv,im,ia,ib,iz)*gxxa**2*(1._DP-calpha(ia,ib)**2)\n\n                gc_t01 = - (1._DP + calpha(ia,ib)**2)*gfmx(iv,im,iz)*gnu_p(iv,im,ia,ib,iz) * gxxa**2*gvl(iv)\n                gc_t02 = - 1.5_DP*dsqrt(pi)*ctauiv(ia,ib)*gfmx(iv,im,iz) &\n                       * ( cph - calpha(ia,ib)*gxxa*(1._DP + calpha(ia,ib)**2)*dph ) / calpha(ia,ib)**2 / gxxa\n                cintgrl = 2._DP * pi * gvp(im,iz) * dv * dvp(iz)\n\n                gvfunc(1,iv,im,ia,ib,iz) = gc_t01 / gfmx(iv,im,iz)                          * cintgrl\n                gvfunc(2,iv,im,ia,ib,iz) = gc_t01 / gfmx(iv,im,iz) * (gvp(im,iz) / gvl(iv)) * cintgrl\n                gvfunc(3,iv,im,ia,ib,iz) = gc_t02 / gfmx(iv,im,iz)                          * cintgrl\n                gvfunc(4,iv,im,ia,ib,iz) = gvl(iv)                                          * cintgrl\n                gvfunc(5,iv,im,ia,ib,iz) = gvp(im,iz)                                       * cintgrl\n                gvfunc(6,iv,im,ia,ib,iz) = (gxxa**2 - 1.5_DP)                               * cintgrl \n\n                gx_tst(1,iv,im,ia,ib,iz) = (ctheta(ia,ib) - 1._DP) * gfmx(iv,im,iz) * gvl(iv)\n                gx_tst(2,iv,im,ia,ib,iz) = gx_tst(1,iv,im,ia,ib,iz) * gvp(im,iz) / gvl(iv) \n                gx_tst(3,iv,im,ia,ib,iz) = gx_tst(1,iv,im,ia,ib,iz) * (gxxa**2/1.5_DP - 1._DP) / gvl(iv)\n                gx_tst(4,iv,im,ia,ib,iz) = (ctheta(ia,ib) - 1._DP) * (gc_t01                              &\n                                            - (ctheta(ia,ib) - 1._DP) * calpha(ia,ib) * ctauiv(ia,ib)     &\n                                              * gfmx(iv,im,iz) * gvl(iv) / dsqrt(1._DP + calpha(ia,ib)**2) )\n                gx_tst(5,iv,im,ia,ib,iz) =  gx_tst(4,iv,im,ia,ib,iz) * gvp(im,iz) / gvl(iv)  \n                gx_tst(6,iv,im,ia,ib,iz) = (ctheta(ia,ib) - 1._DP) * (gc_t02 * 2._DP/3._DP            &\n                                            - (ctheta(ia,ib) - 1._DP) * calpha(ia,ib) * ctauiv(ia,ib) &\n                                              * gfmx(iv,im,iz) * (gxxa**2/1.5_DP - 1._DP) * 2._DP     &\n                                                / (1._DP + calpha(ia,ib)**2)**1.5 )\n\n                if (fcs(ia) == 0.d0 .or. fcs(ib) == 0.d0) then !-care for tracer particle(dens=0)-\n                  gy_fld(1:6,iv,im,ia,ib,iz) = 0._DP\n                else\n                  gy_fld(1,iv,im,ia,ib,iz) = - (fcs(ib)/Znum(ib)) / (fcs(ia)/Znum(ia)) * calpha(ia,ib) * Anum(ia)  & \n                                               * tau(ib) * ctheta(ia,ib) * ctheta(ib,ia) / tau(ia) / cgamma(ia,ib) &\n                                                        * ( gc_t01 - cxi(ia,ib) * gfmx(iv,im,iz) * gvl(iv) ) \n                  gy_fld(2,iv,im,ia,ib,iz) = gy_fld(1,iv,im,ia,ib,iz) * gvp(im,iz) / gvl(iv)  \n                  gy_fld(3,iv,im,ia,ib,iz) = - (fcs(ib)/Znum(ib)) / (fcs(ia)/Znum(ia))                          & \n                                                        * tau(ib) * ctheta(ia,ib) * ctheta(ib,ia) / ceta(ia,ib) &\n                                                        * ( gc_t02                                          &\n                                                            - cxi(ia,ib)/(1._DP+calpha(ia,ib)**2)*gfmx(iv,im,iz)&\n                                                              *(2._DP*gxxa**2 - 3._DP) ) \n                  gy_fld(4,iv,im,ia,ib,iz) = - gy_fld(1,iv,im,ia,ib,iz)*cxi(ib,ia) \n                  gy_fld(5,iv,im,ia,ib,iz) = - gy_fld(2,iv,im,ia,ib,iz)*cxi(ib,ia) \n                  gy_fld(6,iv,im,ia,ib,iz) = - gy_fld(3,iv,im,ia,ib,iz)*2._DP*cxi(ib,ia)/(1._DP+calpha(ib,ia)**2) \n                end if\n\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      do iz = -nz, nz-1\n        do ia = 0, ns-1\n          gnu_ds(:,:,ia,iz) = 0._DP\n          gnu_ps(:,:,ia,iz) = 0._DP\n          gnu_hs(:,:,ia,iz) = 0._DP\n          gnu_gs(:,:,ia,iz) = 0._DP\n          do ib = 0, ns-1\n            gnu_ds(:,:,ia,iz) = gnu_ds(:,:,ia,iz) + nu(ia) * gnu_d(:,:,ia,ib,iz)\n            gnu_ps(:,:,ia,iz) = gnu_ps(:,:,ia,iz) + nu(ia) * gnu_p(:,:,ia,ib,iz)\n            gnu_hs(:,:,ia,iz) = gnu_hs(:,:,ia,iz) + nu(ia) * gnu_h(:,:,ia,ib,iz)\n            gnu_gs(:,:,ia,iz) = gnu_gs(:,:,ia,iz) + nu(ia) * gnu_g(:,:,ia,ib,iz)\n          end do              !- nu(ia) is a bias factor given in namelist\n        end do\n      end do\n                                      !%%% For debug %%%\n                                      ! mx = 1; my = 1; iz = 0; is = 0\n                                      ! if (rankw == 0 .and. rankz == 0 .and. &\n                                      !     ranks == is) then\n                                      !   do im = 0, nm\n                                      !   do iv = 1, 2*nv\n                                      !     write(910000+rankg,*)  &\n                                      !         vl(iv), vp(iz,im), &\n                                      !         fmx(iz,iv,im), &\n                                      !         j0(mx,my,iz,im), &\n                                      !         nu_ds(iz,iv,im)\n                                      !   end do\n                                      !   write(910000+rankg,*)\n                                      !   end do\n                                      ! end if\n                                      !\n                                      ! mx = 1; my = 1; iz = 0; is = 0\n                                      ! if (rankw == 0 .and. rankz == 0) then\n                                      ! call mxmy2ibuffiproc(mx,my,ibuff,iproc)\n                                      ! if (spc_rank == iproc) then\n                                      !   do im = 0, global_nm\n                                      !   do iv = 1, 2*global_nv\n                                      !     write(91,*) gvl(iv), gvp(im,iz), &\n                                      !                 gfmx(iv,im,iz),      &\n                                      !                 gj0(im,is,iz,ibuff), &\n                                      !                 gnu_ds(iv,im,is,iz)\n                                      !   end do\n                                      !   write(91,*)\n                                      !   end do\n                                      ! end if\n                                      ! end if\n                                      !%%%%%%%%%%%%%%%%%\n      deallocate( gnu_d )\n      deallocate( gnu_p )\n      deallocate( gnu_h )\n      deallocate( gnu_g )\n                                      call clock_end(1700)\n\n\n  END SUBROUTINE colliimp_set_param\n\n\n  SUBROUTINE ibuffiproc2mxmy(ibuff, iproc, mx, my)\n    integer, intent(in) :: ibuff, iproc\n    integer, intent(out) :: mx, my\n    integer :: mxy\n      mxy = ibuff + nbuff * iproc\n      !if (mxy <= (2*nx+1)*(ny+1)-1) then\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n      !end if\n  END SUBROUTINE ibuffiproc2mxmy\n\n\n  SUBROUTINE mxmy2ibuffiproc(mx, my, ibuff, iproc)\n    integer, intent(in) :: mx, my\n    integer, intent(out) :: ibuff, iproc\n    integer :: mxy\n      mxy = mx + nx + (2*nx+1) * my\n      ibuff = mod(mxy,nbuff)\n      iproc = mxy / nbuff\n  END SUBROUTINE mxmy2ibuffiproc\n\n\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colliimp_colli( ldt, ff, phi, Al, hh )\n!!!!--------------------------------------\n!!!!   Collsion operator calculation interface\n!!!\n!!!    real(kind=DP), intent(in) :: ldt\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi, Al\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: sender, recver\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wh\n!!!    integer :: iz, ibuff\n!!!\n!!!                                      !%%% For debug %%%\n!!!                                      ! complex(kind=DP) :: wphi, wAl\n!!!                                      ! integer :: mx, my, iproc\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!      allocate( sender(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( recver(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( wh(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) )\n!!!\n!!!      call vms2xy_pack(hh, sender)\n!!!      call vms2xy_transpose(sender, recver)\n!!!      call vms2xy_unpack(recver, wh)\n!!!      \n!!!                                      call clock_sta(1720)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(ldt,wh) &\n!!!!$OMP private(iz,ibuff)\n!!!!$OMP do collapse(2)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          call implicit_collision_solver(ldt, wh(:,:,:,iz,ibuff), iz, ibuff)\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1720)\n!!!\n!!!      call xy2vms_pack(wh, sender)\n!!!      call xy2vms_transpose(sender, recver)\n!!!      call xy2vms_unpack(recver, hh)\n!!!\n!!!      if ( beta .ne. 0._DP ) then\n!!!        call fld_emfield_hh( hh, Al )\n!!!      end if\n!!!      call fld_hh2ff( hh, Al, ff )\n!!!      call fld_esfield( ff, phi )\n!!!                                      !%%% For debug %%%\n!!!                                      ! mx = 1; my = 1\n!!!                                      ! call mxmy2ibuffiproc(mx,my,ibuff,iproc)\n!!!                                      ! if (rankw == 0 .and. &\n!!!                                      !     spc_rank == iproc) then\n!!!                                      !   do iz = -nz, nz-1\n!!!                                      !     call emfield_hh(wh(:,:,:,iz,ibuff),&\n!!!                                      !                     wAl, iz, ibuff)\n!!!                                      !     call esfield(wh(:,:,:,iz,ibuff), &\n!!!                                      !                  wphi, iz, ibuff)\n!!!                                      !     write(10000+rankg,*) zz(iz), &\n!!!                                      !            dble(wphi),           &\n!!!                                      !            aimag(wphi),          &\n!!!                                      !            dble(phi(mx,my,iz)),  &\n!!!                                      !            aimag(phi(mx,my,iz)), &\n!!!                                      !            dble(wAl),            &\n!!!                                      !            aimag(wAl),           &\n!!!                                      !            dble(Al(mx,my,iz)),   &\n!!!                                      !            aimag(Al(mx,my,iz))\n!!!                                      !   end do\n!!!                                      ! end if\n!!!                                      ! call MPI_finalize(ierr_mpi)\n!!!                                      ! stop\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!      deallocate( sender )\n!!!      deallocate( recver )\n!!!      deallocate( wh )\n!!!\n!!!  END SUBROUTINE colliimp_colli\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE vms2xy_pack(hh, sender)\n!!!!--------------------------------------\n!!!!   Data pack for transpose from (x,y*,z*,v*,m*,s*) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: sender\n!!!\n!!!    integer :: mx, my, iz, iv, im, ibuff, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1710)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(hh,sender) &\n!!!!$OMP private(mx,my,iz,iv,im,ibuff,iproc)\n!!!!$OMP workshare\n!!!      sender(:,:,:,:,:) = (0._DP, 0._DP)\n!!!!$OMP end workshare\n!!!!$OMP do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = 0, ny\n!!!              do mx = -nx, nx\n!!!                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n!!!                sender(iv,im,iz,ibuff,iproc) = hh(mx,my,iz,iv,im)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1710)\n!!!                                      !%%% For debug %%%\n!!!                                      ! if (rankg == 0) then\n!!!                                      ! do my = 0, ny\n!!!                                      ! do mx = -nx, nx\n!!!                                      !   mxy = mx+nx + (2*nx+1)*my\n!!!                                      !   ibuff = mod(mxy, nbuff)\n!!!                                      !   iproc = mxy / nbuff\n!!!                                      !   write(99,*) mx, my, mxy, ibuff, iproc\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end if\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!\n!!!  END SUBROUTINE vms2xy_pack\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE vms2xy_transpose(sender, recver)\n!!!!--------------------------------------\n!!!!   Transpose from (x,y*,z*,v*,m*,s*) to ((x,y*)***,z*,v,m,s) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: sender\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: recver\n!!!\n!!!\n!!!                                      call clock_sta(1711)\n!!!      call mpi_alltoall( sender,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         recver,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         spc_comm_world,              &\n!!!                         ierr_mpi     )\n!!!                                      call clock_end(1711)\n!!!\n!!!  END SUBROUTINE vms2xy_transpose\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE vms2xy_unpack(recver, wh)\n!!!!--------------------------------------\n!!!!   Data unpack for transpose to ((x,y*)***,z*,v,m,s) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: recver\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) :: wh\n!!!\n!!!    integer :: iz, iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1712)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(recver,wh) &\n!!!!$OMP private(iz,iv,im,ibuff,irs,irm,irv,iproc,gim,giv)\n!!!!$OMP workshare\n!!!      wh(:,:,:,:,:) = (0._DP, 0._DP)\n!!!!$OMP end workshare\n!!!!$OMP do collapse(5)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          do irs = 0, nprocs-1\n!!!            do irm = 0, nprocm-1\n!!!              do irv = 0, nprocv-1\n!!!                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n!!!                do im = 0, nm\n!!!                  gim = im + (nm+1)*irm\n!!!                  do iv = 1, 2*nv\n!!!                    giv = iv + (2*nv)*irv\n!!!                    wh(giv,gim,irs,iz,ibuff) = recver(iv,im,iz,ibuff,iproc)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1712)\n!!!                                      !%%% For debug %%%\n!!!                                      ! if (rankg == 0) then\n!!!                                      ! do irs = 0, nprocs-1\n!!!                                      ! do irm = 0, nprocm-1\n!!!                                      ! do irv = 0, nprocv-1\n!!!                                      !   iproc = irv + nprocv*irm &\n!!!                                      !         + nprocv*nprocm*irs\n!!!                                      ! do im = 0, nm\n!!!                                      !   gim = im + (nm+1)*irm\n!!!                                      ! do iv = 1, 2*nv\n!!!                                      !   giv = iv + (2*nv)*irv\n!!!                                      !   write(97,*) irs, irm, irv, iproc, &\n!!!                                      !               giv, gim\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end if\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!\n!!!  END SUBROUTINE vms2xy_unpack\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE xy2vms_pack(wh, sender)\n!!!!--------------------------------------\n!!!!   Data pack for transpose from ((x,y*)***,z*,v,m,s) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) :: wh\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: sender\n!!!\n!!!    integer :: iz, iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1730)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(wh,sender) &\n!!!!$OMP private(iz,iv,im,ibuff,irs,irm,irv,iproc,gim,giv)\n!!!!$OMP workshare\n!!!      sender(:,:,:,:,:) = (0._DP, 0._DP)\n!!!!$OMP end workshare\n!!!!$OMP do collapse(5)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          do irs = 0, nprocs-1\n!!!            do irm = 0, nprocm-1\n!!!              do irv = 0, nprocv-1\n!!!                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n!!!                do im = 0, nm\n!!!                  gim = im + (nm+1)*irm\n!!!                  do iv = 1, 2*nv\n!!!                    giv = iv + (2*nv)*irv\n!!!                    sender(iv,im,iz,ibuff,iproc) = wh(giv,gim,irs,iz,ibuff)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1730)\n!!! \n!!!  END SUBROUTINE xy2vms_pack\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE xy2vms_transpose(sender, recver)\n!!!!--------------------------------------\n!!!!   Transpose from ((x,y*)***,z*,v,m,s) to (x,y*,z*,v*,m*,s*) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,0:nbuff-1,-nz:nz-1,0:nprocvms-1) :: sender\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,0:nbuff-1,-nz:nz-1,0:nprocvms-1) :: recver\n!!!\n!!!\n!!!                                      call clock_sta(1731)\n!!!      call mpi_alltoall( sender,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         recver,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         spc_comm_world,              &\n!!!                         ierr_mpi     )\n!!!                                      call clock_end(1731)\n!!!\n!!!  END SUBROUTINE xy2vms_transpose\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE xy2vms_unpack(recver, hh)\n!!!!--------------------------------------\n!!!!   Data unpack for transpose to (x,y*,z*,v*,m*,s*) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: recver\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!\n!!!    integer :: mx, my, iz, iv, im, ibuff, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1732)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(recver,hh) &\n!!!!$OMP private(mx,my,iz,iv,im,ibuff,iproc)\n!!!!$OMP do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = 0, ny\n!!!              do mx = -nx, nx\n!!!                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n!!!                hh(mx,my,iz,iv,im) = recver(iv,im,iz,ibuff,iproc)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1732)\n!!!\n!!!  END SUBROUTINE xy2vms_unpack\n\n\n!--------------------------------------\n  ", "SUBROUTINE colliimp_colli( ldt, ff, phi, Al, hh )\n!--------------------------------------\n!   Collsion operator calculation interface\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable ::  &\n           send1e, recv1e, send2e, recv2e, send1o, recv1o, send2o, recv2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: wh1e, wh2e, wh1o, wh2o\n    integer :: iv, im, iz, is, ibuff, iproc\n\n      allocate( send1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( send1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ldt,hh) &\n!$OMP shared(send1e,recv1e,send2e,recv2e,wh1e,wh2e) &\n!$OMP shared(send1o,recv1o,send2o,recv2o,wh1o,wh2o) &\n!$OMP private(iv,im,iz,is,ibuff,iproc)\n      do iproc = 0, nprocvms-1\n!$OMP do\n        do ibuff = 0, nbuff-1\n          do im = 0, nm\n            do iv = 1, 2*nv\n              send1e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send1o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n      do ibuff = 0, nbuff-1\n!$OMP do\n        do is = 0, ns-1\n          do im = 0, global_nm\n            do iv = 1, 2*global_nv\n              wh1e(iv,im,is,ibuff) = (0._DP, 0._DP)\n              wh1o(iv,im,is,ibuff) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP barrier\n\n!!%%% Without overlap %%%\n!      do iz = -nz, nz-1\n!        call vms2xy_pack_iz(iz, hh, send1e)\n!!$OMP barrier\n!!$OMP master\n!        call vms2xy_transpose_iz(send1e, recv1e)\n!!$OMP end master\n!!$OMP barrier\n!        call vms2xy_unpack_iz(recv1e, wh1e)\n!!$OMP barrier\n!        call solver_wrapper_iz(ldt, iz, wh1e, wh2e)\n!!$OMP barrier\n!        call xy2vms_pack_iz(wh2e, send2e)\n!!$OMP barrier\n!!$OMP master\n!        call xy2vms_transpose_iz(send2e, recv2e)\n!!$OMP end master\n!!$OMP barrier\n!        call xy2vms_unpack_iz(iz, recv2e, hh)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n!%%% With overlap %%%\n      do iz = -nz, nz-1+6\n\n        if (mod(iz+nz,2) == 0) then ! even\n\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call vms2xy_transpose_iz(send1o, recv1o)\n          if (-nz+5<=iz .and. iz<=nz-1+5) call xy2vms_transpose_iz(send2o, recv2o)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call vms2xy_pack_iz(iz, hh, send1e)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1e, wh1e)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call solver_wrapper_iz(ldt, iz-3, wh1o, wh2o)\n          if (-nz+4<=iz .and. iz<=nz-1+4) call xy2vms_pack_iz(wh2e, send2e)\n          if (-nz+6<=iz .and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2e, hh)\n\n        else                        ! odd\n\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call vms2xy_transpose_iz(send1e, recv1e)\n          if (-nz+5<=iz .and. iz<=nz-1+5) call xy2vms_transpose_iz(send2e, recv2e)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call vms2xy_pack_iz(iz, hh, send1o)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1o, wh1o)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call solver_wrapper_iz(ldt, iz-3, wh1e, wh2e)\n          if (-nz+4<=iz .and. iz<=nz-1+4) call xy2vms_pack_iz(wh2o, send2o)\n          if (-nz+6<=iz .and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2o, hh)\n\n        end if\n!$OMP barrier\n\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      if ( beta .ne. 0._DP ) then\n        call fld_emfield_hh( hh, Al )\n      end if\n      call fld_hh2ff( hh, Al, ff )\n      call fld_esfield( ff, phi )\n\n      deallocate( send1e )\n      deallocate( recv1e )\n      deallocate( send2e )\n      deallocate( recv2e )\n      deallocate( wh1e )\n      deallocate( wh2e )\n      deallocate( send1o )\n      deallocate( recv1o )\n      deallocate( send2o )\n      deallocate( recv2o )\n      deallocate( wh1o )\n      deallocate( wh2o )\n\n  END SUBROUTINE colliimp_colli\n\n\n!--------------------------------------\n  SUBROUTINE vms2xy_pack_iz(iz, hh, sender)\n!--------------------------------------\n!   Data pack for transpose from (x,y*,z*,v*,m*,s*) decomposition\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n\n    integer :: mx, my, iv, im, ibuff, iproc\n\n!$OMP master\n                                      call clock_sta(1710)\n!$OMP end master\n      do im = 0, nm\n!$OMP do schedule(dynamic)\n        do iv = 1, 2*nv\n            do my = 0, ny\n              do mx = -nx, nx\n                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n                sender(iv,im,ibuff,iproc) = hh(mx,my,iz,iv,im)\n              end do\n            end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP master\n                                      call clock_end(1710)\n!$OMP end master\n\n  END SUBROUTINE vms2xy_pack_iz\n\n\n!--------------------------------------\n  SUBROUTINE vms2xy_transpose_iz(sender, recver)\n!--------------------------------------\n!   Transpose from (x,y*,z*,v*,m*,s*) to ((x,y*)***,z*,v,m,s) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n    complex(kind=DP), intent(out), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n\n                                      call clock_sta(1711)\n      call mpi_alltoall( sender,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         recver,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         spc_comm_world,       &\n                         ierr_mpi     )\n                                      call clock_end(1711)\n\n  END SUBROUTINE vms2xy_transpose_iz\n\n\n!--------------------------------------\n  SUBROUTINE vms2xy_unpack_iz(recver, wh)\n!--------------------------------------\n!   Data unpack for transpose to ((x,y*)***,z*,v,m,s) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wh\n\n    integer :: iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n\n!$OMP master\n                                      call clock_sta(1712)\n!$OMP end master\n!$OMP do collapse(4) schedule(dynamic)\n      do ibuff = 0, nbuff-1\n          do irs = 0, nprocs-1\n            do irm = 0, nprocm-1\n              do irv = 0, nprocv-1\n                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n                do im = 0, nm\n                  gim = im + (nm+1)*irm\n                  do iv = 1, 2*nv\n                    giv = iv + (2*nv)*irv\n                    wh(giv,gim,irs,ibuff) = recver(iv,im,ibuff,iproc)\n                  end do\n                end do\n              end do\n            end do\n          end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1712)\n!$OMP end master\n\n  END SUBROUTINE vms2xy_unpack_iz\n\n\n!--------------------------------------\n  SUBROUTINE xy2vms_pack_iz(wh, sender)\n!--------------------------------------\n!   Data pack for transpose from ((x,y*)***,z*,v,m,s) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wh\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n\n    integer :: iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n\n!$OMP master\n                                      call clock_sta(1730)\n!$OMP end master\n!$OMP do collapse(4) schedule(dynamic)\n      do ibuff = 0, nbuff-1\n          do irs = 0, nprocs-1\n            do irm = 0, nprocm-1\n              do irv = 0, nprocv-1\n                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n                do im = 0, nm\n                  gim = im + (nm+1)*irm\n                  do iv = 1, 2*nv\n                    giv = iv + (2*nv)*irv\n                    sender(iv,im,ibuff,iproc) = wh(giv,gim,irs,ibuff)\n                  end do\n                end do\n              end do\n            end do\n          end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1730)\n!$OMP end master\n \n  END SUBROUTINE xy2vms_pack_iz\n\n\n!--------------------------------------\n  SUBROUTINE xy2vms_transpose_iz(sender, recver)\n!--------------------------------------\n!   Transpose from ((x,y*)***,z*,v,m,s) to (x,y*,z*,v*,m*,s*) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n    complex(kind=DP), intent(out), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n\n                                      call clock_sta(1731)\n      call mpi_alltoall( sender,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         recver,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         spc_comm_world,       &\n                         ierr_mpi     )\n                                      call clock_end(1731)\n\n  END SUBROUTINE xy2vms_transpose_iz\n\n\n!--------------------------------------\n  SUBROUTINE xy2vms_unpack_iz(iz, recver, hh)\n!--------------------------------------\n!   Data unpack for transpose to (x,y*,z*,v*,m*,s*) decomposition\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    integer :: mx, my, iv, im, ibuff, iproc\n\n!$OMP master\n                                      call clock_sta(1732)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic)\n      do im = 0, nm\n        do iv = 1, 2*nv\n            do my = 0, ny\n              do mx = -nx, nx\n                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n                hh(mx,my,iz,iv,im) = recver(iv,im,ibuff,iproc)\n              end do\n            end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1732)\n!$OMP end master\n\n  END SUBROUTINE xy2vms_unpack_iz\n\n\n!--------------------------------------\n  SUBROUTINE solver_wrapper_iz(ldt, iz, whin, whout)\n!--------------------------------------\n!   Implicit collision solver wrapper for overlap\n\n    real(kind=DP), intent(in) :: ldt\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: whin\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: whout\n\n    complex(kind=DP), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: wc3\n    integer :: ibuff\n\n!$OMP master\n                                      call clock_sta(1720)\n!$OMP end master\n!$OMP do schedule(dynamic)\n      do ibuff = 0, nbuff-1\n        wc3(:,:,:) = whin(:,:,:,ibuff)\n        call implicit_collision_solver(ldt, wc3, iz, ibuff)\n        whout(:,:,:,ibuff) = wc3(:,:,:)\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1720)\n!$OMP end master\n\n  END SUBROUTINE solver_wrapper_iz\n\n\n!--------------------------------------\n  SUBROUTINE implicit_collision_solver(ldt, wh, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    2nd C.N. : 2nd-order Crank-Nicolson method\n!\n!        (h(t+dt) - h(t))/dt = C((g(t+dt) + g(t))/2)\n!      where g is a function of h, i.e., g(t)=g(h(t)).\n!      Since C is a linearized collision operator, it is regard as A*x = b,\n!        A = 1 - dt/2*Cg,\n!        x = h(t+dt),\n!        b = g(h(t)) + dt/2*C(g(h(t))).\n!\n!    1st B.E. : 1st-order backward Euler method\n!\n!        (f(t+dt) - f(t))/dt = C(f(t+dt))\n!      It is regard as A*x = b,\n!        A = 1 - dt*Cg,\n!        x = f(t+dt),\n!        b = g(h(t)).\n!\n!    Difference between 2nd C.N and 1st B.E. appears in \"calc_ap\" and \"calc_b\".\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: wh\n    integer, intent(in) :: iz, ibuff\n  \n    complex(kind=DP), dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b, r\n    real(kind=DP) :: res_error\n    integer :: iter\n  \n      !if (maxval(abs(wh(:,:,:))) < 1.d-100) then\n      if (maxval(abs(wh(:,:,:))) < 1.d-40) then\n        return\n      else\n        res_error = 1._DP\n      end if\n\n      call calc_b(ldt, wh, b, iz, ibuff)\n      do iter = 0, iter_max-1\n        if (res_error < res_error_max) exit\n        call bi_cgstab(ldt, iter, wh, b, r, iz, ibuff)\n       !call gcr      (ldt, iter, wh, b, r, iz, ibuff)\n       !call gcr1     (ldt, iter, wh, b, r, iz, ibuff)\n       !call gcrm     (ldt, iter, wh, b, r, iz, ibuff)\n        call calc_error(r, b, res_error)\n      end do\n      if (iter == iter_max) then\n        write(olog,*) \"# Reach maximum iteration : \", iz, ibuff, iter, res_error\n      end if\n                                      !%%% For debug %%%\n                                      ! write(olog,*) \"#iter= \", iter, iz, ibuff\n                                      !%%%%%%%%%%%%%%%%%\n  \n  END SUBROUTINE implicit_collision_solver\n\n\n!--------------------------------------\n  SUBROUTINE bi_cgstab(ldt, iter, x, b, r, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Bi-conjugate gradient stabilization method (A*x = b for Non-Hermitian A)\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    integer, intent(in) :: iter\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n    integer, intent(in) :: iz, ibuff\n\n    complex(kind=DP), save, &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: p, r0\n!$OMP threadprivate(p,r0)\n    complex(kind=DP), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: s, ap, as\n    complex(kind=DP) :: alpha, beta, omega, sum1, sum2, sum3\n  \n      if (iter == 0) then                           ! r_0 = b - A*x_0, p_0 = r_0\n        call calc_r(ldt, x, b, r, iz, ibuff)\n        p(:,:,:) = r(:,:,:)\n        r0(:,:,:) = r(:,:,:)\n      end if\n  \n      call calc_ap(ldt, p, ap, iz, ibuff)\n      sum1 = sum(r0(:,:,:) * r(:,:,:))\n      sum2 = sum(r0(:,:,:) * ap(:,:,:))\n      alpha = sum1 / sum2                      ! alpha = (r_0,r_k) / (r_0,A*p_k)\n  \n      s(:,:,:) = r(:,:,:) - alpha * ap(:,:,:)          ! s_k = r_k - alpha*A*p_k\n  \n      call calc_ap(ldt, s, as, iz, ibuff)\n      sum2 = sum(s(:,:,:) * as(:,:,:))\n      sum3 = sum(as(:,:,:)**2)\n      omega = sum2 / sum3                  ! omega = (A*s_k,s_k) / (A*s_k,A*s_k)\n  \n      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:) + omega * s(:,:,:)\n                                           ! x_k+1 = x_k * alpha*p_k + omega*s_k\n      r(:,:,:) = s(:,:,:) - omega * as(:,:,:)        ! r_k+1 = s_k - omega*A*s_k\n  \n      sum3 = sum(r0(:,:,:) * r(:,:,:))\n      beta = alpha * sum3 / (omega * sum1)\n                              ! beta = (alpha / omega) * (r_0,r_k+1) / (r_0,r_k)\n  \n      p(:,:,:) = r(:,:,:) + beta * (p(:,:,:) - omega * ap(:,:,:))\n                                    ! p_k+1 = r_k+1 + beta * (p_k - omega*A*p_k)\n  \n  END SUBROUTINE bi_cgstab\n\n\n!!--------------------------------------\n!  ", "SUBROUTINE gcr(ldt, iter, x, b, r, iz, ibuff)\n!!-------------------------------------------------------------------------------\n!!\n!!    Generalized conjugate gradient method (A*x = b for Non-Hermitian A)\n!!\n!!-------------------------------------------------------------------------------\n!\n!    real(kind=DP), intent(in) :: ldt\n!    integer, intent(in) :: iter\n!    complex(kind=DP), intent(inout), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n!    complex(kind=DP), intent(in), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n!    integer, intent(in) :: iz, ibuff\n!\n!    complex(kind=DP), save, &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:iter_max-1) :: p, ap\n!!$OMP threadprivate(p,ap)\n!    complex(kind=DP), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ar\n!    complex(kind=DP) :: alpha, beta, sum1\n!    complex(kind=DP), save, &\n!      dimension(0:iter_max-1) :: sum2\n!!$OMP threadprivate(sum2)\n!    integer :: i\n!  \n!      if (iter == 0) then                           ! r_0 = b - A*x_0, p_0 = r_0\n!        call calc_r(ldt, x, b, r, iz, ibuff)\n!        p(:,:,:,iter) = r(:,:,:)\n!        call calc_ap(ldt, p(:,:,:,iter), ap(:,:,:,iter), iz, ibuff)\n!      end if\n!  \n!      sum1 = sum(ap(:,:,:,iter) * r(:,:,:))\n!      sum2(iter) = sum(ap(:,:,:,iter) * ap(:,:,:,iter))\n!      alpha = sum1 / sum2(iter)            ! alpha = (A*p_k,r_k) / (A*p_k,A*p_k)\n!  \n!      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:,iter)    ! x_k+1 = x_k + alpha*p_k\n!      r(:,:,:) = r(:,:,:) - alpha * ap(:,:,:,iter)   ! r_k+1 = r_k - alpha*A*p_k\n!  \n!      call calc_ap(ldt, r, ar, iz, ibuff)\n!\n!      p(:,:,:,iter+1) = r(:,:,:)\n!      ap(:,:,:,iter+1) = ar(:,:,:)\n!      do i = 0, iter\n!        sum1 = sum(ap(:,:,:,i) * ar(:,:,:))\n!        beta = - sum1 / sum2(i)     ! beta_i = - (A*p_i,A*r_k+1) / (A*p_i,A*p_i)\n!        p(:,:,:,iter+1) = p(:,:,:,iter+1) + beta * p(:,:,:,i)\n!                                            ! p_k+1 = r_k+1 + Sum_i^k beta_i*p_i\n!        ap(:,:,:,iter+1) = ap(:,:,:,iter+1) + beta * ap(:,:,:,i)\n!                                      ! A*p_k+1 = A*r_k+1 + Sum_i^k beta_i*A*p_i\n!      end do\n!  \n!  END SUBROUTINE gcr\n!\n!\n!!--------------------------------------\n!  SUBROUTINE gcr1(ldt, iter, x, b, r, iz, ibuff)\n!!-------------------------------------------------------------------------------\n!!\n!!    Generalized conjugate gradient method (A*x = b for Non-Hermitian A)\n!!\n!!-------------------------------------------------------------------------------\n!\n!    real(kind=DP), intent(in) :: ldt\n!    integer, intent(in) :: iter\n!    complex(kind=DP), intent(inout), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n!    complex(kind=DP), intent(in), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n!    integer, intent(in) :: iz, ibuff\n!\n!    complex(kind=DP), save, &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: p, ap\n!!$OMP threadprivate(p,ap)\n!    complex(kind=DP), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ar\n!    complex(kind=DP) :: alpha, beta, sum1, sum2\n!  \n!      if (iter == 0) then                           ! r_0 = b - A*x_0, p_0 = r_0\n!        call calc_r(ldt, x, b, r, iz, ibuff)\n!        p(:,:,:) = r(:,:,:)\n!        call calc_ap(ldt, p, ap, iz, ibuff)\n!      end if\n!  \n!      sum1 = sum(ap(:,:,:) * r(:,:,:))\n!      sum2 = sum(ap(:,:,:) * ap(:,:,:))\n!      alpha = sum1 / sum2                  ! alpha = (A*p_k,r_k) / (A*p_k,A*p_k)\n!  \n!      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:)         ! x_k+1 = x_k + alpha*p_k\n!      r(:,:,:) = r(:,:,:) - alpha * ap(:,:,:)        ! r_k+1 = r_k - alpha*A*p_k\n!  \n!      call calc_ap(ldt, r, ar, iz, ibuff)\n!      sum1 = sum(ap(:,:,:) * ar(:,:,:))\n!      beta = - sum1 / sum2            ! beta = - (A*p_k,A*r_k+1) / (A*p_k,A*p_k)\n!  \n!      p(:,:,:) = r(:,:,:) + beta * p(:,:,:)           ! p_k+1 = r_k+1 + beta*p_k\n!      ap(:,:,:) = ar(:,:,:) + beta * ap(:,:,:)  ! A*p_k+1 = A*r_k+1 + beta*A*p_k\n!  \n!  END SUBROUTINE gcr1\n!\n!\n!!--------------------------------------\n!  SUBROUTINE gcrm(ldt, iter, x, b, r, iz, ibuff)\n!!-------------------------------------------------------------------------------\n!!\n!!    Generalized conjugate gradient method (A*x = b for Non-Hermitian A)\n!!\n!!-------------------------------------------------------------------------------\n!\n!    real(kind=DP), intent(in) :: ldt\n!    integer, intent(in) :: iter\n!    complex(kind=DP), intent(inout), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n!    complex(kind=DP), intent(in), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n!    integer, intent(in) :: iz, ibuff\n!\n!    integer, parameter :: m = 10\n!    complex(kind=DP), save, &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:m-1) :: p, ap\n!!$OMP threadprivate(p,ap)\n!    complex(kind=DP), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ar\n!    complex(kind=DP) :: alpha, beta, sum1\n!    complex(kind=DP), save, &\n!      dimension(0:m-1) :: sum2\n!!$OMP threadprivate(sum2)\n!    integer :: i, k\n!  \n!      k = mod(iter,m)\n!      if (k == 0) then                    ! r_0 = b - A*x_0, p_0 = r_0\n!        call calc_r(ldt, x, b, r, iz, ibuff)\n!        p(:,:,:,k) = r(:,:,:)\n!        call calc_ap(ldt, p(:,:,:,k), ap(:,:,:,k), iz, ibuff)\n!      end if\n!  \n!      sum1 = sum(ap(:,:,:,k) * r(:,:,:))\n!      sum2(k) = sum(ap(:,:,:,k) * ap(:,:,:,k))\n!      alpha = sum1 / sum2(k)            ! alpha = (A*p_k,r_k) / (A*p_k,A*p_k)\n!  \n!      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:,k)    ! x_k+1 = x_k + alpha*p_k\n!      r(:,:,:) = r(:,:,:) - alpha * ap(:,:,:,k)   ! r_k+1 = r_k - alpha*A*p_k\n!  \n!      call calc_ap(ldt, r, ar, iz, ibuff)\n!\n!      p(:,:,:,k+1) = r(:,:,:)\n!      ap(:,:,:,k+1) = ar(:,:,:)\n!      do i = 0, k\n!        sum1 = sum(ap(:,:,:,i) * ar(:,:,:))\n!        beta = - sum1 / sum2(i)     ! beta_i = - (A*p_i,A*r_k+1) / (A*p_i,A*p_i)\n!        p(:,:,:,k+1) = p(:,:,:,k+1) + beta * p(:,:,:,i)\n!                                            ! p_k+1 = r_k+1 + Sum_i^k beta_i*p_i\n!        ap(:,:,:,k+1) = ap(:,:,:,k+1) + beta * ap(:,:,:,i)\n!                                      ! A*p_k+1 = A*r_k+1 + Sum_i^k beta_i*A*p_i\n!      end do\n!  \n!  END SUBROUTINE gcrm\n\n\n!--------------------------------------\n  SUBROUTINE calc_b(ldt, wh, b, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Calculate b\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: wh\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: ww\n    complex(kind=DP) :: phi, Al\n\n      call emfield_hh(wh, Al, iz, ibuff)\n      call esfield(wh, phi, iz, ibuff)\n\n      if (iFLR == 0) then\n        call setww_ff(wh, Al, ww, iz, ibuff) ! Gyrocenter distribution\n      else\n        call setww_gg(wh, phi, Al, ww, iz, ibuff) ! Non-adiabatic distribution\n      end if\n\n      if (trim(col_type) == \"LB\") then\n        call collision_LB(ww, b, iz, ibuff)\n      else if (trim(col_type) == \"lorentz\") then\n        call collision_lorentz(ww, b, iz, ibuff)\n      else if (trim(col_type) == \"full\") then\n        call collision_full(ww, b, iz, ibuff)\n      else\n        write(olog,*) \"# colliimp module does not support col_type=\", col_type\n        stop\n      end if\n\n      b(:,:,:) = wh(:,:,:) + 0.5_DP * ldt * b(:,:,:) ! 2nd C.N.\n     !b(:,:,:) = wh(:,:,:)                           ! 1st B.E.\n  \n  END SUBROUTINE calc_b\n\n\n!--------------------------------------\n  SUBROUTINE calc_ap(ldt, p, ap, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Calculate A*p^k\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: p\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ap\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: ww\n    complex(kind=DP) :: phi, Al\n\n      call emfield_hh(p, Al, iz, ibuff)\n      call esfield(p, phi, iz, ibuff)\n\n      if (iFLR == 0) then\n        call setww_ff(p, Al, ww, iz, ibuff) ! Gyrocenter distribution\n      else\n        call setww_gg(p, phi, Al, ww, iz, ibuff) ! Non-adiabatic distribution\n      end if\n\n      if (trim(col_type) == \"LB\") then\n        call collision_LB(ww, ap, iz, ibuff)\n      else if (trim(col_type) == \"lorentz\") then\n        call collision_lorentz(ww, ap, iz, ibuff)\n      else if (trim(col_type) == \"full\") then\n        call collision_full(ww, ap, iz, ibuff)\n      else\n        write(olog,*) \"# colliimp module does not support col_type=\", col_type\n        stop\n      end if\n\n      ap(:,:,:) = p(:,:,:) - 0.5_DP * ldt * ap(:,:,:) ! 2nd C.N.\n     !ap(:,:,:) = p(:,:,:) - ldt * ap(:,:,:)          ! 1st B.E.\n  \n  END SUBROUTINE calc_ap\n\n\n!--------------------------------------\n  SUBROUTINE calc_r(ldt, x, b, r, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Calculate residual  r^n = b - A*x^n\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, b\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: r\n    integer, intent(in) :: iz, ibuff\n  \n      call calc_ap(ldt, x, r, iz, ibuff)\n      r(:,:,:) = b(:,:,:) - r(:,:,:)\n  \n  END SUBROUTINE calc_r\n  \n  \n!--------------------------------------\n  SUBROUTINE calc_error(r, b, error)\n!-------------------------------------------------------------------------------\n!\n!    Evaluate relative error of A*x^n = b\n!\n!      When analytic solution x^* is known,\n!\n!        Relative error = ||x^n - x^*|| / ||x^*||\n!\n!      When x^* is not available, error is often replaced by followings:\n!\n!        Relative residual error = ||r^n|| / ||b||\n!        Relative iteration error = ||x^n - x^n-1|| / ||x^n||\n!\n!      where residual is  r^n = b - A*x^n.\n!\n!      Several types of norm of the vector ||x|| are available,\n!\n!              1-norm  ||x|| = sum_i |x_i|\n!              2-norm  ||x|| = sum_i |x_i|^2\n!              p-norm  ||x|| = sum_i |x_i|^p\n!        Maximum norm  ||x|| = max(|x_i|)\n!\n!-------------------------------------------------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: r, b\n    real(kind=DP), intent(out) :: error\n\n     !error = sum(abs(r(:,:,:))) / sum(abs(b(:,:,:)))\n     !error = sum(abs(r(:,:,:))**2) / sum(abs(b(:,:,:))**2)\n      error = maxval(abs(r(:,:,:))) / maxval(abs(b(:,:,:)))\n\n  END SUBROUTINE calc_error\n\n\n!--------------------------------------\n  SUBROUTINE emfield_hh(hh, Al, iz, ibuff)\n!--------------------------------------\n!   Magnetic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(out) :: Al\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP) :: jpara, wf, wfvp, wfvp1\n    real(kind=DP) :: cs2, cintgrl\n    integer :: iv, im, is, mx, my\n\n      jpara = (0._DP, 0._DP)\n      do is = 0, ns-1\n        cs2 = sgn(is) * fcs(is) * sqrt(tau(is) / Anum(is))\n\n        do im = 1, global_nm\n          cintgrl = 2._DP * pi * gvp(im,iz) * dv * dvp(iz)\n          do iv = 1, 2*global_nv\n            wf = hh(iv,im,is) * gj0(im,is,iz,ibuff) * cs2 * gvl(iv)\n            jpara = jpara + wf * cintgrl\n          end do\n        end do\n\n       !- edge compensation -\n        im = 1\n          do iv = 1, 2*global_nv\n            wfvp  = gvp(im  ,iz) * hh(iv,im  ,is) * gj0(im  ,is,iz,ibuff) &\n                  * cs2 * gvl(iv)\n            wfvp1 = gvp(im+1,iz) * hh(iv,im+1,is) * gj0(im+1,is,iz,ibuff) &\n                  * cs2 * gvl(iv)\n            jpara = jpara - ( - wfvp / 12._DP       &\n                            + ( wfvp1               &\n                              - wfvp * 2._DP        &\n                              ) * 11._DP / 720._DP  &\n                            ) * (2._DP * pi * dv * dvp(iz))\n          end do\n\n      end do\n\n      call ibuffiproc2mxmy(ibuff, spc_rank, mx, my)\n      Al = jpara * beta * fct_ampere(mx,my,iz)\n\n  END SUBROUTINE emfield_hh\n\n\n!--------------------------------------\n  SUBROUTINE esfield(hh, phi, iz, ibuff)\n!--------------------------------------\n!   Electrostatic field calculation\n\n    implicit none\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(out) :: phi\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP) :: rho, wf, wfvp, wfvp1\n    real(kind=DP) :: cs1, cintgrl\n    integer :: iv, im, is, mx, my\n\n      rho = (0._DP, 0._DP)\n      do is = 0, ns-1\n        cs1 = sgn(is) * fcs(is)\n\n        do im = 1, global_nm\n          cintgrl = 2._DP * pi * gvp(im,iz) * dv * dvp(iz)\n          do iv = 1, 2*global_nv\n            wf = hh(iv,im,is) * gj0(im,is,iz,ibuff) * cs1\n            rho = rho + wf * cintgrl\n          end do\n        end do\n\n       !- edge compensation -\n        im = 1\n          do iv = 1, 2*global_nv\n            wfvp  = gvp(im  ,iz) * hh(iv,im  ,is) * gj0(im  ,is,iz,ibuff) * cs1\n            wfvp1 = gvp(im+1,iz) * hh(iv,im+1,is) * gj0(im+1,is,iz,ibuff) * cs1\n            rho = rho - ( - wfvp / 12._DP       &\n                        + ( wfvp1               &\n                          - wfvp * 2._DP        &\n                          ) * 11._DP / 720._DP  &\n                        ) * (2._DP * pi * dv * dvp(iz))\n          end do\n\n      end do\n\n      call ibuffiproc2mxmy(ibuff, spc_rank, mx, my)\n      phi = rho * fct_poisson(mx,my,iz)\n\n  END SUBROUTINE esfield\n\n\n!--------------------------------------\n  SUBROUTINE setww_ff(hh, Al, ff, iz, ibuff)\n!--------------------------------------\n!   Set gyrocenter distribution ff\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(in) :: Al\n    complex(kind=DP), intent(out), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: ff\n    integer, intent(in) :: iz, ibuff\n \n    real(kind=DP) :: cs2\n    integer :: iv, im, is, ivb\n\n      do is = 0, ns-1\n        cs2 = sgn(is) * Znum(is) / sqrt( Anum(is) * tau(is) )\n        do im = 0, global_nm\n          do iv = 1, 2*global_nv\n            ff(iv,im,is) = hh(iv,im,is) - gfmx(iv,im,iz) * gj0(im,is,iz,ibuff) &\n                                                          * cs2 * gvl(iv) * Al\n          end do\n        end do\n      end do\n\n    !- Boundary condition -\n      do ivb = 1, nvb\n        ff(1-ivb,:,:) = (0._DP, 0._DP)\n        ff(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n        ff(:,global_nm+ivb,:) = (0._DP, 0._DP)\n        ff(:,-ivb,:) = ff(:,ivb,:)\n      end do\n    !-\n\n  END SUBROUTINE setww_ff\n\n\n!--------------------------------------\n  SUBROUTINE setww_gg(hh, phi, Al, gg, iz, ibuff)\n!--------------------------------------\n!   Set non-adiabatic distribution gg\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(in) :: phi, Al\n    complex(kind=DP), intent(out), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: gg\n    integer, intent(in) :: iz, ibuff\n \n    real(kind=DP) :: cs1, cs2\n    integer :: iv, im, is, ivb\n\n      do is = 0, ns-1\n        cs1 = sgn(is) * Znum(is) / tau(is)\n        cs2 = sgn(is) * Znum(is) / sqrt( Anum(is) * tau(is) )\n        do im = 0, global_nm\n          do iv = 1, 2*global_nv\n            gg(iv,im,is) = hh(iv,im,is) + gfmx(iv,im,iz) * gj0(im,is,iz,ibuff) &\n                                            * (cs1 * phi - cs2 * gvl(iv) * Al)\n          end do\n        end do\n      end do\n\n    !- Boundary condition -\n      do ivb = 1, nvb\n        gg(1-ivb,:,:) = (0._DP, 0._DP)\n        gg(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n        gg(:,global_nm+ivb,:) = (0._DP, 0._DP)\n        gg(:,-ivb,:) = gg(:,ivb,:)\n      end do\n    !-\n\n  END SUBROUTINE setww_gg\n\n\n!--------------------------------------\n  ", "SUBROUTINE collision_LB(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Lenard-Bernstein operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    real(kind=DP) :: nu_s, cv1, cv2, cm1, cm2, cflr\n    integer :: iv, im, is, mxy, mx, my\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n        do is = 0, ns-1\n          nu_s = nu(is) * 3._DP * sqrt(pi) * ctauiv(is,is) / 4._DP\n               !- nu(is) is a bias factor given in namelist\n          cv1 = nu_s / ( 12._DP * dv )\n          cv2 = nu_s / ( 12._DP * dv * dv )\n          cm1 = nu_s / ( 12._DP * dvp(iz) )\n          cm2 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cflr = nu_s * ksq(mx,my,iz) * Anum(is) * tau(is)  &\n                 / ( Znum(is) * omg(iz) )**2 * real(iFLR, kind=DP)\n          im = 0 \n            do iv = 1, 2*global_nv\n              cf(iv,im,is) =                                        &\n                         ( -          wf(iv+2,im,is)                &\n                           + 16._DP * wf(iv+1,im,is)                &\n                           - 30._DP * wf(iv  ,im,is)                &\n                           + 16._DP * wf(iv-1,im,is)                &\n                           -          wf(iv-2,im,is)                &\n                         ) * cv2                                    &\n                       + ( -          wf(iv+2,im,is)                &\n                           +  8._DP * wf(iv+1,im,is)                &\n                           -  8._DP * wf(iv-1,im,is)                &\n                           +          wf(iv-2,im,is)                &\n                         ) * cv1 * gvl(iv)                          &\n                       + ( -          wf(iv,im+2,is)                &\n                           + 16._DP * wf(iv,im+1,is)                &\n                           - 30._DP * wf(iv,im  ,is)                &\n                           + 16._DP * wf(iv,im-1,is)                &\n                           -          wf(iv,im-2,is)                &\n                         ) * cm2 * 2._DP                            &\n                       + nu_s * 3._DP * wf(iv,im,is)                &\n                       - cflr * wf(iv,im,is)\n            end do\n          do im = 1, global_nm\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) =                                            &\n                         ( -          wf(iv+2,im,is)                    &\n                           + 16._DP * wf(iv+1,im,is)                    &\n                           - 30._DP * wf(iv  ,im,is)                    &\n                           + 16._DP * wf(iv-1,im,is)                    &\n                           -          wf(iv-2,im,is)                    &\n                         ) * cv2                                        &\n                       + ( -          wf(iv+2,im,is)                    &\n                           +  8._DP * wf(iv+1,im,is)                    &\n                           -  8._DP * wf(iv-1,im,is)                    &\n                           +          wf(iv-2,im,is)                    &\n                         ) * cv1 * gvl(iv)                              &\n                       + ( -          wf(iv,im+2,is)                    &\n                           + 16._DP * wf(iv,im+1,is)                    &\n                           - 30._DP * wf(iv,im  ,is)                    &\n                           + 16._DP * wf(iv,im-1,is)                    &\n                           -          wf(iv,im-2,is)                    &\n                         ) * cm2                                        &\n                       + ( -          wf(iv,im+2,is)                    &\n                           +  8._DP * wf(iv,im+1,is)                    &\n                           -  8._DP * wf(iv,im-1,is)                    &\n                           +          wf(iv,im-2,is)                    &\n                         ) * cm1 * ( gvp(im,iz) + 1._DP / gvp(im,iz) )  &\n                       + nu_s * 3._DP * wf(iv,im,is)                    &   \n                       - cflr * wf(iv,im,is)\n            end do\n          end do\n        end do\n\n      else\n\n        cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_LB\n\n\n!--------------------------------------\n  SUBROUTINE collision_lorentz(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Lorentz operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    real(kind=DP) :: cv1, cv2, cm1, cm2, cvm, cflr\n    integer :: iv, im, is, mxy, mx, my\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n        do is = 0, ns-1\n          cv1 = 1._DP / (12._DP * dv)\n          cv2 = 1._DP / (12._DP * dv**2)\n          cm1 = 1._DP / (12._DP * dvp(iz))\n          cm2 = 1._DP / (12._DP * dvp(iz)**2)\n          cvm = 1._DP / (144._DP * dv * dvp(iz))\n          cflr = ksq(mx,my,iz) * Anum(is) * tau(is)  &\n                 / ( Znum(is) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n          im = 0\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = 0.5_DP * gnu_ds(iv,im,is,iz) * (                  &\n                          - 2._DP * gvl(iv) * cv1 * (-         wf(iv+2,im,is)  &\n                                                     + 8._DP * wf(iv+1,im,is)  &\n                                                     - 8._DP * wf(iv-1,im,is)  &\n                                                     +         wf(iv-2,im,is)) &\n                       + 2._DP * gvl(iv)**2 * cm2 * (-         wf(iv,im+2,is)  &\n                                                     +16._DP * wf(iv,im+1,is)  &\n                                                     -30._DP * wf(iv,im  ,is)  &\n                                                     +16._DP * wf(iv,im-1,is)  &\n                                                     -         wf(iv,im-2,is)) &\n                           )                                                   &\n                           - 0.25_DP * gnu_ds(iv,im,is,iz)                     &\n                             * (2._DP * gvl(iv)**2)                            &\n                             * cflr * wf(iv,im,is)\n            end do\n\n          do im = 1, global_nm\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = 0.5_DP * gnu_ds(iv,im,is,iz) * (                  &\n                              gvp(im,iz)**2 * cv2 * (-         wf(iv+2,im,is)  &\n                                                     +16._DP * wf(iv+1,im,is)  &\n                                                     -30._DP * wf(iv  ,im,is)  &\n                                                     +16._DP * wf(iv-1,im,is)  &\n                                                     -         wf(iv-2,im,is)) &\n                          - 2._DP * gvl(iv) * cv1 * (-         wf(iv+2,im,is)  &\n                                                     + 8._DP * wf(iv+1,im,is)  &\n                                                     - 8._DP * wf(iv-1,im,is)  &\n                                                     +         wf(iv-2,im,is)) &\n                           - 2._DP * gvl(iv) * gvp(im,iz) &\n                                          * cvm * (+         wf(iv+2,im+2,is)  &\n                                                   - 8._DP * wf(iv+2,im+1,is)  &\n                                                   + 8._DP * wf(iv+2,im-1,is)  &\n                                                   -         wf(iv+2,im-2,is)  &\n                                                   - 8._DP * wf(iv+1,im+2,is)  &\n                                                   +64._DP * wf(iv+1,im+1,is)  &\n                                                   -64._DP * wf(iv+1,im-1,is)  &\n                                                   + 8._DP * wf(iv+1,im-2,is)  &\n                                                   + 8._DP * wf(iv-1,im+2,is)  &\n                                                   -64._DP * wf(iv-1,im+1,is)  &\n                                                   +64._DP * wf(iv-1,im-1,is)  &\n                                                   - 8._DP * wf(iv-1,im-2,is)  &\n                                                   -         wf(iv-2,im+2,is)  &\n                                                   + 8._DP * wf(iv-2,im+1,is)  &\n                                                   - 8._DP * wf(iv-2,im-1,is)  &\n                                                   +         wf(iv-2,im-2,is)) &\n                           + ((gvl(iv)**2 - gvp(im,iz)**2) / gvp(im,iz)) &\n                                            * cm1 * (-         wf(iv,im+2,is)  &\n                                                     + 8._DP * wf(iv,im+1,is)  &\n                                                     - 8._DP * wf(iv,im-1,is)  &\n                                                     +         wf(iv,im-2,is)) &\n                               + gvl(iv)**2 * cm2 * (-         wf(iv,im+2,is)  &\n                                                     +16._DP * wf(iv,im+1,is)  &\n                                                     -30._DP * wf(iv,im  ,is)  &\n                                                     +16._DP * wf(iv,im-1,is)  &\n                                                     -         wf(iv,im-2,is)) &\n                           )                                                   &\n                           - 0.25_DP * gnu_ds(iv,im,is,iz)                     &\n                             * (2._DP * gvl(iv)**2 + gvp(im,iz)**2)            &\n                             * cflr * wf(iv,im,is)\n            end do\n          end do\n        end do\n\n      else\n\n        cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_lorentz\n\n\n!--------------------------------------\n  SUBROUTINE collision_full(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n\n    complex(kind=DP), dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n\n                             !%%% For debug %%%\n                             ! complex(kind=DP), &\n                             ! dimension(1:2*global_nv,0:global_nm,0:ns-1) &\n                             !                              :: cft, cfd, cff\n                             ! integer :: mx, my, iv, im\n                             ! integer, save :: iflg_dbg\n                             ! data iflg_dbg / 0 /\n                             !%%%%%%%%%%%%%%%%%\n\n      call collision_full_CT(wf, cf, iz, ibuff)\n\n      call collision_full_calc_moment(wf, moment_ab, iz, ibuff)\n      call collision_full_DT(moment_ab, cf, iz, ibuff)\n      call collision_full_CF(moment_ab, cf, iz, ibuff)\n\n                             !%%% For debug %%%\n                             ! call ibuffiproc2mxmy&\n                             !                   (ibuff,spc_rank,mx,my)\n                             ! if (rankw == 0 .and. rankz == 0 .and. &\n                             !     mx == 1 .and. my == 1 .and.       &\n                             !     iz == 0 .and. iflg_dbg == 0) then\n                             ! iflg_dbg = 1\n                             ! call collision_full_ct(wf,cft,iz,ibuff)\n                             ! call collision_full_dt(moment_ab,cfd,iz,ibuff)\n                             ! call collision_full_cf(moment_ab,cff,iz,ibuff)\n                             ! do im = 0, global_nm\n                             ! do iv = 1, 2*global_nv\n                             !   write(97,*) gvl(iv), gvp(im,iz), &\n                             !              dble(wf(iv,im,0)),    &\n                             !              aimag(wf(iv,im,0)),   &\n                             !              dble(cft(iv,im,0)),   &\n                             !              aimag(cft(iv,im,0)),  &\n                             !              dble(cfd(iv,im,0)),   &\n                             !              aimag(cfd(iv,im,0)),  &\n                             !              dble(cff(iv,im,0)),   &\n                             !              aimag(cff(iv,im,0))\n                             ! end do\n                             !   write(97,*)\n                             ! end do\n                             ! end if\n                             !%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE collision_full\n\n\n!--------------------------------------\n  ", "SUBROUTINE collision_full_CT(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, test particle part (scattering+slowing down+diffusion)\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    real(kind=DP) :: cv1, cv2, cm1, cm2, cvm, cflr\n    integer :: iv, im, is, mxy, mx, my\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n        do is = 0, ns-1\n\n          cv1 = 1._DP / (12._DP * dv)\n          cv2 = 1._DP / (12._DP * dv**2)\n          cm1 = 1._DP / (12._DP * dvp(iz))\n          cm2 = 1._DP / (12._DP * dvp(iz)**2)\n          cvm = 1._DP / (144._DP * dv * dvp(iz))\n          cflr = ksq(mx,my,iz) * Anum(is) * tau(is)  &\n                 / ( Znum(is) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n          im = 0\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = ( -          wf(iv+2,im,is)                       &\n                               + 16._DP * wf(iv+1,im,is)                       &\n                               - 30._DP * wf(iv  ,im,is)                       &\n                               + 16._DP * wf(iv-1,im,is)                       &\n                               -          wf(iv-2,im,is)                       &\n                             ) * cv2                                           &\n                               * (   gnu_ps(iv,im,is,iz) * gvl(iv)**2          &\n                                 ) * 0.5_DP                                    &\n                           + ( -          wf(iv,im+2,is)                       &\n                               + 16._DP * wf(iv,im+1,is)                       &\n                               - 30._DP * wf(iv,im  ,is)                       &\n                               + 16._DP * wf(iv,im-1,is)                       &\n                               -          wf(iv,im-2,is)                       &\n                             ) * cm2                                           &\n                               * (   gnu_ds(iv,im,is,iz) * gvl(iv)**2          &\n                                 )                                             &\n                           + ( -          wf(iv+2,im,is)                       &\n                               +  8._DP * wf(iv+1,im,is)                       &\n                               -  8._DP * wf(iv-1,im,is)                       &\n                               +          wf(iv-2,im,is)                       &\n                             ) * cv1                                           &\n                               * gnu_gs(iv,im,is,iz) * gvl(iv)                 &\n                          !+ ( gnu_hs(iv,im,is,iz) * gxxa**2 * 2._DP           &\n                           + ( gnu_hs(iv,im,is,iz) * 2._DP                     &\n                                - 0.25_DP * cflr                               &\n                                 * gnu_ds(iv,im,is,iz) * 2._DP * gvl(iv)**2    &\n                             ) * wf(iv,im,is)\n            end do\n\n          do im = 1, global_nm\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = ( -          wf(iv+2,im,is)                       &\n                               + 16._DP * wf(iv+1,im,is)                       &\n                               - 30._DP * wf(iv  ,im,is)                       &\n                               + 16._DP * wf(iv-1,im,is)                       &\n                               -          wf(iv-2,im,is)                       &\n                             ) * cv2                                           &\n                               * (   gnu_ps(iv,im,is,iz) * gvl(iv)**2          &\n                                   + gnu_ds(iv,im,is,iz) * gvp(im,iz)**2       &\n                                 ) * 0.5_DP                                    &\n                           + ( -          wf(iv,im+2,is)                       &\n                               + 16._DP * wf(iv,im+1,is)                       &\n                               - 30._DP * wf(iv,im  ,is)                       &\n                               + 16._DP * wf(iv,im-1,is)                       &\n                               -          wf(iv,im-2,is)                       &\n                             ) * cm2                                           &\n                               * (   gnu_ds(iv,im,is,iz) * gvl(iv)**2          &\n                                   + gnu_ps(iv,im,is,iz) * gvp(im,iz)**2       &\n                                 ) * 0.5_DP                                    &\n                           + ( +          wf(iv+2,im+2,is)                     &\n                               -  8._DP * wf(iv+2,im+1,is)                     &\n                               +  8._DP * wf(iv+2,im-1,is)                     &\n                               -          wf(iv+2,im-2,is)                     &\n                               -  8._DP * wf(iv+1,im+2,is)                     &\n                               + 64._DP * wf(iv+1,im+1,is)                     &\n                               - 64._DP * wf(iv+1,im-1,is)                     &\n                               +  8._DP * wf(iv+1,im-2,is)                     &\n                               +  8._DP * wf(iv-1,im+2,is)                     &\n                               - 64._DP * wf(iv-1,im+1,is)                     &\n                               + 64._DP * wf(iv-1,im-1,is)                     &\n                               -  8._DP * wf(iv-1,im-2,is)                     &\n                               -          wf(iv-2,im+2,is)                     &\n                               +  8._DP * wf(iv-2,im+1,is)                     &\n                               -  8._DP * wf(iv-2,im-1,is)                     &\n                               +          wf(iv-2,im-2,is)                     &\n                             ) * cvm                                           &\n                               * gvl(iv) * gvp(im,iz)                          &\n                               * (   gnu_ps(iv,im,is,iz)                       &\n                                   - gnu_ds(iv,im,is,iz) )                     &\n                           + ( -          wf(iv+2,im,is)                       &\n                               +  8._DP * wf(iv+1,im,is)                       &\n                               -  8._DP * wf(iv-1,im,is)                       &\n                               +          wf(iv-2,im,is)                       &\n                             ) * cv1                                           &\n                               * gnu_gs(iv,im,is,iz) * gvl(iv)                 &\n                           + ( -          wf(iv,im+2,is)                       &\n                               +  8._DP * wf(iv,im+1,is)                       &\n                               -  8._DP * wf(iv,im-1,is)                       &\n                               +          wf(iv,im-2,is)                       &\n                             ) * cm1                                           &\n                               * (   gnu_gs(iv,im,is,iz) * gvp(im,iz)          &\n                                   + gnu_ds(iv,im,is,iz) * 0.5_DP              &\n                                     * (gvl(iv)**2 / gvp(im,iz) + gvp(im,iz)) )&\n                          !+ ( gnu_hs(iv,im,is,iz) * gxxa**2 * 2._DP           &\n                           + ( gnu_hs(iv,im,is,iz) * 2._DP                     &\n                                - 0.25_DP * cflr                               &\n                                 * (  gnu_ds(iv,im,is,iz)                      &\n                                       * (2._DP * gvl(iv)**2 + gvp(im,iz)**2)  &\n                                     + gnu_ps(iv,im,is,iz) * gvp(im,iz)**2 )   &\n                             ) * wf(iv,im,is)\n            end do\n          end do\n        end do\n\n      else\n\n        cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_full_CT\n\n\n!--------------------------------------\n  ", "SUBROUTINE collision_full_calc_moment(wf, moment_ab, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, calculate velocity moments\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n    integer, intent(in) :: iz, ibuff\n\n    complex(kind=DP) :: wfvp, wfvp1\n    integer :: iv, im, ia, ib\n             \n      moment_ab(:,:,:) = (0._DP, 0._DP)\n\n      if ( iFLR == 1 ) then  ! full-GK\n\n        do ib = 0, ns-1\n          do ia = 0, ns-1\n  \n            do im = 1, global_nm\n              do iv = 1, 2*global_nv\n                  moment_ab(1,ia,ib) = moment_ab(1,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(1,iv,im,ia,ib,iz)\n                  moment_ab(2,ia,ib) = moment_ab(2,ia,ib) + wf(iv,im,ia) * gj1(im,ia,iz,ibuff) * gvfunc(2,iv,im,ia,ib,iz)\n                  moment_ab(3,ia,ib) = moment_ab(3,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(3,iv,im,ia,ib,iz)\n                  moment_ab(4,ia,ib) = moment_ab(4,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(4,iv,im,ia,ib,iz)\n                  moment_ab(5,ia,ib) = moment_ab(5,ia,ib) + wf(iv,im,ia) * gj1(im,ia,iz,ibuff) * gvfunc(5,iv,im,ia,ib,iz)\n                  moment_ab(6,ia,ib) = moment_ab(6,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(6,iv,im,ia,ib,iz)\n              end do\n            end do\n  \n           !- edge compensation -\n            im = 1\n              do iv = 1, 2*global_nv\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(1,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(1,iv,im+1,ia,ib,iz)\n                moment_ab(1,ia,ib) = moment_ab(1,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj1(im  ,ia,iz,ibuff) * gvfunc(2,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj1(im+1,ia,iz,ibuff) * gvfunc(2,iv,im+1,ia,ib,iz)\n                moment_ab(2,ia,ib) = moment_ab(2,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(3,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(3,iv,im+1,ia,ib,iz)\n                moment_ab(3,ia,ib) = moment_ab(3,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(4,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(4,iv,im+1,ia,ib,iz)\n                moment_ab(4,ia,ib) = moment_ab(4,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj1(im  ,ia,iz,ibuff) * gvfunc(5,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj1(im+1,ia,iz,ibuff) * gvfunc(5,iv,im+1,ia,ib,iz)\n                moment_ab(5,ia,ib) = moment_ab(5,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(6,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(6,iv,im+1,ia,ib,iz)\n                moment_ab(6,ia,ib) = moment_ab(6,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n              end do\n          \n          end do\n        end do\n\n      else if ( iFLR == 0 ) then ! DK-limit\n\n        do ib = 0, ns-1\n          do ia = 0, ns-1\n  \n            do im = 1, global_nm\n              do iv = 1, 2*global_nv\n                  moment_ab(1,ia,ib) = moment_ab(1,ia,ib) + wf(iv,im,ia) * gvfunc(1,iv,im,ia,ib,iz)\n                  moment_ab(3,ia,ib) = moment_ab(3,ia,ib) + wf(iv,im,ia) * gvfunc(3,iv,im,ia,ib,iz)\n                  moment_ab(4,ia,ib) = moment_ab(4,ia,ib) + wf(iv,im,ia) * gvfunc(4,iv,im,ia,ib,iz)\n                  moment_ab(6,ia,ib) = moment_ab(6,ia,ib) + wf(iv,im,ia) * gvfunc(6,iv,im,ia,ib,iz)\n              end do\n            end do\n  \n           !- edge compensation -\n            im = 1\n              do iv = 1, 2*global_nv\n                wfvp  = wf(iv,im  ,ia) * gvfunc(1,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(1,iv,im+1,ia,ib,iz)\n                moment_ab(1,ia,ib) = moment_ab(1,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gvfunc(3,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(3,iv,im+1,ia,ib,iz)\n                moment_ab(3,ia,ib) = moment_ab(3,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gvfunc(4,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(4,iv,im+1,ia,ib,iz)\n                moment_ab(4,ia,ib) = moment_ab(4,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gvfunc(6,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(6,iv,im+1,ia,ib,iz)\n                moment_ab(6,ia,ib) = moment_ab(6,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n              end do\n          \n          end do\n        end do\n\n      end if\n\n  END SUBROUTINE collision_full_calc_moment\n\n\n!--------------------------------------\n  SUBROUTINE collision_full_DT(moment_ab, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, test particle part (non-isothermal terms)\n\n    complex(kind=DP), intent(in), &\n      dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    integer :: iv, im, ia, ib, mxy\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        if ( iFLR == 1 ) then  ! full-GK\n   \n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gx_tst(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gx_tst(2,iv,im,ia,ib,iz) &\n                                * moment_ab(2,ia,ib)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gx_tst(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gx_tst(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gx_tst(5,iv,im,ia,ib,iz) &\n                                * moment_ab(5,ia,ib)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gx_tst(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)                  \n                end do\n              end do\n            end do\n          end do\n   \n        else if ( iFLR == 0 ) then ! DK-limit\n   \n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gx_tst(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ia,ib)      &\n                               + gx_tst(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ia,ib)      &\n                               + gx_tst(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ia,ib)      &\n                               + gx_tst(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ia,ib)\n                end do\n              end do\n            end do\n          end do\n   \n        end if\n\n      else\n\n        !cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_full_DT\n\n\n!--------------------------------------\n  SUBROUTINE collision_full_CF(moment_ab, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, field particle part\n\n    complex(kind=DP), intent(in), &\n      dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    integer :: iv, im, ia, ib, mxy\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        if ( iFLR == 1 ) then  ! full-GK\n\n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gy_fld(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gy_fld(2,iv,im,ia,ib,iz) &\n                                * moment_ab(2,ib,ia)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gy_fld(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gy_fld(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gy_fld(5,iv,im,ia,ib,iz) &\n                                * moment_ab(5,ib,ia)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gy_fld(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)                  \n                end do\n              end do\n            end do\n          end do\n\n        else if ( iFLR == 0 ) then ! DK-limit\n   \n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gy_fld(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ib,ia)      &\n                               + gy_fld(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ib,ia)      &\n                               + gy_fld(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ib,ia)      &\n                               + gy_fld(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ib,ia)\n                end do\n              end do\n            end do\n          end do\n   \n        end if\n\n      else\n\n        !cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_full_CF\n\n\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colliimp_calc_colli_full( ff, phi, cf )\n!!!!--------------------------------------\n!!!!   Collsion operator calculation interface\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: sender, recver\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n!!!    complex(kind=DP), dimension(:,:,:), allocatable :: w1, w2\n!!!    integer :: mx, my, iz, iv, im, ibuff, ivb\n!!!\n!!!      allocate( sender(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( recver(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( wf(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) )\n!!!      allocate( w1(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) )\n!!!      allocate( w2(1:2*global_nv,0:global_nm,0:ns-1) )\n!!!\n!!!!$OMP parallel do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                cf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n!!!                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n!!!                                                                     * real(iFLR, kind=DP)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!\n!!!      call vms2xy_pack(cf, sender)\n!!!      call vms2xy_transpose(sender, recver)\n!!!      call vms2xy_unpack(recver, wf)\n!!!      \n!!!                                      call clock_sta(1720)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(wf) &\n!!!!$OMP private(w1,w2,iz,ibuff)\n!!!      w1(:,:,:) = (0._DP, 0._DP)\n!!!!$OMP do collapse(2)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          w1(1:2*global_nv,0:global_nm,0:ns-1) = wf(:,:,:,iz,ibuff)\n!!!        !- Boundary condition -\n!!!          do ivb = 1, nvb\n!!!          !w1(1-ivb,:,:) = (0._DP, 0._DP)\n!!!          !w1(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n!!!          !w1(:,global_nm+ivb,:) = (0._DP, 0._DP)\n!!!            w1(:,-ivb,:) = w1(:,ivb,:)\n!!!          end do\n!!!        !-\n!!!          call collision_full(w1, w2, iz, ibuff)\n!!!          wf(:,:,:,iz,ibuff) = w2(:,:,:)\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1720)\n!!!\n!!!      call xy2vms_pack(wf, sender)\n!!!      call xy2vms_transpose(sender, recver)\n!!!      call xy2vms_unpack(recver, cf)\n!!!\n!!!      deallocate( sender )\n!!!      deallocate( recver )\n!!!      deallocate( wf )\n!!!      deallocate( w1 )\n!!!      deallocate( w2 )\n!!!\n!!!  END SUBROUTINE colliimp_calc_colli_full\n\n\n!--------------------------------------\n  SUBROUTINE colliimp_calc_colli_full( ff, phi, cf )\n!--------------------------------------\n!   Collsion operator calculation interface\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable ::  &\n           send1e, recv1e, send2e, recv2e, send1o, recv1o, send2o, recv2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: wh1e, wh2e, wh1o, wh2o\n    integer :: mx, my, iz, iv, im, is, ibuff, iproc\n\n      allocate( send1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( send1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,phi,cf,ist_y,iend_y,sgn,Znum,fmx,tau,j0,iFLR,ranks) &\n!$OMP shared(send1e,recv1e,send2e,recv2e,wh1e,wh2e) &\n!$OMP shared(send1o,recv1o,send2o,recv2o,wh1o,wh2o) &\n!$OMP private(mx,my,iz,iv,im,is,ibuff,iproc)\n      do iproc = 0, nprocvms-1\n!$OMP do\n        do ibuff = 0, nbuff-1\n          do im = 0, nm\n            do iv = 1, 2*nv\n              send1e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send1o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n      do ibuff = 0, nbuff-1\n!$OMP do\n        do is = 0, ns-1\n          do im = 0, global_nm\n            do iv = 1, 2*global_nv\n              wh1e(iv,im,is,ibuff) = (0._DP, 0._DP)\n              wh1o(iv,im,is,ibuff) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = iend_y, ny\n              cf(:,my,iz,iv,im) = (0._DP, 0._DP)\n            end do\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n                                                                     * real(iFLR, kind=DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP barrier\n\n!!%%% Without overlap %%%\n!      do iz = -nz, nz-1\n!        call vms2xy_pack_iz(iz, cf, send1e)\n!!$OMP barrier\n!!$OMP master\n!        call vms2xy_transpose_iz(send1e, recv1e)\n!!$OMP end master\n!!$OMP barrier\n!        call vms2xy_unpack_iz(recv1e, wh1e)\n!!$OMP barrier\n!        call collision_full_wrapper_iz(iz, wh1e, wh2e)\n!!$OMP barrier\n!        call xy2vms_pack_iz(wh2e, send2e)\n!!$OMP barrier\n!!$OMP master\n!        call xy2vms_transpose_iz(send2e, recv2e)\n!!$OMP end master\n!!$OMP barrier\n!        call xy2vms_unpack_iz(iz, recv2e, cf)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n!%%% With overlap %%%\n      do iz = -nz, nz-1+6\n\n        if (mod(iz+nz,2) == 0) then! even\n\n!$OMP master\n          if (-nz+1<=iz.and. iz<=nz-1+1) call vms2xy_transpose_iz(send1o, recv1o)\n          if (-nz+5<=iz.and. iz<=nz-1+5) call xy2vms_transpose_iz(send2o, recv2o)\n!$OMP end master\n          if (-nz  <=iz.and. iz<=nz-1  ) call vms2xy_pack_iz(iz, cf, send1e)\n          if (-nz+2<=iz.and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1e, wh1e)\n          if (-nz+3<=iz.and. iz<=nz-1+3) call collision_full_wrapper_iz(iz-3, wh1o, wh2o)\n          if (-nz+4<=iz.and. iz<=nz-1+4) call xy2vms_pack_iz(wh2e, send2e)\n          if (-nz+6<=iz.and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2e, cf)\n\n        else                       ! odd\n\n!$OMP master\n          if (-nz+1<=iz.and. iz<=nz-1+1) call vms2xy_transpose_iz(send1e, recv1e)\n          if (-nz+5<=iz.and. iz<=nz-1+5) call xy2vms_transpose_iz(send2e, recv2e)\n!$OMP end master\n          if (-nz  <=iz.and. iz<=nz-1  ) call vms2xy_pack_iz(iz, cf, send1o)\n          if (-nz+2<=iz.and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1o, wh1o)\n          if (-nz+3<=iz.and. iz<=nz-1+3) call collision_full_wrapper_iz(iz-3, wh1e, wh2e)\n          if (-nz+4<=iz.and. iz<=nz-1+4) call xy2vms_pack_iz(wh2o, send2o)\n          if (-nz+6<=iz.and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2o, cf)\n\n        end if\n!$OMP barrier\n\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( send1e )\n      deallocate( recv1e )\n      deallocate( send2e )\n      deallocate( recv2e )\n      deallocate( wh1e )\n      deallocate( wh2e )\n      deallocate( send1o )\n      deallocate( recv1o )\n      deallocate( send2o )\n      deallocate( recv2o )\n      deallocate( wh1o )\n      deallocate( wh2o )\n\n  END SUBROUTINE colliimp_calc_colli_full\n\n\n!--------------------------------------\n  SUBROUTINE collision_full_wrapper_iz( iz, wfin, wfout )\n!--------------------------------------\n!   Collsion operator calculation interface\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wfin\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wfout\n\n    complex(kind=DP), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: w1\n    complex(kind=DP), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: w2\n    integer :: ibuff, ivb\n\n!$OMP master\n                                      call clock_sta(1720)\n!$OMP end master\n      w1(:,:,:) = (0._DP, 0._DP)\n!$OMP do schedule(dynamic)\n      do ibuff = 0, nbuff-1\n          w1(1:2*global_nv,0:global_nm,0:ns-1) = wfin(:,:,:,ibuff)\n        !- Boundary condition -\n          do ivb = 1, nvb\n          !w1(1-ivb,:,:) = (0._DP, 0._DP)\n          !w1(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n          !w1(:,global_nm+ivb,:) = (0._DP, 0._DP)\n            w1(:,-ivb,:) = w1(:,ivb,:)\n          end do\n        !-\n          call collision_full(w1, w2, iz, ibuff)\n          wfout(:,:,:,ibuff) = w2(:,:,:)\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1720)\n!$OMP end master\n\n  END SUBROUTINE collision_full_wrapper_iz\n\n\nEND MODULE GKV_colliimp\n", "MODULE GKV_fft\n!-------------------------------------------------------------------------------\n!\n!    FFT module for E x B term calculation using SSL2\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n#ifdef __NEC__\n  include \"aslfftw3.f\"\n#else\n  include \"fftw3.f\"\n#endif\n\n  private\n\n  integer, parameter :: mthds = 8   ! Max OpenMP threads\n  integer(kind=DP), save      :: plan_x_forward(0:mthds-1), plan_x_backward(0:mthds-1)\n  integer(kind=DP), save      :: plan_y_forward(0:mthds-1), plan_y_backward(0:mthds-1)\n  integer(kind=DP), save      :: plan_xf_y2zm(0:mthds-1), plan_xf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: plan_xb_y2zm(0:mthds-1), plan_xb_y2x(0:mthds-1)\n  integer(kind=DP), save      :: plan_yf_y2zm(0:mthds-1), plan_yf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: plan_yb_y2zm(0:mthds-1), plan_yb_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_xf_y2zm(0:mthds-1), planr_xf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_xb_y2zm(0:mthds-1), planr_xb_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_yf_y2zm(0:mthds-1), planr_yf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_yb_y2zm(0:mthds-1), planr_yb_y2x(0:mthds-1)\n\n  public   fft_pre,  &\n           !fft_backward_Xfft, fft_backward_chXY, fft_backward_Yfft, &\n           !fft_forward_Yfft, fft_forward_chYX, fft_forward_Xfft,    &\n           plan_xf_y2zm, plan_xf_y2x, &\n           plan_xb_y2zm, plan_xb_y2x, &\n           plan_yf_y2zm, plan_yf_y2x, &\n           plan_yb_y2zm, plan_yb_y2x, &\n           planr_xf_y2zm, planr_xf_y2x, &\n           planr_xb_y2zm, planr_xb_y2x, &\n           planr_yf_y2zm, planr_yf_y2x, &\n           planr_yb_y2zm, planr_yb_y2x, &\n           plan_x_forward, plan_x_backward, &\n           plan_y_forward, plan_y_backward\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE fft_pre( )\n!--------------------------------------\n!  Initialization of FFT\n\n    complex(kind=DP) :: wk1_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk2_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk1_y_z(0:nyw)\n    real(kind=DP)    :: wk2_y_r(0:2*nyw-1)\n\n    integer :: nfft(1),mfft,lfft(1),lfftr(1),lfftc(1),iostr\n    integer :: nbuf\n    integer :: nthds,nplan,i,ierr\n!$  integer :: omp_get_max_threads\n\n     wk1_x_z(:) = (0._DP, 0._DP)\n     wk2_x_z(:) = (0._DP, 0._DP)\n     wk1_y_z(:) = (0._DP, 0._DP)\n     wk2_y_r(:) = 0._DP\n\n     nplan = 1\n#ifdef OMP_INSIDE_FFTW\n!$   nthds = omp_get_max_threads()\n!$   call dfftw_init_threads(ierr)\n!$   call dfftw_plan_with_nthreads(nthds)\n#else\n!$   nplan = omp_get_max_threads()\n#endif\n\n    do i=0, nplan-1\n     call dfftw_plan_dft_1d( plan_x_backward(i),     &\n                             (2*nxw),             &\n                             wk1_x_z,             &   ! complex in\n                             wk2_x_z,             &   ! complex out\n                             FFTW_BACKWARD,       &\n                             FFTW_MEASURE )\n\n     call dfftw_plan_dft_c2r_1d( plan_y_backward(i), &\n                                 (2*nyw),         &\n                                 wk1_y_z,         &   ! complex in\n                                 wk2_y_r,         &   ! real    out\n                                 FFTW_MEASURE )\n\n     call dfftw_plan_dft_r2c_1d( plan_y_forward(i),  &\n                                 (2*nyw),         &\n                                 wk2_y_r,         &   ! real    in\n                                 wk1_y_z,         &   ! complex out\n                                 FFTW_MEASURE )\n\n     call dfftw_plan_dft_1d( plan_x_forward(i),      &\n                             (2*nxw),             &\n                             wk2_x_z,             &   ! complex in\n                             wk1_x_z,             &   ! complex out\n                             FFTW_FORWARD,        &\n                             FFTW_MEASURE )\n    end do\n\n\n!tune2\n#ifdef USE_TERM_Y2ZM\n    nbuf = ((2*nz)*(nm+1)-1)/nprocw + 1\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(plan_xb_y2zm(i),1,nfft,mfft,wk1_x_z,lfft,1,2*nxw,wk2_x_z,lfft,1,2*nxw,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     call dfftw_plan_many_dft_c2r(plan_yb_y2zm(i),1,nfft,mfft,wk1_y_z,lfftc,1,nyw+1,wk2_y_r,lfftr,1,2*nyw,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     call dfftw_plan_many_dft_r2c(plan_yf_y2zm(i),1,nfft,mfft,wk2_y_r,lfftr,1,2*nyw,wk1_y_z,lfftc,1,nyw+1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(plan_xf_y2zm(i),1,nfft,mfft,wk2_x_z,lfft,1,2*nxw,wk1_x_z,lfft,1,2*nxw,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#else\n    nbuf = 2*nz*(nm+1)\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(plan_xb_y2x(i),1,nfft,mfft,wk1_x_z,lfft,1,2*nxw,wk2_x_z,lfft,1,2*nxw,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_c2r(plan_yb_y2x(i),1,nfft,mfft,wk1_y_z,lfftc,1,nyw+1,wk2_y_r,lfftr,1,2*nyw,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_r2c(plan_yf_y2x(i),1,nfft,mfft,wk2_y_r,lfftr,1,2*nyw,wk1_y_z,lfftc,1,nyw+1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(plan_xf_y2x(i),1,nfft,mfft,wk2_x_z,lfft,1,2*nxw,wk1_x_z,lfft,1,2*nxw,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#endif\n\n\n!tune2r\n#ifdef USE_TERM_Y2ZM\n    nbuf = ((2*nz)*(nm+1)-1)/nprocw + 1\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     iostr= (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(planr_xb_y2zm(i),1,nfft,mfft,wk1_x_z,lfft,iostr,1,wk2_x_z,lfft,iostr,1,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     iostr= 2*nxw*nbuf\n     call dfftw_plan_many_dft_c2r(planr_yb_y2zm(i),1,nfft,mfft,wk1_y_z,lfftc,iostr,1,wk2_y_r,lfftr,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     iostr= 2*nxw*nbuf\n     call dfftw_plan_many_dft_r2c(planr_yf_y2zm(i),1,nfft,mfft,wk2_y_r,lfftr,iostr,1,wk1_y_z,lfftc,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     iostr= (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(planr_xf_y2zm(i),1,nfft,mfft,wk2_x_z,lfft,iostr,1,wk1_x_z,lfft,iostr,1,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#else\n    nbuf = 2*nz*(nm+1)\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     iostr= (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(planr_xb_y2x(i),1,nfft,mfft,wk1_x_z,lfft,iostr,1,wk2_x_z,lfft,iostr,1,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     iostr= (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_c2r(planr_yb_y2x(i),1,nfft,mfft,wk1_y_z,lfftc,iostr,1,wk2_y_r,lfftr,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     iostr= (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_r2c(planr_yf_y2x(i),1,nfft,mfft,wk2_y_r,lfftr,iostr,1,wk1_y_z,lfftc,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     iostr= (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(planr_xf_y2x(i),1,nfft,mfft,wk2_x_z,lfft,iostr,1,wk1_x_z,lfft,iostr,1,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#endif\n\n\n  END SUBROUTINE fft_pre\n\n\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Xfft ( exbdf, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_out ! for outplace\n!    integer :: ist_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1421)\n!                                         ! call fapp_start(\"nlterm_backward_Xfft\",1421,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_backward,  &\n!                          exbdf(0,my,i),    &     ! complex in\n!                        !  exbdf(0,my,i)        )  ! complex out\n!                          wk_x_out             )  ! complex out ! for outplace\n!\n!        ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            do mx = ist_xw, iend_xw\n!             !  send_buff(my,mx,i,irank) = exbdf(mx+ist_xw_g_rank,my,i)\n!               send_buff(my,mx,i,irank) = wk_x_out(mx+ist_xw_g_rank) ! for outplace\n!            enddo\n!          enddo\n!\n!        enddo\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_backward_Xfft\",1421,1)\n!                                           call clock_end(1421)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Xfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_chXY ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         Y divide -> X divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1422)\n!                                         ! call fapp_start(\"nlterm_backward_shiftXY\",1422,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                         ! call fapp_stop(\"nlterm_backward_shiftXY\",1422,1)\n!                                           call clock_end(1422)\n!    \n!\n!  END SUBROUTINE fft_backward_chXY\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Yfft ( recv_buff, exbdf_xw, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_in(0:nyw) ! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1423)\n!                                         ! call fapp_start(\"nlterm_backward_Yfft\",1423,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!        ! --- restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!            !  exbdf_xw(my,mx,i) = recv_buff(my-ist_y_g_rank,mx,i,irank)\n!              wk_y_in(my) = recv_buff(my-ist_y_g_rank,mx,i,irank) ! for outplace\n!            end do\n!          end do\n!        ! --- set filler ---\n!          do my = global_ny+1, nyw\n!          !  exbdf_xw(my,mx,i) = ( 0._DP, 0._DP )\n!            wk_y_in(my) = ( 0._DP, 0._DP ) ! for outplace\n!          end do\n!\n!          call dfftw_execute_dft_c2r( &\n!                          plan_y_backward,   &\n!                        !  exbdf_xw(0,mx,i),  &    ! complex in\n!                          wk_y_in,            &    ! complex in ! for outplace\n!                          exbdf_xw(0,mx,i)     )  ! real    out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_backward_Yfft\",1423,1)\n!                                           call clock_end(1423)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Yfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Yfft ( exbdf_xw, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_out(0:nyw) ! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1441)\n!                                         ! call fapp_start(\"nlterm_forward_Yfft\",1441,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!          call dfftw_execute_dft_r2c( &\n!                          plan_y_forward,    &\n!                          exbdf_xw(0,mx,i),  &    ! real in\n!                        !  exbdf_xw(0,mx,i)     )  ! complex out\n!                          wk_y_out             )  ! complex out ! for outplace\n!\n!        ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!            !  send_buff(my-ist_y_g_rank,mx,i,irank) = exbdf_xw(my,mx,i)\n!              send_buff(my-ist_y_g_rank,mx,i,irank) = wk_y_out(my) ! for outplace\n!            end do\n!          end do\n!\n!      end do\n!    end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_forward_Yfft\",1441,1)\n!                                           call clock_end(1441)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Yfft\n!\n!\n!!--------------------------------------\n!  ", "SUBROUTINE fft_forward_chYX ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         X divide -> Y divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1442)\n!                                        ! call fapp_start(\"nlterm_forward_shiftYX\",1442,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                        ! call fapp_stop(\"nlterm_forward_shiftYX\",1442,1)\n!                                           call clock_end(1442)\n!\n!\n!  END SUBROUTINE fft_forward_chYX\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Xfft ( recv_buff, exbdf, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_in! for outplace\n!    integer :: ist_xw_g_rank, iend_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1443)\n!                                        ! call fapp_start(\"nlterm_forward_Xfft\",1443,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!       ! ---  restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            iend_xw_g_rank = min ( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!            do mx = ist_xw_g_rank, iend_xw_g_rank\n!           !  exbdf(mx,my,i) = recv_buff(my,mx-ist_xw_g_rank,i,irank)\n!              wk_x_in(mx) = recv_buff(my,mx-ist_xw_g_rank,i,irank)! for outplace\n!            enddo\n!          enddo\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_forward,   &\n!                       !  exbdf(0,my,i),    &   ! complex in\n!                          wk_x_in,          &   ! complex in! for outplace\n!                          exbdf(0,my,i)       ) ! complex out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_forward_Xfft\",1443,1)\n!                                           call clock_end(1443)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Xfft\n\n\nEND MODULE GKV_fft\n", "MODULE ring_header\n\n  implicit none\n\n  integer, parameter :: DP = selected_real_kind(14)\n!\n!  integer :: olog = 10\n!\n!  real(kind=DP) :: ring_a = 0.5_DP\n\n  real(kind=DP) :: ring_a\n\n  public  ring_a\n\n\nEND MODULE ring_header\n\n\nMODULE ring_func\n\n  use ring_header\n  use GKV_math,   only: math_eli1, math_eli2\n\n  implicit none\n\n  private\n\n  public func_k, func_g, func_psi, func_x, func_eli1, func_eli2\n\n\nCONTAINS\n\n\n  FUNCTION func_k( r, z )\n\n    real(kind=DP)             :: func_k\n    real(kind=DP), intent(in) :: r, z\n\n      func_k = sqrt( ( 4._DP * ring_a * abs(r) ) / ( ( ring_a + r )**2 + z**2 ) )\n\n  END FUNCTION func_k\n\n\n  FUNCTION func_g( r, z )\n\n    real(kind=DP)             :: func_g\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: eli1, eli2, kk\n\n      kk = func_k( r, z )**2\n\n      call math_eli1( kk, eli1 ) \n!!!        if( icon /= 0 ) print *, \"# icon in celi1 = \", icon\n      call math_eli2( kk, eli2 ) \n!!!        if( icon /= 0 ) print *, \"# icon in celi2 = \", icon\n\n      func_g = ( ( 1._DP - 0.5_DP * kk ) * eli1 - eli2 ) &\n             * sqrt( ( ring_a + r )**2 + z**2 ) * 0.5_DP\n\n  END FUNCTION func_g\n\n\n  FUNCTION func_psi( r, z )\n\n    real(kind=DP)             :: func_psi\n    real(kind=DP), intent(in) :: r, z\n\n      func_psi = func_g( r, z ) / func_g( 1._DP, 0._DP )\n\n  END FUNCTION func_psi\n\n\n  FUNCTION func_x( r, z, psi0 )\n\n    real(kind=DP)             :: func_x\n    real(kind=DP), intent(in) :: r, z, psi0\n\n      func_x =  (func_psi( 1._DP, 0._DP ) - func_psi( r, z ) ) / psi0\n\n  END FUNCTION func_x\n\n\n  FUNCTION func_eli1( r, z )\n\n    real(kind=DP)             :: func_eli1\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: eli1, kk\n\n      kk = func_k( r, z )**2\n\n      call math_eli1( kk, eli1 ) \n\n      func_eli1 = eli1\n\n  END FUNCTION func_eli1\n\n\n  FUNCTION func_eli2( r, z )\n\n    real(kind=DP)             :: func_eli2\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: eli2, kk\n\n      kk = func_k( r, z )**2\n\n      call math_eli2( kk, eli2 ) \n\n      func_eli2 = eli2\n\n  END FUNCTION func_eli2\n\n\nEND MODULE ring_func\n\n\nMODULE ring_diff\n\n  use ring_header\n\n  implicit none\n\n  private\n\n  public diff_r, diff_z, diff_rho\n\n\nCONTAINS\n\n\n  FUNCTION diff_r( fun, rin, zin )\n\n    real(kind=DP), external :: fun\n    real(kind=DP), intent(in)  :: rin, zin\n\n    real(kind=DP) :: diff_r\n\n    real(kind=DP) :: dr1, dr2\n\n\n      dr1   = abs( rin ) * 1.d-4\n      dr2   = dr1 * 2._DP\n\n      if( rin == 0._DP ) then\n        diff_r = 0._DP\n\n      else\n        diff_r = ( - fun(rin+dr2,zin) + 8._DP*fun(rin+dr1,zin)   &\n                   - 8._DP*fun(rin-dr1,zin) + fun(rin-dr2,zin) ) &\n               / ( 12._DP * dr1 )\n\n      end if\n\n\n  END FUNCTION diff_r\n\n\n  FUNCTION diff_z( fun, rin, zin )\n\n    real(kind=DP), external :: fun\n    real(kind=DP), intent(in)  :: rin, zin\n\n    real(kind=DP) :: diff_z\n\n    real(kind=DP) :: dz1, dz2\n\n\n      dz1   = abs( zin ) * 1.d-4\n      dz2   = dz1 * 2._DP\n\n!      if( zin == 0._DP ) then\n       if( abs(zin) < 1.d-12) then\n        diff_z = 0._DP\n\n      else\n        diff_z = ( - fun(rin,zin+dz2) + 8._DP*fun(rin,zin+dz1)   &\n                   - 8._DP*fun(rin,zin-dz1) + fun(rin,zin-dz2) ) &\n               / ( 12._DP * dz1 )\n\n      end if\n\n\n  END FUNCTION diff_z\n\n\n  FUNCTION diff_rho( fun, rin, zin )\n\n    real(kind=DP), external :: fun\n    real(kind=DP), intent(in)  :: rin, zin\n\n    real(kind=DP) :: diff_rho\n\n!    real(kind=DP) :: rho, tht\n    real(kind=DP) :: tht\n\n\n!      rho = sqrt( ( rin - ring_a )**2 + zin**2 )\n      tht = atan2( zin, rin - ring_a ) \n\n      diff_rho = diff_r( fun, rin, zin ) * cos( tht ) &\n               + diff_z( fun, rin, zin ) * sin( tht )\n\n\n  END FUNCTION diff_rho\n\n\nEND MODULE ring_diff\n\n\nMODULE ring_bfld\n\n  use ring_header\n  use ring_func\n  use ring_diff\n\n  implicit none\n\n  private\n\n  public bfld_br, bfld_bz, bfld_magb, bfld_gradbr, bfld_gradbz\n\n\nCONTAINS\n\n\n  FUNCTION bfld_br( r, z )\n\n    real(kind=DP)             :: bfld_br\n    real(kind=DP), intent(in) :: r, z\n\n!      bfld_br = diff_z( func_psi, r, z) / r\n\n      bfld_br = diff_z( func_psi, r, z ) / r\n\n  END FUNCTION bfld_br\n\n\n  FUNCTION bfld_bz( r, z )\n\n    real(kind=DP)             :: bfld_bz\n    real(kind=DP), intent(in) :: r, z\n\n!      bfld_bz = diff_r( func_psi, r, z ) / r\n\n      bfld_bz = - diff_r( func_psi, r, z ) / r\n\n  END FUNCTION bfld_bz\n\n\n  FUNCTION bfld_magb( r, z )\n\n    real(kind=DP)             :: bfld_magb\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: br, bz\n\n      br = bfld_br( r, z )\n      bz = bfld_bz( r, z )\n\n      bfld_magb = sqrt( br**2 + bz**2 )\n\n!!!      print *, br, bz\n\n  END FUNCTION bfld_magb\n\n\n  FUNCTION bfld_gradbr( r, z )\n\n    real(kind=DP)             :: bfld_gradbr\n    real(kind=DP), intent(in) :: r, z\n\n      bfld_gradbr = diff_r( bfld_magb,  r, z )\n\n  END FUNCTION bfld_gradbr\n\n\n  FUNCTION bfld_gradbz( r, z )\n\n    real(kind=DP)             :: bfld_gradbz\n    real(kind=DP), intent(in) :: r, z\n\n      bfld_gradbz = diff_z( bfld_magb,  r, z )\n\n  END FUNCTION bfld_gradbz\n\n\nEND MODULE ring_bfld\n\n\nMODULE GKV_ring\n!-----------------------------------------------------------------\n!\n!   Flux tube coordinates in the ring dipole geometry\n!\n!   Definition of the flux tube coordinates\n!   in the ring dipole geometry\n!\n!     x = (Psi_0 - Psi) / (R_0*B'_0)\n!     y = R_0 * phi\n!     z = Theta (= arctan(Z/(R-a)) \n!     where (R, phi, Z ) are the cylindorical coordinates\n!\n!     B'_0 = 1/R * (dPsi/dr - dPsi/dz) | r=1,z=0\n!     B_0 = B / B'_0                   | r=1,z=0\n!   We also use the normalization of Psi_0*(gradx crs grady) = B_0*R_0^2 \n!     with R_0 = 1 and B_0 = 1 as the units\n!\n!-----------------------------------------------------------------\n\n  use ring_header\n!  use gkv_header\n  use ring_func\n  use ring_diff\n  use ring_bfld\n\n  implicit none\n\n  private\n\n  public ring_coordinates\n\n\nCONTAINS\n\n  SUBROUTINE ring_coordinates( a, tht, bb, ub_dot_grdb, ub_crs_grdb, &\n                               gxx, gxy, gxz, gyy, gyz, gzz, rootg, dbdx, dbdz)\n\n  real(kind=DP), intent(in)  :: a, tht\n  real(kind=DP), intent(out) :: bb, ub_dot_grdb, ub_crs_grdb\n  real(kind=DP), intent(out) :: gxx, gxy, gxz, gyy, gyz, gzz, rootg\n!>>\n  real(kind=DP), intent(out) :: dbdx, dbdz\n  real(kind=DP) :: R0, psi0\n  real(kind=DP) :: eps_x, rho_p, rho_m, r_p, r_m, z_p, z_m\n!<<\n  real(kind=DP) :: r, z, rho, rho1, hh, dh\n\n  real(kind=DP) :: b0\n  real(kind=DP) :: gbr, gbz, ubr, ubz!, psi_n, b_rootg_i, ub_dot_grdh\n\n!  real(kind=DP) :: rootg2\n\n  real(kind=DP) :: eps, eps0 = 0.00000001_DP\n  integer       :: ic, nc = 20\n\n\n    ring_a = a\n\n    rho  = 1._DP - ring_a\n\n      hh  = 0._DP\n      dh  = acos(-1._DP) * 0.01_DP\n\n\n\n! compute for hh\n!!!      do while ( hh < abs(tht)-dh*0.5 )\n      do while ( hh < abs(tht)-dh )\n        hh = hh + dh\n\n        eps = 1._DP\n        ic  = 0\n\n        r = rho * cos(hh) + ring_a\n        z = rho * sin(hh)\n\n      do while ( eps > eps0 .AND.  ic < nc )\n\n        ic = ic + 1\n\n        rho1 = rho - ( func_psi( r, z ) - 1._DP ) / diff_rho( func_psi, r, z )\n        eps  = abs( rho1 - rho ) / abs( rho )\n        rho  = rho1\n\n        r = rho * cos(hh) + ring_a\n        z = rho * sin(hh)\n        if( abs(z) < 1.d-14 ) z = 0._DP\n\n      end do\n!!!           print *, \"# ic, tht, rho1, psi = \", ic, tht, rho, func_psi( r, z )\n\n      end do\n\n! compute for tht\n        eps = 1._DP\n        ic  = 0\n\n        r = rho * cos(tht) + ring_a\n        z = rho * sin(tht)\n\n      do while ( eps > eps0 .AND.  ic < nc )\n\n        ic = ic + 1\n\n        rho1 = rho - ( func_psi( r, z ) - 1._DP ) / diff_rho( func_psi, r, z )\n        eps  = abs( rho1 - rho ) / abs( rho )\n        rho  = rho1\n\n        r = rho * cos(tht) + ring_a\n        z = rho * sin(tht)\n        if( abs(z) < 1.d-14 ) z = 0._DP\n\n      end do\n\n        if( ic == nc ) then\n           print *, \"# ic, tht, rho1, psi = \", ic, tht, rho, func_psi( r, z )\n        end if\n\n!>>\n        R0 = 1._DP\n        eps_x = 0.0000001_DP\n        rho_p = rho + eps_x\n        r_p = rho_p * cos(tht) + ring_a\n        z_p = rho_p * sin(tht)\n        rho_m = rho - eps_x\n        r_m = rho_m * cos(tht) + ring_a\n        z_m = rho_m * sin(tht)\n!<<\n\n        b0 = bfld_magb( 1._DP, 0._DP )\n\n        bb  = bfld_magb  ( r, z )/b0\n\n!>>\n        psi0 = b0*R0**2\n        dbdx = ( bfld_magb( r_p, z_p ) - bfld_magb( r_m, z_m ) )/b0/( func_x(r_p, z_p, psi0) - func_x(r_m, z_m, psi0) )\n!<<\n\n        ubr = bfld_br( r, z )/b0 / bb\n        ubz = bfld_bz( r, z )/b0 / bb\n\n        gbr = bfld_gradbr( r, z )/b0\n        gbz = bfld_gradbz( r, z )/b0\n\n        ub_dot_grdb = ubr * gbr + ubz * gbz\n        ub_crs_grdb = ubz * gbr - ubr * gbz\n\n!        ub_dot_grdh = - ubr * sin( tht ) + ubz * cos( tht )\n\n!        psi_n = func_psi( r, z ) / func_psi( 1._DP, 0._DP )\n\n        gxx   = ( r * bb )**2\n        gxy   = 0._DP\n        gxz   = - r * bb * ( ubz*sin(tht) + ubr*cos(tht) ) / rho\n        gyy   = 1._DP / r**2\n        gyz   = 0._DP\n        gzz   = 1._DP / rho**2\n        rootg = 1._DP / sqrt( gyy*( gxx*gzz - gxz**2 ) )\n\n!>>\n        dbdz = ub_dot_grdb * bb * rootg\n!<<\n\n!        b_rootg_i = 1._DP / ( bb * rootg )\n\n!        rootg2= r * rho * b0 / ( diff_r( func_psi, r, z )*cos(tht)   &\n!                                 + diff_z( func_psi, r, z )*sin(tht) )\n!        rootg2= 1._DP / ( ubz * bb * cos(tht)   &\n!                        - ubr * bb * sin(tht) )\n\n!! debug\n!        write(unit=6, fmt=\"(1p, 32e15.7)\" ) tht, rho, r, z, func_psi(r,z), &\n!              bb, ubr, ubz, gbr, gbz, ub_dot_grdb, ub_crs_grdb, ub_dot_grdh,  &\n!              psi_n, gxx, gxy, gxz, gyy, gyz, gzz, rootg, b_rootg_i, rootg2\n!! debug\n\n\n\n  END SUBROUTINE ring_coordinates\n\n\nEND MODULE GKV_ring\n", "MODULE GKV_advnc\n!-------------------------------------------------------------------------------\n!\n!    Calculate df/dt and time advance by Runge-Kutta-Gill method\n!\n!    Update history of gkvp_advnc.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Time-dependent metrics for rotating flux-tube model is implemented.\n!          See lines at \"!%%% For shearflow rotating flux tube model %%%\".\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Unitialized access for padding iend_y<my is removed.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fld,   only: fld_esfield, fld_emfield_hh, fld_hh2ff\n  use GKV_exb,   only: exb_NL_term\n  use GKV_colli, only: colli_LB!, colli_full\n  use GKV_colliimp, only: colliimp_calc_colli_full, colliimp_set_param\n  use GKV_bndry, only: bndry_bound_e,  &\n                       bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout\n  use GKV_clock, only: clock_sta, clock_end\n  use GKV_zfilter, only: zfilter\n  use GKV_tips,  only: tips_reality\n  use GKV_geom, only: geom_increment_time\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_zv = 1, nchunk_yzv = 1, nchunk_yz = 1\n\n  public   advnc_rkgsteps_rev, caldlt_rev\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n!--------------------------------------\n!     time integration of GK equation using RKG method\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    complex(kind=DP), save,  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: qh\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dh, cf, ef\n    integer :: mx, my, iz, iv, im, istep\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  qh(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zv = ((2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yzv = ((iend_y-ist_y+1)*(2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yz = ((iend_y-ist_y+1)*(2*nz)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      do istep = 1, 4\n\n       !%%% For shearflow rotating flux tube model %%%\n        if (gamma_e /= 0._DP .and. trim(flag_shearflow) == \"rotating\") then\n          if (istep == 2 .or. istep == 4) then\n            call geom_increment_time(0.5_DP * dt)\n            if (trim(col_type) == \"full\" .or. trim(col_type) == \"lorentz\" .or. trim(time_advnc) == \"imp_colli\") then\n              call colliimp_set_param\n            end if\n          end if\n        end if\n       !%%%\n\n        call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n                                           call clock_sta(11)\n                                         ! call fapp_start(\"rkg\",11,1)\n        call rkg( hh, dh, qh, istep )\n                                         ! call fapp_stop(\"rkg\",11,1)\n                                           call clock_end(11)\n\n        call tips_reality ( hh )\n\n                                           call clock_sta(12)\n                                         ! call fapp_start(\"esfield\",12,1)\n        if ( beta > 0._DP ) then\n          call fld_emfield_hh( hh, Al )\n        end if\n        call fld_hh2ff( hh, Al, ff )\n        call fld_esfield( ff, phi )\n                                         ! call fapp_stop(\"esfield\",12,1)\n                                           call clock_end(12)\n      end do\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n\n  END SUBROUTINE advnc_rkgsteps_rev\n\n\n!--------------------------------------\n  SUBROUTINE rkg( hh, dh, qh, istep )\n!--------------------------------------\n!     Runge-Kutta-Gill\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh, qh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n    integer, intent(in) :: istep\n\n    real(kind=DP) :: c1, c2, cq, c0\n    integer :: mx, my, iz, iv, im\n\n\n      if      ( istep == 1 ) then\n        c1   =  0.5_DP\n        c2   = -1._DP\n        cq   = -2._DP\n        c0   =  1._DP\n      else if ( istep == 2 ) then\n        c1   =  1._DP - sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 3 ) then\n        c1   =  1._DP + sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 4 ) then\n        c1   =  1._DP / 6._DP\n        c2   = -1._DP / 3._DP\n        cq   =  0._DP\n        c0   =  0._DP\n      end if\n\n!$OMP parallel do collapse(3)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                hh(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im)           &\n                                   + c1 * dt * dh(mx,my,iz,iv,im) &\n                                   + c2 * qh(mx,my,iz,iv,im)\n                qh(mx,my,iz,iv,im) = cq * qh(mx,my,iz,iv,im) &\n                                   + c0 * dt * dh(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n\n  END SUBROUTINE rkg\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: dh, cf, ef\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi\n    integer :: mx, my, iz, iv, im\n\n      allocate( psi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n\n!$OMP parallel default(none) &\n!$OMP shared(psi,chi,phi,Al,j0,ist_y,iend_y) &\n!$OMP private(mx,my,iz,im)\n!$OMP do collapse(2)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = iend_y, ny\n            psi(:,my,iz,im) = (0._DP, 0._DP)\n            chi(:,my,iz,im) = (0._DP, 0._DP)\n          end do\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n              chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do\n!$OMP end parallel\n\n                                           call clock_sta(13)\n                                         ! call fapp_start(\"literm\",13,1)\n     !%%% Linear collisionless term %%%\n      call caldlt_linear( ff, psi, chi, dh )\n\n     !%%% Collision term %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n\n        if ( trim(col_type) == \"LB\" ) then\n          call colli_LB( ff, phi, cf )\n        else if ( trim(col_type) == \"full\" .or. &\n                  trim(col_type) == \"lorentz\" ) then\n          !call colli_full( ff, phi, cf )\n          call colliimp_calc_colli_full( ff, phi, cf )\n        else \n          write(olog,*) \"## Illegal choice for col_type!! ---> stop\"\n          call flush(olog)\n          call MPI_Finalize(ierr_mpi)\n          stop\n        end if\n\n      else if ( trim(colliflag) == \"collisionless\" ) then\n\n!!$OMP parallel workshare\n!        cf(:,:,:,:,:) = (0._DP, 0._DP)\n!!$OMP end parallel workshare\n\n      else \n\n        write(olog,*) \"## Illegal choice for colliflag:\", colliflag\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n                                         ! call fapp_stop(\"literm\",13,1)\n                                           call clock_end(13)\n\n                                           call clock_sta(14)\n                                         ! call fapp_start(\"nlterm\",14,1)\n     !%%% Nonlinear term %%%\n      call exb_NL_term( hh, psi, chi, ef )\n                                         ! call fapp_stop(\"nlterm\",14,1)\n                                           call clock_end(14)\n\n     !%%% dh/dt = (Linear collisionless) + (Collision) - (Nonlinear) %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              !do my = 0, ny\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     + cf(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      else if ( trim(colliflag) == \"collisionless\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              !do my = 0, ny\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      end if\n                                           call clock_sta(15)\n                                         ! call fapp_start(\"zfilter\",15,1)\n      if ( trim(z_filt) == \"on\" ) then\n        call zfilter( dh )\n      end if                                \n                                         ! call fapp_stop(\"zfilter\",15,1)\n                                           call clock_end(15)\n\n      deallocate( psi )\n      deallocate( chi )\n\n  END SUBROUTINE caldlt_rev\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_linear( ff, psi, chi, dh )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: &\n                         zb1be, zb1te, zb2be, zb2te, zb1bo, zb1to, zb2bo, zb2to\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    integer :: im\n\n\n      allocate( zb1be(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb1te(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2be(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2te(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb1bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb1to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( vb1e(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n      allocate( vb1o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n      allocate( vb2o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n\n      call bndry_bound_e( psi )\n\n      call literm_k_rev( ff, psi, chi, dh )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,psi,chi,dh) &\n!$OMP shared(zb1be,zb1te,zb2be,zb2te,zb1bo,zb1to,zb2bo,zb2to,vb1e,vb2e,vb1o,vb2o) &\n!$OMP private(im)\n\n!!%%% Without overlap %%%\n!      do im = 0, nm\n!        call bndry_zv_buffin( ff(:,:,:,:,im), zb1be, zb1te, vb1e )\n!!$OMP barrier\n!!$OMP master\n!        call bndry_zv_sendrecv( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n!!$OMP end master\n!!$OMP barrier\n!        call bndry_zv_buffout( zb2be, zb2te, vb2e, ff(:,:,:,:,im) )\n!!$OMP barrier\n!        call literm_zv( ff(:,:,:,:,im), psi(:,:,:,im), im, dh(:,:,:,:,im) )\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!!%%% With overlap %%%\n      do im = 0, nm+3\n        if (mod(im,2) == 0) then ! even\n!$OMP master\n          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1bo, zb1to, zb2bo, zb2to, vb1o, vb2o )\n!$OMP end master\n          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1be, zb1te, vb1e )\n          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2be, zb2te, vb2e, ff(:,:,:,:,im-2) )\n          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n        else                     ! odd\n!$OMP master\n          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n!$OMP end master\n          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1bo, zb1to, vb1o )\n          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2bo, zb2to, vb2o, ff(:,:,:,:,im-2) )\n          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n        end if\n!$OMP barrier\n      end do\n!!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( zb1be )\n      deallocate( zb1te )\n      deallocate( zb2be )\n      deallocate( zb2te )\n      deallocate( zb1bo )\n      deallocate( zb1to )\n      deallocate( zb2bo )\n      deallocate( zb2to )\n      deallocate( vb1e )\n      deallocate( vb2e )\n      deallocate( vb1o )\n      deallocate( vb2o )\n\n\n  END SUBROUTINE caldlt_linear\n\n\n!--------------------------------------\n  SUBROUTINE literm_k_rev ( ff, psi, chi, lf )\n!--------------------------------------\n!     z-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: lf\n\n    real(kind=DP) :: cs1, cs2, kvd, kvs\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1320)\n                                         ! call fapp_start(\"literm_perp\",1320,1)\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      cs2    = sqrt( tau(ranks) / Anum(ranks) )\n\n!$OMP parallel do collapse(3) private(kvd,kvs)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im)\n                kvs = ky(my) * vsy(iz,iv,im)\n                lf(mx,my,iz,iv,im) =                  &\n                   - ui * kvd * ff(mx,my,iz,iv,im)    &\n                   - cs1 * fmx(iz,iv,im) * (          &\n                       + ui * kvd * psi(mx,my,iz,im)  &\n                       - ui * kvs                     &\n                            * ( psi(mx,my,iz,im) - cs2 * vl(iv) * chi(mx,my,iz,im) ) )\n              end do\n            end do\n          end do\n        end do\n      end do\n                                         ! call fapp_stop(\"literm_perp\",1320,1)\n                                           call clock_end(1320)\n\n\n  END SUBROUTINE literm_k_rev\n\n\n!--------------------------------------\n  ", "SUBROUTINE literm_zv ( ff, psi, im, lf )\n!--------------------------------------\n!     (z,v)-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb)            :: psi\n    integer, intent(in) :: im\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)             :: lf\n\n    real(kind=DP), dimension(-nz:nz-1) :: cefz, cefz2\n    real(kind=DP) :: cefv, cs1, rotating_cf4, rotating_up5\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1330)\n                                        ! call fapp_start(\"literm_para\",1330,1)\n!$OMP end master\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      do iz = -nz, nz-1\n        cefz(iz)   = 1._DP / ( 12._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n        cefz2(iz)  = 1._DP / ( 60._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n      end do\n      cefv   = 1._DP / ( 12._DP * dv ) * sqrt( tau(ranks) / Anum(ranks) )\n    !%%% For shearflow rotating flux tube model %%%\n      if (gamma_e /= 0._DP.and. trim(flag_shearflow) == \"rotating\") then\n        rotating_cf4 = - gamma_e / (s_hat_g * 12._DP * (zz(0)-zz(-1)))\n        rotating_up5 = - gamma_e / (s_hat_g * 60._DP * (zz(0)-zz(-1)))\n      else\n        rotating_cf4 = 0._DP\n        rotating_up5 = 0._DP\n      end if\n    !%%%\n\n      if (trim(z_calc) == \"cf4\") then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_zv)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n             !%%% For shearflow rotating flux tube model %%%\n             !!!- vl(iv) * cefz(iz) * (              &\n                 - (vl(iv) * cefz(iz) + rotating_cf4) * ( &\n             !%%%\n                     -         ff(mx,my,iz+2,iv)      &\n                     + 8._DP * ff(mx,my,iz+1,iv)      &\n                     - 8._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )    &\n                 + mir(iz,im) * cefv * (              &\n                     -         ff(mx,my,iz,iv+2)      &\n                     + 8._DP * ff(mx,my,iz,iv+1)      &\n                     - 8._DP * ff(mx,my,iz,iv-1)      &\n                     +         ff(mx,my,iz,iv-2) )    &\n                 - cs1 * fmx(iz,iv,im) * (            &\n                       vl(iv) * cefz(iz) * (          &\n                         -         psi(mx,my,iz+2)    &\n                         + 8._DP * psi(mx,my,iz+1)    &\n                         - 8._DP * psi(mx,my,iz-1)    &\n                         +         psi(mx,my,iz-2) ) )&\n                 - art_diff * (                       &\n                     +         ff(mx,my,iz+2,iv)      &\n                     - 4._DP * ff(mx,my,iz+1,iv)      &\n                     + 6._DP * ff(mx,my,iz ,iv)      &\n                     - 4._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      else if (trim(z_calc) == \"up5\") then\n\n        do iv = 1, 2*nv\n          if ( vl(iv) > 0._DP ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                   !%%% For shearflow rotating flux tube model %%%\n                     - rotating_cf4 * (                   &\n                         -         ff(mx,my,iz+2,iv)      &\n                         + 8._DP * ff(mx,my,iz+1,iv)      &\n                         - 8._DP * ff(mx,my,iz-1,iv)      &\n                         +         ff(mx,my,iz-2,iv) )    &\n                   !%%%\n                     - vl(iv) * cefz2(iz) * (             &\n                         - 3._DP * ff(mx,my,iz+2,iv)      &\n                         +30._DP * ff(mx,my,iz+1,iv)      &\n                         +20._DP * ff(mx,my,iz ,iv)      &\n                         -60._DP * ff(mx,my,iz-1,iv)      &\n                         +15._DP * ff(mx,my,iz-2,iv)      &\n                         - 2._DP * ff(mx,my,iz-3,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          else\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                   !%%% For shearflow rotating flux tube model %%%\n                     - rotating_cf4 * (                   &\n                         -         ff(mx,my,iz+2,iv)      &\n                         + 8._DP * ff(mx,my,iz+1,iv)      &\n                         - 8._DP * ff(mx,my,iz-1,iv)      &\n                         +         ff(mx,my,iz-2,iv) )    &\n                   !%%%\n                     - vl(iv) * cefz2(iz) * (             &\n                         + 2._DP * ff(mx,my,iz+3,iv)      &\n                         -15._DP * ff(mx,my,iz+2,iv)      &\n                         +60._DP * ff(mx,my,iz+1,iv)      &\n                         -20._DP * ff(mx,my,iz ,iv)      &\n                         -30._DP * ff(mx,my,iz-1,iv)      &\n                         + 3._DP * ff(mx,my,iz-2,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          end if\n        end do\n\n      else\n\n        write(olog,*) \"## Illegal choice for z_calc!! ---> stop\"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_para\",1330,1)\n                                           call clock_end(1330)\n!$OMP end master\n\n\n  END SUBROUTINE literm_zv\n\n\nEND MODULE GKV_advnc\n", "MODULE GKV_vmecbzx\n!-------------------------------------------------------------------------------\n!\n!    Calculate the magnetic field components and metric coefficients\n!      from the VMEC equilibrium by using BZX code. \n!\n!    Update history of gkvp_vmecbxz.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Input of vmecbzx_boozxcoef is modified from local iz for each rankz\n!          to global index giz.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public :: vmecbzx_boozx_read, vmecbzx_boozx_coeff\n\n  real(kind=DP), dimension(:),         allocatable   :: ss_bz, q_bz, shat_bz, eps_bz\n  real(kind=DP), dimension(:),         allocatable   :: theta_bz, zeta_bz\n  real(kind=DP), dimension(:,:,:,:,:), allocatable   :: ggup_bz\n  real(kind=DP), dimension(:,:,:),     allocatable   :: B_bz, rootg_bz, rootg_bz0\n  real(kind=DP), dimension(:,:,:),     allocatable   :: dBds_bz, dBdt_bz, dBdz_bz\n  real(kind=DP), dimension(:,:),       allocatable   :: bbozc_bz, bbozs_bz\n  real(kind=DP), dimension(:,:,:),     allocatable   :: rr_bz, zz_bz, ph_bz\n  integer,       dimension(:),         allocatable   :: ixn_bz, ixm_bz\n\n  integer        :: nss_bz, ntheta_bz, nzeta_bz\n  integer        :: nfp_bz, mnboz_bz, mboz_bz, nboz_bz, asym_flg\n  real(kind=DP)  :: Rax_bz, Bax_bz, aa_bz, volume_bz, alpha_fix\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE vmecbzx_boozx_read( nss, ntheta, nzeta )\n!--------------------------------------\n\n    implicit none\n\n    integer, intent(in)        :: nss, ntheta, nzeta\n    integer                    :: ibzx\n    character(512) :: f_bozx\n!   character(512) :: env_string      !fj\n\n    namelist /bozxf/ f_bozx\n\n    allocate(q_bz(1:nss),shat_bz(1:nss),eps_bz(1:nss))\n    allocate(ss_bz(1:nss),theta_bz(0:ntheta),zeta_bz(0:nzeta))\n    allocate(ggup_bz(1:nss,0:ntheta,0:nzeta,1:3,1:3))\n    allocate(B_bz(1:nss,0:ntheta,0:nzeta),rootg_bz(1:nss,0:ntheta,0:nzeta),rootg_bz0(1:nss,0:ntheta,0:nzeta))\n    allocate(dBds_bz(1:nss,0:ntheta,0:nzeta),dBdt_bz(1:nss,0:ntheta,0:nzeta),dBdz_bz(1:nss,0:ntheta,0:nzeta))\n\n      read(inml,nml=bozxf)\n      ibzx = 5000\n\n!      call getenv ( 'fu09',env_string ) !fj\n!      open(ibzx, file=env_string, status=\"old\", action=\"read\", form=\"unformatted\", CONVERT='LITTLE_ENDIAN' )         !fj\n\n\n      open( ibzx, file=trim(f_bozx)//\"metric_boozer.bin.dat\", status=\"old\", &\n                  action=\"read\", form=\"unformatted\", CONVERT='LITTLE_ENDIAN' )\n      write(olog,*) \"# mag.coord.(Booz_xform) input file : \"\n      write(olog,*) trim(f_bozx)//\"metric_boozer.bin.dat\"\n\n! --- read B-field and metric components\n     ! binary\n      read(unit=ibzx) nfp_bz, nss_bz, ntheta_bz, nzeta_bz, mnboz_bz, mboz_bz, nboz_bz, & \n                      Rax_bz, Bax_bz, aa_bz, volume_bz, asym_flg, alpha_fix\n      if (nss_bz /= nss.OR. ntheta_bz /= ntheta.OR. nzeta_bz /= nzeta ) then \n        print*, \"nss_bz, ntheta_bz, nzeta_bz = \", nss_bz, ntheta_bz, nzeta_bz\n        call MPI_Finalize\n        stop \"# nss or ntheta or nzeta is inconsistent between gkv_namelist and metric_boozer.dat! --> stop\"\n      end if \n\n      read(unit=ibzx) ss_bz, theta_bz, zeta_bz, q_bz, shat_bz, eps_bz, B_bz, rootg_bz, rootg_bz0, & \n                      ggup_bz, dBds_bz, dBdt_bz, dBdz_bz\n\n      allocate(rr_bz(1:nss,0:ntheta,0:nzeta),zz_bz(1:nss,0:ntheta,0:nzeta),ph_bz(1:nss,0:ntheta,0:nzeta))\n      allocate(bbozc_bz(1:mnboz_bz,1:nss),bbozs_bz(1:mnboz_bz,1:nss))\n      allocate(ixn_bz(1:mnboz_bz),ixm_bz(1:mnboz_bz))\n\n      read(unit=ibzx) rr_bz, zz_bz, ph_bz, bbozc_bz, ixn_bz, ixm_bz\n\n\n                 !!!! ascii for debug: NOT Used usually\n                 !!! read(unit=ibzx, fmt=\"(7I5,4ES24.15e3)\") nfp_bz, nss, ntheta, nzeta, mnboz_bz, mboz_bz, nboz_bz, &\n                 !!!                                         Rax_bz, Bax_bz, aa_bz, volume_bz\n                 !!! do js = 1, nss\n                 !!!   do iz = 0, nzeta\n                 !!!     do it = 0, ntheta\n                 !!!       write(unit=ibzx, fmt=\"(256ES24.15e3)\")                       &\n                 !!!               ss_bz(js),            theta_bz(it),    zeta_bz(iz),  &\n                 !!!                q_bz(js),             shat_bz(js),     eps_bz(js),  &\n                 !!!          B_bz(js,it,iz),      rootg_bz(js,it,iz),                  &\n                 !!!         ggup_bz(js,it,iz,1,1), ggup_bz(js,it,iz,1,2), ggup_bz(js,it,iz,1,3),    &\n                 !!!         ggup_bz(js,it,iz,2,2), ggup_bz(js,it,iz,2,3), ggup_bz(js,it,iz,3,3),    & \n                 !!!         Rax_bz, Bax_bz, aa_bz, volume_bz, nss, ntheta, nzeta, nfp_bz\n                 !!!     end do\n                 !!!     write(unit=ibzx, fmt=*)\n                 !!!   end do\n                 !!!     write(unit=ibzx, fmt=*)\n                 !!!     write(unit=ibzx, fmt=*)\n                 !!! end do\n\n      write(olog,*) \"# Rax_bz[m], Bax_bz[T], aa_bz[m], volume_bz[m3] = \", Rax_bz, Bax_bz, aa_bz, volume_bz\n      write(olog,*) \"# nss(=ns_b), ntheta(=ntht), nzeta, asym_flg    = \", nss, ntheta, nzeta, asym_flg\n      write(olog,*) \"# nfp_bz, mboz_bz, nboz_bz, mnboz_bz            = \", nfp_bz, mboz_bz, nboz_bz, mnboz_bz\n      if(nzeta == 0) write(olog,*) \"# fixed alpha (= zeta - q*theta) = \", alpha_fix\n      write(olog,*) \n\n\n! --- normalizartion with Bax, Rax \n      \n      B_bz       =  B_bz/Bax_bz\n      rootg_bz   =  rootg_bz/Rax_bz**3\n      ggup_bz    =  ggup_bz*Rax_bz**2\n      dBds_bz    =  dBds_bz/Bax_bz\n      dBdt_bz    =  dBdt_bz/Bax_bz\n      dBdz_bz    =  dBdz_bz/Bax_bz\n      bbozc_bz   =  bbozc_bz/Bax_bz\n\n\n      return \n\n  END SUBROUTINE vmecbzx_boozx_read\n\n\n\n!----------------------------------------------------------------------------------\n!smae start 202303\n!  SUBROUTINE vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input,  iz, zz,  lz_l,    & ! input \n  SUBROUTINE vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input,  giz, zz,  lz_l,    & ! input \n!smae end 202303\n                                   s_0,       q_0,    s_hat,   eps_r,   phi_ax,           & ! output\n                                   omg,     rootg,   domgdx,  domgdz,  domgdy,            &\n                                  gg11,      gg12,     gg13,    gg22,                     &\n                                  gg23,      gg33  )\n!----------------------------------------------------------------------------------\n\n!smae start 202303\n!    integer, intent(in)        :: isw, nss, ntheta, nzeta, iz\n    integer, intent(in)        :: isw, nss, ntheta, nzeta, giz\n!smae end 202303\n    real(kind=DP), intent(in)  :: s_input, zz, lz_l\n\n    real(kind=DP), intent(inout) :: s_0, q_0, s_hat, eps_r, phi_ax\n    real(kind=DP), intent(out) :: omg, rootg, domgdx, domgdz, domgdy\n    real(kind=DP), intent(out) :: gg11, gg12, gg13, gg22, gg23, gg33\n\n! --- local variables \n    integer                    :: is0, jj0, zt0\n    real(kind=DP)              :: eps_a\n\n\n  ! is0 = nint(s_input*(nss+1))\n    is0 = nint(s_input*(nss-1))+1\n    \n    if ( isw == 0 ) then \n\n      s_0   =   ss_bz(is0)\n      q_0   =    q_bz(is0)\n      s_hat = shat_bz(is0)\n      eps_r =  eps_bz(is0)\n\n    else if ( isw == 1 ) then\n\n      s_0   =   ss_bz(is0)\n!smae start 202303\n!      giz = (-global_nz + 2*nz*rankz + iz + nz )          \n!smae end 202303\n      jj0 = giz + ntheta/2\n  \n     \n! --- for debug\n!      write(2000+rankg,*) giz, jj0\n\n      eps_a =  eps_bz(nss)\n\n      zt0    =  0 ! for fixed alpha (i.e., single fluxtube)\n      phi_ax =  ph_bz(is0,jj0,zt0)\n      omg    =  B_bz(is0,jj0,zt0)\n      rootg  =  (eps_a**(-2))*q_0/s_0*rootg_bz(is0,jj0,zt0)\n      domgdx =  ( dBds_bz(is0,jj0,zt0) + q_0*s_hat*zz/s_0*dBdz_bz(is0,jj0,zt0) )/eps_a\n      domgdz =    dBdt_bz(is0,jj0,zt0) + q_0*dBdz_bz(is0,jj0,zt0)\n      domgdy =  - q_0/s_0*dBdz_bz(is0,jj0,zt0)/eps_a\n\n      gg11   =  eps_a**2 * ggup_bz(is0,jj0,zt0,1,1)\n\n      gg12   =  eps_a**2 * (  s_hat*zz*ggup_bz(is0,jj0,zt0,1,1)   &\n                             +     s_0*ggup_bz(is0,jj0,zt0,1,2)   &\n                             - s_0/q_0*ggup_bz(is0,jj0,zt0,1,3) )\n\n      gg13   =  eps_a*ggup_bz(is0,jj0,zt0,1,2)\n\n      gg22   =  eps_a**2 * (            (s_hat*zz)**2*ggup_bz(is0,jj0,zt0,1,1)   &\n                             +                 s_0**2*ggup_bz(is0,jj0,zt0,2,2)   &\n                             +           (s_0/q_0)**2*ggup_bz(is0,jj0,zt0,3,3)   & \n                             +     2._DP*s_0*s_hat*zz*ggup_bz(is0,jj0,zt0,1,2)   & \n                             -       2._DP*s_0**2/q_0*ggup_bz(is0,jj0,zt0,2,3)   & \n                             - 2._DP*s_0/q_0*s_hat*zz*ggup_bz(is0,jj0,zt0,1,3) )\n\n      gg23   =     eps_a * (  s_hat*zz*ggup_bz(is0,jj0,zt0,1,2)   &\n                             +     s_0*ggup_bz(is0,jj0,zt0,2,2)   &\n                             - s_0/q_0*ggup_bz(is0,jj0,zt0,2,3) )\n\n      gg33   =  ggup_bz(is0,jj0,zt0,2,2)\n\n    end if\n\n    return\n    \n  END SUBROUTINE vmecbzx_boozx_coeff\n\n\nEND MODULE GKV_vmecbzx\n", "MODULE GKV_dtc\n!-------------------------------------------------------------------------------\n!\n!    Time step size control\n!\n!    Update history of gkvp_dtc.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Minimum value of time step size is set to avoid zero-division\n!          e.g., nu_max2=max(nu_max2,1.d-20) for nu=0.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_exb, only: exb_maxvx_eachrank, exb_maxvy_eachrank\n  use GKV_colliimp, only: colliimp_colli, gvl, gvp, gnu_ds, gnu_ps, gnu_hs, gnu_gs\n\n  implicit none\n\n  private\n\n  real(kind=DP), save :: dt_linear, dt_nl, dt_limit, dt_col\n\n  real(kind=DP), save :: dx_inv, dy_inv\n\n  integer, save :: flag_time_advnc! 0: rkg4\n                                  ! 1: imp_colli\n  integer, save :: flag_time_split! 0: colli(dt/2)->RK(dt)! for imp_colli\n                                  ! 1: colli(dt  )->RK(dt)! for imp_colli\n\n  public   dtc_init, dtc_cntrl, flag_time_advnc, flag_time_split\n\n\n CONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE dtc_init( lx, ly, vmax )\n!--------------------------------------\n\n    real(kind=DP), intent(in) :: lx, ly, vmax\n\n    real(kind=DP) :: dt_perp, dt_zz, dt_vl\n    real(kind=DP) :: kvd_max, kvd_max2, vl_max, vl_max2, mir_max, mir_max2\n    real(kind=DP) :: ksq_max0, ksq_max, nu_max, nu_max2, nu_temp\n    real(kind=DP) :: cs, dx, dy, kvd\n    integer :: mx, my, iz, iv, im, is\n\n\n      ksq_max0 = 0._DP\n      ksq_max  = 0._DP\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n!              do mx = 0, nx\n                if ( ksq_max0 < ksq(mx,my,iz) ) ksq_max0 = ksq(mx,my,iz)\n              end do\n            end do\n          end do\n      call MPI_Allreduce( ksq_max0, ksq_max, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n\n      kvd_max = 0._DP\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n!              do mx = 0, nx\n                kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im)\n                if ( kvd_max < abs(kvd) ) then \n                  kvd_max = abs(kvd)\n                end if \n              end do\n            end do\n          end do\n        end do\n      end do\n      call MPI_Allreduce( kvd_max, kvd_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n      kvd_max2 = max(kvd_max2, 1.d-20)\n      dt_perp = courant_num * pi / kvd_max2\n\n      cs = sqrt( tau(ranks) / Anum(ranks) )\n      vl_max = 0._DP\n      do iz = -nz, nz-1\n        if ( vl_max < cs * vmax / dpara(iz) ) vl_max = cs * vmax / dpara(iz)\n      end do\n      call MPI_Allreduce( vl_max, vl_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n      vl_max2 = max(vl_max2, 1.d-20)\n      dt_zz = courant_num / vl_max2\n\n      mir_max = 0._DP\n      do im = 0, nm\n        do iz = -nz, nz-1\n          if ( mir_max < cs * mir(iz,im) ) mir_max = cs * mir(iz,im)\n        end do\n      end do\n      call MPI_Allreduce( mir_max, mir_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n      mir_max2 = max(mir_max2, 1.d-20)\n      dt_vl = courant_num * dv / mir_max2\n\n      if ( trim(col_type) == \"LB\" ) then\n\n        nu_max = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP &\n               * ( 2._DP / dv**2 )\n        do iz = -nz, nz-1\n          nu_temp = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP &\n                  * ( 2._DP / dvp(iz)**2 )\n          if ( nu_max < nu_temp ) nu_max = nu_temp\n        end do\n        call MPI_Allreduce( nu_max, nu_max2, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n        nu_max2 = max(nu_max2, 1.d-20)\n        dt_col = courant_num / nu_max2\n        \n      else if ( trim(col_type) == \"full\".or. &\n                trim(col_type) == \"lorentz\" ) then\n\n       !nu_max = 0._DP\n       !do im = 0, nm\n       !  do iv = 1, 2*nv\n       !    do iz = -nz, nz-1\n       !      nu_temp = ( nu_ps(iz,iv,im) * vl(iv)**2    & \n       !                + nu_ds(iz,iv,im) * vp(iz,im)**2 &\n       !                ) * 0.5_DP * ( 2._DP / dv**2 )\n       !      if ( nu_max < nu_temp ) nu_max = nu_temp\n       !    end do\n       !  end do\n       !end do\n       !do im = 0, nm\n       !  do iv = 1, 2*nv\n       !    do iz = -nz, nz-1\n       !      nu_temp = ( nu_ds(iz,iv,im) * vl(iv)**2    & \n       !                + nu_ps(iz,iv,im) * vp(iz,im)**2 &\n       !                ) * 0.5_DP * ( 2._DP / dvp(iz)**2 )\n       !      if ( nu_max < nu_temp ) nu_max = nu_temp\n       !    end do\n       !  end do\n       !end do\n        nu_max = 0._DP\n        do iz = -nz, nz-1\n          do is = 0, ns-1\n            do im = 0, global_nm\n              do iv = 1, 2*global_nv\n                nu_temp = ( gnu_ps(iv,im,is,iz) * gvl(iv)**2    & \n                          + gnu_ds(iv,im,is,iz) * gvp(im,iz)**2 &\n                          ) * 0.5_DP * ( 2._DP / dv**2 )\n                if ( nu_max < nu_temp ) nu_max = nu_temp\n              end do\n            end do\n          end do\n        end do\n        do iz = -nz, nz-1\n          do is = 0, ns-1\n            do im = 0, global_nm\n              do iv = 1, 2*global_nv\n                nu_temp = ( gnu_ds(iv,im,is,iz) * gvl(iv)**2    & \n                          + gnu_ps(iv,im,is,iz) * gvp(im,iz)**2 &\n                          ) * 0.5_DP * ( 2._DP / dvp(iz)**2 )\n                if ( nu_max < nu_temp ) nu_max = nu_temp\n              end do\n            end do\n          end do\n        end do\n        call MPI_Allreduce( nu_max, nu_max2, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n        nu_max2 = max(nu_max2, 1.d-20)\n        dt_col = courant_num / nu_max2\n\n      else\n\n        write( olog, * ) \"This col_type is not supported by dtc:\", trim(col_type)\n        dt_col = 99._DP\n\n      end if\n\n\n      dt_linear = min( dt_perp, dt_zz, dt_vl )\n\n      if (trim(time_advnc) == \"rkg4\") then\n\n        dt_limit = min( dt_max, dt_linear, dt_col )\n        dt = dt_max\n        if ( adapt_dt ) then\n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) dt = dt_limit\n        end if\n        flag_time_advnc = 0\n\n      else if (trim(time_advnc) == \"imp_colli\") then\n\n        dt_limit = min( dt_max, dt_linear )\n        dt = dt_max\n        if ( adapt_dt ) then\n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) dt = dt_limit\n        end if\n        flag_time_advnc = 1\n\n      else if (trim(time_advnc) == \"auto_init\") then\n\n        dt_limit = min( dt_max, dt_linear )\n        dt = dt_max\n        if ( adapt_dt ) then\n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) dt = dt_limit\n        end if\n        if (dt < dt_col) then\n           flag_time_advnc = 0\n        else\n           flag_time_advnc = 1\n        end if\n\n      else\n\n        write( olog, * ) \" # Wrong type of time_advnc in namelist: \", time_advnc\n        call flush(olog)\n        call MPI_Finalize ( ierr_mpi )\n        stop\n\n      end if\n\n      flag_time_split = 0\n\n        write( olog, * ) \" # Time step size control\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # time_advnc   = \", time_advnc\n        write( olog, * ) \" # flag_time_adv= \", flag_time_advnc\n        write( olog, * ) \" # courant num. = \", courant_num\n        write( olog, * ) \" # ksq_max      = \", ksq_max\n        write( olog, * ) \" # dt_perp      = \", dt_perp\n        write( olog, * ) \" # dt_zz        = \", dt_zz\n        write( olog, * ) \" # dt_vl        = \", dt_vl\n        write( olog, * ) \" # dt_col       = \", dt_col\n        write( olog, * ) \" # dt_linear    = \", dt_linear\n        write( olog, * ) \" # dt_max       = \", dt_max\n        write( olog, * ) \" # dt           = \", dt\n        write( olog, * ) \"\"\n\n      dx = lx / real( nxw, kind=DP )\n      dy = ly / real( nyw, kind=DP )\n      dx_inv = 1._DP / dx\n      dy_inv = 1._DP / dy\n\n  \n  END SUBROUTINE dtc_init\n\n\n!--------------------------------------\n  SUBROUTINE dtc_cntrl( ff, phi, Al, hh, time, id )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    real(kind=DP), intent(in) :: time\n    integer, intent(in) :: id\n\n    real(kind=DP), save :: tout_dtc\n\n\n      if( id == 0 ) then\n\n        tout_dtc  = ( int( ( time + eps )/dtout_dtc ) + 1 ) * dtout_dtc\n \n        if ( trim(calc_type) == \"nonlinear\" ) call dtc_estimate\n\n        if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) then\n          dt = dt_limit\n          write( olog, * ) &\n            \" # dt is changed at time = \", time, \", dt = \", dt\n        end if\n     \n        if ( rankg == 0 ) then\n          write( unit=odtc, fmt=\"(f10.5, 1p, 3e15.7)\" )  &\n            time, dt, dt_limit, dt_nl\n        end if\n  \n      else if( id == 1 ) then\n\n        if ( time >= tout_dtc - eps ) then\n\n          tout_dtc   = tout_dtc + dtout_dtc\n   \n          if ( trim(calc_type) == \"nonlinear\" ) call dtc_estimate\n  \n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) then\n\n            if (flag_time_advnc == 1) then! Operator split + implicit collision\n              if (flag_time_split == 1) then! dt/2 integration for 2nd-order split\n                call colliimp_colli(0.5_DP*dt, ff, phi, al, hh)\n                                              !%%% For debug %%%\n                                              ! if (rankg==0) write(olog,*) &\n                                              ! time, \"half-step for dtc_cntrl\"\n                                              !%%%%%%%%%%%%%%%%%\n              end if\n              flag_time_split = 0! flag_time_split==0 means you have physical quantities at time\n            end if\n\n            dt = dt_limit\n            write( olog, * ) &\n              \" # dt is changed at time = \", time, \", dt = \", dt\n          end if\n       \n          if ( rankg == 0 ) then\n            write( unit=odtc, fmt=\"(f10.5, 1p, 3e15.7)\" )  &\n              time, dt, dt_limit, dt_nl\n          end if\n\n        end if\n\n      end if\n\n\n  END SUBROUTINE dtc_cntrl\n\n\n!!--------------------------------------\n!  SUBROUTINE dtc_estimate\n!!--------------------------------------\n!\n!    real(kind=DP) :: wx_nl1, wx_nl2, wy_nl1, wy_nl2, w_nl_max, w_nl_max2\n!    real(kind=DP) :: cs\n!    integer  ::  mx, my, iz, iv, im\n!  \n!  \n!      w_nl_max = 0._DP\n!  \n!      cs = sqrt( tau(ranks) / Anum(ranks) )\n!\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          do iz = -nz, nz-1\n!            do mx = ist_xw, iend_xw\n!              do my = 0, nyw-1\n!                wx_nl1 = abs( dx_inv * real( eyw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * byw_xw(my,mx,iz,im), kind=DP ) )\n!                wx_nl2 = abs( dx_inv * aimag( eyw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * byw_xw(my,mx,iz,im)          ) )\n!                wy_nl1 = abs( dy_inv * real( exw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * bxw_xw(my,mx,iz,im), kind=DP ) )\n!                wy_nl2 = abs( dy_inv * aimag( exw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * bxw_xw(my,mx,iz,im)          ) )\n!                if ( w_nl_max < wx_nl1 ) w_nl_max = wx_nl1\n!                if ( w_nl_max < wx_nl2 ) w_nl_max = wx_nl2\n!                if ( w_nl_max < wy_nl1 ) w_nl_max = wy_nl1\n!                if ( w_nl_max < wy_nl2 ) w_nl_max = wy_nl2\n!              end do\n!            end do\n!          end do\n!        end do\n!      end do\n!  \n!      call MPI_Allreduce( w_nl_max, w_nl_max2, 1, MPI_DOUBLE_PRECISION, &\n!                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n!  \n!      dt_nl = courant_num / w_nl_max2\n!  \n!      dt_limit = min( dt_max, dt_linear, dt_nl )\n!\n!  \n!  END SUBROUTINE dtc_estimate\n\n!--------------------------------------\n  SUBROUTINE dtc_estimate\n!--------------------------------------\n\n    real(kind=DP) :: w_nl_max, w_nl_max2\n\n      w_nl_max = max(eps, dx_inv*exb_maxvx_eachrank, dy_inv*exb_maxvy_eachrank)\n  \n      call MPI_Allreduce( w_nl_max, w_nl_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n  \n      dt_nl = courant_num / w_nl_max2\n  \n      dt_limit = min( dt_max, dt_linear, dt_nl )\n\n  \n  END SUBROUTINE dtc_estimate\n\n\nEND MODULE GKV_dtc\n", "MODULE GKV_clock\n!-------------------------------------------------------------------------------\n!\n!    Elapsed time measurements\n!\n!    Update history of gkvp_clock.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public   clock_timer, clock_etime, clock_sta, clock_end, clock_reset\n\n  real(kind=DP), dimension(1:2000), save :: sss, eee, elt\n  integer, dimension(1:2000), save :: ccount\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE clock_timer( isw, iflg )\n!--------------------------------------\n\n    integer, intent(in)  :: isw\n    integer, intent(out) :: iflg\n\n    real(kind=DP), save  :: sss0, eee0\n    real(kind=DP)        :: ttotl\n\n\n      if( isw == 0 ) then\n\n        if( rank == 0 ) then\n          call clock_etime ( sss0 )\n        end if\n\n        call MPI_Bcast( sss0, 1, MPI_DOUBLE_PRECISION, 0, &\n                      MPI_COMM_WORLD, ierr_mpi )\n\n        iflg = 0\n\n        sss(1:2000) = 0._DP\n        eee(1:2000) = 0._DP\n        elt(1:2000) = 0._DP\n        ccount(1:2000) = 0\n\n      else if( isw == 1 ) then\n\n        if( rank == 0 ) then\n          call clock_etime ( eee0 )\n        end if\n\n        call MPI_Bcast( eee0, 1, MPI_DOUBLE_PRECISION, 0, &\n                      MPI_COMM_WORLD, ierr_mpi )\n\n        if ( eee0-sss0 > e_limit ) then\n          write( olog, * ) \" # elapsed time is closing to the limit\", eee0-sss0\n          iflg = 1\n        else\n          iflg = 0\n        end if\n\n      else if( isw == 2 ) then\n\n        if( rank == 0 ) then\n          call clock_etime ( eee0 )\n        end if\n\n        call MPI_Bcast( eee0, 1, MPI_DOUBLE_PRECISION, 0, &\n                      MPI_COMM_WORLD, ierr_mpi )\n\n        ttotl   = eee0 - sss0\n        elt(1310) = sum(elt(1311:1319));               ccount(1310) = ccount(1311)\n        elt(1350) = elt(1351) + elt(1352) + elt(1353); ccount(1350) = ccount(1351)\n        elt(1360) = elt(1361) + elt(1362) + elt(1363); ccount(1360) = ccount(1361)\n        elt(1370) = elt(1371) + elt(1372) + elt(1373); ccount(1370) = ccount(1371)\n        elt(1380) = elt(1381) + elt(1382) + elt(1383); ccount(1380) = ccount(1381)\n      !elt(1420) = elt(1421) + elt(1422) + elt(1423); ccount(1420) = ccount(1421)\n      !elt(1440) = elt(1441) + elt(1442) + elt(1443); ccount(1440) = ccount(1441)\n        elt(1520) = elt(1521) + elt(1522) + elt(1523); ccount(1520) = ccount(1521)\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### elapsed time (sec) and call count #########\"\n        write( olog, '(a22,f15.5,i15)' ) \"   total            = \", ttotl\n        write( olog, '(a22,f15.5,i15)' ) \"   pre              = \", elt(1), ccount(1)\n        write( olog, '(a22,f15.5,i15)' ) \"   timesteploop     = \", elt(2), ccount(2)\n        write( olog, '(a22,f15.5,i15)' ) \"   post             = \", elt(3), ccount(3)\n        write( olog, '(a22,f15.5,i15)' ) \"   output           = \", elt(10), ccount(10)\n        write( olog, '(a22,f15.5,i15)' ) \"   rkg              = \", elt(11), ccount(11)\n        write( olog, '(a22,f15.5,i15)' ) \"   field            = \", elt(12), ccount(12)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm           = \", elt(13), ccount(13)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm           = \", elt(14), ccount(14)\n        write( olog, '(a22,f15.5,i15)' ) \"   zfilter          = \", elt(15), ccount(15)\n        write( olog, '(a22,f15.5,i15)' ) \"   checkp           = \", elt(16), ccount(16)\n        write( olog, '(a22,f15.5,i15)' ) \"   colliimp         = \", elt(17), ccount(17)\n        write( olog, '(a22,f15.5,i15)' ) \"   other            = \", elt(2)-elt(10)-elt(11) &\n                                         -elt(12)-elt(13)-elt(14)-elt(15)-elt(16)-elt(17), ccount(2)\n        write( olog, * ) \" #####################################################\"\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### elapsed time detail (sec) and call count #########\"\n        write( olog, '(a22,f15.5,i15)' ) \"   field:v0moment   = \", elt(1220), ccount(1220)\n        write( olog, '(a22,f15.5,i15)' ) \"   field:fsrfave    = \", elt(1230), ccount(1230)\n        write( olog, '(a22,f15.5,i15)' ) \"   field:other      = \", elt(1210), ccount(1210)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:colli     = \", elt(1310), ccount(1310)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:perp      = \", elt(1320), ccount(1320)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:para      = \", elt(1330), ccount(1330)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:other     = \", elt(1340), ccount(1340)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:boundf    = \", elt(1350), ccount(1350)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:shiftv    = \", elt(1360), ccount(1360)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:shiftm    = \", elt(1370), ccount(1370)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:bounde    = \", elt(1380), ccount(1380)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:pack      = \", elt(1410), ccount(1410)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:transpose = \", elt(1420), ccount(1420)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:realspcal = \", elt(1430), ccount(1430)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:transpose = \", elt(1440), ccount(1440)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:unpack    = \", elt(1450), ccount(1450)\n        write( olog, '(a22,f15.5,i15)' ) \"   zfilter:calc     = \", elt(1510), ccount(1510)\n        write( olog, '(a22,f15.5,i15)' ) \"   zfilter:comm     = \", elt(1520), ccount(1520)\n        write( olog, * ) \" ############################################################\"\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### elapsed time more detail (sec) and call count #########\"\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:ct         = \", elt(1311), ccount(1311)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:dt         = \", elt(1312), ccount(1312)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:cf         = \", elt(1313), ccount(1313)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:mom        = \", elt(1314), ccount(1314)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:ar         = \", elt(1315), ccount(1315)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:com        = \", elt(1316), ccount(1316)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:dvp        = \", elt(1317), ccount(1317)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:0          = \", elt(1318), ccount(1318)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:hwset      = \", elt(1319), ccount(1319)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:boundf:bufferin  = \", elt(1351), ccount(1351)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:boundf:sendrecv  = \", elt(1352), ccount(1352)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:boundf:bufferout = \", elt(1353), ccount(1353)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftv:bufferin  = \", elt(1361), ccount(1361)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftv:sendrecv  = \", elt(1362), ccount(1362)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftv:bufferout = \", elt(1363), ccount(1363)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftm:bufferin  = \", elt(1371), ccount(1371)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftm:sendrecv  = \", elt(1372), ccount(1372)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftm:bufferout = \", elt(1373), ccount(1373)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:bounde:bufferin  = \", elt(1381), ccount(1381)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:bounde:sendrecv  = \", elt(1382), ccount(1382)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:bounde:bufferout = \", elt(1383), ccount(1383)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:backward:Xfft    = \", elt(1421), ccount(1421)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:backward:shiftXY = \", elt(1422), ccount(1422)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:backward:Yfft    = \", elt(1423), ccount(1423)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:forward:Yfft     = \", elt(1441), ccount(1441)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:forward:shiftYX  = \", elt(1442), ccount(1442)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:forward:Xfft     = \", elt(1443), ccount(1443)\n        write( olog, '(a29,f15.5,i15)' ) \"   zfilter:comm:bufferin   = \", elt(1521), ccount(1521)\n        write( olog, '(a29,f15.5,i15)' ) \"   zfilter:comm:sendrecv   = \", elt(1522), ccount(1522)\n        write( olog, '(a29,f15.5,i15)' ) \"   zfilter:comm:bufferout  = \", elt(1523), ccount(1523)\n        write( olog, * ) \" #################################################################\"\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### For implicit collison solver #########\"\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:init     = \", elt(1700), ccount(1700)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:pack     = \", elt(1710), ccount(1710)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:alltoall = \", elt(1711), ccount(1711)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:unpack   = \", elt(1712), ccount(1712)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:bicgstab = \", elt(1720), ccount(1720)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:pack     = \", elt(1730), ccount(1730)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:alltoall = \", elt(1731), ccount(1731)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:unpack   = \", elt(1732), ccount(1732)\n        write( olog, * ) \" ################################################\"\n\n        iflg = 0\n\n      end if\n\n\n  END SUBROUTINE clock_timer\n\n\n!--------------------------------------\n  SUBROUTINE clock_etime( ttt )\n!--------------------------------------\n\n    real(kind=DP) :: ttt\n\n\n      ttt = MPI_Wtime()\n\n\n  END SUBROUTINE clock_etime\n\n\n!--------------------------------------\n  SUBROUTINE clock_sta( id )\n!--------------------------------------\n\n    integer, intent(in) :: id\n\n\n      call clock_etime( sss(id) )\n\n\n  END SUBROUTINE clock_sta\n\n\n!--------------------------------------\n  SUBROUTINE clock_end( id )\n!--------------------------------------\n\n    integer, intent(in) :: id\n\n\n      call clock_etime( eee(id) )\n\n      elt(id) = elt(id) + eee(id) - sss(id)\n\n      ccount(id)=ccount(id)+1\n\n\n  END SUBROUTINE clock_end\n\n\n!--------------------------------------\n  SUBROUTINE clock_reset\n!--------------------------------------\n\n\n      elt(10:2000) = 0._DP\n      ccount(10:2000) = 0\n\n\n  END SUBROUTINE clock_reset\n\n\nEND MODULE GKV_clock\n", "MODULE GKV_trans\n!-------------------------------------------------------------------------------\n!\n!    Entropy transfer diagnostics\n!\n!    Update history of gkvp_trans.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Use fileio module to switch Fortran/NetCDF binary output.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_intgrl, only: intgrl_thet, intgrl_v0_moment\n  use GKV_clock, only: clock_sta, clock_end\n  use GKV_exb, only: exb_NL_term\n  !fj start 202010\n  use GKV_fileio\n  !fj end 202010\n\n  implicit none\n\n  private\n\n  integer, save, &\n    dimension(:), allocatable :: triad_diag_mxt, triad_diag_myt\n  integer, save :: nbuff\n\n  public   trans_sum, trans_triad\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE trans_sum ( ff, phi, Al, neint, nmint )\n!--------------------------------------\n!     Check the entropy balance equation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny) :: neint, nmint\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf, wef, wbf\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi\n    complex(kind=DP), dimension(:,:,:), allocatable :: wc3\n    complex(kind=DP), dimension(-nx:nx,0:ny) :: wc2\n    integer  ::  mx, my, iz, iv, im\n\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( wef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( wbf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( psi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( wc3(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel workshare\n      wf(:,:,:,:,:) = (0._DP, 0._DP)\n      psi(:,:,:,:) = (0._DP, 0._DP)\n      chi(:,:,:,:) = (0._DP, 0._DP)\n      neint(:,:) = 0._DP\n      nmint(:,:) = 0._DP\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n                          * fmx(iz,iv,im) / tau(ranks) * psi(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call exb_NL_term( wf, psi, chi, wef )  ! Electrostatic part\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call exb_NL_term( wf, psi, chi, wbf )\n\n!$OMP parallel workshare\n      wbf(:,:,:,:,:) = wbf(:,:,:,:,:) - wef(:,:,:,:,:) ! Magnetic part\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wef(mx,my,iz,iv,im) = - fcs(ranks) / Znum(ranks) * wef(mx,my,iz,iv,im)  &\n                      * tau(ranks) * conjg( wf(mx,my,iz,iv,im) ) / fmx(iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment ( wef, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          neint(mx,my) = real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wbf(mx,my,iz,iv,im) = - fcs(ranks) / Znum(ranks) * wbf(mx,my,iz,iv,im)  &\n                      * tau(ranks) * conjg( wf(mx,my,iz,iv,im) ) / fmx(iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment ( wbf, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          nmint(mx,my) = real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n\n      deallocate( wf )\n      deallocate( wef )\n      deallocate( wbf )\n      deallocate( psi )\n      deallocate( chi )\n      deallocate( wc3 )\n\n\n  END SUBROUTINE trans_sum\n\n\n!--------------------------------------\n  SUBROUTINE trans_triad ( time, ff, phi, Al )\n!--------------------------------------\n!   Triad transfer    T [(kx,ky)|(px,py),(qx,qy)] * delta(kx+px+qx=0,ky+py+qy=0)\n!   Setting (kx,ky)=(diagx,diagy) and (qx=-px-kx,qy=-py-ky), \n!   T=T(px,py) represents transfer from (px,py) and (-px-diagx,-py-diagy) to (diagx,diagy).\n\n    real(kind=DP), intent(in)                                     :: time\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                             :: phi, Al\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: gg\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi, wg\n    complex(kind=DP), dimension(:,:,:), allocatable :: wps, wch\n    real(kind=DP), dimension(:,:), allocatable :: jkpq_es, jpqk_es, jqkp_es, &\n                                                  jkpq_em, jpqk_em, jqkp_em\n    real(kind=DP) :: ceff\n    integer  ::  mx, my, iz, iv, im, it, mxt, myt\n    character(1)   :: srank\n    character(3)   :: cnew\n    character(4)   :: cmx, cmy\n    character(256)   :: env_string\n    integer, save ::  iflg\n\n    data iflg / 0 /\n    namelist /triad/ mxt, myt\n\n\n      !%%% Initialize triad_diag_mxt, triad_diag_myt, nbuff %%%\n      if( iflg == 0 ) then\n\n        iflg = 1\n\n        close(inml)\n        call getenv ( 'fu05',env_string )\n        open(inml, file=env_string )\n\n        allocate(triad_diag_mxt(0:num_triad_diag-1))\n        allocate(triad_diag_myt(0:num_triad_diag-1))\n\n        do it = 0, num_triad_diag-1\n          read(inml, nml=triad)\n          triad_diag_mxt(it) = mxt\n          triad_diag_myt(it) = myt\n\n          !fj start 202011\n          !if ( rank == 0 ) then\n          !  write( srank, fmt=\"(i1.1)\" ) ranks\n          !  write( cnew,  fmt=\"(i3.3)\" ) inum\n          !  write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n          !  write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n          !  open( otri, file=trim(f_phi)//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, & \n          !              form=\"unformatted\", status=\"replace\" )\n          !  close( otri )\n          !end if\n          write( srank, fmt=\"(i1.1)\" ) ranks\n          write( cnew,  fmt=\"(i3.3)\" ) inum\n          write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n          write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n          call fileio_open_tri( trim(f_phi), cmx, cmy, .true. )\n          call fileio_close_tri\n          !fj end 202011\n\n        end do\n\n        if ( mod(2*nz*(nm+1),nprocw) == 0 ) then\n          nbuff = 2*nz*(nm+1)/nprocw\n        else\n          nbuff = 2*nz*(nm+1)/nprocw + 1\n        end if\n\n      end if\n\n      !%%% Set gg, psi, chi %%%\n      allocate( gg(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( psi(-nx:nx,0:ny,-nz:nz-1,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz:nz-1,0:nm) )\n      allocate( wg(-nx:nx,0:global_ny,1:2*nv,0:nbuff-1) )\n      allocate( wps(-nx:nx,0:global_ny,0:nbuff-1) )\n      allocate( wch(-nx:nx,0:global_ny,0:nbuff-1) )\n      allocate( jkpq_es(-nx:nx,-global_ny:global_ny) )\n      allocate( jpqk_es(-nx:nx,-global_ny:global_ny) )\n      allocate( jqkp_es(-nx:nx,-global_ny:global_ny) )\n      allocate( jkpq_em(-nx:nx,-global_ny:global_ny) )\n      allocate( jpqk_em(-nx:nx,-global_ny:global_ny) )\n      allocate( jqkp_em(-nx:nx,-global_ny:global_ny) )\n!$OMP parallel workshare\n      gg(:,:,:,:,:) = (0._DP, 0._DP)\n      psi(:,:,:,:) = (0._DP, 0._DP)\n      chi(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end parallel workshare\n\n!$OMP parallel do collapse(2)\n      do im = 0, nm\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n                chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n      end do\n!$OMP parallel do collapse(2)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im)                       &\n                                   + sgn(ranks) * Znum(ranks) * fmx(iz,iv,im) &\n                                              / tau(ranks) * psi(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      !%%% Multiply the jacobian on gg for zz,vl,mu integration %%%\n      if ( rankm == 0 ) then\n        im = 0\n!$OMP parallel do private(ceff)\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = 0._DP\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        im = 1\n!$OMP parallel do private(ceff)\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi * (     &\n                     1._DP + 1._DP/12._DP + 22._DP / 720._DP )&\n                   * rootg(iz) / cfsrf                        &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        im = 2\n!$OMP parallel do private(ceff)\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi * ( &\n                     1._DP - 11._DP / 720._DP )           &\n                   * rootg(iz) / cfsrf                    &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP parallel do private(ceff)\n        do im = 3, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi     &\n                   * rootg(iz) / cfsrf                    &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        end do\n      else\n!$OMP parallel do private(ceff)\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi     &\n                   * rootg(iz) / cfsrf                    &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        end do\n      end if\n\n      !%%% Transpose from (y,z,v,m) to (zm,z,v,m) decomposition %%%\n      call trans_triad_transpose(gg, psi, chi, wg, wps, wch)\n\n      do it = 0, num_triad_diag-1\n\n        !%%% Calculate traid coupling %%%\n        call trans_triad_coupling(it, wg, wps, wch, jkpq_es, jpqk_es, jqkp_es,&\n                                                    jkpq_em, jpqk_em, jqkp_em)\n\n        !%%% Output %%%\n        !fj start 202011\n        !if ( rank == 0 ) then\n        !  write( srank, fmt=\"(i1.1)\" ) ranks\n        !  write( cnew,  fmt=\"(i3.3)\" ) inum\n        !  write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n        !  write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n        !  open( otri, file=trim(f_phi)//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, & \n        !              form=\"unformatted\", status=\"unknown\", position=\"append\" )\n        !  write( unit=otri ) time, jkpq_es, jpqk_es, jqkp_es, jkpq_em, jpqk_em, jqkp_em\n        !  close( otri )\n        !end if\n        write( srank, fmt=\"(i1.1)\" ) ranks\n        write( cnew,  fmt=\"(i3.3)\" ) inum\n        write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n        write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n        call fileio_open_tri( trim(f_phi), cmx, cmy, .false. )\n        call fileio_write_tri( jkpq_es, jpqk_es, jqkp_es, jkpq_em, jpqk_em, jqkp_em, time )\n        call fileio_close_tri\n        !fj end 202011\n\n      end do\n\n      deallocate( gg )\n      deallocate( psi )\n      deallocate( chi )\n      deallocate( wg )\n      deallocate( wps )\n      deallocate( wch )\n      deallocate( jkpq_es )\n      deallocate( jpqk_es )\n      deallocate( jqkp_es )\n      deallocate( jkpq_em )\n      deallocate( jpqk_em )\n      deallocate( jqkp_em )\n\n\n  END SUBROUTINE trans_triad\n\n\n!--------------------------------------\n  ", "SUBROUTINE trans_triad_transpose ( gg, psi, chi, wg, wps, wch )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: gg\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm)        :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:global_ny,1:2*nv,0:nbuff-1) :: wg\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:global_ny,0:nbuff-1)        :: wps, wch\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: send_gg, recv_gg\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: send_psi, recv_psi, &\n                                                         send_chi, recv_chi\n    integer  ::  mx, my, iz, iv, im, izm, ibuff, iprocw, global_my\n\n\n      allocate( send_gg(-nx:nx,0:ny,1:2*nv,0:nbuff-1,0:nprocw-1) )\n      allocate( recv_gg(-nx:nx,0:ny,1:2*nv,0:nbuff-1,0:nprocw-1) )\n      allocate( send_psi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n      allocate( recv_psi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n      allocate( send_chi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n      allocate( recv_chi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n\n    !%%% PACK: gg -> send_gg %%%\n!$OMP parallel workshare\n      send_gg(:,:,:,:,:) = (0._DP, 0._DP)\n      send_psi(:,:,:,:) = (0._DP, 0._DP)\n      send_chi(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end parallel workshare\n!$OMP parallel do private(izm,ibuff,iprocw)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                izm = (2*nz)*im + (iz + nz)\n                ibuff = mod(izm, nbuff)\n                iprocw = izm / nbuff\n                send_gg(mx,my,iv,ibuff,iprocw) = gg(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP parallel do private(izm,ibuff,iprocw)\n      do im = 0, nm\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                izm = (2*nz)*im + (iz + nz)\n                ibuff = mod(izm, nbuff)\n                iprocw = izm / nbuff\n                send_psi(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n                send_chi(mx,my,ibuff,iprocw) = chi(mx,my,iz,im)\n              end do\n            end do\n          end do\n      end do\n\n    !%%% TRANSPOSE: send_gg -> recv_gg %%%\n      call MPI_Alltoall( send_gg,                      &\n                         (2*nx+1)*(ny+1)*(2*nv)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,           &\n                         recv_gg,                      &\n                         (2*nx+1)*(ny+1)*(2*nv)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,           &\n                         fft_comm_world,               &\n                         ierr_mpi )\n      call MPI_Alltoall( send_psi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         recv_psi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n      call MPI_Alltoall( send_chi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         recv_chi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n\n    !%%% UNPACK: recv_gg -> wg %%%\n!$OMP parallel do private(iprocw,my)\n      do ibuff = 0, nbuff-1\n        do iv = 1, 2*nv\n          do global_my = 0, global_ny\n            do mx = -nx, nx\n              iprocw = global_my / (ny+1)\n              my = mod(global_my, ny+1)\n              wg(mx,global_my,iv,ibuff) = recv_gg(mx,my,iv,ibuff,iprocw)\n            end do\n          end do\n        end do\n      end do\n!$OMP parallel do private(iprocw,my)\n      do ibuff = 0, nbuff-1\n          do global_my = 0, global_ny\n            do mx = -nx, nx\n              iprocw = global_my / (ny+1)\n              my = mod(global_my, ny+1)\n              wps(mx,global_my,ibuff) = recv_psi(mx,my,ibuff,iprocw)\n              wch(mx,global_my,ibuff) = recv_chi(mx,my,ibuff,iprocw)\n            end do\n          end do\n      end do\n\n      deallocate( send_gg )\n      deallocate( recv_gg )\n      deallocate( send_psi )\n      deallocate( recv_psi )\n      deallocate( send_chi )\n      deallocate( recv_chi )\n                                         !%%% For debug %%%\n                                         !iz = nz-1\n                                         !im = nm\n                                         !call MPI_Allgather(     &\n                                         !     psi(-nx,0,iz,im),  &\n                                         !     (2*nx+1)*(ny+1),   &\n                                         !     MPI_DOUBLE_COMPLEX,&\n                                         !     wch(-nx,0,0),      &\n                                         !     (2*nx+1)*(ny+1),   &\n                                         !     MPI_DOUBLE_COMPLEX,&\n                                         !     fft_comm_world,    &\n                                         !     ierr_mpi)\n                                         !izm = (2*nz)*im+(iz+nz)\n                                         !ibuff = mod(izm,nbuff)\n                                         !iprocw = izm/nbuff\n                                         !if (rankg==iprocw) then\n                                         !write(888,*)\"#\",ibuff,iprocw\n                                         !do my = 0, global_ny\n                                         !  do mx = -nx, nx\n                                         !    write(888,*) mx, my,    &\n                                         !     dble(wps(mx,my,ibuff)),&\n                                         !    aimag(wps(mx,my,ibuff)),&\n                                         !     dble(wch(mx,my,0)),    &\n                                         !    aimag(wch(mx,my,0))\n                                         !  end do\n                                         !  write(888,*)\n                                         !end do\n                                         !end if\n                                         !call MPI_Finalize(ierr_mpi)\n                                         !stop\n                                         !%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE trans_triad_transpose\n\n\n!--------------------------------------\n  ", "SUBROUTINE trans_triad_coupling ( it, wg, wps, wch, jkpq_es, jpqk_es, jqkp_es,&\n                                                      jkpq_em, jpqk_em, jqkp_em )\n!--------------------------------------\n\n    integer, intent(in)                              :: it\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:global_ny,1:2*nv,0:nbuff-1) :: wg\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:global_ny,0:nbuff-1)        :: wps, wch\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,-global_ny:global_ny) :: jkpq_es, jpqk_es, jqkp_es, &\n                                                jkpq_em, jpqk_em, jqkp_em\n\n    complex(kind=DP), dimension(:,:), allocatable :: gg, psi, chi\n    real(kind=DP), dimension(:,:), allocatable :: &\n                        wkpq_es, wpqk_es, wqkp_es, wkpq_em, wpqk_em, wqkp_em\n    real(kind=DP) :: dky, wky(-global_ny:global_ny), cs1\n    integer :: mx, my, px, py, qx, qy! (mx,my) + (px,py) + (qx,qy) = (0,0)\n    integer :: iv, ibuff\n\n      allocate(  gg(-nx:nx,-global_ny:global_ny) )\n      allocate( psi(-nx:nx,-global_ny:global_ny) )\n      allocate( chi(-nx:nx,-global_ny:global_ny) )\n      allocate( wkpq_es(-nx:nx,-global_ny:global_ny) )\n      allocate( wpqk_es(-nx:nx,-global_ny:global_ny) )\n      allocate( wqkp_es(-nx:nx,-global_ny:global_ny) )\n      allocate( wkpq_em(-nx:nx,-global_ny:global_ny) )\n      allocate( wpqk_em(-nx:nx,-global_ny:global_ny) )\n      allocate( wqkp_em(-nx:nx,-global_ny:global_ny) )\n\n     !-set (mx,my)-\n      mx = triad_diag_mxt(it)\n      my = triad_diag_myt(it)\n\n     !-set wky-\n      dky = ky(1) - ky(0)\n      do py = -global_ny, global_ny\n        wky(py) = dky * real( py, kind=DP )\n      end do\n\n!$OMP parallel workshare\n      wkpq_es(:,:) = 0._DP\n      wpqk_es(:,:) = 0._DP\n      wqkp_es(:,:) = 0._DP\n      wkpq_em(:,:) = 0._DP\n      wpqk_em(:,:) = 0._DP\n      wqkp_em(:,:) = 0._DP\n!$OMP end parallel workshare\n      cs1 = sqrt( tau(ranks) / Anum(ranks) )\n!$OMP parallel default(none) &\n!$OMP shared(mx,my,kx,wky,vl,cs1,nbuff,wps,wch,wg) &\n!$OMP shared(wkpq_es,wpqk_es,wqkp_es,wkpq_em,wpqk_em,wqkp_em) &\n!$OMP private(px,py,qx,qy,iv,ibuff,psi,chi,gg)\n!$OMP do reduction(+:wkpq_es) reduction(+:wpqk_es) reduction(+:wqkp_es) &\n!$OMP    reduction(+:wkpq_em) reduction(+:wpqk_em) reduction(+:wqkp_em)\n      do ibuff = 0, nbuff-1\n\n       !-copy-\n        do py = 0, global_ny\n          do px = -nx, nx\n            psi(px,py) = wps(px,py,ibuff)\n            chi(px,py) = wch(px,py,ibuff)\n          end do\n        end do\n        do py = 1, global_ny\n          do px = -nx, nx\n            psi(-px,-py) = conjg( wps(px,py,ibuff) )\n            chi(-px,-py) = conjg( wch(px,py,ibuff) )\n          end do\n        end do\n\n        do iv = 1, 2*nv\n\n         !-copy-\n          do py = 0, global_ny\n            do px = -nx, nx\n              gg(px,py) = wg(px,py,iv,ibuff)\n            end do\n          end do\n          do py = 1, global_ny\n            do px = -nx, nx\n              gg(-px,-py) = conjg( wg(px,py,iv,ibuff) )\n            end do\n          end do\n\n         !-triad coupling among (mx,my)+(px,py)+(qx,qy)=0-\n          do py = max(-global_ny-my,-global_ny), min(global_ny,global_ny-my)\n            qy = - my - py\n            do px = max(-nx-mx,-nx), min(nx,nx-mx)\n              qx = - mx - px\n            !wkpq(px,py) = wkpq(px,py)                                         &\n            !  - (- kx(px) * wky(qy) + wky(py) * kx(qx))                       &\n            !  * real((  (psi(px,py) - cs1 * vl(iv) * chi(px,py)) * gg(qx,qy)  &\n            !          - (psi(qx,qy) - cs1 * vl(iv) * chi(qx,qy)) * gg(px,py)) &\n            !                                              * gg(mx,my), kind=DP)\n            !wpqk(px,py) = wpqk(px,py)                                         &\n            !  - (- kx(qx) * wky(my) + wky(qy) * kx(mx))                       &\n            !  * real((  (psi(qx,qy) - cs1 * vl(iv) * chi(qx,qy)) * gg(mx,my)  &\n            !          - (psi(mx,my) - cs1 * vl(iv) * chi(mx,my)) * gg(qx,qy)) &\n            !                                              * gg(px,py), kind=DP)\n            !wqkp(px,py) = wqkp(px,py)                                         &\n            !  - (- kx(mx) * wky(py) + wky(my) * kx(px))                       &\n            !  * real((  (psi(mx,my) - cs1 * vl(iv) * chi(mx,my)) * gg(px,py)  &\n            !          - (psi(px,py) - cs1 * vl(iv) * chi(px,py)) * gg(mx,my)) &\n            !                                              * gg(qx,qy), kind=DP)\n              wkpq_es(px,py) = wkpq_es(px,py)             &\n                - (- kx(px) * wky(qy) + wky(py) * kx(qx)) &\n                * real((  (psi(px,py)) * gg(qx,qy)        &\n                        - (psi(qx,qy)) * gg(px,py))       &\n                                      * gg(mx,my), kind=DP)\n              wpqk_es(px,py) = wpqk_es(px,py)             &\n                - (- kx(qx) * wky(my) + wky(qy) * kx(mx)) &\n                * real((  (psi(qx,qy)) * gg(mx,my)        &\n                        - (psi(mx,my)) * gg(qx,qy))       &\n                                      * gg(px,py), kind=DP)\n              wqkp_es(px,py) = wqkp_es(px,py)             &\n                - (- kx(mx) * wky(py) + wky(my) * kx(px)) &\n                * real((  (psi(mx,my)) * gg(px,py)        &\n                        - (psi(px,py)) * gg(mx,my))       &\n                                      * gg(qx,qy), kind=DP)\n              wkpq_em(px,py) = wkpq_em(px,py)                        &\n                - (- kx(px) * wky(qy) + wky(py) * kx(qx))            &\n                * real((  (- cs1 * vl(iv) * chi(px,py)) * gg(qx,qy)  &\n                        - (- cs1 * vl(iv) * chi(qx,qy)) * gg(px,py)) &\n                                                 * gg(mx,my), kind=DP)\n              wpqk_em(px,py) = wpqk_em(px,py)                        &\n                - (- kx(qx) * wky(my) + wky(qy) * kx(mx))            &\n                * real((  (- cs1 * vl(iv) * chi(qx,qy)) * gg(mx,my)  &\n                        - (- cs1 * vl(iv) * chi(mx,my)) * gg(qx,qy)) &\n                                                 * gg(px,py), kind=DP)\n              wqkp_em(px,py) = wqkp_em(px,py)                        &\n                - (- kx(mx) * wky(py) + wky(my) * kx(px))            &\n                * real((  (- cs1 * vl(iv) * chi(mx,my)) * gg(px,py)  &\n                        - (- cs1 * vl(iv) * chi(px,py)) * gg(mx,my)) &\n                                                 * gg(qx,qy), kind=DP)\n            end do\n          end do\n\n        end do\n      end do\n!$OMP end do\n!$OMP end parallel\n\n     !-zz,vl,mu integration-\n!$OMP parallel workshare\n      jkpq_es(:,:) = 0._DP\n      jpqk_es(:,:) = 0._DP\n      jqkp_es(:,:) = 0._DP\n      jkpq_em(:,:) = 0._DP\n      jpqk_em(:,:) = 0._DP\n      jqkp_em(:,:) = 0._DP\n!$OMP end parallel workshare\n      call MPI_Allreduce( wkpq_es, jkpq_es, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wpqk_es, jpqk_es, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wqkp_es, jqkp_es, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wkpq_em, jkpq_em, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wpqk_em, jpqk_em, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wqkp_em, jqkp_em, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n\n      deallocate(  gg )\n      deallocate( psi )\n      deallocate( chi )\n      deallocate( wkpq_es )\n      deallocate( wpqk_es )\n      deallocate( wqkp_es )\n      deallocate( wkpq_em )\n      deallocate( wpqk_em )\n      deallocate( wqkp_em )\n\n  END SUBROUTINE trans_triad_coupling\n\n\nEND MODULE GKV_trans\n", "MODULE GKV_colli\n!-------------------------------------------------------------------------------\n!\n!    Collision term\n!\n!    Update history of gkvp_colli.f90\n!    --------------\n!      gkvp_f0.61 (S. Maeyama, Mar 2020)\n!        - Treat tracer particles (fcs=0).\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Deallocations of gge, ggo are added.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only : clock_sta, clock_end\n  use GKV_bndry, only : bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n           bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout, &\n           bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_xy = 1, nchunk_yvb = 1, nchunk_ymb = 1\n\n  public   colli_set_param, colli_LB!, colli_full\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE colli_set_param (q0, eps_r, nust)\n!-------------------------------------------------------------------------------\n!\n!    Set parameters for GK collision term\n!\n!    by M. Nakata and M. Nunami, April 2014\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), parameter :: mp      = 1.67262178d-24, & ! proton mass in g\n                                ee      = 4.80320425d-10, & ! elementary charge in esu\n                                ev2erg  = 1.60217657d-12    ! erg/eV  (cf. 1J = 10^7 erg)\n    \n    real(kind=DP),                    intent(in)  :: q0, eps_r\n    real(kind=DP), dimension(0:ns-1,0:ns-1), intent(out) :: nust\n\n    real(kind=DP), dimension(0:ns-1)        :: tmpr, dens, freq_factor\n    real(kind=DP), dimension(0:ns-1,0:ns-1) :: log_lambda\n!    real(kind=DP)                           :: cph, dph, cgg\n\n    integer :: is, is1, is2\n  \n! --- temperature [in eV] and density [in cm^(-3)]\n    do is = 0, ns-1\n      tmpr(is) = tau(is) * Tref*1.d3\n      dens(is) = Nref*1.d-6 * fcs(is)/Znum(is)\n    end do\n\n! --- factor for collision frequencies\n    do is = 0, ns-1\n      freq_factor(is)  = (dens(is) * ee**4 * Lref*1.d2) / (Tref*1.d3*ev2erg)**2 \n    end do\n\n\n! --- Coulomb logarithm in cm^(-3) and eV units (see NRL plasma Formulary)  \n    do is1 = 0, ns-1\n      if (sgn(is1) < 0.d0) then  !! For is1 = electron\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! e-e case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23.5_DP - dlog( dsqrt( dens(is1) ) * tmpr(is1)**(-1.25_DP) )  &\n                                            - dsqrt( 1.d-5 + (( dlog(tmpr(is1)) - 2._DP )**2 )/16._DP )\n            end if\n          else                        !! e-i case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is1) ) / tmpr(is1) )\n            end if\n          end if\n        end do\n\n      else                     !! For is1 = ions\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! i-e case\n            if (dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is2) ) / tmpr(is2) )\n            end if\n          else                       !! i-i case\n            if (dens(is1) == 0.d0 .and. dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23._DP &\n                - dlog( Znum(is1)*Znum(is2)*(Anum(is1)+Anum(is2))/(Anum(is1)*tmpr(is2)+Anum(is2)*tmpr(is1)) &\n                        * dsqrt( (dens(is1) * Znum(is1)**2)/tmpr(is1)                                       &\n                               + (dens(is2) * Znum(is2)**2)/tmpr(is2) ) )\n            end if\n          end if\n        end do\n\n      end if\n    end do\n\n! --- Constant parameters\n    do is1 = 0, ns-1\n      do is2 = 0, ns-1 \n\n         ctauiv(is1,is2) = freq_factor(is2) * (8._DP*dsqrt(pi)/3._DP/dsqrt(2._DP))*log_lambda(is1,is2)  & \n                                   * ( Znum(is1)**2*Znum(is2)**2/dsqrt(Anum(is1))/tau(is1)**1.5 )\n\n         calpha(is1,is2) = dsqrt( tau(is1) * Anum(is2) / ( tau(is2) * Anum(is1) ) )\n         ctheta(is1,is2) = dsqrt( tau(is1) * ( Anum(is1) + Anum(is2) ) / ( tau(is1) * Anum(is2) + tau(is2) * Anum(is1) ) )\n\n         cgamma(is1,is2) = - Anum(is1) * calpha(is1,is2)                                      &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**1.5_DP \n\n         ceta(is1,is2)   = - tau(is1) * 3._DP * calpha(is1,is2)                               &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**2.5_DP\n\n          cxi(is1,is2)   =  calpha(is1,is2) * ( ctheta(is1,is2) - 1._DP ) * ctauiv(is1,is2)   &\n                             / dsqrt(1._DP + calpha(is1,is2)**2) \n\n         nust(is1,is2)   = q0*(ctauiv(is1,is2)/dsqrt(2._DP))/(eps_r**1.5*dsqrt(tau(is1)/Anum(is1)))\n\n      end do\n    end do\n\n!!!%%% Parameters for colli_full %%%\n!!!! --- xxa = v/vta/sqrt(2), where vta = sqrt(Ta/ma)\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1\n!!!          xxa(iz,iv,im) = dsqrt(vl(iv)**2 + vp(iz,im)**2)/dsqrt(2._DP) \n!!!        end do \n!!!      end do\n!!!    end do\n!!!\n!!!! --- collision frequencies and v-space functions\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1 \n!!!          do is1 = 0, ns-1\n!!!            do is2 = 0, ns-1 \n!!!\n!!!              cph = derf(calpha(is1,is2)*xxa(iz,iv,im))\n!!!              dph = 2._DP/dsqrt(pi)*dexp(-calpha(is1,is2)**2*xxa(iz,iv,im)**2)\n!!!              cgg = (cph - calpha(is1,is2)*xxa(iz,iv,im)*dph)/(calpha(is1,is2)**2*xxa(iz,iv,im)**2)*0.5_DP\n!!!\n!!!              nu_d(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*(cph-cgg)/xxa(iz,iv,im)**3\n!!!              nu_p(iz,iv,im,is1,is2) = 1.50_DP*dsqrt(pi)*ctauiv(is1,is2)*(  cgg  )/xxa(iz,iv,im)**3\n!!!              nu_h(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*calpha(is1,is2)*dph/xxa(iz,iv,im)**2\n!!!              nu_g(iz,iv,im,is1,is2) = nu_p(iz,iv,im,is1,is2)*xxa(iz,iv,im)**2*(1._DP-calpha(is1,is2)**2)\n!!!\n!!!              c_t0(iz,iv,im,is1,is2,1)  = - (1._DP + calpha(is1,is2)**2)*fmx(iz,iv,im)*nu_p(iz,iv,im,is1,is2)               &\n!!!                                             * xxa(iz,iv,im)**2*vl(iv)\n!!!              c_t0(iz,iv,im,is1,is2,2)  = - 1.5_DP*dsqrt(pi)*ctauiv(is1,is2)*fmx(iz,iv,im)                                  & \n!!!                                             * ( cph - calpha(is1,is2)*xxa(iz,iv,im)*(1._DP + calpha(is1,is2)**2)*dph )     & \n!!!                                             / calpha(is1,is2)**2 / xxa(iz,iv,im)\n!!!\n!!!              x_tst(1,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*fmx(iz,iv,im)*vl(iv)\n!!!              x_tst(2,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv) \n!!!              x_tst(3,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)/vl(iv)\n!!!              x_tst(4,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,1)                              &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)           &\n!!!                                                              * fmx(iz,iv,im)*vl(iv)/dsqrt(1._DP + calpha(is1,is2)**2) )\n!!!              x_tst(5,iz,iv,im,is1,is2) =  x_tst(4,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              x_tst(6,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,2)*2._DP/3._DP                &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)         &\n!!!                                                              * fmx(iz,iv,im)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)*2._DP     &\n!!!                                                               / (1._DP + calpha(is1,is2)**2)**1.5 )\n!!!\n!!!              y_fld(1,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))*calpha(is1,is2)*Anum(is1)             & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/tau(is1)/cgamma(is1,is2)     &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,1) - cxi(is1,is2)*fmx(iz,iv,im)*vl(iv) ) \n!!!              y_fld(2,iz,iv,im,is1,is2) = y_fld(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              y_fld(3,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))                                     & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/ceta(is1,is2)              &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,2)                                          &\n!!!                                                           - cxi(is1,is2)/(1._DP+calpha(is1,is2)**2)*fmx(iz,iv,im)        &\n!!!                                                               *(2._DP*xxa(iz,iv,im)**2 - 3._DP) ) \n!!!              y_fld(4,iz,iv,im,is1,is2) = - y_fld(1,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(5,iz,iv,im,is1,is2) = - y_fld(2,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(6,iz,iv,im,is1,is2) = - y_fld(3,iz,iv,im,is1,is2)*2._DP*cxi(is2,is1)/(1._DP+calpha(is2,is1)**2) \n!!!\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do\n!!!    end do \n!!!\n!!!! --- summation of collision frequencies with respect to is2, and adiabatic term (used in colli_GK_CT)\n!!!    nu_hs = 0._DP \n!!!    nu_gs = 0._DP \n!!!    nu_ds = 0._DP \n!!!    nu_ps = 0._DP \n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1 \n!!!            do is2 = 0, ns-1 \n!!!                nu_hs(iz,iv,im) = nu_hs(iz,iv,im) + nu_h(iz,iv,im,is1,is2)\n!!!                nu_gs(iz,iv,im) = nu_gs(iz,iv,im) + nu_g(iz,iv,im,is1,is2)\n!!!                nu_ds(iz,iv,im) = nu_ds(iz,iv,im) + nu_d(iz,iv,im,is1,is2)\n!!!                nu_ps(iz,iv,im) = nu_ps(iz,iv,im) + nu_p(iz,iv,im,is1,is2)\n!!!            end do \n!!!          end do \n!!!        end do\n!!!      end do \n!!!\n!!!    if (trim(col_type) == \"lorentz\") then\n!!!      nu_hs(:,:,:) = 0._DP\n!!!      nu_ps(:,:,:) = 0._DP\n!!!      x_tst(:,:,:,:,:,:) = 0._DP\n!!!      y_fld(:,:,:,:,:,:) = 0._DP\n!!!      nu_gs(:,:,:) = - nu_ds(:,:,:)\n!!!    end if\n!!!\n!!!! --- adiabatic part (used in colli_GK_CT)\n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!\n!!!        if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                               - ( nu_ds(iz,iv,im)*vl(iv)**2                           &\n!!!                                     * ksq(mx,my,iz)*Anum(is1)/Znum(is1)/omg(iz)**2    &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        else\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                                 ( -( nu_ds(iz,iv,im)*vl(iv)**2                        &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2                     &\n!!!                                     * (j0(mx,my,iz,im) - j2(mx,my,iz,im))             &\n!!!                                   -( nu_hs(iz,iv,im)*vp(iz,im)                        &\n!!!                                       - 0.5_DP*nu_ps(iz,iv,im)*vp(iz,im)              &\n!!!                                               *(1._DP-vl(iv)**2-vp(iz,im)**2)         &\n!!!                                       + 0.5_DP*nu_ds(iz,iv,im)                        &\n!!!                                               *(vl(iv)**2/vp(iz,im)-vp(iz,im)) )      &\n!!!                                     * dsqrt(ksq(mx,my,iz)*Anum(is1)/tau(is1))/omg(iz) &\n!!!                                     * j1(mx,my,iz,im)                                 &\n!!!                                   -( nu_ds(iz,iv,im)                                  &\n!!!                                               *(2._DP*vl(iv)**2+vp(iz,im)**2)         &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2 * j0(mx,my,iz,im)   &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        end if\n!!!\n!!!      end do\n!!!\n!!!\n!!!! --- set v-space functions used in colli_moment\n!!!\n!!!    vfunc(:,:,:,:,:) = 0._DP\n!!!    jfunc(:,:,:,:,:) = 0._DP\n!!!\n!!!    ", "if ( iFLR == 1 ) then\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = & \n!!!      !                              j1(mx,my,iz,im)*vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = j0(mx,my,iz,im)*vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = j1(mx,my,iz,im)*vp(iz,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = j0(mx,my,iz,im)*(xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = vp(iz,im)\n!!!                vfunc(iz,iv,im,is2,6) = xxa(iz,iv,im)**2-1.5_DP\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,2) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,3) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,4) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,5) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,6) = j0(mx,my,iz,im)\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!   \n!!!    else \n!!!\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = 0._DP\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = 0._DP\n!!!                vfunc(iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = 1._DP\n!!!              jfunc(mx,my,iz,im,2) = 0._DP\n!!!              jfunc(mx,my,iz,im,3) = 1._DP\n!!!              jfunc(mx,my,iz,im,4) = 1._DP\n!!!              jfunc(mx,my,iz,im,5) = 0._DP\n!!!              jfunc(mx,my,iz,im,6) = 1._DP\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!\n!!!    end if\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n! -----------------------------------\n! --- Output constants\n    if ( rankg == nprocz/2 ) then\n\n      do is1 = 0, ns-1\n        do is2 = 0, ns-1 \n          write(unit=ocst,fmt=\"(2I3,SP,256ES24.15e3)\") is1, is2, ctheta(is1,is2), calpha(is1,is2), &\n                                                                 fcs(is1)/Znum(is1)*ceta(is1,is2), &\n                                                               fcs(is1)/Znum(is1)*cgamma(is1,is2), & \n                                                                    cxi(is1,is2), ctauiv(is1,is2), &\n                                                                              log_lambda(is1,is2)\n! --- Note that, for ns >=3, cgamma(is1,is2) /= cgamma(is2,is1), but dens(is1)*cgamma(is1,is2) = dense(is2)*cgamma(is2,is1)\n! ---  due to normalizartion with dens(is). \n        end do\n      end do\n\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=4000,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_h(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_g(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_d(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_p(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=4000,fmt=*)\n!        write (unit=4001,fmt=*)\n!        write (unit=4002,fmt=*)\n!        write (unit=4003,fmt=*)\n!        write (unit=4004,fmt=*)\n!        write (unit=4005,fmt=*)\n!      end do\n!\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=5001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=5001,fmt=*)\n!        write (unit=5002,fmt=*)\n!        write (unit=5003,fmt=*)\n!        write (unit=5004,fmt=*)\n!        write (unit=5005,fmt=*)\n!        write (unit=5006,fmt=*)\n!        write (unit=6001,fmt=*)\n!        write (unit=6002,fmt=*)\n!        write (unit=6003,fmt=*)\n!        write (unit=6004,fmt=*)\n!        write (unit=6005,fmt=*)\n!        write (unit=6006,fmt=*)\n!      end do\n\n    end if\n\n    return\n\n   END SUBROUTINE colli_set_param\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB( ff, phi, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: gge, ggo\n    integer :: iz\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_xy = ((2*nx+1)*(ny+1)-1) / (nthreads-1) + 1\n!$      nchunk_yvb = ((ny+1)*(2*nv)*(2*nvb)-1) / (nthreads-1) + 1\n!$      nchunk_ymb = ((ny+1)*(nm+1)*(2*nvb)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( vb1e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( mb1e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( mb2e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( gge(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) )\n      allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( ggo(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,phi,cf,vb1e,vb2e,mb1e,mb2e,gge) &\n!$OMP shared(vb1o,vb2o,mb1o,mb2o,ggo) &\n!$OMP private(iz)\n\n!$OMP workshare\n      vb1e(:,:,:,:) = (0._DP, 0._DP)\n      vb2e(:,:,:,:) = (0._DP, 0._DP)\n      mb1e(:,:,:,:) = (0._DP, 0._DP)\n      mb2e(:,:,:,:) = (0._DP, 0._DP)\n       gge(:,:,:,:) = (0._DP, 0._DP)\n      vb1o(:,:,:,:) = (0._DP, 0._DP)\n      vb2o(:,:,:,:) = (0._DP, 0._DP)\n      mb1o(:,:,:,:) = (0._DP, 0._DP)\n      mb2o(:,:,:,:) = (0._DP, 0._DP)\n       ggo(:,:,:,:) = (0._DP, 0._DP)\n      cf(:,:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n!!%%% Without overlap %%%\n!      do iz = -nz, nz-1\n!        call colli_LB_buffin(iz, ff, phi, vb1e, mb1e)\n!!$OMP barrier\n!!$OMP master\n!        call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!!$OMP barrier\n!        call colli_LB_buffout(iz, ff, phi, vb2e, mb2e, gge)\n!!$OMP barrier\n!        call colli_LB_calc(iz, gge, cf)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      do iz = -nz, nz-1+3\n        if (mod(iz+nz,2) == 0) then ! even\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1e, mb1e)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2e, mb2e, gge)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, ggo, cf)\n        else                        ! odd\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1o, mb1o)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2o, mb2o, ggo)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, gge, cf)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( vb1e )\n      deallocate( vb2e )\n      deallocate( mb1e )\n      deallocate( mb2e )\n      deallocate(  gge )\n      deallocate( vb1o )\n      deallocate( vb2o )\n      deallocate( mb1o )\n      deallocate( mb2o )\n      deallocate(  ggo )\n\n  END SUBROUTINE colli_LB\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_buffin( iz, ff, phi, vb1, mb1 )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    real(kind=DP) :: cs1\n    integer :: mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_ymb)\n      do iv = 1, nvb\n        do im = 0, nm\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im) &\n                                  + cs1 * fmx(iz,         iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n              vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im) &\n                                  + cs1 * fmx(iz,2*nv-nvb+iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_yvb)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1) &\n                                  + cs1 * fmx(iz,iv,     im-1) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im) &\n                                  + cs1 * fmx(iz,iv,nm-nvb+im) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffin\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout( iz, ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          do im = 0, nm\n            do iv = 1, 2*nv\n              gg(iv,im,mx,my) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = (0._DP, 0._DP)\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = (0._DP, 0._DP)\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc( iz, gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                         ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n      cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n      cef4 = nu_s / ( 12._DP * dvp(iz) )\n      cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                  / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n\n      if ( rankm /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                           ) * cef1                                    &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &      \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankm == 0\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            im = 0\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            -          gg(iv,im+2,mx,my)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            im = 1\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im  ,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im  ,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &   \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            do im = 2, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                    ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc\n\n\n\n!!--------------------------------------\n!  SUBROUTINE colli_LB( ff, phi, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n!    integer :: iz\n!\n!      allocate( vb1e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!\n!!$OMP parallel default(none) &\n!!$OMP shared(ff,cf,vb1e,vb2e,mb1e,mb2e) &\n!!$OMP shared(vb1o,vb2o,mb1o,mb2o) &\n!!$OMP private(iz)\n!\n!!!%%% Without overlap %%%\n!!      do iz = -nz, nz-1\n!!        call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!!!$OMP barrier\n!!!$OMP master\n!!        call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!!$OMP end master\n!!!$OMP barrier\n!!        call bndry_vm_buffout(iz, vb2e, mb2e, ff)\n!!!$OMP barrier\n!!        call colli_LB_model_rev(iz, ff, cf)\n!!!$OMP barrier\n!!      end do\n!!!%%%%%%%%%%%%%%%%%%%%%%%\n!\n!\n!!%%% With overlap %%%\n!      do iz = -nz, nz-1+3\n!        if (mod(iz+nz,2) == 0) then ! even\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2e, mb2e, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        else                        ! odd\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1o, mb1o)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2o, mb2o, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        end if\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%\n!\n!!$OMP end parallel\n!\n!      deallocate( vb1e )\n!      deallocate( vb2e )\n!      deallocate( mb1e )\n!      deallocate( mb2e )\n!      deallocate( vb1o )\n!      deallocate( vb2o )\n!      deallocate( mb1o )\n!      deallocate( mb2o )\n!\n!  END SUBROUTINE colli_LB\n!\n!\n!!--------------------------------------\n!  ", "SUBROUTINE colli_LB_model_rev( iz, ff, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    integer, intent(in) :: iz\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4\n!    integer  ::  mx, my, iv, im\n!\n!\n!!$OMP master\n!                                           call clock_sta(1311)\n!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!$OMP end master\n!\n!! --- Note that nu(ranks) is a bias factor \n!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!      nu_s = 1.d-3\n!\n!      cef1   = nu_s / ( 12._DP * dv * dv )\n!      cef2   = nu_s / ( 12._DP * dv )\n!      cef3   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!      cef4   = nu_s / ( 12._DP * dvp(iz) )\n!\n!      if( rankm /= 0  ) then\n!\n!        do im = 0, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!                              -          ff(mx,my,iz,iv-2,im)                 &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                               * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      else\n!\n!        im = 0\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -          ff(mx,my,iz,iv,im+2)                &\n!                             ) * cef3 * 2._DP                                 &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        im = 1\n!\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        do im = 2, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      end if\n!\n!!$OMP master\n!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!                                      call clock_end(1311)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE colli_LB_model_rev\n\n\n\n\n!!!!%%% Subroutines for colli_LB (old version) %%%\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_LB( ff, phi, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    integer :: im\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(ff,cf,vb1,vb2,mb1,mb2) &\n!!!!$OMP private(im)\n!!!\n!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!$OMP barrier\n!!!\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!      call colli_zeroset( cf )\n!!!!$OMP barrier\n!!!\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_m_buffout ( mb2, ff )\n!!!!$OMP barrier\n!!!\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!      call colli_LB_model( ff, nm-1, cf(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!      call colli_LB_model( ff, nm, cf(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!\n!!!  END SUBROUTINE colli_LB\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_LB_model( ff, im, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    real(kind=DP) :: nu_s, cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3, cef4\n!!!    integer  ::  mx, my, iz, iv\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1311)\n!!!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!! --- Note that nu(ranks) is a bias factor \n!!!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!!!      nu_s = 1.d-3\n!!!\n!!!      cef1   = nu_s / ( 12._DP * dv * dv )\n!!!      cef2   = nu_s / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!        cef4(iz)   = nu_s / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!      if( rankm /= 0  ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                           &\n!!!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!!!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!!!                              -          ff(mx,my,iz,iv-2,im)                 &\n!!!                             ) * cef1                                         &\n!!!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                               +          ff(mx,my,iz,iv-2,im)                &\n!!!                             ) * cef2 * vl(iv)                                &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               -          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef3(iz)                                     &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!!!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!!$OMP end do nowait\n!!!          end do\n!!!\n!!!      else\n!!!\n!!!          if ( im == 0 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -          ff(mx,my,iz,iv,im+2)                &\n!!!                               ) * cef3(iz) * 2._DP                             &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else if ( im == 1 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else  ! 2=<im=<nm\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          end if\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_LB_model\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_zeroset( cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    zero clear for collision terms \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)    :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv,im) = ( 0._DP, 0._DP )     \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_zeroset\n\n\n!!!%%% Subroutines for colli_full %%%\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 4th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 12._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 32._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -  2._DP * ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 31._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[2,nm] nm for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( -          ff(mx,my,iz,iv,im-2)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT6( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 6th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 90._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 60._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 90._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 270._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               -   27_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +   2._DP * ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 135._DP  * ff(mx,my,iz,iv,im-1)                   &\n!!!                               - 258.5_DP * ff(mx,my,iz,iv,im  )                   &\n!!!                               + 136._DP  * ff(mx,my,iz,iv,im+1)                   &\n!!!                               - 13.5_DP  * ff(mx,my,iz,iv,im+2)                   &\n!!!                               +            ff(mx,my,iz,iv,im+3)                   &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 2 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 136._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[3,nm] for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( +           ff(mx,my,iz,iv,im-3)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_DT( moment_ab_wk, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Non-isothermal terms of test particle part and field particle part \n!!!!                                                      in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1312)\n!!!                                    ! call fapp_start(\"literm_colli_dt\",1312,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dt\",1312,1)\n!!!                                      call clock_end(1312)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_GK_CF_DT(moment_ba_wk, moment_ab_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle and non-isothermal parts in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk, moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CF(moment_ba_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle part in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)         \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_calc( hh, phi, ww )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: local velocity moment part \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!\n!!!    !complex(kind=DP), intent(out), &\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!\n!!!    real(kind=DP) :: v2a, v2b, dflg\n!!!    complex(kind=DP) :: wf1, wf2\n!!!    integer :: mx, my, iz, iv, im, is1, is2, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1314)\n!!!                                    ! call fapp_start(\"literm_colli_mom\",1314,1)\n!!!!$OMP end master\n!!!\n!!!      if ( rankm == 0 ) then\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii,v2a,v2b,wf1,wf2)\n!!!      do ii = 1, 6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!\n!!!! for edge compensation\n!!!!         im  = 1\n!!!          do im = 1, 1\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !v2a = vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    !v2b = vfunc(mx,my,iz,iv,im+1,is2,ii)\n!!!                    v2a = jfunc(mx,my,iz,im,ii)  *vfunc(iz,iv,im,is2,ii)\n!!!                    v2b = jfunc(mx,my,iz,im+1,ii)*vfunc(iz,iv,im+1,is2,ii)\n!!!                    wf1 = hh(mx,my,iz,iv,im)   \n!!!                    wf2 = hh(mx,my,iz,iv,im+1)\n!!!                    ww(mx,my,iz,is2,ii)  = ww(mx,my,iz,is2,ii)            &\n!!!                          - ( - wf1/12._DP*v2a + ( wf2*v2b - wf1*2._DP*v2a )*11._DP/720._DP ) \n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      else\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii)\n!!!      do ii=1,6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_mom\",1314,1)\n!!!                                      call clock_end(1314)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_calc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_redc( ww, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: All_reduce_part\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww\n!!! \n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: wn\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1315)\n!!!                                         ! call fapp_start(\"literm_colli_ar\",1315,1)\n!!!!$OMP end master\n!!!\n!!!      call MPI_Allreduce( ww, wn, nxyz*ns*6, MPI_DOUBLE_COMPLEX, &\n!!!                          MPI_SUM, vel_comm_world, ierr_mpi )\n!!!\n!!!!$OMP master\n!!!                                         ! call fapp_stop(\"literm_colli_ar\",1315,1)\n!!!                                           call clock_end(1315)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_redc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_comm_alltoall( wm, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Inter-species communication of moment quantities for field particle part\n!!!!       with MPI_AlltoAll\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wm\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wn\n!!!\n!!!    complex(kind=DP),              & \n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:6,0:ns-1)  :: send_buff, recv_buff\n!!!\n!!!    integer :: mx, my, iz, is, ii\n!!!    integer :: datasize, datasize_ns\n!!!\n!!!\n!!!!$OMP master\n!!!                                       call clock_sta(1316)\n!!!                                     ! call fapp_start(\"literm_colli_com\",1316,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      datasize = (2*nx+1)*(ny+1)*(2*nz)*6\n!!!      datasize_ns = (2*nx+1)*(ny+1)*(2*nz)*6*ns\n!!!\n!!!      if ( vel_rank == 0 ) then\n!!!\n!!!        do ii = 1, 6\n!!!          do is = 0, ns-1\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!!                  send_buff(mx,my,iz,ii,is)  = real(ranks,kind=DP) + ii ! for debug\n!!!                  send_buff(mx,my,iz,ii,is)  = wm(mx,my,iz,is,ii)\n!!!                end do\n!!!              end do \n!!!            end do\n!!!          end do\n!!!        end do\n!!!\n!!!\n!!!          call MPI_Alltoall( send_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  &\n!!!                             recv_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  & \n!!!                             col_comm_world, ierr_mpi  )\n!!! \n!!!!! --- for debug \n!!!!        write(unit=8000+ranks,fmt=\"(I3,SP,6ES24.15e3)\") ranks, real(recv_buff(0,1,1,1,0)), real(recv_buff(0,1,1,6,0)), &\n!!!!                                                           real(recv_buff(0,1,1,1,1)), real(recv_buff(0,1,1,6,1)), &\n!!!!                                                           real(recv_buff(0,1,1,1,2)), real(recv_buff(0,1,1,6,2))\n!!!!        write(unit=8000+ranks,fmt=*)\n!!!\n!!!      end if\n!!!\n!!!\n!!!      call MPI_Bcast( recv_buff(-nx,ist_y,-nz,1,0), datasize_ns, MPI_DOUBLE_COMPLEX, & \n!!!                      0, vel_comm_world, ierr_mpi  ) \n!!!\n!!!\n!!!      do is = 0, ns-1\n!!!        do ii = 1, 6\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wn(mx,my,iz,is,ii) = recv_buff(mx,my,iz,ii,is)\n!!!              end do\n!!!            end do \n!!!          end do\n!!!        end do         \n!!!      end do         \n!!!\n!!!!$OMP master\n!!!                                     ! call fapp_stop(\"literm_colli_com\",1316,1)\n!!!                                       call clock_end(1316)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_comm_alltoall\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_dfdvp( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 4th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im  )                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!        do im = 2, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!\n!!!      else   \n!!!\n!!!        do im = 0, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_dfdvp6( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 6th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 60._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 44._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 2\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 46._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 3, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!\n!!!      else   \n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_hhset(hh,phi,ff)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    real(kind=DP) :: dflg\n!!!    integer :: mx, my, iz, iv, im, is1\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!     !dflg = real(1-icheck,kind=DP)\n!!!      dflg = real(1-icheck,kind=DP) * real(iFLR,kind=DP)\n!!!\n!!!      is1 = ranks\n!!!!$OMP do collapse(2) private(mx,my,iz,iv,im)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                hh(mx,my,iz,iv,im) = ( ff(mx,my,iz,iv,im) + dflg*sgn(is1)*j0(mx,my,iz,im)*phi(mx,my,iz)   &\n!!!                                                                * fmx(iz,iv,im)*Znum(is1)/tau(is1) )      &\n!!!                                    * vp(iz,im) * dvp(iz) * dv * twopi\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_hhset\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_wwset(ww)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!    integer :: mx, my, iz, is1, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,is1,ii)\n!!!    do ii = 1, 6\n!!!      do is1 = 0, ns-1\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx, nx\n!!!              ww(mx,my,iz,is1,ii) = ( 0._DP, 0._DP )\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!    end do \n!!!!$OMP end do\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_wwset\n!!!\n!!!\n!!!!!--------------------------------------\n!!!!  ", "SUBROUTINE colli_full( ff, phi, cf )! Analytic derivative of J0*phi\n!!!!!--------------------------------------\n!!!!!   Sugama collision operator\n!!!!\n!!!!    complex(kind=DP), intent(inout), &\n!!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!!    complex(kind=DP), intent(in), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!!    complex(kind=DP), intent(out), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!!\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!!\n!!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff,phi,dfdvp) &\n!!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP private(im,ii) \n!!!!\n!!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!      call colli_hhset(hh2,phi,ff)\n!!!!      call colli_wwset(wrkm)\n!!!!!$OMP barrier\n!!!!\n!!!!!----------------------------------------------------- ovlp1\n!!!!!$OMP master\n!!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!!$OMP end master\n!!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!!      call colli_zeroset( cff )\n!!!!\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      call bndry_shifts_m_buffout ( mb2, ff )\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp2\n!!!!!$OMP master\n!!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!!$OMP end master\n!!!!\n!!!!!!!      call colli_dfdvp6( ff, dfdvp ) ! 6th-order CFD\n!!!!      call colli_dfdvp( ff, dfdvp ) ! 4th-order CFD\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp3\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!! --- No calculations appear here in f0.52 (Nakata July2015)\n!!!!!!!      call colli_zeroset( cdt )\n!!!!\n!!!!!$OMP barrier\n!!!!\n!!!!      do im = 1, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!!\n!!!!!-----------------------------------------------------\n!!!!!$OMP end parallel\n!!!!\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP shared(phi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!!\n!!!!!----------------------------------------------------- ovlp4\n!!!!!$OMP master\n!!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!!$OMP end master\n!!!!\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!!do nn = 0, ns-1\n!!!!  do iz = -nz, nz-1\n!!!!    do my = ist_y, iend_y\n!!!!      do mx = -nx, nx\n!!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!!\n!!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!!      enddo\n!!!!    enddo\n!!!!  enddo\n!!!!enddo\n!!!!!$OMP enddo\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp5\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp6\n!!!!      im = 1\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp7\n!!!!      im = 2\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD \n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp8\n!!!!      do im = 3, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD\n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!!----------------------------------------------------- \n!!!!\n!!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!!$OMP barrier\n!!!!\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP end parallel\n!!!!\n!!!!!$OMP parallel workshare\n!!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!!$OMP end parallel workshare\n!!!!\n!!!!      deallocate( vb1 )\n!!!!      deallocate( vb2 )\n!!!!      deallocate( mb1 )\n!!!!      deallocate( mb2 )\n!!!!      deallocate( cft )\n!!!!      deallocate( cff )\n!!!!      deallocate( wrkm )\n!!!!      deallocate( moment_ab )\n!!!!      deallocate( moment_ba )\n!!!!      deallocate( moment_ab_wk )\n!!!!      deallocate( moment_ba_wk )\n!!!!      deallocate( dfdvp )\n!!!!      deallocate( hh2 )\n!!!!\n!!!!  END SUBROUTINE colli_full\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_full( ff, phi, cf )! Finite difference of J0*phi\n!!!!--------------------------------------\n!!!!   Sugama collision operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: wff\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: wphi\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!\n!!!!$OMP parallel do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wff(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n!!!                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n!!!                                                                     * real(iFLR, kind=DP)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!      wphi(:,:,:) = (0._DP, 0._DP)\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(ff,wff,phi,dfdvp) &\n!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP private(im,ii) \n!!!\n!!!      call bndry_shifts_m_buffin ( wff, mb1, mb2 )\n!!!      call colli_hhset(hh2,phi,ff)\n!!!      call colli_wwset(wrkm)\n!!!!$OMP barrier\n!!!\n!!!!----------------------------------------------------- ovlp1\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!      call colli_zeroset( cff )\n!!!\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      call bndry_shifts_m_buffout ( mb2, wff )\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp2\n!!!!$OMP master\n!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!$OMP end master\n!!!\n!!!!!!      call colli_dfdvp6( ff, dfdvp ) ! 6th-order CFD\n!!!      call colli_dfdvp( wff, dfdvp ) ! 4th-order CFD\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp3\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!! --- No calculations appear here in f0.52 (Nakata July2015)\n!!!!!!      call colli_zeroset( cdt )\n!!!\n!!!!$OMP barrier\n!!!\n!!!      do im = 1, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!\n!!!!-----------------------------------------------------\n!!!!$OMP end parallel\n!!!\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(wff) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP shared(wphi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!\n!!!!----------------------------------------------------- ovlp4\n!!!!$OMP master\n!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!$OMP end master\n!!!\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( wff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!do nn = 0, ns-1\n!!!  do iz = -nz, nz-1\n!!!    do my = ist_y, iend_y\n!!!      do mx = -nx, nx\n!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!\n!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!      enddo\n!!!    enddo\n!!!  enddo\n!!!enddo\n!!!!$OMP enddo\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp5\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp6\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp7\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD \n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp8\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD\n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!!----------------------------------------------------- \n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), wff(:,:,:,:,nm) )\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!!$OMP parallel workshare\n!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!$OMP end parallel workshare\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!      deallocate( cft )\n!!!      deallocate( cff )\n!!!      deallocate( wrkm )\n!!!      deallocate( moment_ab )\n!!!      deallocate( moment_ba )\n!!!      deallocate( moment_ab_wk )\n!!!      deallocate( moment_ba_wk )\n!!!      deallocate( dfdvp )\n!!!      deallocate( hh2 )\n!!!\n!!!  END SUBROUTINE colli_full\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nEND MODULE GKV_colli\n", "MODULE GKV_fld\n!-------------------------------------------------------------------------------\n!\n!    Field solver\n!\n!    Update history of gkvp_fld.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Intent is changed from intent(out) :: phi to intent(inout) :: phi,\n!          to keep initialized values at padding iend_y<my.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_intgrl, only: intgrl_fsrf, intgrl_v0_moment, intgrl_v0_moment_ms\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   fld_esfield, fld_emfield_ff, fld_emfield_hh, fld_ff2hh, fld_hh2ff\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE fld_esfield ( ff, phi )\n!--------------------------------------\n!     electrostatic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw, ww\n    complex(kind=DP), dimension(-nx:nx) :: zf\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n                                           call clock_sta(1220)\n                                        ! call fapp_start(\"esfield_v0moment\",1220,1)\n      call intgrl_v0_moment_ms ( wf, nw )\n                                        ! call fapp_stop(\"esfield_v0moment\",1220,1)\n                                           call clock_end(1220)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          nw(0,0,iz) = ( 0._DP, 0._DP )      !  zero-zero\n        end do\n      end if\n\n      if ( ns == 1 ) then\n! --- adiabatic model for ITG-ae or ETG-ai\n        \n        zf = ( 0._DP, 0._DP )\n\n        if ( sgn(0) > 0._DP ) then ! --- ZF-calculation for ITG-ae \n\n         ! --- calculation of zonal flow potential\n          if ( rankw == 0 ) then\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n            my   = 0\n!$OMP parallel do\n            do iz = -nz, nz-1\n                do mx = -nx, -1\n                  ww(mx,my,iz)   = nw(mx,my,iz)                                     &\n                               / ( (  1._DP - g0(mx,my,iz)  + tau(0)*tau_ad ) * fctgt(mx) )\n                end do\n                mx = 0\n                  ww(mx,my,iz) = (0._DP, 0._DP)\n                do mx = 1, nx\n                  ww(mx,my,iz)   = nw(mx,my,iz)                                     &\n                               / ( (  1._DP - g0(mx,my,iz)  + tau(0)*tau_ad ) * fctgt(mx) )\n                end do\n            end do\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n    \n                                           call clock_sta(1230)\n                                        ! call fapp_start(\"esfield_fsrf\",1230,1)\n            call intgrl_fsrf ( ww, zf )\n                                        ! call fapp_stop(\"esfield_fsrf\",1230,1)\n                                           call clock_end(1230)\n    \n            zf(0)   = ( 0._DP, 0._DP )\n\n          end if\n\n        end if\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              phi(mx, my,iz) = nw(mx, my,iz) / ( 1._DP - g0(mx, my,iz) + tau(0)*tau_ad )\n            end do\n          end do\n        end do\n  \n        if ( rankw == 0 ) then\n!$OMP parallel do private(my)\n          do iz = -nz, nz-1\n            my = 0\n              do mx = -nx, nx\n              phi(mx,my,iz) = ( nw(mx,my,iz) + zf(mx)*tau(0)*tau_ad ) &\n                             / ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )\n              end do\n          end do\n        end if\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n      else\n! --- kinetic model for multi-species\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              phi(mx,my,iz) = nw(mx,my,iz) * fct_poisson(mx,my,iz)\n            end do\n          end do\n        end do\n\n      deallocate( wf )\n      deallocate( nw )\n      deallocate( ww )\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n      end if\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          phi(0,0,iz) = ( 0._DP, 0._DP )\n        end do\n      end if\n\n\n  END SUBROUTINE fld_esfield\n\n\n!--------------------------------------\n  SUBROUTINE fld_emfield_ff ( ff, Al )\n!--------------------------------------\n!     magnetic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks) &\n                                   * sqrt( tau(ranks) / Anum(ranks) ) * vl(iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n                                           call clock_sta(1220)\n                                        ! call fapp_start(\"esfield_v0moment\",1220,1)\n      call intgrl_v0_moment_ms ( wf, nw )\n                                        ! call fapp_stop(\"esfield_v0moment\",1220,1)\n                                           call clock_end(1220)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          nw(0,0,iz) = ( 0._DP, 0._DP )      !  zero-zero\n        end do\n      end if\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n\n              if ( rankw == 0.and. mx == 0.and. my == 0 ) then\n                Al(mx,my,iz) = ( 0._DP, 0._DP )\n              else\n                Al(mx,my,iz) = nw(mx,my,iz) * beta / ksq(mx,my,iz)\n              end if\n\n            end do\n          end do\n        end do\n\n      deallocate( wf )\n      deallocate( nw )\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n  END SUBROUTINE fld_emfield_ff\n\n\n!--------------------------------------\n  SUBROUTINE fld_emfield_hh ( hh, Al )\n!--------------------------------------\n!     magnetic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks) &\n                                   * sqrt( tau(ranks) / Anum(ranks) ) * vl(iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n                                           call clock_sta(1220)\n                                        ! call fapp_start(\"esfield_v0moment\",1220,1)\n      call intgrl_v0_moment_ms ( wf, nw )\n                                        ! call fapp_stop(\"esfield_v0moment\",1220,1)\n                                           call clock_end(1220)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          nw(0,0,iz) = ( 0._DP, 0._DP )      !  zero-zero\n        end do\n      end if\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              Al(mx,my,iz) = nw(mx,my,iz) * beta * fct_ampere(mx,my,iz)\n            end do\n          end do\n        end do\n\n      deallocate( wf )\n      deallocate( nw )\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          Al(0,0,iz) = ( 0._DP, 0._DP )\n        end do\n      end if\n\n\n  END SUBROUTINE fld_emfield_hh\n\n\n!--------------------------------------\n  SUBROUTINE fld_ff2hh ( ff, Al, hh )\n!--------------------------------------\n!     ff -> hh\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n\n    integer :: mx, my, iz, iv, im\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                hh(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im)  &\n                    + sgn(ranks) * Znum(ranks)  / sqrt( Anum(ranks) * tau(ranks) )  &\n                    * fmx(iz,iv,im) * vl(iv) * j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n\n  END SUBROUTINE fld_ff2hh\n\n\n!--------------------------------------\n  SUBROUTINE fld_hh2ff ( hh, Al, ff )\n!--------------------------------------\n!     hh -> ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iz, iv, im\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im)  &\n                      - sgn(ranks) * Znum(ranks)  / sqrt( Anum(ranks) * tau(ranks) )  &\n                      * fmx(iz,iv,im) * vl(iv) * j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n\n  END SUBROUTINE fld_hh2ff\n\n\nEND MODULE GKV_fld\n", "MODULE GKV_bndry\n!-------------------------------------------------------------------------------\n!\n!    MPI send/recv communications in zz,vl,mu\n!\n!    Update history of gkvp_bndry.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n/\n  public   bndry_zvm_bound_f, bndry_bound_e,  &\n      bndry_bound_f_buffin, bndry_bound_f_sendrecv, bndry_bound_f_buffout,  &\n      bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout,  &\n      bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout, &\n      bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n      bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zvm_bound_f( ff )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n    integer :: im\n\n      allocate( zb1_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n\n!$OMP parallel default (none) &\n!$OMP shared(ff,zb1_bottom,zb1_top,zb2_bottom,zb2_top,vb1,vb2,mb1,mb2) &\n!$OMP private(im)\n      do im = 0, nm\n        call bndry_bound_f_buffin ( ff(:,:,:,:,im), zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_bound_f_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                      zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_bound_f_buffout ( zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      do im = 0, nm\n        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!$OMP barrier\n!$OMP master\n      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!$OMP end master\n!$OMP barrier\n      call bndry_shifts_m_buffout ( mb2, ff )\n!$OMP end parallel\n\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n      deallocate( vb1 )\n      deallocate( vb2 )\n      deallocate( mb1 )\n      deallocate( mb2 )\n\n  END SUBROUTINE bndry_zvm_bound_f\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffin( ff, zb1_bottom, zb1_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                zb1_bottom(mx,my,iz,iv) = ff(mx,my,-nz+iz  ,iv)\n                zb1_top   (mx,my,iz,iv) = ff(mx,my, nz-nzb+iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_bound_f_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffout ( zb2_bottom, zb2_top, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffout\n\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_buffin( ff, vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1, vb2\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1361)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1361,1)\n!$OMP end master\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do iv = 1, 2*nvb\n!$OMP do schedule (dynamic)\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                vb1(mx,my,iz,iv    ) = ff(mx,my,iz,         iv)\n                vb1(mx,my,iz,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv)\n!              vb1(mx,my,iz,1) = ff(mx,my,iz,     1)\n!              vb1(mx,my,iz,2) = ff(mx,my,iz,     2)\n!              vb1(mx,my,iz,3) = ff(mx,my,iz,     3)\n!              vb1(mx,my,iz,4) = ff(mx,my,iz,2*nv-2)\n!              vb1(mx,my,iz,5) = ff(mx,my,iz,2*nv-1)\n!              vb1(mx,my,iz,6) = ff(mx,my,iz,2*nv  )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1361,1)\n                                           call clock_end(1361)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_sendrecv( vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    integer  ::  slngv\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1362)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1362,1)\n!      call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n!                         vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n!                         vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1362,1)\n                                           call clock_end(1362)\n\n\n  END SUBROUTINE bndry_shifts_v_sendrecv\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_shifts_v_buffout( vb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1363)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1363,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                ff(mx,my,iz,-nvb+iv) = vb2(mx,my,iz,iv    )\n                ff(mx,my,iz,2*nv+iv) = vb2(mx,my,iz,iv+nvb)\n!              ff(mx,my,iz,    -2) = vb2(mx,my,iz,1)\n!              ff(mx,my,iz,    -1) = vb2(mx,my,iz,2)\n!              ff(mx,my,iz,     0) = vb2(mx,my,iz,3)\n!              ff(mx,my,iz,2*nv+1) = vb2(mx,my,iz,4)\n!              ff(mx,my,iz,2*nv+2) = vb2(mx,my,iz,5)\n!              ff(mx,my,iz,2*nv+3) = vb2(mx,my,iz,6)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1363,1)\n                                           call clock_end(1363)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffin( ff, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1, mb2\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do im = 1, 2*nvb\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mb2(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                mb1(mx,my,iz,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n                mb1(mx,my,iz,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n!              mb1(mx,my,iz,iv,1) = ff(mx,my,iz,iv,   0)\n!              mb1(mx,my,iz,iv,2) = ff(mx,my,iz,iv,   1)\n!              mb1(mx,my,iz,iv,3) = ff(mx,my,iz,iv,   2)\n!              mb1(mx,my,iz,iv,4) = ff(mx,my,iz,iv,nm-2)\n!              mb1(mx,my,iz,iv,5) = ff(mx,my,iz,iv,nm-1)\n!              mb1(mx,my,iz,iv,6) = ff(mx,my,iz,iv,nm  )\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_sendrecv( mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    integer  ::  slngm\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngm = (2*nx+1)*(ny+1)*(2*nz)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n!                         mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n!                         mb2(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n\n  END SUBROUTINE bndry_shifts_m_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffout( mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iz,iv,im+nvb)\n!              ff(mx,my,iz,iv,  -3) = mb2(mx,my,iz,iv,1)\n!              ff(mx,my,iz,iv,  -2) = mb2(mx,my,iz,iv,2)\n!              ff(mx,my,iz,iv,  -1) = mb2(mx,my,iz,iv,3)\n!              ff(mx,my,iz,iv,nm+1) = mb2(mx,my,iz,iv,4)\n!              ff(mx,my,iz,iv,nm+2) = mb2(mx,my,iz,iv,5)\n!              ff(mx,my,iz,iv,nm+3) = mb2(mx,my,iz,iv,6)\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_e ( ew )\n!--------------------------------------\n!  Impose the modified periodic boundary condition \n!    in the z-direction for the electric field\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)   :: ew\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb1e_bottom, zb1e_top\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb2e_bottom, zb2e_top\n    integer  ::  mx, my, iz, im, mwn, mwp\n    integer  ::  slngze\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      allocate( zb1e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb1e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n\n      slngze  = (2*nx+1)*(ny+1)*(nm+1) * nzb\n\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP private(mx,my,iz,im)\n!$OMP master\n                                           call clock_sta(1381)\n                                         ! call fapp_start(\"literm_bounde_bufferin\",1381,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2e_bottom(mx,my,iz,im) = ( 0._DP, 0._DP )\n              zb2e_top   (mx,my,iz,im) = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb1e_bottom(mx,my,iz,im) = ew(mx,my,-nz+iz  ,im)\n              zb1e_top   (mx,my,iz,im) = ew(mx,my, nz-nzb+iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferin\",1381,1)\n                                           call clock_end(1381)\n!$OMP end master\n!$OMP end parallel\n\n                                           call clock_sta(1382)\n                                         ! call fapp_start(\"literm_bounde_sendrecv\",1382,1)\n!      call MPI_sendrecv( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_bounde_sendrecv\",1382,1)\n                                           call clock_end(1382)\n\n! --- substitution\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP shared(rankz,z_bound,ck,dj) &\n!$OMP private(mx,my,iz,im,mwp,mwn)\n!$OMP master\n                                           call clock_sta(1383)\n                                         ! call fapp_start(\"literm_bounde_bufferout\",1383,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,-nz-nzb+iz,im) = zb2e_bottom(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-1,im)   =   ew(mx,my,-nz  ,im)\n                    ew(mx,my,-nz-2,im)   = - ew(mx,my,-nz+1,im) + 2._DP * ew(mx,my,-nz  ,im)\n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-nzb+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,nz+iz,im) = zb2e_top(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz  ,im)   =   ew(mx,my,nz-1,im)\n                    ew(mx,my,nz+1,im)   = - ew(mx,my,nz-2,im) + 2._DP * ew(mx,my,nz-1,im) \n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferout\",1383,1)\n                                           call clock_end(1383)\n!$OMP end master\n!$OMP end parallel\n\n      deallocate( zb1e_bottom )\n      deallocate( zb1e_top )\n      deallocate( zb2e_bottom )\n      deallocate( zb2e_top )\n\n\n  END SUBROUTINE bndry_bound_e\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_zv_buffin( ff, zb1_bottom, zb1_top, vb1 )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n\n    integer :: iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            zb1_bottom(:,:,iz,iv) = ff(:,:,-nz+iz  ,iv)\n            zb1_top   (:,:,iz,iv) = ff(:,:, nz-nzb+iz,iv)\n          end do\n        end do\n!$OMP end do nowait\n\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!!$OMP do schedule(dynamic)\n!          do iz = -nz, nz-1\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!          end do\n!!$OMP end do nowait\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            vb1(:,:,iz,iv    ) = ff(:,:,iz,         iv)\n            vb1(:,:,iz,iv+nvb) = ff(:,:,iz,2*nv-nvb+iv)\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top, vb1, vb2 )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n\n    integer :: slngz, slngv\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n     !call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n     !                   zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n     !                   zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n     !                   vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n     !                   vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_zv_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_buffout ( zb2_bottom, zb2_top, vb2, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer :: mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,-nz-nzb+iz,iv) = zb2_bottom(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,nz+iz,iv) = zb2_top(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n\n        if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = (0._DP, 0._DP)\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = (0._DP, 0._DP)\n            end do\n          end do\n!$OMP end do nowait\n        else\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffin( iz, ff, vb1, mb1 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    integer :: mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!        do im = 0, nm\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,im,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im)\n                vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do im = 1, 2*nvb\n!        do iv = 1, 2*nv\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                mb2(mx,my,iv,im) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffin\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_vm_sendrecv ( vb1, vb2, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n\n    integer :: slngv, slngm\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(nm+1) * nvb\n      slngm = (2*nx+1)*(ny+1)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                        ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n    !call MPI_sendrecv( vb1(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n    !                   vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n    !                   sub_comm_world, status, ierr_mpi )\n    !call MPI_sendrecv( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n    !                   vb2(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n    !                   sub_comm_world, status, ierr_mpi )\n    !call MPI_sendrecv( mb1(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n    !                   mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n    !                   sub_comm_world, status, ierr_mpi )\n    !call MPI_sendrecv( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n    !                   mb2(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n    !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                        ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n  END SUBROUTINE bndry_vm_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffout ( iz, vb2, mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iv, im\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1373)\n                                        ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = (0._DP, 0._DP)\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = (0._DP, 0._DP)\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffout\n\n\nEND MODULE GKV_bndry\n", "MODULE GKV_zfilter\n!-------------------------------------------------------------------------------\n!\n!    Filtering in zz to reduce high-kz numerical oscillations\n!\n!    Update history of gkvp_zfilter.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   zfilter\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE zfilter ( vv )\n!--------------------------------------\n!     z-derivative of f\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: vv\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: ww\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    integer :: im\n\n      allocate( ww(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) )\n      allocate( zb1_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n\n!$OMP parallel default (none) &\n!$OMP shared (vv,ww,zb1_bottom,zb1_top,zb2_bottom,zb2_top) &\n!$OMP private (im)\n      call zfilter_copy (         vv(:,:,:,:,0),      ww(:,:,:,:,0),  &\n                          zb1_bottom(:,:,:,:,0), zb1_top(:,:,:,:,0),  &\n                          zb2_bottom(:,:,:,:,0), zb2_top(:,:,:,:,0) )\n!$OMP barrier\n\n      im = 0\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!$OMP barrier\n\n      im = 1\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n                               ww(:,:,:,:,im-1) )\n!$OMP barrier\n\n      do im = 2, nm-1\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n                               ww(:,:,:,:,im-1) )\n        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!$OMP barrier\n      end do\n\n      im = nm\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n                               ww(:,:,:,:,im-1) )\n        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!$OMP barrier\n\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,nm), zb2_top(:,:,:,:,nm), &\n                               ww(:,:,:,:,nm) )\n        call zfilter_filtering ( ww(:,:,:,:,nm-1), vv(:,:,:,:,nm-1) )\n!$OMP barrier\n\n        call zfilter_filtering ( ww(:,:,:,:,nm), vv(:,:,:,:,nm) )\n!$OMP end parallel\n\n      deallocate( ww )\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n\n  END SUBROUTINE zfilter\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_copy( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv) :: vv\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    complex(kind=DP) :: wk\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1521)\n                                        ! call fapp_start(\"zfilter_comm_bufferin\",1521,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my,-nz+iz ,iv)\n              zb1_bottom(mx,my,iz,iv) = wk\n                  ww(mx,my,-nz+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = -nz+nzb, nz-1-nzb\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n                      ww(mx,my,iz,iv) = vv(mx,my,iz,iv)\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my, nz-nzb+iz,iv)\n              zb1_top   (mx,my,iz,iv) = wk\n              ww(mx,my, nz-nzb+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2_bottom(mx,my,iz,iv)  = ( 0._DP, 0._DP )\n              zb2_top   (mx,my,iz,iv)  = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"zfilter_comm_bufferin\",1521,1)\n                                           call clock_end(1521)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_copy\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_sendrecv( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1522)\n                                        ! call fapp_start(\"zfilter_comm_sendrecv\",1522,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                        ! call fapp_stop(\"zfilter_comm_sendrecv\",1522,1)\n                                           call clock_end(1522)\n\n\n   END SUBROUTINE zfilter_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_buffout( zb2_bottom, zb2_top, ww )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n!$OMP master\n                                           call clock_sta(1523)\n                                        ! call fapp_start(\"zfilter_comm_bufferout\",1523,1)\n!$OMP end master\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankz==0\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                if( abs(mwn) > nx ) then\n                  ww(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else! rankz==nprocz-1\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                if( abs(mwp) > nx ) then\n                  ww(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n!$OMP master\n                                        ! call fapp_stop(\"zfilter_comm_bufferout\",1523,1)\n                                           call clock_end(1523)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_buffout\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_filtering( ww, vv )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)         :: vv\n\n    real(kind=DP) :: alph, ceff\n    integer  ::  mx, my, iz, iv\n\n\n      alph   = 1._DP\n      ceff   = alph / 16._DP\n\n!$OMP master\n                                             call clock_sta(1510)\n                                          ! call fapp_start(\"zfilter_calc\",1510,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vv(mx,my,iz,iv) =                               &\n                      ( 1._DP - alph )  * ww(mx,my,iz ,iv)   &\n                    + ceff * ( -          ww(mx,my,iz+2,iv)   &\n                               +  4._DP * ww(mx,my,iz+1,iv)   &\n                               + 10._DP * ww(mx,my,iz ,iv)   &\n                               +  4._DP * ww(mx,my,iz-1,iv)   &\n                               -          ww(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                          ! call fapp_stop(\"zfilter_calc\",1510,1)\n                                             call clock_end(1510)\n!$OMP end master\n\n  END SUBROUTINE zfilter_filtering\n\n\nEND MODULE GKV_zfilter\n", "MODULE GKV_zfilter\n!-------------------------------------------------------------------------------\n!\n!    Some useful tools and tips\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   zfilter\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE zfilter ( vv )\n!--------------------------------------\n!     z-derivative of f\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: vv\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: ww\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    integer :: im\n\n      allocate( ww(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) )\n      allocate( zb1_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n\n!$OMP parallel default (none) &\n!$OMP shared (vv,ww,zb1_bottom,zb1_top,zb2_bottom,zb2_top) &\n!$OMP private (im)\n\n!!%%% Without overlap * nm %%%\n      call zfilter_copy_v2 ( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n      call zfilter_sendrecv_v2 ( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n      call zfilter_buffout_v2 ( zb2_bottom, zb2_top, ww )\n      call zfilter_filtering_v2 ( ww, vv )\n\n!!%%%%%%%%%%%%%%%%%%%%\n\n!!%%% With overlap %%%\n!      call zfilter_copy (         vv(:,:,:,:,0),      ww(:,:,:,:,0),  &\n!                          zb1_bottom(:,:,:,:,0), zb1_top(:,:,:,:,0),  &\n!                          zb2_bottom(:,:,:,:,0), zb2_top(:,:,:,:,0) )\n!!$OMP barrier\n!\n!      im = 0\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n!                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n!                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!!$OMP barrier\n!\n!      im = 1\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n!                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n!                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n!                               ww(:,:,:,:,im-1) )\n!!$OMP barrier\n!\n!      do im = 2, nm-1\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n!                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n!                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n!                               ww(:,:,:,:,im-1) )\n!        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!!$OMP barrier\n!      end do\n!\n!      im = nm\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n!                               ww(:,:,:,:,im-1) )\n!        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!!$OMP barrier\n!\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,nm), zb2_top(:,:,:,:,nm), &\n!                               ww(:,:,:,:,nm) )\n!        call zfilter_filtering ( ww(:,:,:,:,nm-1), vv(:,:,:,:,nm-1) )\n!!$OMP barrier\n!\n!        call zfilter_filtering ( ww(:,:,:,:,nm), vv(:,:,:,:,nm) )\n!!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( ww )\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n\n  END SUBROUTINE zfilter\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_copy( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv) :: vv\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    complex(kind=DP) :: wk\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1521)\n                                         ! call fapp_start(\"zfilter_comm_bufferin\",1521,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my,-nz+iz  ,iv)\n              zb1_bottom(mx,my,iz,iv) = wk\n                  ww(mx,my,-nz+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = -nz+nzb, nz-1-nzb\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n                      ww(mx,my,iz,iv) = vv(mx,my,iz,iv)\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my, nz-nzb+iz,iv)\n              zb1_top   (mx,my,iz,iv) = wk\n              ww(mx,my, nz-nzb+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2_bottom(mx,my,iz,iv)  = ( 0._DP, 0._DP )\n              zb2_top   (mx,my,iz,iv)  = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"zfilter_comm_bufferin\",1521,1)\n                                           call clock_end(1521)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_copy\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_sendrecv( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1522)\n                                         ! call fapp_start(\"zfilter_comm_sendrecv\",1522,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"zfilter_comm_sendrecv\",1522,1)\n                                           call clock_end(1522)\n\n\n   END SUBROUTINE zfilter_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_buffout( zb2_bottom, zb2_top, ww )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n!$OMP master\n                                           call clock_sta(1523)\n                                         ! call fapp_start(\"zfilter_comm_bufferout\",1523,1)\n!$OMP end master\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                if( abs(mwn) > nx ) then\n                  ww(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                if( abs(mwp) > nx ) then\n                  ww(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n!$OMP master\n                                         ! call fapp_stop(\"zfilter_comm_bufferout\",1523,1)\n                                           call clock_end(1523)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_buffout\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_filtering( ww, vv )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)         :: vv\n\n    real(kind=DP) :: alph, ceff\n    integer  ::  mx, my, iz, iv\n\n\n      alph   = 1._DP\n      ceff   = alph / 16._DP\n\n!$OMP master\n                                             call clock_sta(1510)\n                                           ! call fapp_start(\"zfilter_calc\",1510,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vv(mx,my,iz,iv) =                               &\n                      ( 1._DP - alph )  * ww(mx,my,iz  ,iv)   &\n                    + ceff * ( -          ww(mx,my,iz+2,iv)   &\n                               +  4._DP * ww(mx,my,iz+1,iv)   &\n                               + 10._DP * ww(mx,my,iz  ,iv)   &\n                               +  4._DP * ww(mx,my,iz-1,iv)   &\n                               -          ww(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                           ! call fapp_stop(\"zfilter_calc\",1510,1)\n                                             call clock_end(1510)\n!$OMP end master\n\n  END SUBROUTINE zfilter_filtering\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_copy_v2( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: vv\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n\n    complex(kind=DP) :: wk\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1521)\n                                         ! call fapp_start(\"zfilter_comm_bufferin\",1521,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule (dynamic)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my,-nz+iz  ,iv,im)\n              zb1_bottom(mx,my,iz,iv,im) = wk\n                  ww(mx,my,-nz+iz,iv,im) = wk\n            end do\n          end do\n        end do\n        do iz = -nz+nzb, nz-1-nzb\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n                      ww(mx,my,iz,iv,im) = vv(mx,my,iz,iv,im)\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my, nz-nzb+iz,iv,im)\n              zb1_top   (mx,my,iz,iv,im) = wk\n              ww(mx,my, nz-nzb+iz,iv,im) = wk\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2_bottom(mx,my,iz,iv,im)  = ( 0._DP, 0._DP )\n              zb2_top   (mx,my,iz,iv,im)  = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"zfilter_comm_bufferin\",1521,1)\n                                           call clock_end(1521)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_copy_v2\n\n\n!--------------------------------------\n  ", "SUBROUTINE zfilter_sendrecv_v2( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv)*(nm+1) * nzb\n\n                                           call clock_sta(1522)\n                                        ! call fapp_start(\"zfilter_comm_sendrecv\",1522,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                        ! call fapp_stop(\"zfilter_comm_sendrecv\",1522,1)\n                                           call clock_end(1522)\n\n\n   END SUBROUTINE zfilter_sendrecv_v2\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_buffout_v2( zb2_bottom, zb2_top, ww )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) :: ww\n\n    integer  ::  mx, my, iz, iv, im, mwn, mwp\n\n\n!$OMP master\n                                           call clock_sta(1523)\n                                        ! call fapp_start(\"zfilter_comm_bufferout\",1523,1)\n!$OMP end master\n      if( rankz /= 0 ) then\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,-nz-nzb+iz,iv,im) = zb2_bottom(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      else ! rankz==0\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                if( abs(mwn) > nx ) then\n                  ww(mx,my,-nz-nzb+iz,iv,im) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,-nz-nzb+iz,iv,im) = ck(my) * zb2_bottom(mwn,my,iz,iv,im)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,nz+iz,iv,im) = zb2_top(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      else! rankz==nprocz-1\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                if( abs(mwp) > nx ) then\n                  ww(mx,my,nz+iz,iv,im) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,nz+iz,iv,im) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv,im)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      end if\n!$OMP master\n                                        ! call fapp_stop(\"zfilter_comm_bufferout\",1523,1)\n                                           call clock_end(1523)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_buffout_v2\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_filtering_v2( ww, vv )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)         :: vv\n\n    real(kind=DP) :: alph, ceff\n    integer  ::  mx, my, iz, iv, im\n\n\n      alph   = 1._DP\n      ceff   = alph / 16._DP\n\n!$OMP master\n                                             call clock_sta(1510)\n                                          ! call fapp_start(\"zfilter_calc\",1510,1)\n!$OMP end master\n!!TBI!!!$OMP do schedule (dynamic)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vv(mx,my,iz,iv,im) =                               &\n                      ( 1._DP - alph )  * ww(mx,my,iz ,iv,im)   &\n                    + ceff * ( -          ww(mx,my,iz+2,iv,im)   &\n                               +  4._DP * ww(mx,my,iz+1,iv,im)   &\n                               + 10._DP * ww(mx,my,iz ,iv,im)   &\n                               +  4._DP * ww(mx,my,iz-1,iv,im)   &\n                               -          ww(mx,my,iz-2,iv,im) )\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                          ! call fapp_stop(\"zfilter_calc\",1510,1)\n                                             call clock_end(1510)\n!$OMP end master\n\n  END SUBROUTINE zfilter_filtering_v2\n\n\nEND MODULE GKV_zfilter\n", "MODULE GKV_fft\n!-------------------------------------------------------------------------------\n!\n!    FFT module for E x B term calculation using FFTW\n!\n!    Update history of gkvp_fft_fftw.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  include \"fftw3.f\"\n\n  private\n\n  integer(kind=DP), save      :: plan_x_forward, plan_x_backward\n  integer(kind=DP), save      :: plan_y_forward, plan_y_backward\n\n  public   fft_pre,  &\n          !fft_backward_Xfft, fft_backward_chXY, fft_backward_Yfft, &\n          !fft_forward_Yfft, fft_forward_chYX, fft_forward_Xfft,    &\n           plan_x_forward, plan_x_backward,                         &\n           plan_y_forward, plan_y_backward\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE fft_pre( )\n!--------------------------------------\n!  Initialization of FFT\n\n    complex(kind=DP) :: wk1_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk2_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk1_y_z(0:nyw)\n    real(kind=DP)    :: wk2_y_r(0:2*nyw-1)\n\n\n     wk1_x_z(:) = (0._DP, 0._DP)\n     wk2_x_z(:) = (0._DP, 0._DP)\n     wk1_y_z(:) = (0._DP, 0._DP)\n     wk2_y_r(:) = 0._DP\n\n     call dfftw_plan_dft_1d( plan_x_backward,     &\n                             (2*nxw),             &\n                             wk1_x_z,             &  ! complex in\n                             wk2_x_z,             &  ! complex out\n                             FFTW_BACKWARD,       &\n                             FFTW_MEASURE )\n                            !! FFTW_ESTIMATE )\n\n     call dfftw_plan_dft_c2r_1d( plan_y_backward, &\n                                 (2*nyw),         &\n                                 wk1_y_z,         &  ! complex in\n                                 wk2_y_r,         &  ! real    out\n                                 FFTW_MEASURE )\n                                !! FFTW_ESTIMATE )\n\n     call dfftw_plan_dft_r2c_1d( plan_y_forward,  &\n                                 (2*nyw),         &\n                                 wk2_y_r,         &  ! real    in\n                                 wk1_y_z,         &  ! complex out\n                                 FFTW_MEASURE )\n                                !! FFTW_ESTIMATE )\n\n     call dfftw_plan_dft_1d( plan_x_forward,      &\n                             (2*nxw),             &\n                             wk2_x_z,             &  ! complex in\n                             wk1_x_z,             &  ! complex out\n                             FFTW_FORWARD,        &\n                             FFTW_MEASURE )\n                            !! FFTW_ESTIMATE )\n\n\n  END SUBROUTINE fft_pre\n\n\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Xfft ( exbdf, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_out! for outplace\n!    integer :: ist_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1421)\n!                                        ! call fapp_start(\"nlterm_backward_Xfft\",1421,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_backward,  &\n!                          exbdf(0,my,i),    &    ! complex in\n!                       !  exbdf(0,my,i)        ) ! complex out\n!                          wk_x_out             ) ! complex out! for outplace\n!\n!       ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            do mx = ist_xw, iend_xw\n!            !  send_buff(my,mx,i,irank) = exbdf(mx+ist_xw_g_rank,my,i)\n!               send_buff(my,mx,i,irank) = wk_x_out(mx+ist_xw_g_rank)! for outplace\n!            enddo\n!          enddo\n!\n!        enddo\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_backward_Xfft\",1421,1)\n!                                           call clock_end(1421)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Xfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_chXY ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         Y divide -> X divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1422)\n!                                        ! call fapp_start(\"nlterm_backward_shiftXY\",1422,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                        ! call fapp_stop(\"nlterm_backward_shiftXY\",1422,1)\n!                                           call clock_end(1422)\n!    \n!\n!  END SUBROUTINE fft_backward_chXY\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Yfft ( recv_buff, exbdf_xw, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_in(0:nyw)! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1423)\n!                                        ! call fapp_start(\"nlterm_backward_Yfft\",1423,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!       ! --- restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!           !  exbdf_xw(my,mx,i) = recv_buff(my-ist_y_g_rank,mx,i,irank)\n!              wk_y_in(my) = recv_buff(my-ist_y_g_rank,mx,i,irank)! for outplace\n!            end do\n!          end do\n!       ! --- set filler ---\n!          do my = global_ny+1, nyw\n!         !  exbdf_xw(my,mx,i) = ( 0._DP, 0._DP )\n!            wk_y_in(my) = ( 0._DP, 0._DP )! for outplace\n!          end do\n!\n!          call dfftw_execute_dft_c2r( &\n!                          plan_y_backward,   &\n!                       !  exbdf_xw(0,mx,i),  &   ! complex in\n!                          wk_y_in,            &   ! complex in! for outplace\n!                          exbdf_xw(0,mx,i)     ) ! real    out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_backward_Yfft\",1423,1)\n!                                           call clock_end(1423)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Yfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Yfft ( exbdf_xw, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_out(0:nyw)! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1441)\n!                                        ! call fapp_start(\"nlterm_forward_Yfft\",1441,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!          call dfftw_execute_dft_r2c( &\n!                          plan_y_forward,    &\n!                          exbdf_xw(0,mx,i),  &   ! real in\n!                       !  exbdf_xw(0,mx,i)     ) ! complex out\n!                          wk_y_out             ) ! complex out! for outplace\n!\n!       ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!           !  send_buff(my-ist_y_g_rank,mx,i,irank) = exbdf_xw(my,mx,i)\n!              send_buff(my-ist_y_g_rank,mx,i,irank) = wk_y_out(my)! for outplace\n!            end do\n!          end do\n!\n!      end do\n!    end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_forward_Yfft\",1441,1)\n!                                           call clock_end(1441)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Yfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_chYX ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         X divide -> Y divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1442)\n!                                        ! call fapp_start(\"nlterm_forward_shiftYX\",1442,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                        ! call fapp_stop(\"nlterm_forward_shiftYX\",1442,1)\n!                                           call clock_end(1442)\n!\n!\n!  END SUBROUTINE fft_forward_chYX\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Xfft ( recv_buff, exbdf, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_in! for outplace\n!    integer :: ist_xw_g_rank, iend_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1443)\n!                                        ! call fapp_start(\"nlterm_forward_Xfft\",1443,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!       ! ---  restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            iend_xw_g_rank = min ( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!            do mx = ist_xw_g_rank, iend_xw_g_rank\n!           !  exbdf(mx,my,i) = recv_buff(my,mx-ist_xw_g_rank,i,irank)\n!              wk_x_in(mx) = recv_buff(my,mx-ist_xw_g_rank,i,irank)! for outplace\n!            enddo\n!          enddo\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_forward,   &\n!                       !  exbdf(0,my,i),    &   ! complex in\n!                          wk_x_in,          &   ! complex in! for outplace\n!                          exbdf(0,my,i)       ) ! complex out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_forward_Xfft\",1443,1)\n!                                           call clock_end(1443)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Xfft\n\n\nEND MODULE GKV_fft\n", "MODULE GKV_exb\n!-------------------------------------------------------------------------------\n!\n!    E x B term\n!\n!    Update history of gkvp_exb.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fft, only: plan_x_forward, plan_x_backward, &\n                     plan_y_forward, plan_y_backward\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  real(kind=DP), save :: exb_maxvx_eachrank, exb_maxvy_eachrank\n\n  integer, parameter :: nbuff = ((2*nz)*(nm+1)-1)/nprocw + 1\n                            !if ( mod(2*nz*(nm+1),nprocw) == 0 ) then\n                            !  nbuff = 2*nz*(nm+1)/nprocw\n                            !else\n                            !  nbuff = 2*nz*(nm+1)/nprocw + 1\n                            !end if\n  real(kind=DP), dimension(0:global_ny), save :: gky\n  integer, save :: nchunk_zm = 1, nchunk_yb = 1, nchunk_xb = 1\n\n  integer, save :: nchunk_yzm = 1, nchunk_xzm = 1\n\n\n  public   exb_NL_term, exb_maxvx_eachrank, exb_maxvy_eachrank\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term(hh, psi, chi, pb)\n!--------------------------------------\n!  Nonlinear term calculation interface\n    implicit none\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: pb\n\n    real(kind=DP) :: dky\n    integer, save :: iflg\n    integer :: my\n!$  integer :: nthreads, omp_get_num_threads\n    data iflg / 0 /\n                                               !%%% For debug %%%\n                                               !complex(kind=DP) ::                        &\n                                               !  whh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm),   &\n                                               !  wpsi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm), &\n                                               !  wchi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)\n                                               !integer :: mx, iz, iv, im\n                                               !%%%%%%%%%%%%%%%%%\n\n    if( iflg == 0 ) then\n      iflg = 1\n      dky = ky(1) - ky(0)\n      do my = 0, global_ny\n        gky(my) = dky * real(my, kind=DP)\n      end do\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zm = ((2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_yb = ((global_ny+1)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_xb = ((2*nxw)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_yzm = ((iend_y-ist_y+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_xzm = ((iend_xw-ist_xw+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n    end if\n                                               !%%% For debug %%%\n                                               !whh(:,:,:,:,:) = (0._DP, 0._DP)\n                                               !wpsi(:,:,:,:) = (0._DP, 0._DP)\n                                               !wchi(:,:,:,:) = (0._DP, 0._DP)\n                                               !if (rankw == 0) then\n                                               !  whh(0,1,:,:,:) = (0.5_DP, 0._DP)\n                                               !  wpsi(2,0,:,:) = (0._DP, 0.5_DP)\n                                               !  wpsi(-2,0,:,:) = (0._DP, -0.5_DP)\n                                               !end if\n                                               !%%%%%%%%%%%%%%%%%\n\n    if (trim(calc_type) == \"nonlinear\") then\n\n        call exb_NL_term_y2zm(hh, psi, chi, pb)\n\n        !call exb_NL_term_y2x(hh, psi, chi, pb)\n\n    else\n\n!$OMP parallel workshare\n      pb(:,:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n    end if\n\n                                               !%%% For debug %%%\n                                               !if (rankz == 0 .and. rankv == 0 .and. rankm == 0 .and. ranks == 0) then\n                                               !  im = 0; iv = 1; iz = 0\n                                               !  do my = 0, ny\n                                               !    do mx = -nx, nx\n                                               !      write(80000+rankg,*) kx(mx), ky(my),  &\n                                               !  dble(whh(mx,my,iz,iv,im)), aimag(whh(mx,my,iz,iv,im)), &\n                                               !  dble(wpsi(mx,my,iz,im)), aimag(wpsi(mx,my,iz,im)), &\n                                               !  dble(pb(mx,my,iz,iv,im)), aimag(pb(mx,my,iz,iv,im))\n                                               !    end do\n                                               !    write(80000+rankg,*)\n                                               !  end do\n                                               !end if\n                                               !call MPI_Finalize(ierr_mpi)\n                                               !stop\n                                               !%%%%%%%%%%%%%%%%%\n\n\n  END SUBROUTINE exb_NL_term\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term_y2zm( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: &\n                      wc1o, wc2o, wc3o, wc4o,   wc1e, wc2e, wc3e, wc4e\n    complex(kind=DP), dimension(:,:,:), allocatable ::   &\n                         wwdxo, wwdyo, wwefo,      wwdxe, wwdye, wwefe\n    integer :: iv\n\n      allocate(dpdx(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(dpdy(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(dadx(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(dady(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(wc1o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc2o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc3o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc4o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc1e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc2e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc3e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc4e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wwdxo(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwdyo(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwefo(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwdxe(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwdye(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwefe(0:global_ny,0:2*nxw-1,0:nbuff-1))\n\n!$OMP parallel default(none)                          &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)       &\n!$OMP shared(wc1o,wc2o,wc3o,wc4o,wc1e,wc2e,wc3e,wc4e) &\n!$OMP shared(wwdxo,wwdyo,wwefo,wwdxe,wwdye,wwefe)     &\n!$OMP private(iv)\n\n!$OMP workshare\n      wc1o(:,:,:,:) = (0._DP, 0._DP)\n      wc3o(:,:,:,:) = (0._DP, 0._DP)\n      wc1e(:,:,:,:) = (0._DP, 0._DP)\n      wc3e(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!!      call exb_pack_y2zm(psi(-nx:nx,0:ny,-nz:nz-1,0:nm),wc3o)\n!      call exb_pack_psi_y2zm(psi,wc3o)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3o,wc4o)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n!!$OMP barrier\n!!      call exb_pack_y2zm(chi(-nx:nx,0:ny,-nz:nz-1,0:nm),wc3e)\n!      call exb_pack_psi_y2zm(chi,wc3e)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3e,wc4e)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!!        call exb_pack_y2zm(hh(:,:,:,iv,:),wc1o)\n!        call exb_pack_hh_y2zm(iv,hh,wc1o)\n!!$OMP barrier\n!        call exb_transpose_y2zm(wc1o,wc2o)\n!!$OMP barrier\n!        call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n!!$OMP barrier\n!        call exb_realspcal_y2zm(iv,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n!!$OMP barrier\n!        call exb_pack_zm2y(wwefo,wc3o)\n!!$OMP barrier\n!        call exb_transpose_zm2y(wc3o,wc4o)\n!!$OMP barrier\n!        call exb_unpack_zm2y(iv,wc4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2zm(psi,wc3o)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3o,wc4o)\n      call exb_pack_psi_y2zm(chi,wc3e)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3e,wc4e)\n      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n      do iv = 1, 2*nv+6\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1e,wc2e)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3e,wc4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxe,wwdye,wwefe)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefo,wc3o)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1o,wc2o)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3o,wc4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2e,wwdxe,wwdye)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefe,wc3e)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2zm(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wc1o)\n      deallocate(wc2o)\n      deallocate(wc3o)\n      deallocate(wc4o)\n      deallocate(wc1e)\n      deallocate(wc2e)\n      deallocate(wc3e)\n      deallocate(wc4e)\n      deallocate(wwdxo)\n      deallocate(wwdyo)\n      deallocate(wwefo)\n      deallocate(wwdxe)\n      deallocate(wwdye)\n      deallocate(wwefe)\n\n  END SUBROUTINE exb_NL_term_y2zm\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2zm ( psi, wc4 )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2zm)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n!\n!    integer :: mx, my, iz, im, izm, ibuff, iprocw\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(2) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!\n!         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n!          izm = (2*nz)*im + (iz + nz)\n!          ibuff = mod(izm, nbuff)\n!          iprocw = izm / nbuff\n!          do my = ist_y, iend_y\n!            do mx = -nx, nx\n!              wc4(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n!            end do\n!          end do\n!         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2zm ( psi, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2zm ( iv, hh, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(mx,my,ibuff,iprocw) = hh(mx,my,iz,iv,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_transpose_y2zm ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_y2zm ( wc4, wwdx, wwdy )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nx:nx) :: psi\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: my, ibuff, iprocw, global_my\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_yb)\n      do ibuff = 0, nbuff-1\n        do global_my = 0, global_ny\n\n         !%%% UNPACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          iprocw = global_my / (ny+1)\n          my = mod(global_my, ny+1)\n          psi(-nx:nx) = wc4(-nx:nx,my,ibuff,iprocw)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Backward x-FFT (kx,ky)->(ky,x) %%%\n          w1(0:nx) = ui * kx(0:nx) * psi(0:nx)\n          w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1)\n          call dfftw_execute_dft(plan_x_backward, w1, w2)\n          wwdx(global_my,0:2*nxw-1,ibuff) = w2(0:2*nxw-1)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Backward x-FFT (kx,ky)->(ky,x) %%%\n          w1(0:nx) = ui * gky(global_my) * psi(0:nx)\n          w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          w1(2*nxw-nx:2*nxw-1) = ui * gky(global_my) * psi(-nx:-1)\n          call dfftw_execute_dft(plan_x_backward, w1, w2)\n          wwdy(global_my,0:2*nxw-1,ibuff) = w2(0:2*nxw-1)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_backwardfft_y2zm ( wwdx, wwdy, dpdx, dpdy )\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwdx, wwdy\n    real(kind=DP), intent(out), &\n      dimension(0:2*nyw-1,0:2*nxw-1,0:nbuff-1) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    integer :: ix, ibuff\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_xb)\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n\n         !%%% Backward y-FFT (ky,x)->(y,x) %%%\n          w3(0:global_ny) = wwdx(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdx(:,ix,ibuff))\n          w3(0:global_ny) = wwdy(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdy(:,ix,ibuff))\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2zm ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:2*nxw-1,0:nbuff-1) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwdx, wwdy\n    complex(kind=DP), intent(out), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwef\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    real(kind=DP), dimension(0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: ix, iy, ibuff\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_xb)\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n\n         !%%% Backward y-FFT (ky,x)->(y,x) %%%\n          w3(0:global_ny) = wwdx(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdx)\n          w3(0:global_ny) = wwdy(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdy)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Poisson brackets in (y,x) %%%\n          do iy = 0, 2*nyw-1\n            pbxy(iy) = cef * ( & ! Normalization for 2D Forward FFT\n                       (dpdx(iy,ix,ibuff) - cs1 * vl(iv) * dadx(iy,ix,ibuff)) * dhdy(iy) &\n                     - (dpdy(iy,ix,ibuff) - cs1 * vl(iv) * dady(iy,ix,ibuff)) * dhdx(iy))\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Forward y-FFT (y,x)->(ky,x) %%%\n          call dfftw_execute_dft_r2c(plan_y_forward, pbxy, w3)\n          wwef(0:global_ny,ix,ibuff) = w3(0:global_ny)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_zm2y ( wwef, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    complex(kind=DP), dimension(-nx:nx) :: ef\n    integer :: mx, my, ibuff, iprocw, global_my\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_yb)\n      do ibuff = 0, nbuff-1\n        do global_my = 0, global_ny\n\n         !%%% Forward x-FFT (ky,x)->(kx,ky) %%%\n          w2(0:2*nxw-1) = wwef(global_my,0:2*nxw-1,ibuff) ! FFTW may destroy input array!\n          call dfftw_execute_dft(plan_x_forward, w2, w1)\n          ef(0:nx) = w1(0:nx)\n          ef(-nx:-1) = w1(2*nxw-nx:2*nxw-1)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% PACK: (kx,ky,(z*,m*)*)->(kx,ky*,z*,m*) %%%\n          iprocw = global_my / (ny+1)\n          my = mod(global_my, ny+1)\n          do mx = -nx, nx\n            wc4(mx,my,ibuff,iprocw) = ef(mx)\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_zm2y ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1440)\n                                         ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_zm2y ( iv, wc4, ef )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n    !complex(kind=DP), intent(inout), &\n    !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n    !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n    !      When the subroutine is called in a OpenMP parallel region, \n    !      the copied subarray may be treated as a thread-private variable.\n\n    integer :: iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1450)\n                                         ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% UNPACK: (kx,ky,(z*,m*)*)->(kx,ky*,z*,m*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          ef(:,:,iz,iv,im) = wc4(:,:,ibuff,iprocw)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2zm ( dpdx, dpdy, dadx, dady )\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:2*nxw-1,0:nbuff-1) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, ibuff, iv\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      iv = 2*nv\n!$OMP parallel default(none)                               &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)        &\n!$OMP shared(iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,ibuff,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n        do ibuff = 0, nbuff-1\n          do ix = 0, 2*nxw-1\n            do iy = 0, 2*nyw-1\n              wv_nl = abs(dpdy(iy,ix,ibuff) - cs1 * vl(iv) * dady(iy,ix,ibuff))\n              if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n        do ibuff = 0, nbuff-1\n          do ix = 0, 2*nxw-1\n            do iy = 0, 2*nyw-1\n              wv_nl = abs(dpdx(iy,ix,ibuff) - cs1 * vl(iv) * dadx(iy,ix,ibuff))\n              if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_NL_term_y2x( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: &\n                                   wdx1o, wdy1o, wdx2o, wdy2o, wef3o, wef4o, &\n                                   wdx1e, wdy1e, wdx2e, wdy2e, wef3e, wef4e\n    integer :: iv, iprocw\n\n      allocate(dpdx(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(dpdy(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(dadx(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(dady(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(wdx1o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy1o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdx2o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy2o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef3o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef4o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdx1e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy1e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdx2e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy2e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef3e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef4e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n\n!$OMP parallel default(none)                      &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)   &\n!$OMP shared(wdx1o,wdy1o,wdx2o,wdy2o,wef3o,wef4o) &\n!$OMP shared(wdx1e,wdy1e,wdx2e,wdy2e,wef3e,wef4e) &\n!$OMP private(iv,iprocw)\n\n!$OMP workshare\n      ef(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3o(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3e(:,:,:,:,:) = (0._DP, 0._DP)\n      dpdx(:,:,:,:) = 0._DP\n      dpdy(:,:,:,:) = 0._DP\n      dadx(:,:,:,:) = 0._DP\n      dady(:,:,:,:) = 0._DP\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!!      call exb_pack_y2x(psi(-nx:nx,0:ny,-nz:nz-1,0:nm),wdx1o,wdy1o)\n!      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1o,wdx2o)\n!      call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!!$OMP barrier\n!!      call exb_pack_y2x(chi(-nx:nx,0:ny,-nz:nz-1,0:nm),wdx1e,wdy1e)\n!      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1e,wdx2e)\n!      call exb_transpose_y2x(wdy1e,wdy2e)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!!        call exb_pack_y2x(hh(:,:,:,iv,:),wdx1o,wdy1o)\n!        call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n!!$OMP barrier\n!        call exb_transpose_y2x(wdx1o,wdx2o)\n!        call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!        call exb_realspcal_y2x(iv,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n!!$OMP barrier\n!        call exb_transpose_x2y(wef3o,wef4o)\n!!$OMP barrier\n!        call exb_unpack_x2y(iv,wef4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1o,wdx2o)\n      call exb_transpose_y2x(wdy1o,wdy2o)\n      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1e,wdx2e)\n      call exb_transpose_y2x(wdy1e,wdy2e)\n      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!$OMP barrier\n      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n      do iv = 1, 2*nv+4\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1e,wdx2e)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1e,wdy2e)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3e,wef4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1o,wdx2o)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1o,wdy2o)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3o,wef4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1e,wdy1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2e,wdy2e,wef3e)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2x(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wdx1o)\n      deallocate(wdy1o)\n      deallocate(wdx2o)\n      deallocate(wdy2o)\n      deallocate(wef3o)\n      deallocate(wef4o)\n      deallocate(wdx1e)\n      deallocate(wdy1e)\n      deallocate(wdx2e)\n      deallocate(wdy2e)\n      deallocate(wef3e)\n      deallocate(wef4e)\n\n  END SUBROUTINE exb_NL_term_y2x\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2x ( psi, wwdx, wwdy )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2x)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n!    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(3) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!          do my = ist_y, iend_y\n!\n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * kx(0:nx) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * ky(my) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!          enddo\n!        enddo\n!      enddo\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2x ( psi, wwdx, wwdy )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_yzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * kx(0:nx) * psi(0:nx,my,iz,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1,my,iz,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * ky(my) * psi(0:nx,my,iz,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * psi(-nx:-1,my,iz,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n          enddo\n        enddo\n      enddo\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2x ( iv, hh, wwdx, wwdy )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_yzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * kx(0:nx) * hh(0:nx,my,iz,iv,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * hh(-nx:-1,my,iz,iv,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * ky(my) * hh(0:nx,my,iz,iv,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * hh(-nx:-1,my,iz,iv,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n          enddo\n        enddo\n      enddo\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_y2x ( wwin, wwout )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2x\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_backwardfft_y2x ( wwdx, wwdy, dpdx, dpdy )\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n    real(kind=DP), intent(inout), &\n      dimension(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    integer :: ix, my, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_xzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do ix = ist_xw, iend_xw\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdx(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdx(:,ix,iz,im))\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdy(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdy(:,ix,iz,im))\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2x ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n    complex(kind=DP), intent(inout), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwef\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    real(kind=DP), dimension(0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: my, ix, iy, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_xzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do ix = ist_xw, iend_xw\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdx(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdx)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdy(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdy)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% Poisson brackets in (y,x) %%%\n            do iy = 0, 2*nyw-1\n              pbxy(iy) = cef * ( &! Normalization for 2D Forward FFT\n                         (dpdx(iy,ix,iz,im) - cs1 * vl(iv) * dadx(iy,ix,iz,im)) * dhdy(iy) &\n                       - (dpdy(iy,ix,iz,im) - cs1 * vl(iv) * dady(iy,ix,iz,im)) * dhdx(iy))\n            end do\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% Forward y-FFT (y,x)->(ky,x) %%%\n            call dfftw_execute_dft_r2c(plan_y_forward, pbxy, w3)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% PACK: (ky,x*,z*,m*)->(x,ky*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                wwef(my-ist_y_g_rank,ix,iz,im,irank) = w3(my)\n              end do\n            end do\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_x2y ( wwin, wwout )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1440)\n                                        ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                        ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_x2y ( iv, wwef, ef )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n   !complex(kind=DP), intent(inout), &\n   !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n   !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n   !      When the subroutine is called in a OpenMP parallel region, \n   !      the copied subarray may be treated as a thread-private variable.\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n!$OMP master\n                                           call clock_sta(1450)\n                                        ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_yzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n          !%%% UNPACK: (ky,x*,z*,m*)->(x,ky*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                w2(ix) = wwef(my,ix-ist_xw_g_rank,iz,im,irank)\n              enddo\n            enddo\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Forward x-FFT (x,ky)->(kx,ky) %%%\n            call dfftw_execute_dft(plan_x_forward, w2, w1)\n            ef(0:nx,my,iz,iv,im) = w1(0:nx)\n            ef(-nx:-1,my,iz,iv,im) = w1(2*nxw-nx:2*nxw-1)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2x ( dpdx, dpdy, dadx, dady )\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, iz, iv, im\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      im = 0\n        iv = 2*nv\n!$OMP parallel default(none)                                  &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)           &\n!$OMP shared(im,iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,iz,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n          do iz = -nz, nz-1\n            do ix = ist_xw, iend_xw\n              do iy = 0, 2*nyw-1\n                wv_nl = abs(dpdy(iy,ix,iz,im) - cs1 * vl(iv) * dady(iy,ix,iz,im))\n                if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n          do iz = -nz, nz-1\n            do ix = ist_xw, iend_xw\n              do iy = 0, 2*nyw-1\n                wv_nl = abs(dpdx(iy,ix,iz,im) - cs1 * vl(iv) * dadx(iy,ix,iz,im))\n                if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2x\n\n\nEND MODULE GKV_exb\n", "MODULE GKV_fileio\n!-------------------------------------------------------------------------------\n!\n!    File I/O interface for NetCDF binary output\n!\n!    Update history of gkvp_fileio_netcdf.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - NetCDF binary I/O interface by Fujitsu.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  use netcdf\n\n  implicit  none\n\n  private\n\n  public    fileio_open_icnt, fileio_close_icnt, &\n            fileio_open_cnt,  fileio_close_cnt, &\n            fileio_open_fxv,  fileio_close_fxv, &\n            fileio_open_phi,  fileio_close_phi, &\n            fileio_open_Al,   fileio_close_Al, &\n            fileio_open_mom,  fileio_close_mom, &\n            fileio_open_trn,  fileio_close_trn, &\n            fileio_open_tri,  fileio_close_tri, &\n            \n            fileio_read_cnt,  fileio_write_cnt, &\n            fileio_write_fxv, fileio_write_phi, &\n            fileio_write_Al,  fileio_write_mom, &\n            fileio_write_trn, fileio_write_tri\n\n  integer :: icnt_nc, &\n             ocnt_nc, &\n             ofxv_nc, &\n             ophi_nc, &\n             oAl_nc, &\n             omom_nc, &\n             otrn_nc, &\n             otri_nc\n\n  integer :: phi_comm, &\n             Al_comm, &\n             mom_comm, &\n             trn_comm, &\n             tri_comm\n\nCONTAINS\n\n!--------------------------------------\n  SUBROUTINE fileio_open_icnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    integer :: ierr_nf90\n\n    character(3)   :: cold\n\n    write( cold,  fmt=\"(i3.3)\" ) inum-1\n\n    ierr_nf90=nf90_open( path=path//\"cnt.\"//cold//\".nc\",  &\n                         mode=NF90_NOWRITE, ncid=icnt_nc, &\n                         comm=MPI_COMM_WORLD, info=MPI_INFO_NULL )\n    call check_nf90err( ierr_nf90, \"nf90_open\" )\n\n  END SUBROUTINE fileio_open_icnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_icnt\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( inum > 1 ) then\n      ierr_nf90=nf90_close( icnt_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_icnt\n\n \n!--------------------------------------\n  SUBROUTINE fileio_open_cnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    integer :: ierr_nf90\n\n    character(3)   :: cnew\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    ierr_nf90=nf90_create( path=path//\"cnt.\"//cnew//\".nc\", &\n                           cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                           ncid=ocnt_nc, &\n                           comm=MPI_COMM_WORLD, info=MPI_INFO_NULL ) \n    call check_nf90err( ierr_nf90, \"nf90_create\" )\n\n  END SUBROUTINE fileio_open_cnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_cnt\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    ierr_nf90=nf90_close( ocnt_nc )\n    call check_nf90err( ierr_nf90, \"nf90_close\" )\n\n  END SUBROUTINE fileio_close_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_fxv ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    integer :: ierr_nf90\n\n    character(3)   :: cnew\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    ierr_nf90=nf90_create( path=path//\"fxv.\"//cnew//\".nc\", &\n                           cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                           ncid=ofxv_nc, &\n                           comm=MPI_COMM_WORLD, info=MPI_INFO_NULL ) \n    call check_nf90err( ierr_nf90, \"nf90_create\" )\n\n  END SUBROUTINE fileio_open_fxv\n\n!--------------------------------------\n  SUBROUTINE fileio_close_fxv\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    ierr_nf90=nf90_close( ofxv_nc )\n    call check_nf90err( ierr_nf90, \"nf90_close\" )\n\n  END SUBROUTINE fileio_close_fxv\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_phi ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: phi_tf(1)\n    integer, allocatable :: rank_list(:), phi_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(phi_tf_list(nproc))\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      phi_tf(1) = 1\n    else\n      phi_tf(1) = 0\n    end if\n\n    call MPI_Allgather( phi_tf, 1, MPI_INTEGER, phi_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( phi_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, phi_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"phi.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=ophi_nc, &\n                             comm=phi_comm, info=MPI_INFO_NULL ) \n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(phi_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_phi\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_close( ophi_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_Al ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: Al_tf(1)\n    integer, allocatable :: rank_list(:), Al_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(Al_tf_list(nproc))\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      Al_tf(1) = 1\n    else\n      Al_tf(1) = 0\n    end if\n\n    call MPI_Allgather( Al_tf, 1, MPI_INTEGER, Al_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( Al_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, Al_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"Al.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=oAl_nc, &\n                             comm=Al_comm, info=MPI_INFO_NULL )\n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(Al_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_Al\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_close( oAl_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_mom ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: mom_tf(1)\n    integer, allocatable :: rank_list(:), mom_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(mom_tf_list(nproc))\n    rank_list = 0\n    mom_tf_list = 0\n\n    if ( vel_rank == 0 ) then\n      mom_tf(1) = 1\n    else\n      mom_tf(1) = 0\n    end if\n\n    call MPI_Allgather( mom_tf, 1, MPI_INTEGER, mom_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( mom_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, mom_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"mom.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=omom_nc, &\n                             comm=mom_comm, info=MPI_INFO_NULL )\n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(mom_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_mom\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( vel_rank == 0 ) then\n      ierr_nf90=nf90_close( omom_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_trn( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: trn_tf(1)\n    integer, allocatable :: rank_list(:), trn_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(trn_tf_list(nproc))\n\n    if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      trn_tf(1) = 1\n    else\n      trn_tf(1) = 0\n    end if\n\n    call MPI_Allgather( trn_tf, 1, MPI_INTEGER, trn_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( trn_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, trn_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"trn.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=otrn_nc, &\n                             comm=trn_comm, info=MPI_INFO_NULL ) \n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(trn_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_trn\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_trn\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_close( otrn_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_trn\n\n\n!!--------------------------------------\n!  SUBROUTINE fileio_open_tri ( path, cmx, cmy, replace )\n!!--------------------------------------\n!\n!    character(*), intent(in) :: path\n!    character(*), intent(in) :: cmx, cmy\n!    logical, intent(in) :: replace\n!\n!    character(3)   :: cnew\n!\n!    integer :: ierr_nf90\n!    integer :: counter, i\n!    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n!    integer :: tri_tf(1)\n!    integer, allocatable :: rank_list(:), tri_tf_list(:)\n!\n!    allocate(rank_list(nproc))\n!    allocate(tri_tf_list(nproc))\n!\n!    if ( rank == 0 ) then\n!      tri_tf(1) = 1\n!    else\n!      tri_tf(1) = 0\n!    end if\n!\n!    call MPI_Allgather( tri_tf, 1, MPI_INTEGER, tri_tf_list, 1, MPI_INTEGER, &\n!                        MPI_COMM_WORLD, ierr_mpi)\n!\n!    counter = 1\n!    do i = 1, nproc\n!      if ( tri_tf_list(i) == 1 ) then\n!        rank_list(counter) = i-1\n!        counter = counter+1\n!      end if\n!    end do\n!\n!    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n!    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n!                         ierr_mpi )\n!    call MPI_Comm_create( MPI_COMM_WORLD, new_group, tri_comm, ierr_mpi )\n!\n!    write( cnew,  fmt=\"(i3.3)\" ) inum\n!\n!    if ( rank == 0 ) then\n!      if ( replace ) then\n!        ierr_nf90=nf90_create( &\n!                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n!                cmode=IOR(NF90_NETCDF4,NF90_MPIIO), ncid=otri_nc, &\n!                comm=tri_comm, info=MPI_INFO_NULL ) \n!        call check_nf90err( ierr_nf90, \"nf90_create\" )\n!      else\n!        ierr_nf90=nf90_open( &\n!                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n!                mode=NF90_WRITE, ncid=otri_nc, &\n!                comm=tri_comm, info=MPI_INFO_NULL ) \n!        call check_nf90err( ierr_nf90, \"nf90_open\" )\n!      end if\n!    end if\n!\n!    deallocate(tri_tf_list, rank_list)\n!\n!  END SUBROUTINE fileio_open_tri\n\n!--------------------------------------\n  SUBROUTINE fileio_open_tri ( path, cmx, cmy, replace )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n    character(*), intent(in) :: cmx, cmy\n    logical, intent(in) :: replace\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: tri_tf(1)\n    integer, allocatable :: rank_list(:), tri_tf_list(:)\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( replace ) then ! Initial creation of NetCDF files\n\n      allocate(rank_list(nproc))\n      allocate(tri_tf_list(nproc))\n\n      if ( rank == 0 ) then\n        tri_tf(1) = 1\n      else\n        tri_tf(1) = 0\n      end if\n      call MPI_Allgather( tri_tf, 1, MPI_INTEGER, tri_tf_list, 1, MPI_INTEGER, &\n                          MPI_COMM_WORLD, ierr_mpi)\n      counter = 1\n      do i = 1, nproc\n        if ( tri_tf_list(i) == 1 ) then\n          rank_list(counter) = i-1\n          counter = counter+1\n        end if\n      end do\n      call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n      call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                           ierr_mpi )\n      call MPI_Comm_create( MPI_COMM_WORLD, new_group, tri_comm, ierr_mpi )\n\n      if ( rank == 0 ) then\n        ierr_nf90=nf90_create( &\n                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n                cmode=IOR(NF90_NETCDF4,NF90_MPIIO), ncid=otri_nc, &\n                comm=tri_comm, info=MPI_INFO_NULL )\n        call check_nf90err( ierr_nf90, \"nf90_create\" )\n      end if\n\n      deallocate(tri_tf_list, rank_list)\n\n    else ! For appending data to NetCDF files\n\n      if ( rank == 0 ) then\n        ierr_nf90=nf90_open( &\n                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n                mode=NF90_WRITE, ncid=otri_nc, &\n                comm=tri_comm, info=MPI_INFO_NULL )\n        call check_nf90err( ierr_nf90, \"nf90_open\" )\n      end if\n\n    end if\n\n  END SUBROUTINE fileio_open_tri\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_tri\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( rank == 0 ) then\n      ierr_nf90=nf90_close( otri_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_tri\n\n\n\n!--------------------------------------\n  SUBROUTINE fileio_read_cnt ( wf, time, istatus )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(out) :: time\n    integer, optional, intent(out) :: istatus\n\n    integer :: input_status\n    integer :: ierr_nf90\n    integer :: varid_tt, varid_recnt, varid_imcnt\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_cnt(1:7), count_cnt(1:7)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nv(1), count_nv(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: t_count\n    real(kind=DP), dimension(1) :: t_value\n    real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: recnt\n    real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: imcnt\n\n    integer :: ndims, nvars, ngatts, unlimdimid\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( icnt_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    ierr_nf90=nf90_inq_varid(icnt_nc, \"t\", varid_tt)\n    ierr_nf90=nf90_inq_varid(icnt_nc, \"recnt\", varid_recnt)\n    ierr_nf90=nf90_inq_varid(icnt_nc, \"imcnt\", varid_imcnt)\n    call check_nf90err(ierr_nf90, \"nf90_inq_varid\")\n\n    ierr_nf90=nf90_inquire_dimension(icnt_nc, unlimdimid, len=t_count)\n    call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n    count_nv=nv*2\n    start_nv=count_nv*rankv+1\n    count_nm=nm+1\n    start_nm=count_nm*rankm+1\n\n    count_time(:) = 1\n    start_time(:) = t_count\n    ierr_nf90=nf90_get_var( ncid=icnt_nc, varid=varid_tt, values=t_value, &\n                            start=start_time, count=count_time )\n    time = t_value(1)\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_cnt(:) = int((/ 2*nx+1,count_ny,count_nz,count_nv,count_nm,1,1 /), kind=4)\n    start_cnt(:) = (/ 1,start_ny,start_nz,start_nv,start_nm,1+ranks,t_count /)\n    ierr_nf90=nf90_get_var(icnt_nc, varid_recnt, &\n                           values=recnt(:,ny_st:ny_end,:,:,:), &\n                           start=start_cnt, count=count_cnt )\n    ierr_nf90=nf90_get_var(icnt_nc, varid_imcnt, &\n                           values=imcnt(:,ny_st:ny_end,:,:,:), &\n                           start=start_cnt, count=count_cnt )\n    call check_nf90err(ierr_nf90, \"nf90_get_var\")\n\n    wf = cmplx(recnt,imcnt)\n\n    istatus = ierr_nf90\n\n  END SUBROUTINE fileio_read_cnt\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_cnt ( wf, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:7), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_vl, varid_mu, varid_is, &\n               varid_tt, varid_recnt, varid_imcnt\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_cnt(1:7), count_cnt(1:7)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nv(1), count_nv(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: is\n    integer :: ny_st, ny_end\n\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: ocnt_t_count\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( ocnt_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"vl\", &\n                              len=int(2*global_nv,kind=4), dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"mu\", &\n                              len=int(global_nm+1,kind=4), dimid=dimids(5) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(6) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(7) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"vl\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_vl )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"mu\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(5),   varid=varid_mu )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(6),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(7),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"recnt\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_recnt )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"imcnt\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_imcnt )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=ocnt_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      ocnt_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( ocnt_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( ocnt_nc, \"recnt\", varid_recnt )\n      ierr_nf90=nf90_inq_varid( ocnt_nc, \"imcnt\", varid_imcnt )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(ocnt_nc, unlimdimid, len=ocnt_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_vl, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_mu, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_recnt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_imcnt, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n    count_nv=nv*2\n    start_nv=count_nv*rankv+1\n    count_nm=nm+1\n    start_nm=count_nm*rankm+1\n\n    if ( ndims == 0 ) then\n      != Write variables: static coordinates x and y\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_vl, &\n                              values=vl(1:2*nv), &\n                              start=start_nv, count=count_nv )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_mu, &\n                              values=mu(0:nm), &\n                              start=start_nm, count=count_nm )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    ocnt_t_count = ocnt_t_count+1\n    count_time(:) = 1\n    start_time(:) = ocnt_t_count\n    ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_cnt(:) = int((/ 2*nx+1,count_ny,count_nz,count_nv,count_nm,1,1 /), kind=4)\n    start_cnt(:) = (/ 1,start_ny,start_nz,start_nv,start_nm,1+ranks,ocnt_t_count /)\n    ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_recnt, &\n                            values=dble(wf(:,ny_st:ny_end,:,:,:)), &\n                            start=start_cnt, count=count_cnt )\n    ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_imcnt, &\n                            values=aimag(wf(:,ny_st:ny_end,:,:,:)), &\n                            start=start_cnt, count=count_cnt )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_fxv ( fout, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,1:2*nv,0:nm) :: fout\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:7), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_vl, varid_mu, varid_is, &\n               varid_tt, varid_refxv, varid_imfxv\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_fxv(1:7), count_fxv(1:7)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nv(1), count_nv(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: ofxv_t_count\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( ofxv_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"zz\", &\n                              len=int(nprocz,kind=4),      dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"vl\", &\n                              len=int(2*global_nv,kind=4), dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"mu\", &\n                              len=int(global_nm+1,kind=4), dimid=dimids(5) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(6) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(7) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"vl\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_vl )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"mu\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(5),   varid=varid_mu )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(6),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(7),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"refxv\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_refxv )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"imfxv\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_imfxv )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=ofxv_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      ofxv_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( ofxv_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( ofxv_nc, \"refxv\", varid_refxv )\n      ierr_nf90=nf90_inq_varid( ofxv_nc, \"imfxv\", varid_imfxv )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(ofxv_nc, unlimdimid, len=ofxv_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_vl, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_mu, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_refxv, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_imfxv, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=1\n    start_nz=rankz+1\n    count_nv=nv*2\n    start_nv=count_nv*rankv+1\n    count_nm=nm+1\n    start_nm=count_nm*rankm+1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1:2*nz), &\n                              start=start_nz, count=count_nz )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_vl, &\n                              values=vl(1:2*nv), &\n                              start=start_nv, count=count_nv )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_mu, &\n                              values=mu(0:nm), &\n                              start=start_nm, count=count_nm )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    ofxv_t_count = ofxv_t_count+1\n    count_time(:) = 1\n    start_time(:) = ofxv_t_count\n    ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_fxv(:) = int((/ 2*nx+1,count_ny,count_nz,count_nv,count_nm,1,1 /), kind=4)\n    start_fxv(:) = (/ 1,start_ny,start_nz,start_nv,start_nm,1+ranks,ofxv_t_count /)\n    ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_refxv, &\n                            values=dble(fout(:,ny_st:ny_end,:,:)), &\n                            start=start_fxv, count=count_fxv )\n    ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_imfxv, &\n                            values=aimag(fout(:,ny_st:ny_end,:,:)), &\n                            start=start_fxv, count=count_fxv )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_fxv\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_phi ( phi, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:4), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_is, &\n               varid_tt, varid_rephi, varid_imphi\n    integer(kind=4) :: start_time(1), count_time(1), start_phi(1:4), count_phi(1:4)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: ophi_t_count\n\n    != Write conditions check\n    if ( (ranks /= 0) .OR. (vel_rank /= 0) ) then\n      return\n    end if\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( ophi_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(4) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"rephi\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_rephi )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"imphi\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_imphi )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=ophi_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      ophi_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( ophi_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( ophi_nc, \"rephi\", varid_rephi )\n      ierr_nf90=nf90_inq_varid( ophi_nc, \"imphi\", varid_imphi )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(ophi_nc, unlimdimid, len=ophi_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_rephi, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_imphi, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    ophi_t_count = ophi_t_count+1\n    count_time(:) = 1\n    start_time(:) = ophi_t_count\n    ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_phi(:) = int((/ 2*nx+1,count_ny,count_nz,1 /), kind=4)\n    start_phi(:) = (/ 1,start_ny,start_nz,ophi_t_count /)\n    ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_rephi, &\n                            values=dble(phi(:,ny_st:ny_end,:)), &\n                            start=start_phi, count=count_phi )\n    ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_imphi, &\n                            values=aimag(phi(:,ny_st:ny_end,:)), &\n                            start=start_phi, count=count_phi )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_Al ( Al, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:4), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_is, &\n               varid_tt, varid_reAl, varid_imAl\n    integer(kind=4) :: start_time(1), count_time(1), &\n                       start_Al(1:4), count_Al(1:4)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: oAl_t_count\n\n    != Write conditions check\n    if ( (ranks /= 0) .OR. (vel_rank /= 0) ) then\n      return\n    end if\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( oAl_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(4) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"kx\",   xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"ky\",   xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"zz\",   xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"t\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"reAl\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_reAl )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"imAl\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_imAl )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=oAl_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      oAl_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( oAl_nc, \"t\",    varid_tt )\n      ierr_nf90=nf90_inq_varid( oAl_nc, \"reAl\", varid_reAl )\n      ierr_nf90=nf90_inq_varid( oAl_nc, \"imAl\", varid_imAl )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(oAl_nc, unlimdimid, len=oAl_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_reAl, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_imAl, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    oAl_t_count = oAl_t_count+1\n    count_time(:) = 1\n    start_time(:) = oAl_t_count\n    ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_Al(:) = int((/ 2*nx+1,count_ny,count_nz,1 /), kind=4)\n    start_Al(:) = (/ 1,start_ny,start_nz,oAl_t_count /)\n    ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_reAl, &\n                            values=dble(Al(:,ny_st:ny_end,:)), &\n                            start=start_Al, count=count_Al )\n    ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_imAl, &\n                            values=aimag(Al(:,ny_st:ny_end,:)), &\n                            start=start_Al, count=count_Al )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_Al\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_mom ( dens, upara, ppara, pperp, qlpara, qlperp, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) ::  dens, upara, ppara, pperp, qlpara, qlperp\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: nmom = 6   ! Number of output moments\n\n    integer :: dimids(1:6), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_imom, varid_is, &\n               varid_tt, varid_remom, varid_immom\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_mom(1:6), count_mom(1:6)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: imom, is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: omom_t_count\n\n    != Write conditions check\n    if ( vel_rank /= 0 ) return\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( omom_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"imom\", &\n                              len=int(nmom,kind=4),        dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(5) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(6) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"imom\",  xtype=NF90_INT, &\n                              dimids=dimids(4),   varid=varid_imom )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(5),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(6),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"remom\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:6), varid=varid_remom )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"immom\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:6), varid=varid_immom )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=omom_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      omom_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( omom_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( omom_nc, \"remom\", varid_remom )\n      ierr_nf90=nf90_inq_varid( omom_nc, \"immom\", varid_immom )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(omom_nc, unlimdimid, len=omom_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_imom, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_remom, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_immom, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n    count_nm=1\n    start_nm=1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_imom, &\n                              values=(/ (imom, imom=0,nmom-1) /) )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    omom_t_count = omom_t_count+1\n    count_time(:) = 1\n    start_time(:) = omom_t_count\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_mom(:) = int((/ 2*nx+1,count_ny,count_nz,count_nm,1,1 /), kind=4)\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(dens(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(dens(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=2\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(upara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(upara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=3\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(ppara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(ppara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=4\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(pperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(pperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=5\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(qlpara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(qlpara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=6\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(qlperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(qlperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_mom\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_trn ( entrpy, fenegy, menegy, peint, pmint, &\n                                neint, nmint, dcd, pflux_es, pflux_em, &\n                                eflux_es, eflux_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy, peint, &\n                                   pmint, neint, nmint, dcd, &\n                                   pflux_es, pflux_em, eflux_es, eflux_em\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: ntrn = 12  ! Number of output total transfer diagnostics\n\n    integer :: dimids(1:5), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_itrn, varid_is, varid_tt, varid_trn\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_trn(1:5), count_trn(1:5)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nt(1), count_nt(1)\n    integer :: itrn, is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: otrn_t_count\n\n    != Write conditions check\n    if ( (zsp_rank /= 0) .OR. (vel_rank /= 0) ) then\n      return\n    end if\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( otrn_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"itrn\", &\n                              len=int(ntrn,kind=4),        dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(5) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"itrn\",  xtype=NF90_INT, &\n                              dimids=dimids(3),   varid=varid_itrn )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(4),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(5),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"trn\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:5), varid=varid_trn )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=otrn_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      otrn_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( otrn_nc, \"t\",   varid_tt )\n      ierr_nf90=nf90_inq_varid( otrn_nc, \"trn\", varid_trn )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(otrn_nc, unlimdimid, len=otrn_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_itrn, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_trn, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nt=1\n    start_nt=1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_itrn, &\n                              values=(/ (itrn, itrn=0,ntrn-1) /) )\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar(kx,ky,itrn,is)\" )\n    end if\n\n    otrn_t_count = otrn_t_count + 1\n    count_time(:) = 1\n    start_time(:) = otrn_t_count\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n    call check_nf90err( ierr_nf90, \"nf90_putvar(time)\" )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_trn(:) = int((/ 2*nx+1,count_ny,count_nt,1,1 /), kind=4)\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=entrpy(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=2\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=fenegy(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=3\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=menegy(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=4\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=peint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=5\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=pmint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=6\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=neint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=7\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=nmint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=8\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=dcd(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=9\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=pflux_es(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=10\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=pflux_em(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=11\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=eflux_es(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=12\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=eflux_em(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    call check_nf90err( ierr_nf90, \"nf90_putvar(trn)\" )\n\n  END SUBROUTINE fileio_write_trn\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_tri ( jkpq_es, jpqk_es, jqkp_es, &\n                                jkpq_em, jpqk_em, jqkp_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,-global_ny:global_ny) :: jkpq_es, jpqk_es, jqkp_es, &\n         jkpq_em, jpqk_em, jqkp_em\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: ntri = 6  ! Number of output triad transfer diagnostics\n\n    integer :: dimids(1:5), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_itri, varid_is, varid_tt, varid_tri\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_tri(1:5), count_tri(1:5)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nt(1), count_nt(1)\n    integer :: itri, is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: otri_t_count\n\n    real(kind=DP), dimension(0:global_ny)            :: gky\n    integer :: my\n\n    character(256)   :: env_string\n\n    integer       :: n_tht, m_j\n    real(kind=DP) :: kymin, del_c\n\n    namelist /nperi/ n_tht, kymin, m_j, del_c\n\n    if ( rank == 0 ) then\n     != Information about an open netCDF dataset\n      ierr_nf90=nf90_inquire( otri_nc, ndims, nvars, ngatts, unlimdimid )\n      call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n      if ( ndims == 0 ) then\n       != Define dimensions in file\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"kx\", &\n                                len=int(2*nx+1,kind=4),        dimid=dimids(1) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"ky\", &\n                                len=int(2*global_ny+1,kind=4), dimid=dimids(2) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"itri\", &\n                                len=int(ntri,kind=4),          dimid=dimids(3) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"is\", &\n                                len=int(ns,kind=4),            dimid=dimids(4) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"t\",  &\n                                len=NF90_UNLIMITED,            dimid=dimids(5) )\n        call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n       != Define variables in file\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"kx\",   xtype=NF90_DOUBLE, &\n                                dimids=dimids(1),   varid=varid_kx )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"ky\",   xtype=NF90_DOUBLE, &\n                                dimids=dimids(2),   varid=varid_ky )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"itri\", xtype=NF90_INT, &\n                                dimids=dimids(3),   varid=varid_itri )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"is\",   xtype=NF90_INT, &\n                                dimids=dimids(4),   varid=varid_is )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"t\",    xtype=NF90_DOUBLE, &\n                                dimids=dimids(5),   varid=varid_tt )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"tri\",  xtype=NF90_DOUBLE, &\n                                dimids=dimids(1:5), varid=varid_tri )\n        call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n       != End of definition of file\n        ierr_nf90=nf90_enddef( ncid=otri_nc )\n        call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n        otri_t_count = 0\n      else\n        ierr_nf90=nf90_inq_varid( otri_nc, \"t\",   varid_tt )\n        ierr_nf90=nf90_inq_varid( otri_nc, \"tri\", varid_tri )\n        call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n        ierr_nf90=nf90_inquire_dimension(otri_nc, unlimdimid, len=otri_t_count)\n        call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n      end if\n\n     != Parallel data access type\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_kx, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_ky, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_itri, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_is, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_tt, &\n                                     access=NF90_COLLECTIVE )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_tri, &\n                                     access=NF90_COLLECTIVE )\n      call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n      count_ny=2*global_ny+1\n      start_ny=1\n      count_nt=1\n      start_nt=1\n\n      if ( ndims == 0 ) then\n        close(inml)\n        call getenv ( 'fu05',env_string )\n        open(inml, file=env_string )\n\n        read(inml, nml=nperi)\n\n        do my = 0, global_ny\n          gky(my) = kymin * real( my, kind=DP )\n        end do\n      end if\n\n     != Write variables: static coordinates x and y\n      if ( ndims == 0 ) then\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_kx, &\n                                values=kx(-nx:nx) )\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_ky, &\n                                values=(/ -gky(global_ny:1:-1),gky(0:global_ny) /) )\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_itri, &\n                                values=(/ (itri, itri=0,ntri-1) /) )\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_is, &\n                                values=(/ (is, is=0,ns-1) /) )\n        call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n      end if\n\n      otri_t_count = otri_t_count+1\n      count_time(:) = 1\n      start_time(:) = otri_t_count\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tt, values=(/time/), &\n                              start=start_time, count=count_time )\n\n      ny_st = -global_ny\n      ny_end = global_ny\n      count_tri(:) = int((/ 2*nx+1,count_ny,count_nt,1,1 /), kind=4)\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jkpq_es(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=2\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jpqk_es(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=3\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jqkp_es(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=4\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jkpq_em(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=5\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jpqk_em(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=6\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jqkp_em(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n  END SUBROUTINE fileio_write_tri\n\n\n !--------------------------------------\n  SUBROUTINE check_nf90err(werr, comment)\n !--------------------------------------\n !  Check error message of nf90\n    integer(kind=4), intent(in) :: werr\n    character(len=*), intent(in) :: comment\n\n    if(werr /= nf90_noerr) then\n      write(*,*) comment//\" \"//trim(nf90_strerror(werr))\n      stop\n    end if\n\n  END SUBROUTINE check_nf90err\n\n\nEND MODULE GKV_fileio\n", "PROGRAM GKV_main\n!-------------------------------------------------------------------------------\n!\n!    GKV+: nonlinear gyrokinetic Vlasov code in a flux tube geometry\n!\n!    Hierarchy of the modules (The lower should be complied earlier)\n!    ------------------------\n!        main\n!         |\n!        set, out\n!         |\n!        advnc, dtc, trans\n!         |\n!        colli, colliimp, exb, shearflow\n!         |\n!        bndry, fft, fld, zfilter, geom\n!         |\n!        clock, intgrl, tips, freq, igs, vmecbzx, ring, fileio\n!         |\n!        mpienv, math\n!         |\n!        header\n!\n!    Update history of gkvp_main.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Adapt to modification of freq module.\n!      gkvp_f0.52 (S. Maeyama, Sep 2018)\n!        - Updated for implicit collision solver.\n!      gkvp_f0.40 (M. Nakata, June 2014)\n!        - Updated for realistic tokamak equilibrium, \n!          multi-species collision \n!      gkvp_f0.30 (S. Maeyama, March 2013)\n!        - Updated for electromagnetic, multi-species,\n!          MHD equilibrium, 5D-parallelization\n!      gkvp_r0.3 (T.-H. Watanabe, Jun 2011)\n!        - GKV is rearranged to Fortran90 module style. \n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_set,   only: set_init, set_close\n  use GKV_clock, only: clock_timer, clock_sta, clock_end, clock_reset\n  use GKV_out,   only: out_cntrl, out_contnu\n  use GKV_dtc,   only: dtc_cntrl, flag_time_advnc, flag_time_split\n  use GKV_fld,   only: fld_esfield\n  use GKV_advnc, only: advnc_rkgsteps_rev\n  use GKV_colliimp, only: colliimp_colli\n  use GKV_fft,   only: fft_pre\n  use GKV_freq,  only: freq_set, freq_conv\n  use GKV_tips,  only: tips_flush\n  use GKV_shearflow,  only: shearflow_kxmap\n\n  implicit none\n\n  complex(kind=DP), &\n    dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n  complex(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1)       :: Al, phi\n\n  complex(kind=DP), &\n    dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n  real(kind=DP) :: time\n  character(15) :: colliflag\n  integer :: loop, iflg, cflg\n\n\n    call mpienv_init( nprocw, nprocz, nprocv, nprocm, nprocs )\n\n    call clock_timer( 0, iflg )\n                                           call clock_sta(1)\n                                        ! call fapp_start(\"pre\",1,1)\n    call fft_pre( )\n    call set_init( ff, phi, Al, hh, time )\n      write( olog, * ) \" # simulation is started at t = \", time\n\n    if ( calc_type == \"lin_freq\" ) call freq_set( time )\n    call out_cntrl( ff, phi, Al, hh, time, 0 )\n\n    if ( adapt_dt ) call dtc_cntrl( ff, phi, Al, hh, time, 0 )\n                                        ! call fapp_stop(\"pre\",1,1)\n                                           call clock_end(1)\n                                           call clock_reset\n    \n    loop   = 0\n    cflg   = 0\n    call flush(olog)\n                                           call clock_sta(2)\n                                        !!call PAT_region_begin(1,\"timesteploop\",ierr_mpi)\n                                        ! call fipp_start\n                                        ! call fapp_start(\"timesteploop\",2,1)\n\n    do\n\n      if ( time > tend - eps ) exit\n\n      time   = time + dt\n      loop   = loop + 1\n\n      if (flag_time_advnc == 0) then! 4th-order RKG explicit time integration\n\n        colliflag = \"collisional\"\n        call advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n\n      else if (flag_time_advnc == 1) then! 2nd-order operator split with implicit collision\n\n        if (flag_time_split == 0) then\n                                           call clock_sta(17)\n                                        ! call fapp_start(\"colliimp\",17,1)\n          call colliimp_colli( 0.5_DP*dt, ff, phi, Al, hh )\n                                        ! call fapp_stop(\"colliimp\",17,1)\n                                           call clock_end(17)\n          colliflag = \"collisionless\"\n          call advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n          flag_time_split = 1\n                                          !%%% For debug %%%\n                                          ! if (rankg==0) write(olog,*) &\n                                          ! loop, time, \"half-step\"\n                                          !%%%%%%%%%%%%%%%%%\n        else if (flag_time_split == 1) then\n                                           call clock_sta(17)\n                                        ! call fapp_start(\"colliimp\",17,1)\n          call colliimp_colli( dt, ff, phi, Al, hh )\n                                        ! call fapp_stop(\"colliimp\",17,1)\n                                           call clock_end(17)\n          colliflag = \"collisionless\"\n          call advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n                                          !%%% For debug %%%\n                                          ! if (rankg==0) write(olog,*) &\n                                          ! loop, time, \"one-step\"\n                                          !%%%%%%%%%%%%%%%%%\n        end if\n\n      end if\n\n      if (gamma_e /= 0._DP.and. trim(flag_shearflow) == \"remap\") then\n        call shearflow_kxmap( time, ff, phi, Al, hh )\n        if (time > tlim_exb - eps.AND. cflg == 0 ) then \n          write( olog, * ) \"\"\n          write( olog, * ) \" ########## CAUTION! ############\"\n          write( olog, * ) \" # time variable exceeds the time-limit: tlim_exb = \", tlim_exb\n          write( olog, * ) \" # --> GKV is still running, but you need to check the results after tlim_exb.\"\n          write( olog, * ) \" ########## CAUTION! ############\"\n          write( olog, * ) \"\"\n          cflg = 1\n         !!! exit \n        end if\n      end if\n\n                                           call clock_sta(10)\n                                        ! call fapp_start(\"output\",10,1)\n      call out_cntrl( ff, phi, Al, hh, time, 1 )\n      if ( adapt_dt ) call dtc_cntrl( ff, phi, Al, hh, time, 1 )\n      if ( calc_type == \"lin_freq\" ) then\n        if ( all(freq_conv) ) then\n          write( olog, * ) \" # Growth rate and frequency are well converged.\"\n          exit\n        end if\n      end if\n                                        ! call fapp_stop(\"output\",10,1)\n                                           call clock_end(10)\n\n! --- output continu file every 10000 steps\n      if (mod(loop+10000,10000) == 0 ) then \n                                           call clock_sta(16)\n                                        ! call fapp_start(\"checkp\",16,1)\n        write( olog, * ) \"# check-point at time = \", time\n        call out_contnu ( ff, time )\n        call tips_flush\n                                        ! call fapp_stop(\"checkp\",16,1)\n                                           call clock_end(16)\n      end if\n! ---\n      call clock_timer( 1, iflg )\n      \n      if( iflg == 1 ) exit\n\n    end do\n                                        ! call fapp_stop(\"timesteploop\",2,1)\n                                        ! call fipp_stop\n                                        !!call PAT_region_end(1,ierr_mpi)\n                                           call clock_end(2)\n\n                                           call clock_sta(3)\n                                        ! call fapp_start(\"post\",3,1)\n    call out_cntrl( ff, phi, Al, hh, time, 2 )\n      write( olog, * ) \" # simulation is stopped at t = \", time\n                                        ! call fapp_stop(\"post\",3,1)\n                                           call clock_end(3)\n    call clock_timer( 2, iflg )\n\n    call set_close\n\n    call MPI_Finalize ( ierr_mpi )\n\n  stop\n\n\nEND PROGRAM GKV_main\n", "MODULE GKV_shearflow\n!-------------------------------------------------------------------------------\n!\n!    Shearflow convection term  \n!\n!    Update history of gkvp_shearflow.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!      gkvp_f0.55 (M. Nakata, Dec 2018)   \n!        - First implementation\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fld,    only: fld_esfield, fld_emfield_ff, fld_ff2hh\n  use GKV_tips,  only: tips_reality\n\n  implicit none\n\n  private\n\n  public   shearflow_kxmap\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE shearflow_kxmap( time, ff, phi, Al, hh )\n!--------------------------------------\n!     discrete advection in kx direction due to the mean radial flow shear\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    real(kind=DP), intent(in)           :: time\n\n    complex(kind=DP), dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff_tmp\n\n    integer :: mx, my, iz, iv, im, mx_new, gmy, tloop\n    integer, dimension(0:ny) :: my_map, loop_mapping\n\n      tloop = nint(time/dt)\n      my_map(:) = -1\n      if (rankw == 0) loop_mapping(0) = 1\n\n      do my = ist1_y, iend_y\n \n        gmy = my + (ny+1)*rankw\n       !!!loop_mapping(my) = nint(kxmin_g/(kymin_g*abs(gamma_e)*dt))/gmy\n        loop_mapping(my) = nint(kxmin_g/(kymin_g*gmy*abs(gamma_e)*dt))\n\n        if (mod(tloop+loop_mapping(my),loop_mapping(my)) == 0 ) then \n          my_map(my) = my\n        else \n          my_map(my) = -1\n        end if \n\n      end do\n\n      if (maxval(my_map) < 0 ) then \n        return\n      else \n\n        if ( gamma_e > 0._DP ) then\n\n!$OMP parallel do collapse(2) default(none) &\n!$OMP shared(ist_y,iend_y,my_map,ff,ff_tmp) &\n!$OMP private(mx,my,iz,iv,im,mx_new)\n          do im = 0-nvb, nm+nvb\n            do iv = 1-nvb, 2*nv+nvb\n              do iz = -nz-nzb, nz-1+nzb\n                do my = ist_y, iend_y\n\n                  if (my == my_map(my)) then       \n                    do mx = -nx+1, nx\n                      mx_new = mx - 1  \n                      ff_tmp(mx_new,my,iz,iv,im) = ff(mx,my,iz,iv,im)\n                    end do \n                    ff_tmp(nx,my,iz,iv,im) = (0._DP, 0._DP)\n                  end if\n\n                end do \n              end do \n            end do \n          end do \n\n        else if (gamma_e < 0._DP) then  \n\n!$OMP parallel do collapse(2) default(none) &\n!$OMP shared(ist_y,iend_y,my_map,ff,ff_tmp) &\n!$OMP private(mx,my,iz,iv,im,mx_new)\n          do im = 0-nvb, nm+nvb\n            do iv = 1-nvb, 2*nv+nvb\n              do iz = -nz-nzb, nz-1+nzb\n                do my = ist_y, iend_y\n\n                  if (my == my_map(my)) then       \n                    do mx = -nx, nx-1\n                      mx_new = mx + 1  \n                      ff_tmp(mx_new,my,iz,iv,im) = ff(mx,my,iz,iv,im)\n                    end do \n                    ff_tmp(-nx,my,iz,iv,im) = (0._DP, 0._DP)\n                  end if\n\n                end do \n              end do \n            end do \n          end do \n      \n        end if \n\n!$OMP parallel do collapse(2) default(none) &\n!$OMP shared(ist_y,iend_y,my_map,ff,ff_tmp) &\n!$OMP private(mx,my,iz,iv,im,mx_new)\n        do im = 0-nvb, nm+nvb\n          do iv = 1-nvb, 2*nv+nvb\n            do iz = -nz-nzb, nz-1+nzb\n              do my = ist_y, iend_y\n\n                if (my == my_map(my)) then       \n                  do mx = -nx, nx\n                    ff(mx,my,iz,iv,im) = ff_tmp(mx,my,iz,iv,im)\n                  end do\n                end if\n\n              end do\n            end do\n          end do\n        end do\n\n        call fld_esfield( ff, phi )\n        if ( beta.ne. 0._DP ) then\n          call fld_emfield_ff( ff, Al )\n        end if\n        call fld_ff2hh( ff, Al, hh )\n\n        call tips_reality( hh )\n\n      end if\n\n  END SUBROUTINE shearflow_kxmap\n\nEND MODULE GKV_shearflow\n", "MODULE GKV_set\n!-------------------------------------------------------------------------------\n!\n!    Set file I/O, and read parameters from namelist\n!\n!    Update history of gkvp_set.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Contents of subroutine set_cnfig are moved to GKV_geom, to implement\n!          time-dependent metrics and operators in rotating flux-tube model.\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - equib_type = \"s-alpha-shift\" is added.\n!        - Initial random phase rr is set by global (mx,gmy) indices.\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Use fileio module to switch Fortran/NetCDF binary output.\n!      gkvp_f0.58 (S. Maeyama, Oct 2020)\n!        - init_random is added to switch random number for initialization.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - equib_type=\"slab\" is added for shearless slab geometry.\n!        - Set ky=0, ksq=0 for padding iend_y<my.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_math,   only: math_random\n  use GKV_fld,    only: fld_esfield, fld_emfield_ff, fld_ff2hh\n  use GKV_bndry,  only: bndry_zvm_bound_f\n  use GKV_advnc,  only: caldlt_rev\n  use GKV_dtc,    only: dtc_init\n  use GKV_colli,  only: colli_set_param\n  use GKV_colliimp,  only: colliimp_set_param\n  use GKV_tips,   only: tips_reality\n  !fj start 202010\n  use GKV_fileio\n  !fj end 202010\n  use GKV_geom, only : geom_read_nml, geom_init_kxkyzvm,      &\n                       geom_init_metric, geom_set_operators,  &\n                       geom_reset_time\n\n  implicit none\n\n  private\n\n  public   set_init, set_close\n\nCONTAINS\n\n!--------------------------------------\n  SUBROUTINE set_init( ff, phi, Al, hh, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    real(kind=DP), intent(out) :: time\n\n\n      call set_start\n      call set_param\n\n\n      if ( trim(equib_type) == \"slab\"     .OR. &\n           trim(equib_type) == \"analytic\" .OR. &\n           trim(equib_type) == \"s-alpha\"  .OR. &\n           trim(equib_type) == \"s-alpha-shift\"  .OR. &\n           trim(equib_type) == \"circ-MHD\" .OR. &\n           trim(equib_type) == \"vmec\"     .OR. &\n           trim(equib_type) == \"eqdsk\"    .OR. &\n           trim(equib_type) == \"ring\" ) then\n\n        call set_cnfig\n\n      else\n\n        if ( rankg == 0 ) then\n          write(*,*) \"set_cnfig_error!! on namelist: equib\"\n        end if\n        call MPI_Finalize (ierr_mpi)\n        stop\n\n      end if\n\n      call set_value( ff, phi, Al, hh, time )\n\n    return\n\n\n  END SUBROUTINE set_init\n\n\n!--------------------------------------\n  SUBROUTINE set_start\n!--------------------------------------\n\n    character(128) :: memo\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cold, cnew\n\n    character(10)   :: cdate, ctime\n\n    namelist /cmemo/ memo\n    namelist /calct/ calc_type, z_bound, z_filt, z_calc, art_diff, &\n                     init_random, num_triad_diag\n    namelist /equib/ equib_type\n    namelist /run_n/ inum, ch_res\n    namelist /files/ f_log, f_hst, f_phi, f_fxv, f_cnt\n\n    character(256)   :: env_string       !fj\n\n\n      call getenv ( 'fu05',env_string )  !fj\n      open(inml, file=env_string )       !fj\n\n\n      call date_and_time( cdate, ctime )\n\n      read(inml,nml=cmemo)\n\n\n      read(inml,nml=calct)\n      read(inml,nml=equib)\n      if (trim(z_calc) == \"up5\") art_diff = 0._DP\n\n\n      inum = 1\n      ch_res = .false.\n      read(inml,nml=run_n)\n\n\n      read(inml,nml=files)\n\n      write( crank, fmt=\"(i6.6)\" ) rankg\n      write( srank, fmt=\"(i1.1)\" ) ranks\n      write( cold,  fmt=\"(i3.3)\" ) inum-1\n      write( cnew,  fmt=\"(i3.3)\" ) inum\n\n\n      open( olog, file=trim(f_log)//crank//\".\"//srank//\".log.\"//cnew )\n\n      if ( inum > 1 ) then\n        !fj start 202010\n        !open( icnt, file=trim(f_cnt)//crank//\".cnt.\"//cold, &\n        !      form=\"unformatted\", status=\"old\", action=\"read\" )\n        call fileio_open_icnt( trim(f_cnt) )\n        !fj end 202010\n      end if\n\n      !fj start 202010\n      !open( ofxv, file=trim(f_fxv)//crank//\".\"//srank//\".fxv.\"//cnew, form=\"unformatted\" )\n      !open( ocnt, file=trim(f_cnt)//crank//\".cnt.\"//cnew, form=\"unformatted\" )\n      call fileio_open_fxv( trim(f_fxv) )\n      call fileio_open_cnt( trim(f_cnt) )\n      !fj end 202010\n\n      !fj start 202011\n      !if ( vel_rank == 0 ) then\n      !  open( omom, file=trim(f_phi)//crank//\".\"//srank//\".mom.\"//cnew, form=\"unformatted\" )\n      !end if\n      call fileio_open_mom( trim(f_phi) )\n      !fj end 202011\n\n      !fj start 202011\n      !if ( ranks == 0 .AND. vel_rank == 0 ) then\n      !  open( ophi, file=trim(f_phi)//crank//\".\"//srank//\".phi.\"//cnew, form=\"unformatted\" )\n      !  open(  oAl, file=trim(f_phi)//crank//\".\"//srank//\".Al.\"//cnew, form=\"unformatted\" )\n      !end if\n      call fileio_open_phi( trim(f_phi) )\n      call fileio_open_Al( trim(f_phi) )\n      !fj end 202011\n\n      !fj start 202011\n      !if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      !  open( otrn, file=trim(f_phi)//crank//\".\"//srank//\".trn.\"//cnew, form=\"unformatted\" )\n      !end if\n      call fileio_open_trn( trim(f_phi) )\n      !fj end 202011\n\n      if( rankg == 0 ) then\n        open( omtr, file=trim(f_hst)//\"mtr.\"//cnew )\n        open( omtf, file=trim(f_hst)//\"mtf.\"//cnew )\n        open( odtc, file=trim(f_hst)//\"dtc.\"//cnew )\n        open( oeng, file=trim(f_hst)//\"eng.\"//cnew )\n        open( omen, file=trim(f_hst)//\"men.\"//cnew )\n        open( owes, file=trim(f_hst)//\"wes.\"//cnew )\n        open( owem, file=trim(f_hst)//\"wem.\"//cnew )\n        if ( trim(calc_type) == \"lin_freq\" ) then\n          open( ofrq, file=trim(f_hst)//\"frq.\"//cnew )\n          open( odsp, file=trim(f_hst)//\"dsp.\"//cnew )\n        end if\n      end if\n      if( rankg == nprocz/2 ) then\n        open( ocst, file=trim(f_hst)//\"cst.\"//cnew )\n      end if\n\n      if( rank == 0 ) then\n        open( obln, file=trim(f_hst)//\"bln.\"//srank//\".\"//cnew )\n        open( oges, file=trim(f_hst)//\"ges.\"//srank//\".\"//cnew )\n        open( ogem, file=trim(f_hst)//\"gem.\"//srank//\".\"//cnew )\n        open( oqes, file=trim(f_hst)//\"qes.\"//srank//\".\"//cnew )\n        open( oqem, file=trim(f_hst)//\"qem.\"//srank//\".\"//cnew )\n      end if\n\n      write( olog, * ) \"##### \", trim(memo), \" #####\"\n      write( olog, * ) \"\"\n      write( olog, * ) \"# Date : \", cdate\n      write( olog, * ) \"# Time : \", ctime\n      write( olog, * ) \"\"\n      write( olog, * ) \"# Type of calc. : \", trim(calc_type)\n      write( olog, * ) \"# Boundary condition in zz       : \", trim(z_bound)\n      write( olog, * ) \"# 4th-order filter in zz         : \", trim(z_filt)\n      write( olog, * ) \"# Finite difference scheme in zz : \", trim(z_calc)\n      write( olog, * ) \"# Artificial diffusion in zz     : \", art_diff\n      write( olog, * ) \"# Number of triad transfer diag. : \", num_triad_diag\n      write( olog, * ) \"# Type of equib. : \", trim(equib_type)\n      write( olog, * ) \"\"\n      write( olog, * ) \"# Run number = \", inum\n      write( olog, * ) \"# Resolution change = \", ch_res\n      write( olog, * ) \"\"\n\n\n    return\n  \n\n  END SUBROUTINE set_start\n\n\n!--------------------------------------\n  SUBROUTINE set_close\n!--------------------------------------\n\n     close( olog )\n\n     !fj start 202010\n     !close( icnt )\n     !close( ofxv )\n     !close( ocnt )\n     call fileio_close_icnt\n     call fileio_close_fxv\n     call fileio_close_cnt\n     !fj end 202010\n\n     !fj start 202011\n     !if ( vel_rank == 0 ) then\n     !  close( omom )\n     !end if\n     call fileio_close_mom\n     !fj end 202011\n\n     !fj start 202011\n     !if ( ranks == 0 .AND. vel_rank == 0 ) then\n     !  close( ophi )\n     !  close( oAl  )\n     !end if\n     call fileio_close_phi\n     call fileio_close_Al\n     !fj end 202011\n\n     !fj start 202011\n     !if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n       !close( otrn )\n     !end if\n     call fileio_close_trn\n     !fj end 202011\n\n     if( rankg == 0 ) then\n       close( omtr )\n       close( omtf )\n       close( odtc )\n       close( oeng )\n       close( omen )\n       close( owes )\n       close( owem )\n       if ( trim(calc_type) == \"lin_freq\" ) then\n         close( ofrq )\n         close( odsp )\n       end if\n     end if\n      if( rankg == nprocz/2 ) then\n       close( ocst )\n     end if\n\n     if( rank == 0 ) then\n       close( obln )\n       close( oges )\n       close( ogem )\n       close( oqes )\n       close( oqem )\n     end if\n\n  END SUBROUTINE set_close\n\n\n!--------------------------------------\n  SUBROUTINE set_param\n!--------------------------------------\n\n    namelist /runlm/ e_limit\n    namelist /times/ tend, dtout_fxv, dtout_ptn, dtout_eng, dtout_dtc\n    namelist /deltt/ dt_max, adapt_dt, courant_num, time_advnc\n\n\n      e_limit   = 5._DP * 3600._DP - 300._DP\n\n      read(inml,nml=runlm)\n\n\n      tend      = 10.00_DP\n      dtout_fxv = 5._DP\n      dtout_ptn = 0.5_DP\n      dtout_eng = 0.005_DP\n      dtout_dtc = 0.005_DP\n\n      read(inml,nml=times)\n\n\n      dt_max    = 0.005_DP\n      adapt_dt  = .false.\n      courant_num  = 0.6_DP\n\n      read(inml,nml=deltt)\n\n\n        write( olog, * ) \" # Numerical parameters \"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # nxw, nyw  = \", nxw, nyw\n        write( olog, * ) \" # global_ny = \", global_ny\n        write( olog, * ) \" # global_nz = \", global_nz\n        write( olog, * ) \" # global_nv, global_nm = \", global_nv, global_nm\n        write( olog, * ) \"\"\n        write( olog, * ) \" # nx, ny, nz   = \", nx, ny, nz\n        write( olog, * ) \" # nv, nm       = \", nv, nm\n        write( olog, * ) \" # nzb, nvb     = \", nzb, nvb\n        write( olog, * ) \" # nxw_size (local xw allocation size) = \", nxw_size\n        write( olog, * ) \" # number of species  = \", nprocs\n        write( olog, * ) \" # ranks=0: Electron\"\n        write( olog, * ) \" # ranks=1: main ion\"\n        write( olog, * ) \" # ranks>1: other ions\"\n        write( olog, * ) \" # Note that proton mass mp and main ion tmep. Ti is used for normalizations\"\n        write( olog, * ) \" # kx, ky are normalized with rho_tp = mp*vtp/e/Baxi, where vtp = sqrt(Ti/mp)\"\n        write( olog, * ) \" # time t is normalized with Raxi/vtp\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # e_limit      = \", e_limit\n        write( olog, * ) \" # tend         = \", tend\n        write( olog, * ) \" # dtout_fxv, dtout_ptn = \", dtout_fxv, dtout_ptn\n        write( olog, * ) \" # dtout_eng, dtout_dtc = \", dtout_eng, dtout_dtc\n        write( olog, * ) \"\"\n        write( olog, * ) \" # maximum time step dt_max = \", dt_max\n        write( olog, * ) \" # adaptive time step = \", adapt_dt\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # MPI parallelization parameters \"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # nproc , rankg = \", nproc , rankg\n        write( olog, * ) \" # nprocw, rankw = \", nprocw, rankw\n        write( olog, * ) \" # nprocz, rankz = \", nprocz, rankz\n        write( olog, * ) \" # nprocv, rankv = \", nprocv, rankv\n        write( olog, * ) \" # nprocm, rankm = \", nprocm, rankm\n        write( olog, * ) \" # nprocs, rank  = \", nprocs , rank\n        write( olog, * ) \" # izup, izdn    = \", izup, izdn\n        write( olog, * ) \" # ivup, ivdn    = \", ivup, ivdn\n        write( olog, * ) \" # imup, imdn    = \", imup, imdn\n        write( olog, * ) \"\"\n        write( olog, * ) \" # fft_nproc , fft_rank  = \", fft_nproc , fft_rank\n        write( olog, * ) \" # zsp_nproc , zsp_rank  = \", zsp_nproc , zsp_rank\n        write( olog, * ) \" # vel_nproc , vel_rank  = \", vel_nproc , vel_rank\n        write( olog, * ) \" # ranks                 = \", ranks\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # ist_y     = \", ist_y\n        write( olog, * ) \" # iend_y    = \", iend_y\n        write( olog, * ) \" # nsize_y   = \", nsize_y\n        write( olog, * ) \" # ist1_y    = \", ist1_y\n        write( olog, * ) \" # ist_y_g   = \", ist_y_g\n        write( olog, * ) \" # iend_y_g  = \", iend_y_g\n        write( olog, * ) \"\"\n        write( olog, * ) \" # ist_xw    = \", ist_xw\n        write( olog, * ) \" # iend_xw   = \", iend_xw\n        write( olog, * ) \" # nsize_xw  = \", nsize_xw\n        write( olog, * ) \" # ist_xw_g  = \", ist_xw_g\n        write( olog, * ) \" # iend_xw_g = \", iend_xw_g\n        write( olog, * ) \"\"\n\n\n  END SUBROUTINE set_param\n\n\n!--------------------------------------\n  SUBROUTINE set_cnfig\n!--------------------------------------\n\n    real(kind=DP), dimension(0:ns-1,0:ns-1) :: nust\n    real(kind=DP) :: lx, ly, eps_r\n    integer       :: is1, is2\n   \n    namelist /nu_ref/ Nref,     & ! reference (electron) density in m^(-3)\n                      Lref,     & ! reference length (=R_axis) in m\n                      Tref,     & ! reference main-ion (ranks=1) temperature in keV \n                      col_type, & ! flag for collision type: LB or full\n                      iFLR,     & ! flag for GK- or DK-limit in collision\n                      icheck      ! flag for Maxwellain anihilation test (w/ iFLR=0)\n\n! --- read GKV namelist relating to configurations ---\n        call geom_read_nml\n\n! --- coordinate settings (time-indep.) ---\n        call geom_init_kxkyzvm(lx, ly, eps_r)\n\n! --- set collision frequencies and v-space functions for multi-species GK collision\n        read(inml,nml=nu_ref)\n        call colli_set_param(q_0, eps_r, nust)\n        write( olog, * ) \" # Collision parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # Nref [m^-3]  = \", Nref\n        write( olog, * ) \" # Lref [m]     = \", Lref\n        write( olog, * ) \" # Tref [keV]   = \", Tref\n        write( olog, * ) \" # col_type     = \", col_type\n        write( olog, * ) \" # iFLR         = \", iFLR\n        write( olog, * ) \" # icheck       = \", icheck\n        write( olog, * ) \n        write( olog, * ) \" # Normalized collisionality: nu*\"\n        do is1 = 0, ns-1\n        do is2 = 0, ns-1\n        write( olog, * ) \" # a, b, nu*_ab = \", is1, is2, nust(is1,is2)\n        end do\n        end do\n        write( olog, * ) \n        if ( trim(col_type) == \"LB\" ) then\n          write( olog, * ) \" # col.-freq. bias factor for LB, nu = \", nu(:)\n          write( olog, * ) \n        end if\n\n        Zeff = 0._DP\n        do is1 = 1, ns-1\n          Zeff = Zeff + fcs(is1)*Znum(is1)\n        end do\n        write( olog, * ) \" # Zeff         = \", Zeff\n        write( olog, * ) \n\n\n! --- coordinate settings (explicitly time-dependent metrics) ---\n        call geom_init_metric\n\n! --- operator settings (time-dependent through metrics) ---\n        call geom_set_operators\n        if (trim(col_type) == \"full\" .or. trim(col_type) == \"lorentz\" .or. trim(time_advnc) == \"imp_colli\") then\n          call colliimp_set_param\n        end if\n\n! --- initial estimate of time steps ---\n        call dtc_init( lx, ly, vmax )\n\n  END SUBROUTINE set_cnfig\n\n\n!--------------------------------------\n  ", "SUBROUTINE set_value( ff, phi, Al, hh, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n\n    real(kind=DP), intent(out) :: time\n\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf, dh, cf, ef\n    real(kind=DP),    dimension(:),         allocatable :: rr\n    character(15) :: colliflag\n    integer :: input_status\n    integer :: mx, my, iz, iv, im, nx_init, gmy\n\n\n      ff(:,:,:,:,:) = ( 0._DP, 0._DP )\n      phi(:,:,:)    = ( 0._DP, 0._DP )\n      Al(:,:,:)     = ( 0._DP, 0._DP )\n      hh(:,:,:,:,:) = ( 0._DP, 0._DP )\n\n\n      if( inum == 1 ) then\n\n\n        time     = 0._DP\n\n        allocate( rr((2*nx+1)*(global_ny+1)) )\n\n        if (init_random) then\n          call math_random ( rr )\n        else\n          rr(:) = 0._DP\n        end if\n\n        if ( nx0 > nx ) then \n          nx_init = nx\n        else        \n          nx_init = nx0\n        end if\n\n!!!        my = 0 for R-H test\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = ist1_y, iend_y\n           ! do my = ist_y, iend_y\n                gmy = my + (ny+1)*rankw\n                do mx = -nx_init, nx_init\n                  ff(mx,my,iz,iv,im)   = dns1(ranks) * fmx(iz,iv,im)  &\n                          * ( 1._DP + vl(iv) + zz(iz) )**2            &\n                          * exp( -zz(iz)**2 / (0.2_DP*pi)**2 ) &\n                          * exp( ui * twopi * rr(mx+nx+1+(2*nx+1)*gmy) )\n                end do\n              end do\n            end do\n          end do\n        end do\n\n        if ( rankw == 0 ) then\n          do im = 0, nm\n            do iv = 1, 2*nv\n              do iz = -nz, nz-1\n                my = 0\n                  do mx = 1, nx\n                    ff(-mx,my,iz,iv,im) = conjg( ff(mx,my,iz,iv,im) )\n                  end do\n                ff(0,0,iz,iv,im) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n        end if\n\n        deallocate( rr )\n\n\n        if ( ch_res ) call set_ch_resolution ( ff, time )\n\n\n      else\n\n\n        allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n        time   = - 1._DP\n\n        do \n         !fj start 202010\n         !read( unit=icnt, iostat=input_status ) time, wf\n          call fileio_read_cnt( wf, time, input_status )\n         !fj end 202010\n\n          if ( input_status < 0 ) then\n            write( olog, * ) &\n               \" # end of file of unit=30 is detected --> stop\"\n            call flush(olog)\n            call MPI_Abort(MPI_COMM_WORLD, ierr_mpi)\n            stop\n          end if\n\n          if ( input_status > 0 ) then\n            write( olog, * ) &\n               \" # input error of unit=30 is detected --> stop\"\n            call flush(olog)\n            call MPI_Abort(MPI_COMM_WORLD, ierr_mpi)\n            stop\n          end if\n\n          if ( time > eps ) exit\n        end do\n\n\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,iz,iv,im) = wf(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        end do\n\n        deallocate( wf )\n\n\n          write( olog, * ) \"\"\n          write( olog, * ) \" # simulation is re-started at t = \", time\n          write( olog, * ) \"\"\n\n\n      end if\n\n    !%%% For shearflow rotating flux tube model %%%\n      if (gamma_e /= 0._DP.and. trim(flag_shearflow) ==\"rotating\") then\n        call geom_reset_time(time)\n        if (trim(col_type) == \"full\".or. trim(col_type) == \"lorentz\".or. trim(time_advnc) == \"imp_colli\") then\n          call colliimp_set_param\n        end if\n      end if\n    !%%%\n\n      call bndry_zvm_bound_f( ff )\n\n      call fld_esfield( ff, phi )\n      if ( beta.ne. 0._DP ) then\n        call fld_emfield_ff( ff, Al )\n      end if\n      call fld_ff2hh( ff, Al, hh )\n\n      call tips_reality( hh )\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      colliflag = \"collisional\"\n      call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n!! --- for debug\n!      call MPI_Finalize(ierr_mpi)\n!      stop\n\n\n  END SUBROUTINE set_value\n\n\n!--------------------------------------\n  SUBROUTINE set_ch_resolution ( ff, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    real(kind=DP), intent(out) :: time\n\n\n   !--- Set perpendicular resolution employed in the input file. ---\n   !!! NOTE!!!\n   !    Resolutions in (z,v,m,s) should be kept the same.\n   !    Since lx and ly should be larger than or equal to lx0, ly0,\n   !    xfold and yfold are set to be integers.\n   !!!!!!!!!!!!\n      integer, parameter :: xfold = 1  ! kxmin0 = xfold * kxmin\n      integer, parameter :: yfold = 1  ! kymin0 = yfold * kymin\n      integer, parameter :: nx0 = 95, global_ny0 = 1, nprocw0 = 1\n      integer, parameter :: ny0 = global_ny0 / nprocw0\n      real(kind=DP) :: amplify = 1._DP\n   !----------------------------------------------------------------\n\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    integer :: input_status\n    integer :: ny_size0, nwk0, irw, ist_y_g0, iend_y_g0\n    integer :: mx, my, iz, iv, im, mxw, myw\n    character(6)   :: crank\n    character(1)   :: srank\n\n\n\n      allocate( wf(-nx0:nx0,0:ny0,-nz:nz-1,1:2*nv,0:nm) )\n\n      do irw = 0, nprocw0-1\n\n        ny_size0 = global_ny0 + 1 \n        if( mod(ny_size0,nprocw0) == 0 )  then\n          nwk0    = ny_size0 / nprocw0\n        else\n          nwk0    = ny_size0 / nprocw0 + 1\n        endif\n       !--- global index range ---------------- \n        ist_y_g0  = nwk0*irw\n        iend_y_g0 = min( nwk0*(irw+1)-1, (ny_size0-1) )\n\n        write( crank, fmt=\"(i6.6)\" ) irw + nprocw0*rankz + nprocw0*nprocz*rankv  &\n            + nprocw0*nprocz*nprocv*rankm + nprocw0*nprocz*nprocv*nprocm*ranks\n        write( srank, fmt=\"(i1.1)\" ) ranks\n\n       !fj start 202010\n       !open( icnt, file=trim(f_cnt)//crank//\".cnt.000\", &\n       !      form=\"unformatted\", status=\"old\", action=\"read\" )\n       !read( unit=icnt, iostat=input_status ) time, wf\n       !rewind( icnt )\n       !close( icnt )\n        call fileio_open_icnt( trim(f_cnt) )\n        call fileio_read_cnt( wf, time, input_status )\n        call fileio_close_icnt\n       !fj end 202010\n\n        if ( ist_y_g <= iend_y_g0 * yfold.and. ist_y_g0 * yfold <= iend_y_g ) then\n          do im = 0, nm\n            do iv = 1, 2*nv\n              do iz = -nz, nz-1\n                do my = ist_y_g0, iend_y_g0\n                  myw = my * yfold\n                  if ( ist_y_g <= myw.and. myw <= iend_y_g ) then\n                    do mx = -nx0, nx0\n                      mxw = mx * xfold\n                      if ( -nx <= mxw.and. mxw <= nx ) then\n                        ff(mxw,myw-ist_y_g,iz,iv,im) = wf(mx,my-ist_y_g0,iz,iv,im) * amplify\n                      end if\n                    end do\n                  end if\n                end do\n              end do\n            end do\n          end do\n        end if\n\n      end do\n\n      deallocate( wf )\n\n      write( olog, * ) \"\"\n      write( olog, * ) \" # simulation is re-started at t = \", time\n      write( olog, * ) \" # perpendicular resolutions are changed:\"\n      write( olog, * ) \" # lx is \", xfold, \"times larger\" \n      write( olog, * ) \" # ly is \", yfold, \"times larger\" \n      write( olog, * ) \" # nx =\", nx0, \"to\", nx\n      write( olog, * ) \" # global_ny =\", global_ny0, \"to\", global_ny\n      write( olog, * ) \" # nprocw from\", nprocw0, \"to\", nprocw\n      write( olog, * ) \"\"\n\n\n  END SUBROUTINE set_ch_resolution\n\n\nEND MODULE GKV_set\n", "MODULE GKV_header\n!-------------------------------------------------------------------------------\n!\n!    Header for general use in the fluxtube code\n!\n!    Notes\n!    -----\n!      There are some restrictions on numerical parameters:\n!         mod( global_nz, nprocz ) = 0, due to z parallelization.\n!         mod( global_nv, nprocv ) = 0, due to v parallelization.\n!         mod( global_nm+1, nprocm ) = 0, due to m parallelization.\n!         nm>=3, due to fft and colli.\n!         nzb>=2, due to 4th-oreder z derivative.\n!      There are some recommendations on numerical parameters:\n!         mod( nxw, nprocw ) = 0, due to w parallelization.\n!         mod( global_ny+1, nprocw ) = 0, due to w parallelization.\n!         nzb<=nz due to data copy in zfilter.\n!\n!    Update history\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - flag_shearflow = \"rotating\" is set as a default. Alternatively,\n!          flag_shaerflow = \"remap\" is still available for time-discontinuous\n!          wave-vector remap with nearest grid approximation.\n!        - File I/O unit \"omtf\" is added for metrics in flux-coordinates.\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - equib_type is extended from len=8 to len=15.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  implicit none\n\n  public\n\n  integer, parameter :: DP = selected_real_kind(14)\n\n!--------------------------------------\n!  Dimension size (grid numbers)\n!--------------------------------------\n!  Global simulation domain \n!  in  x, y,z,v,m (0:2*nxw-1,  0:2*nyw-1,-global_nz:global_nz-1,1:2*global_nv,0:global_nm)\n!  in kx,ky,z,v,m (   -nx:nx,0:global_ny,-global_nz:global_nz-1,1:2*global_nv,0:global_nm)\n\n  integer, parameter :: nxw = 20, nyw = 20\n  integer, parameter :: nx = 4, global_ny = 1! 2/3 de-aliasing rule\n  integer, parameter :: global_nz = 12, global_nv = 24, global_nm = 7\n\n  integer, parameter :: nzb = 2, & ! the number of ghost grids in z\n                        nvb = 2    ! the number of ghost grids in v and m\n\n!--------------------------------------\n!  Data distribution for MPI\n!--------------------------------------\n\n  integer, parameter :: nprocw = 1, nprocz = 2, nprocv = 4, nprocm = 2, nprocs = 1\n\n!--------------------------------------\n!  Parameters for variable sizes\n!--------------------------------------\n!  Local simulation domain \n!  in kx,ky,z,v,m (divided in ky,z,v,m) (   -nx:nx,      0:ny,-nz:nz-1,1:2*nv,0:nm)\n!  in  x,ky,z,v,m (divided in ky,z,v,m) (0:2*nxw-1,      0:ny,-nz:nz-1,1:2*nv,0:nm)\n!  in  y, x,z,v,m (divided in  x,z,v,m) (    0:nyw,0:nxw_size,-nz:nz-1,1:2*nv,0:nm)\n\n  integer, parameter :: nxw_size = (2*nxw-1)/nprocw    ! local allocation size (0:nxw_size)\n  integer, parameter :: ny       = global_ny / nprocw  ! local allocation size (0:ny)\n\n  integer, parameter :: nz = global_nz / nprocz,          &\n                        nv = global_nv / nprocv,          &\n                        nm = (global_nm + 1) / nprocm - 1,&\n                        ns = nprocs\n\n  integer, parameter :: nxyz = (2*nx+1)*(ny+1)*(2*nz), &\n                        nxy  = (2*nx+1)*(ny+1)\n\n  integer, parameter :: nnx = nxw*2, nny = nyw*2\n\n\n!--------------------------------------\n!  Constants\n!--------------------------------------\n\n  real(kind=DP),    parameter :: pi  = 3.141592653589793_DP, &\n                                 twopi = pi * 2._DP,         &\n                                 eps = 0.0000000001_DP\n  complex(kind=DP), parameter :: ui  = ( 0._DP, 1._DP )\n\n\n!--------------------------------------\n!  Index Range\n!--------------------------------------\n\n! ---- y dimension -------\n  integer :: ist_y                          ! local start index of y\n  integer :: iend_y                         ! local end   index of y\n  integer :: nsize_y                        ! local size of y\n  integer :: ist1_y                         ! local start index of y for global start index 1 \n\n  integer :: ist_y_g                        ! global start index of y\n  integer :: iend_y_g                       ! global end   index of y\n\n! ---- xw dimension  -------\n  integer :: ist_xw                          ! local start index of xw\n  integer :: iend_xw                         ! local end   index of xw\n  integer :: nsize_xw                        ! local size of xw\n\n  integer :: ist_xw_g                        ! global start index of xw\n  integer :: iend_xw_g                       ! global end   index of xw\n\n\n!--------------------------------------\n!  Parameters for time\n!--------------------------------------\n\n  real(kind=DP) :: e_limit                          ! elapsed time limit of a job\n  real(kind=DP) :: tend                             ! end time\n  real(kind=DP) :: dtout_fxv, dtout_ptn, dtout_eng  ! time-spacing for output\n  real(kind=DP) :: dtout_dtc                        ! time-spacing for dt control\n\n\n!--------------------------------------\n!  Configuration parameters to be \n!    initialized in init subroutine\n!--------------------------------------\n\n!  real(kind=DP), &\n!    dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)  :: kvd, kvs\n  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm)  :: vdx, vdy, vsy\n  real(kind=DP), &\n    dimension(-nx:nx,0:ny,-nz:nz-1,0:nm)         :: j0, j1, j2\n  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1) :: g0, ksq\n  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1) :: fct_poisson, fct_e_energy\n  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1) :: fct_ampere, fct_m_energy\n  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm) :: fmx\n  real(kind=DP), dimension(-nx:nx)               :: fctgt\n\n!!!%%% Parameters for colli_full %%%\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm) :: xxa\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm,0:ns-1,0:ns-1) :: nu_h, nu_g, nu_d, nu_p\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm)               :: nu_hs, nu_gs, nu_ds, nu_ps\n!!!  real(kind=DP), dimension(1:6,-nz:nz-1,1:2*nv,0:nm,0:ns-1,0:ns-1) :: x_tst, y_fld \n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm,0:ns-1,0:ns-1,1:2) :: c_t0\n!!!!  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm,0:ns-1,1:6) :: vfunc\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm,0:ns-1,1:6) :: vfunc\n!!!  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:6) :: jfunc\n!!!  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: adbtc\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  real(kind=DP), dimension(0:ns-1,0:ns-1) :: ctauiv, calpha, ctheta, cgamma, ceta, cxi\n\n  real(kind=DP), dimension(-nx:nx)          :: kx\n  real(kind=DP), dimension(0:ny)            :: ky\n  real(kind=DP), dimension(-nz:nz-1)        :: zz, omg\n  real(kind=DP), dimension(1:2*nv)          :: vl\n  real(kind=DP), dimension(0:nm)            :: mu\n  real(kind=DP), dimension(-nz:nz-1,0:nm)   :: vp, mir\n  real(kind=DP), dimension(-nz:nz-1)        :: dvp\n  real(kind=DP), dimension(-nz:nz-1)        :: dpara, rootg\n\n  complex(kind=DP), dimension(0:ny)         :: ck\n  integer, dimension(0:ny)                  :: dj\n\n  real(kind=DP) :: dt_max, dt\n  logical :: adapt_dt\n                                                    !!! Parameters for the R0 units\n  real(kind=DP), dimension(0:ns-1) ::   R0_Ln,  &   ! R0/Lns\n                                        R0_Lt,  &   ! R0/Lts\n                                           nu,  &   ! collision freq.   \n                                         Anum,  &   ! mass number\n                                         Znum,  &   ! charge number     \n                                          fcs,  &   ! charge-density fraction \n                                          sgn,  &   ! signs of charge   \n                                          tau,  &   ! T-ratio\n                                         dns1       ! initial perturbation amp.\n  real(kind=DP) :: dv, cfsrf, lambda_i, q_0, q_bar, beta, tau_ad, vmax\n  real(kind=DP) :: mach, uprime, gamma_e, kxmin_g, kymin_g, tlim_exb, s_hat_g\n  real(kind=DP) :: Nref, Lref, Tref, Zeff\n  integer       :: iFLR, icheck, ibprime, nx0\n  real(kind=DP) :: baxfactor\n\n  real(kind=DP) :: courant_num \n\n!--------------------------------------\n!  Type of calculation\n!--------------------------------------\n\n  character(9)  :: calc_type, & ! \"linear\", \"lin_freq\", \"nonlinear\"\n                   z_bound,   & ! \"zerofixed\", \"outflow\", \"mixed\"\n                   z_filt,    & ! \"on\", \"off\"\n                   z_calc,    & ! \"cf4\", \"up5\"\n                   col_type,  & ! \"LB\", \"full\", \"lorentz\"\n                   time_advnc   ! \"rkg4\", \"imp_colli\", \"auto_init\"\n  real(kind=DP) :: art_diff\n\n  integer :: num_triad_diag\n\n\n!--------------------------------------\n!  Parameters for numerical settings\n!--------------------------------------\n\n  integer :: inum\n  logical :: ch_res, init_random\n  character(512) :: f_log, f_hst, f_phi, f_fxv, f_cnt\n  character(15)  :: equib_type ! \"analytic\", \"s-alpha\", \"s-alpha-shift\",\n                               ! \"circ-MHD\", \"vmec\", \"eqdsk\", \"slab\"\n\n !character(15)  :: flag_shearflow = \"remap\"  ! Wavevector remap method\n !                                            ! with nearest grid approximation\n !                                            ! (Discontinuous in time)\n  character(15)  :: flag_shearflow = \"rotating\"! Rotating flux tube model\n\n! --- unit numbers for I/O\n  integer, parameter :: inml = 5,  & \n                        olog = 10, &\n                        icnt = 20, &\n                        ophi = 30, &\n                        oAl  = 31, &\n                        omom = 32, &\n                        otrn = 33, &\n                        otri = 34, &\n                        ofxv = 40, &\n                        ocnt = 50, &\n                        odtc = 59, &\n                        oeng = 60, &\n                        omen = 61, &\n                        owes = 62, &\n                        owem = 63, &\n                        oges = 64, &\n                        ogem = 65, &\n                        oqes = 66, &\n                        oqem = 67, &\n                        obln = 68, &\n                        ofrq = 69, &\n                        odsp = 70, &\n                        ocst = 71, &\n                        inbz = 14, &\n                        ivmc = 15, &\n                        omtr = 16, &\n                        omtf = 17, &\n                        ovmc = olog\n\n\nEND MODULE GKV_header\n", "MODULE GKV_geom\n!-------------------------------------------------------------------------------\n!\n!    Calculate geometric constants  \n!\n!    Update history of gkvp_geom.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - First implementation.\n!        - Geometric constants, which had been set in gkvp_set.f90, are moved.\n!          This module will be called from gkvp_set.f90 for initialization,\n!          and from gkvp_advnc.f90 for update in rotating flux-tube model.\n!        - Subroutines geom_* are public, can be called from other module.\n!        - Subroutines metric_* are private, treating metric structure.\n!        - equib_type = \"ring\" is added for ring dipole geometry.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_math,   only: math_j0, math_j1, math_j2, math_g0\n  use GKV_intgrl, only: intgrl_fsrf, intgrl_v0_moment_ms\n! for vmec equilibrium w/ Booz_xform by M. Nakata & M. Nunami  (Aug. 2016)\n  use GKV_vmecbzx, only: vmecbzx_boozx_read, vmecbzx_boozx_coeff\n! for tokamak(eqdsk) equilibrium\n  use GKV_igs,    only: igs_read, igs_coeff\n  !sakano_ring-dipole st 202303\n  use GKV_ring,   only: ring_coordinates\n  !sakano_ring-dipole end 202303\n\n  implicit none\n\n  private\n\n  public   geom_read_nml,      & ! Called once in GKV_set. Read namelist.\n           geom_init_kxkyzvm,  & ! Called once in GKV_set. Set time-indep. grids.\n           geom_init_metric,   & ! Called once in GKV_set. Set metrics at t=0.\n           geom_set_operators, & ! Set operators (e.g., ksq) by using metrics at t. \n           geom_reset_time,    & ! Called once in GKV_set. Reset metrics and operators at a given time.\n           geom_increment_time   ! Called in GKV_advnc. Increment metrics and operators by a given time step.\n           \n\n  type metric_global\n     ! Global metrics at t=0 are stored.\n     ! Metrics in GKV coordinates (x,y,z)\n     ! Metrics in flux coordinates (r,t,q)=(rho,theta,zeta)\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: zz    ! The rotating flux tube coordinate (= z'')\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: theta ! The poloidal angle theta_pol, not the flux-coordinate theta\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: omg   ! Magnetic field strength\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: &\n          domgdx, domgdy, domgdz, gxx, gxy, gxz, gyy, gyz, gzz, rootg_xyz\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: &\n          domgdr, domgdt, domgdq, grr, grt, grq, gtt, gtq, gqq, rootg_rtq\n    contains\n      procedure :: init => metric_global_init\n      procedure :: xyz2rtq => metric_global_xyz2rtq\n      procedure :: rtq2xyz => metric_global_rtq2xyz\n  end type\n\n  type metric_fourier\n     ! Metrics in flux coordinates at t=0, stored in Fourier coefficient\n     !   e.g.,   fourier_omg(kz) = \\int omg(z) * exp(-i*kz*z) dz / \\int dz\n     !           omg(z) = \\sum_k fourier_omg(kz) * exp(i*kz*z)\n     ! Thus, omg(z) at arbitrary z is obtained by Fourier interpolation.\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: kz\n      complex(kind=DP), dimension(-global_nz:global_nz-1) :: theta_tilde, omg\n      complex(kind=DP), dimension(-global_nz:global_nz-1) :: &\n          domgdr, domgdt, domgdq, grr, grt, grq, gtt, gtq, gqq, rootg_rtq\n    contains\n      procedure :: init => metric_fourier_init\n      procedure :: dft_rtq2coef => metric_fourier_dft_rtq2coef\n  end type\n\n  type metric_local\n     ! Local metrics at any time t are stored.\n     ! They are updated with time integration, and used for solving\n     ! Gyrokinetic equation in the rotating flux tube model.\n      real(kind=DP), dimension(-nz:nz-1) :: zz          ! The rotating flux tube coordinate (= z'')\n      real(kind=DP), dimension(-nz:nz-1) :: zz_labframe ! The flux-coordinate theta in the lab frame (= z''+t*gamma_e/s_hat)\n      real(kind=DP), dimension(-nz:nz-1) :: theta ! The geometrical poloidal angle theta_pol, not the flux-coordinate theta\n      real(kind=DP), dimension(-nz:nz-1) :: omg   ! Magnetic field strength\n      real(kind=DP), dimension(-nz:nz-1) :: &\n          domgdx, domgdy, domgdz, gxx, gxy, gxz, gyy, gyz, gzz, rootg_xyz\n      real(kind=DP), dimension(-nz:nz-1) :: &\n          domgdr, domgdt, domgdq, grr, grt, grq, gtt, gtq, gqq, rootg_rtq\n    contains\n      procedure :: copy_global => metric_local_copy_global\n      procedure :: init => metric_local_init\n      procedure :: update => metric_local_update\n      procedure :: dft_coef2rtq => metric_local_dft_coef2rtq\n      procedure :: rtq2xyz => metric_local_rtq2xyz\n  end type\n\n  type(metric_global),  save :: mtr_global\n  type(metric_fourier), save :: mtr_fourier\n  type(metric_local),   save :: mtr_local\n\n  real(kind=DP), save :: cx, cy, cb\n\n\n! for s-alpha model with Shafranov shift\n    real(kind=DP) ::  p_total, dp_totaldx, beta_total, alpha_MHD\n\n    real(kind=DP) :: r_major\n\n    integer, parameter :: num_omtr = 13\n!   real(kind=DP) :: metric_l(1:num_omtr,-nz:nz-1), metric_g(1:num_omtr,-global_nz:global_nz-1)\n\n    real(kind=DP) :: s_hat\n\n    real(kind=DP) :: eps_r\n\n    real(kind=DP) :: lz, kxmin, kymin, dz, mmax, dm, del_c\n    real(kind=DP) :: z0, z0_l\n    integer       :: n_tht, m_j\n\n    real(kind=DP) :: rdeps00, eps_hor, lprd, mprd, lmmq, malpha\n    real(kind=DP) :: eps_mor, eps_por, lprdm1, lprdp1, lmmqm1, lmmqp1\n    real(kind=DP) :: eps_rnew, rdeps1_0, rdeps1_10, rdeps2_10, rdeps3_10\n\n    real(kind=DP) :: s_input, s_0      ! radial label of fluxtube center \n    integer       :: mc_type           ! 0:Axisym., 1:Boozer, 2:Hamada\n    integer       :: q_type            ! 0:use q and s_hat value in confp, 1:calclated by IGS\n    integer       :: isw, nss, ntheta, nzeta\n    real(kind=DP) :: phi_ax            ! axisymmetric toroidal angle \n\n!sakano_ring-dipole st 202303\n    real(kind=DP) :: ring_a\n!sakano_ring-dipole end 202303\n\n    real(kind=DP) :: lz_l\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE geom_read_nml\n!--------------------------------------\n    implicit none\n\n    real(kind=DP) :: theta\n    real(kind=DP), dimension(0:ns-1) :: eta\n    real(kind=DP) :: domgdx, domgdy, domgdz\n    real(kind=DP), dimension(1:3,1:3) :: gg\n    integer :: iz, is, isw\n\n\n    namelist /physp/ R0_Ln,  &    ! R0/Lns\n                     R0_Lt,  &    ! R0/Lts\n                        nu,  &    ! factor for collision freq. in LB model    \n                      Anum,  &    ! mass number\n                      Znum,  &    ! charge number \n                       fcs,  &    ! charge-density fraction \n                       sgn,  &    ! signs of charge \n                       tau,  &    ! T-ratio Ts/T0, T0=reference ion temp. of ranks=1\n                      dns1,  &    ! initial perturbation amplitude\n                    tau_ad,  &    ! Ti/Te for ITG-ae, Te/Ti for ETG-ai\n                  lambda_i,  &    ! (Debye/rho_tp)^2 \n                      beta,  &    ! mu0*ni*Ti/B^2\n                   ibprime,  &    ! flag for finite beta-prime effect on kvd\n                      vmax,  &    ! maximum v_para in unit of v_ts\n                       nx0        ! mode number for the initial perturbation\n\n    namelist /rotat/ mach, uprime, gamma_e\n\n    namelist /nperi/ n_tht, kymin, m_j, del_c\n    namelist /confp/ eps_r, eps_rnew,                       &\n                     q_0, s_hat,                            &\n                     lprd, mprd, eps_hor, eps_mor, eps_por, &\n                     rdeps00, rdeps1_0, rdeps1_10,          & \n                     rdeps2_10, rdeps3_10, malpha\n!    namelist /vmecp/ q_0, rad_a,                            &\n!                     R0_unit, r_edge,                       &\n!                     b0b00, alpha_fix\n    namelist /vmecp/ s_input, nss, ntheta, nzeta\n\n    namelist /igsp/ s_input, mc_type, q_type, nss, ntheta\n!sakano_ring-dipole st 202303\n    namelist /ring/ ring_a, kxmin\n!sakano_ring-dipole end 202303\n\n      tau(:)   = 1.0_DP\n      nu(:)    = 0.002_DP\n      R0_Ln(:) = 2.5_DP\n      R0_Lt(:) = 7.5_DP\n\n\n      read(inml,nml=physp)\n\n\n        do is = 0, ns-1\n          if( R0_Ln(is) /= 0._DP ) then\n            eta(is) = R0_Lt(is) / R0_Ln(is)\n          else\n            eta(is) = 1.d+20\n          end if\n        end do\n\n\n        write( olog, * ) \" # Physical parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # r_major/L_ns = \", R0_Ln(:)\n        write( olog, * ) \" # r_major/L_ts = \", R0_Lt(:)\n        write( olog, * ) \" # eta          = \", eta(:)\n        write( olog, * ) \" # nu           = \", nu(:)\n        write( olog, * ) \" # A-number     = \", Anum(:)\n        write( olog, * ) \" # Z-number     = \", Znum(:)\n        write( olog, * ) \" # fcs          = \", fcs(:)\n        write( olog, * ) \" # sgn          = \", sgn(:)\n        write( olog, * ) \" # tau          = \", tau(:)\n        write( olog, * ) \" # dns1         = \", dns1(:)\n        write( olog, * ) \" # tau_ad       = \", tau_ad\n        write( olog, * ) \" # lambda_i^2   = \", lambda_i\n        write( olog, * ) \" # beta_i       = \", beta\n        write( olog, * ) \" # ibprime      = \", ibprime\n        write( olog, * ) \" # nx0          = \", nx0\n        write( olog, * ) \"\"\n\n\n      mach = 0._DP\n      uprime = 0._DP\n      gamma_e = 0._DP\n\n      read(inml,nml=rotat)\n\n        write( olog, * ) \" # Mean rotation parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # Mach number  = \", mach\n        write( olog, * ) \" # uptime       = \", uprime\n        write( olog, * ) \" # gamma_ExB    = \", gamma_e\n        write( olog, * ) \"\"\n\n\n      n_tht = 1\n\n      read(inml,nml=nperi)\n\n\n      if( trim(equib_type) == \"slab\") then\n\n        read(inml,nml=confp)\n\n        lprdm1   = 0._DP\n        lprdp1   = 0._DP\n\n        lmmq     = 0._DP\n        lmmqm1   = 0._DP\n        lmmqp1   = 0._DP\n\n        q_0      = 1._DP ! For now, fixed q_0=1. Changing q_0 can extend parallel z-box size.\n        s_hat    = 0._DP ! only shear less slab\n        eps_r    = 1._DP\n\n        eps_hor  = 0._DP\n        lprd     = 0._DP\n        mprd     = 0._DP\n        malpha   = 0._DP\n\n        rdeps00  = 0._DP\n        eps_mor  = 0._DP\n        eps_por  = 0._DP\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # eps_hor      = \", eps_hor\n        write( olog, * ) \" # lprd         = \", lprd\n        write( olog, * ) \" # mprd         = \", mprd\n        write( olog, * ) \" # malpha       = \", malpha\n        write( olog, * ) \" # rdeps00      = \", rdeps00\n\n        write( olog, * ) \" # eps_mor      = \", eps_mor\n        write( olog, * ) \" # lprdm1       = \", lprdm1\n        write( olog, * ) \" # eps_por      = \", eps_por\n        write( olog, * ) \" # lprdp1       = \", lprdp1\n        write( olog, * ) \"\"\n\n      else if( trim(equib_type) == \"analytic\"  .OR.  &\n               trim(equib_type) == \"s-alpha\"   .OR.  &\n               trim(equib_type) == \"s-alpha-shift\"   .OR.  &\n               trim(equib_type) == \"circ-MHD\" ) then\n\n\n        read(inml,nml=confp)\n\n\n        lprdm1   = lprd - 1.0_DP\n        lprdp1   = lprd + 1.0_DP\n\n        lmmq     = lprd   - mprd * q_0\n        lmmqm1   = lprdm1 - mprd * q_0\n        lmmqp1   = lprdp1 - mprd * q_0\n\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # eps_hor      = \", eps_hor\n        write( olog, * ) \" # lprd         = \", lprd\n        write( olog, * ) \" # mprd         = \", mprd\n        write( olog, * ) \" # malpha       = \", malpha\n        write( olog, * ) \" # rdeps00      = \", rdeps00\n\n        write( olog, * ) \" # eps_mor      = \", eps_mor\n        write( olog, * ) \" # lprdm1       = \", lprdm1\n        write( olog, * ) \" # eps_por      = \", eps_por\n        write( olog, * ) \" # lprdp1       = \", lprdp1\n        write( olog, * ) \"\"\n\n\n     else if( trim(equib_type) == \"vmec\" ) then\n\n\n        read(inml,nml=confp)\n\n        read(inml,nml=vmecp)\n\n        call vmecbzx_boozx_read( nss, ntheta, nzeta )\n\n         isw = 0\n         iz = 0\n         call vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input, iz, 0._DP,  lz_l,   &  ! input \n                           s_0,           q_0,     s_hat,    eps_r,  phi_ax,             &  ! output\n                           omg(iz), rootg(iz),    domgdx,   domgdz,  domgdy,             &\n                           gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                      &\n                           gg(2,3),   gg(3,3)  )\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # r_major/L_ns = \", R0_Ln(:)\n        write( olog, * ) \" # r_major/L_ts = \", R0_Lt(:)\n        write( olog, * ) \" # eta          = \", eta(:)\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \" # s_input, s_0 = \", s_input, s_0\n        write( olog, * ) \" # nss, ntheta, nzeta  = \", nss, ntheta, nzeta\n\n\n     else if( trim(equib_type) == \"eqdsk\" ) then\n\n\n        read(inml,nml=confp)\n\n        read(inml,nml=igsp)\n\n        call igs_read( mc_type, nss, ntheta )\n\n        if ( q_type == 1 ) then\n         isw = 0\n         iz = 0\n         call igs_coeff( isw,  mc_type,   nss,    ntheta,  s_input,  0._DP, lz_l,   &  ! input \n                         s_0,       q_0,     s_hat,    eps_r,  theta,               &  ! output\n                           omg(iz), rootg(iz),    domgdx,   domgdz, domgdy,         &\n                           gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                 &\n                           gg(2,3),   gg(3,3)  )\n        end if\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # r_major/L_ns = \", R0_Ln(:)\n        write( olog, * ) \" # r_major/L_ts = \", R0_Lt(:)\n        write( olog, * ) \" # eta          = \", eta(:)\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \" # s_input, s_0 = \", s_input, s_0\n        write( olog, * ) \" # nss, ntheta  = \", nss, ntheta\n\n!sakano_ring-dipole st 202303\n      else if ( trim(equib_type) == \"ring\" ) then\n\n        read(inml,nml=confp)\n\n        read(inml,nml=ring)\n\n        s_hat = 0._DP\n\n        write( olog, * ) \" # Configuration parameters for ring dipole configuration\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # kxmin        = \", kxmin\n        write( olog, * ) \" # ring_a       = \", ring_a\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \" # q_0          = \", q_0\n!sakano_ring-dipole end 202303\n\n      else\n\n        write( olog, * ) \" # wrong choice of the equilibrium \"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n  END SUBROUTINE geom_read_nml\n\n\n!--------------------------------------\n  ", "SUBROUTINE geom_init_kxkyzvm(lx, ly, eps_r_temp)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(out) :: lx, ly, eps_r_temp\n    integer       :: global_iv, global_im\n    integer       :: mx, my, iz, iv, im\n\n      eps_r_temp = eps_r\n\n      if ( trim(equib_type) /= \"ring\" ) then\n        if (abs(s_hat) < 1.d-10) then ! When s_hat == ZERO\n          m_j = 0\n          kxmin = kymin\n        else if (m_j == 0) then\n          kxmin = kymin\n        else\n          kxmin    = abs(2._DP * pi * s_hat * kymin / real(m_j, kind=DP))\n        end if\n      end if\n      lx       = pi / kxmin\n      ly       = pi / kymin\n                    ! kymin=pi/ly=pi/[r_minor*pi/(q0*n_alp)]=q0*n_alp/r_minor\n\n      lz       = real( n_tht, kind=DP ) * pi        ! total z-length\n      lz_l     = lz / real( nprocz, kind=DP )       ! local z-length\n\n      do mx = -nx, nx\n        kx(mx)   = kxmin * real( mx, kind=DP )\n      end do\n\n      ky(:) = 0._DP\n      do my = ist_y_g, iend_y_g\n        ky(my-ist_y_g)   = kymin * real( my, kind=DP )\n      end do\n\n      kxmin_g = kxmin\n      kymin_g = kymin \n\n      z0       = - lz                     ! global lower boundary\n      z0_l     = 2._DP * lz_l * real( rankz, kind=DP ) + z0\n                                          ! local lower boundary\n\n      dz       = lz_l / real( nz, kind=DP )\n\n      do iz = -nz, nz-1\n        zz(iz)   = dz * real( iz + nz, kind=DP ) + z0_l\n      end do\n\n\n      dv       = 2._DP * vmax / real( 2 * nv * nprocv -1, kind=DP )\n\n      do iv = 1, 2*nv\n        global_iv = 2 * nv * rankv + iv\n        vl(iv)    = dv * ( real( global_iv - nv * nprocv - 1, kind=DP ) + 0.5_DP )\n      end do\n                                          ! --- debug\n                                          !   write( olog, * ) \" *** iv, vl \"\n                                          !   do iv = 1, 2*nv\n                                          !     global_iv = 2 * nv * rankv + iv\n                                          !     write( olog, * ) iv, global_iv, vl(iv)\n                                          !   end do\n                                          !   write( olog, * ) \"\"\n\n      mmax     = vmax\n      dm       = mmax / real( nprocm * ( nm+1 ) - 1, kind=DP )\n                                          ! --- equal spacing in vperp\n\n      do im = 0, nm\n        global_im = ( nm+1 ) * rankm + im\n        mu(im)    = 0.5_DP * ( dm * real( global_im, kind=DP ) )**2\n      end do\n\n\n      do my = ist_y_g, iend_y_g\n        ck(my-ist_y_g)   = exp( ui * 2._DP * pi * del_c &\n                                   * real( n_tht * my, kind=DP ) )\n        dj(my-ist_y_g)   = - m_j * n_tht * my\n                                          !  del_c = q_0*n_alp-int(q_0*n_alp)\n                                          !  m_j   = 2*n_alp*q_d\n      end do\n\n\n      write( olog, * ) \" # Numerical parameters\"\n      write( olog, * ) \"\"\n      write( olog, * ) \" # n_tht = \", n_tht\n      write( olog, * ) \" # lx, ly, lz   = \", lx, ly, lz\n      write( olog, * ) \" # lz,   z0     = \", lz, z0\n      write( olog, * ) \" # lz_l, z0_l   = \", lz_l, z0_l\n      write( olog, * ) \" # kxmin, kymin = \", kxmin, kymin\n      write( olog, * ) \" # kxmax, kymax = \", kxmin*nx, kymin*global_ny\n      write( olog, * ) \" # kperp_max    = \", sqrt((kxmin*nx)**2+(kymin*global_ny)**2)\n      write( olog, * ) \" # m_j, del_c   = \", m_j, del_c\n      write( olog, * ) \" # dz           = \", dz\n      write( olog, * ) \" # dv, vmax     = \", dv, vmax\n      write( olog, * ) \" # dm, mmax     = \", dm, mmax\n      write( olog, * ) \"\"\n\n      if (gamma_e == 0._DP) then\n        tlim_exb = 999999.d0\n      else\n        tlim_exb = (kxmin*(nx-nx0))/(kymin*global_ny*abs(gamma_e))\n      end if\n      write( olog, * ) \" # ExB limit time tlim_exb  = \", tlim_exb\n      write( olog, * ) \" # for (mx=nx0,my=global_ny) initial perturbation: \"\n      write( olog, * ) \" # tlim_exb = kxmin*(nx-nx0)/(kymax*|gamma_e|)\"\n      write( olog, * ) \"\"\n\n  END SUBROUTINE geom_init_kxkyzvm\n\n\n!--------------------------------------\n  SUBROUTINE geom_init_metric\n!--------------------------------------\n    real(kind=DP) :: r_0\n    real(kind=DP) :: wzz, theta, gomg\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz, is\n!sakano_ring-dipole st 202303\n    real(kind=DP) :: ub_dot_grdb, ub_crs_grdb\n!sakano_ring-dipole end 202303\n\n      s_hat_g = s_hat\n\n      !- zero clear -\n      gdomgdr = 0._DP\n      gdomgdt = 0._DP\n      gdomgdq = 0._DP\n      ggrr = 1._DP\n      ggrt = 0._DP\n      ggrq = 0._DP\n      ggtt = 1._DP\n      ggtq = 0._DP\n      ggqq = 1._DP\n      grootg_rtq = 1._DP\n\n      do iz = -global_nz, global_nz-1\n\n        wzz = dz * iz\n\n        if ( trim(equib_type) == \"slab\") then\n         !- Shearless slab geometry-\n         !  Consider translationally symmetric flux surface\n         !  (r,t,q)=(x_car,y_car,z_car).\n         !  GKV coordinates are\n         !    x = x_car,              -lx<=x/gyroradius<lx\n         !    y = y_car,              -ly<=y/gyroradius<ly\n         !    z = z_car/q_0*r_major,  -n_tht*pi<=z<n_tht*pi\n         !  z is dimensionless. \n         !  Length in field-aligned z_car is 2*q_0*lz*r_major.\n         !  r_major = 1 in the R0 unit.\n         !  Magnetic field is constant B=B0 in z, so omg = 1 in the B0 unit.\n         !  Normalized cb = B0/B0 = 1\n         !-\n          r_major = 1._DP ! in the R0 unit\n          cx = 1._DP\n          cy = 1._DP\n          cb = 1._DP\n\n          q_bar = q_0 \n          theta = wzz\n          gomg = 1._DP\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdx = 0._DP\n          gdomgdy = 0._DP\n          gdomgdz = 0._DP\n          ggxx = 1._DP\n          ggxy = 0._DP\n          ggxz = 0._DP\n          ggyy = 1._DP\n          ggyz = 0._DP\n          ggzz = 1._DP/(q_0*r_major)**2\n          grootg_xyz = q_0*r_major\n         !- Metrics in cartesian (x_car,y_car,z_car)\n         !gdomgdr = 0._DP\n         !gdomgdt = 0._DP\n         !gdomgdq = 0._DP\n         !ggrr = 1._DP\n         !ggrt = 0._DP\n         !ggrq = 0._DP\n         !ggtt = 1._DP\n         !ggtq = 0._DP\n         !ggqq = 1._DP\n         !grootg_rtq = 1._DP\n\n\n        else if( trim(equib_type) == \"analytic\" ) then\n         !- Analytic model of large-aspect-ratio helical system -\n         !  [Ref.1] H. Sugama and T.-H. Watanabe, Phys. Plasmas 11, 3068 (2004).\n         !  [Ref.2] T.-H.Watanabe, H. Sugama, and S. Ferrando-Margalet,\n         !          Nucl. Fusion 47, 1383 (2007).\n         !\n         !  Consider concentric circular, but helically twisted,\n         !  flux surface (r,theta,zeta). \n         !  GKV coordinates are\n         !    x = cx*(r-r0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=1, cy=cx*r0/q0.\n         !  In the large-aspect ratio limit, the geometrical length\n         !  in the field-aligned direction is dpara=q*r_major*dz.\n         !  r_major = 1 in the R0 unit.\n         !  Finite aspect ratio eps_r = r0/R0 is retained only in \n         !  magnetic field omg, domgdx, domgdy, domgdz, but not for metrics.\n         !  Flux-surface averaged magnetic field is <omg>=B_ax,\n         !  where B_ax is the value at the magnetic axis.\n         !  cb = (psi_p(r))'/(cx*cy) = B_ax\n         !  Normalized <omg> = 1 and cb = 1 in the B_ax unit.\n         !-\n          r_major = 1._DP       ! Major radius of magnetic axis in the R0 unit\n          r_0 = r_major * eps_r ! Minor radius of flux-tube center\n          cx = 1._DP\n          cy = r_0/q_0\n          cb = 1._DP\n\n          q_bar = q_0 \n          theta = wzz\n          gomg = 1._DP                                          &\n               - eps_r * ( cos( wzz )                           &\n                       + eps_hor * cos( lmmq   * wzz - malpha ) &\n                       + eps_mor * cos( lmmqm1 * wzz - malpha ) &\n                       + eps_por * cos( lmmqp1 * wzz - malpha ) )\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdz = eps_r * ( sin(wzz)                                        &\n                          + eps_hor * lmmq   * sin( lmmq   * wzz - malpha )   &\n                          + eps_mor * lmmqm1 * sin( lmmqm1 * wzz - malpha )   &\n                          + eps_por * lmmqp1 * sin( lmmqp1 * wzz - malpha ) )\n          gdomgdy = - eps_rnew / r_major * (                              &\n                    - ( sin( wzz )                                        &\n                      + eps_hor * lprd   * sin( lmmq   * wzz - malpha )   &\n                      + eps_mor * lprdm1 * sin( lmmqm1 * wzz - malpha )   &\n                      + eps_por * lprdp1 * sin( lmmqp1 * wzz - malpha )   &\n                    ) - (-1._DP/eps_r) * gdomgdz )\n          gdomgdx = eps_rnew / r_major * (                                &\n                    - (                                                   &\n                        rdeps00                                           &\n                      + rdeps1_0 * cos( wzz )                             &\n                      + rdeps2_10 * cos( lmmq   * wzz - malpha )          &\n                      + rdeps1_10 * cos( lmmqm1 * wzz - malpha )          &\n                      + rdeps3_10 * cos( lmmqp1 * wzz - malpha )          &\n                      + s_hat * wzz * ( sin( wzz )                        &\n                      + eps_hor * lprd   * sin( lmmq   * wzz - malpha )   &\n                      + eps_mor * lprdm1 * sin( lmmqm1 * wzz - malpha )   &\n                      + eps_por * lprdp1 * sin( lmmqp1 * wzz - malpha ) ) &\n                    ) - (-s_hat*wzz/eps_r) * gdomgdz )\n          ggxx = 1._DP\n          ggxy = s_hat*wzz\n          ggxz = 0._DP\n          ggyy = 1._DP + (s_hat*wzz)**2\n          ggyz = 1._DP/r_0\n          ggzz = 1._DP/r_0**2\n          grootg_xyz = q_0*r_major/gomg\n         !- Metrics in flux coordinates (r,theta,zeta)\n         !ggrr = 1._DP\n         !ggrt = 0._DP\n         !ggrq = 0._DP\n         !ggtt = 1._DP/r_0**2\n         !ggtq = 0._DP\n         !ggqq = 0._DP ! /=1._DP/r_major**2, because of large-aspect ratio approximation\n         !grootg_rtq = r_0*r_major/gomg\n\n\n        else if( trim(equib_type) == \"s-alpha\" .or. trim(equib_type) == \"s-alpha-shift\" ) then\n         !- Analytic model of large-aspect-ratio tokamak system -\n         !  Consider concentric circular flux surface (r,theta,zeta). \n         !  GKV coordinates are\n         !    x = cx*(r-r0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=1, cy=cx*r0/q0.\n         !  In the large-aspect ratio limit, the geometrical length\n         !  in the field-aligned direction is dpara=q*r_major*dz.\n         !  r_major = 1 in the R0 unit.\n         !  Finite aspect ratio eps_r = r0/R0 is retained only in \n         !  magnetic field omg, domgdx, domgdy, domgdz, but not for metrics.\n         !  Flux-surface averaged magnetic field is <omg>=B_ax,\n         !  where B_ax is the value at the magnetic axis.\n         !  cb = (psi_p(r))'/(cx*cy) = B_ax\n         !  Normalized <omg> = 1 and cb = 1 in the B_ax unit.\n         !-\n          r_major = 1._DP       ! Major radius of magnetic axis in the R0 unit\n          r_0 = r_major * eps_r ! Minor radius of flux-tube center\n          cx = 1._DP\n          cy = r_0/q_0\n          cb = 1._DP\n\n          if (trim(equib_type) == \"s-alpha\") then\n            !--- s-alpha model without Shafranov shift -\n            alpha_MHD = 0._DP\n          else ", "if (trim(equib_type) == \"s-alpha-shift\") then\n            !--- s-alpha model with Shafranov shift ----\n            p_total = 0._DP\n            dp_totaldx = 0._DP\n            beta_total = 0._DP\n            do is = 0, ns-1\n              p_total = p_total + fcs(is) * tau(is) / Znum(is)\n              dp_totaldx = dp_totaldx - fcs(is) * tau(is) / Znum(is) * (R0_Ln(is) + R0_Lt(is))\n              beta_total = beta_total + 2._DP * beta * fcs(is) * tau(is) / Znum(is)\n            end do\n            alpha_MHD = - q_0**2 * r_major * beta_total * dp_totaldx / p_total\n          end if\n          q_bar = q_0\n          theta = wzz\n          gomg = 1._DP - eps_r * cos( theta ) ! s-alpha with eps-expansion\n          !!!!gomg = 1._DP / (1._DP + eps_r * cos( theta )) ! for benchmark\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdz = eps_r * sin( theta )\n          !!!!gdomgdz = eps_r * sin( theta ) * omg(iz)**2 ! for benchmark\n          gdomgdx = - cos( theta ) / r_major\n          gdomgdy = 0._DP\n          ggxx = 1._DP\n          ggxy = s_hat*wzz - alpha_MHD*sin(wzz) ! with Shafranov shift\n          ggxz = 0._DP\n          ggyy = 1._DP + (s_hat*wzz - alpha_MHD*sin(wzz))**2 ! with Shafranov shift\n          ggyz = 1._DP/r_0\n          ggzz = 1._DP/r_0**2\n          grootg_xyz = q_0*r_major/gomg\n         !- Metrics in flux coordinates (r,theta,zeta)\n         !gdomgdr = - cos( theta ) / r_major\n         !gdomgdt = eps_r * sin( theta )\n         !gdomgdq = 0._DP\n         !ggrr = 1._DP\n         !ggrt = 0._DP\n         !ggrq = 0._DP + sin(wzz)*alpha_MHD*q_0/r_0 ! with Shafranov shift\n         !ggtt = 1._DP/r_0**2\n         !ggtq = 0._DP\n         !ggqq = 0._DP & ! /=1._DP/r_major**2, because of large-aspect ratio approximation\n         !     + sin(wzz)*(alpha_MHD*q_0/r_0)**2 ! with Shafranov shift\n         !grootg_rtq = r_0*r_major/gomg\n\n\n        else if( trim(equib_type) == \"circ-MHD\" ) then\n         !- Circular MHD equilibrium -\n         !  [Ref.] X. Lapillonne, et al., Phys. Plasmas 16, 032308 (2009).\n         !\n         !  Consider concentric circular flux surface (r,theta,zeta). \n         !  GKV coordinates are\n         !    x = cx*(r-r0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=1, cy=cx*r0/q0.\n         !  In the large-aspect ratio limit, the geometrical length\n         !  in the field-aligned direction is dpara=q*r_major*dz.\n         !  r_major = 1 in the R0 unit.\n         !  In contrast to the s-alpha model, finite aspect ratio eps_r = r0/R0\n         !  is retained in both of magnetic field and metrics.\n         !  Difference between the flux-surface averaged magnetic field <omg>\n         !  and the value at the magnetic axis B_ax also appears.\n         !  cb = (psi_p(r))'/(cx*cy) = B_ax\n         !  Normalized omg = B(z)/B_ax and cb = 1 in the B_ax unit.\n         !-\n          r_major = 1._DP       ! in the R0 unit\n          r_0 = r_major * eps_r ! Minor radius of flux-tube center\n          cx = 1._DP\n          cy = r_0/q_0\n          cb = 1._DP\n\n          theta = 2._DP*atan( sqrt( (1._DP+eps_r)/(1._DP-eps_r) ) &\n                             * tan(wzz/2._DP) )\n          q_bar = dsqrt( 1._DP - eps_r**2 )*q_0\n          gomg = sqrt( q_bar**2 + eps_r**2 ) &\n               / ( 1._DP + eps_r*cos( theta ) ) / q_bar\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdz = eps_r * sin(theta) * sqrt( q_bar**2 + eps_r**2 ) &\n                     / ( 1._DP + eps_r * cos( theta ) )**2           &\n                     / ( 1._DP - eps_r * cos( wzz) ) / q_0\n          gdomgdx = -( cos(theta)                                           &\n                       - eps_r*(1._DP-s_hat+eps_r**2*q_0**2/q_bar**2)        &\n                              *(1._DP+eps_r*cos(theta))/(q_bar**2+eps_r**2) &\n                       - eps_r*sin(theta)**2/(1._DP-eps_r**2)               &\n                       ) / ((1._DP + eps_r*cos(theta))**2)                  &\n                         * sqrt(q_bar**2+eps_r**2) / q_bar / r_major\n          gdomgdy = 0._DP\n          ggxx = (q_0/q_bar)**2\n          ggxy = ( s_hat*wzz*q_0/q_bar - eps_r*sin(wzz)/(1._DP-eps_r**2) )*q_0/q_bar\n          ggxz = - sin(wzz)/(1._DP-eps_r**2)/r_major*q_0/q_bar\n          ggyy = (s_hat*wzz*q_0/q_bar)**2                                      &\n                 - 2._DP*q_0/q_bar*s_hat*wzz*eps_r*sin(wzz)/(1._DP-eps_r**2)   &\n                 + (q_bar**2+eps_r**2)/((1._DP+eps_r*cos(theta))**2)/(q_0**2) &\n                 + (eps_r*sin(wzz))**2/(1._DP-eps_r**2)**2\n          ggyz = ( -s_hat*wzz*q_0/q_bar*sin(wzz)/(1._DP-eps_r**2)           &\n                   + ((q_bar/q_0)**2)/((1._DP+eps_r*cos(theta))**2)/eps_r  &\n                   + eps_r*(sin(wzz)**2)/((1._DP-eps_r**2)**2)              &\n                 ) / r_major\n          ggzz = ( ((q_bar/q_0)**2)/((1._DP+eps_r*cos(theta))**2)/(eps_r**2) &\n                   + (sin(wzz)**2)/((1._DP-eps_r**2)**2)                      &\n                 ) / (r_major**2)\n          grootg_xyz = q_0*r_major*( 1._DP+eps_r*cos(theta) )**2\n\n\n        else if( trim(equib_type) == \"vmec\" ) then\n         !- VMEC-BoozXform interface for stellarator equilibirum -\n         !  References on the previous implementation by VMEC-NEWBOZ is\n         !  [Ref.1] M. Nunami, T.-H. Watanabe, H. Sugama, Plasma Fusion Res. 5,\n         !          016 (2010).\n         !  New interface for VMEC-BoozXform is developed by M. Nakata and \n         !  M. Nunami (Aug. 2016) in the same manner for IGS.\n         !\n         !  Consider flux coordinates (rho,theta,zeta).\n         !  Using the toroidal flux psi_t, the normalized minor radius is\n         !  rho= sqrt(psi_t/psi_ta), and the minor radius at the last closed\n         !  flux surface is a=sqrt(2*psi_ta/B_ax).\n         !  Poloidal and toroidal angles are defined in the Boozer coordinates.\n         !  GKV coordinates (x,y,z) are\n         !    x = cx*(rho-rho0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=a, cy=cx*rho0/q0.\n         !  In these definitions, the factor on the magnetic field \n         !  B = cb * \\nabla x \\times \\nabla y is\n         !  cb = (psi_p(rho))'/(cx*cy) = B_ax.\n         !  Normalized omg = B(z)/B_ax and cb = 1 in the B_ax unit.\n         !  The reference length is set to be r_major at the magnetic axis R0.\n         !-\n          r_major = 1._DP ! in the R0 unit\n          q_bar = q_0\n          isw = 1\n          call vmecbzx_boozx_coeff( isw, nss, ntheta, nzeta, s_input, iz, wzz, lz_l, &  ! input \n                                    s_0, q_0, s_hat, eps_r, phi_ax,                  &  ! output\n                                    gomg, grootg_xyz, gdomgdx, gdomgdz, gdomgdy,     &\n                                    ggxx, ggxy, ggxz, ggyy, ggyz, ggzz )\n         ! NOTE: phi_ax axisymmetric toroidal angle is stored for vmec, rather than theta\n          theta = phi_ax\n          cx = eps_r/s_0 ! = eps_a = a/R0\n          cy = cx*s_0/q_0\n          cb = 1._DP\n\n        else if( trim(equib_type) == \"eqdsk\" ) then\n         !- EQDSK-IGS interface for tokamak equilibirum -\n         !  [Ref.] M. Nakata, A. Matsuyama, N. Aiba, S. Maeyama, M. Nunami,\n         !         and T.-H. Watanabe, Plasma Fusion Res. 9, 1403029 (2014).\n         !\n         !  Consider flux coordinates (rho,theta,zeta).\n         !  GKV coordinates (x,y,z) are\n         !    x = cx*(rho-rho0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=a, cy=cx*rho0/q0. All explanation is the same as that in\n         !  equib_type == \"vmec\", except that poloidal and toroidal angles have\n         !  a choice of freedom: Hamada, Boozer, or axisymmetric coordinates.\n         !-\n          r_major = 1._DP ! in the R0 unit\n          q_bar = q_0\n          isw = 1\n          call igs_coeff( isw, mc_type, nss, ntheta, s_input, wzz, lz_l, &  ! input \n                          s_0, q_0, s_hat, eps_r, theta,                 &  ! output\n                          gomg, grootg_xyz, gdomgdx, gdomgdz, gdomgdy,   &\n                          ggxx, ggxy, ggxz, ggyy, ggyz, ggzz )\n          cx = eps_r/s_0 ! = eps_a = a/R0\n          cy = cx*s_0/q_0\n          cb = 1._DP\n\n!sakano_ring-dipole st 202303\n        else if( trim(equib_type) == \"ring\" ) then\n         !- Ring dipole geometry -\n         !  [Ref.] J. Sakano, Master thesis, Nagoya University (in Japanese).\n         !\n         !  Consider flux coordinates (Psi,Theta,phi), where the magnetic\n         !  poloidal flux Psi<0, the geometrical poloidal angle Theta = arctan(Z/(R-a)), \n         !  the azimuthal angle of the cylindrical coordinate phi.\n         !  There is a ring current in direction of phi at R=a. The field line \n         !  passing through (R,Z)=(R0,0) is picked up as a flux-tube domain.\n         !  \n         !  GKV coordinates (x,y,z) are (right-handed system)\n         !    x = cx*(Psi0 - Psi)/Psi0\n         !    y = cy*phi\n         !    z = Theta\n         !  with cx=R0, cy=R0. Note that Psi0 is the magnetic poloidal flux \n         !  at the center of the considered flux-tube domain.\n         !  In these definitions, the factor on the magnetic field \n         !  B = cb * \\nabla x \\times \\nabla y is cb = Psi0/(R0*R0) = B0,\n         !  where B0 is the magnetic field strength at (R,Z)=(R0,0).\n         !  Normalized omg = B(z)/B0 and cb = 1 in the B0 unit.\n         !  The reference length is set to be R0 (not the ring current at R=a).\n         !  The normalized parameter to specify the flux-tube is \n         !    ring_a = a / R0\n         !-\n          r_major = 1._DP ! in the R0 unit\n          q_bar   = 0._DP\n          theta = wzz\n          call ring_coordinates( ring_a, wzz, &                                ! input\n                                 gomg, ub_dot_grdb, ub_crs_grdb, ggxx, ggxy, & ! output\n                                 ggxz, ggyy, ggyz, ggzz, grootg_xyz, gdomgdx, gdomgdz )\n          gdomgdy = 0._DP\n          cx = 1._DP\n          cy = 1._DP\n          cb = 1._DP\n!sakano_ring-dipole end 202303\n\n        else\n\n          write( olog, * ) \" # wrong choice of the equilibrium \"\n          call flush(olog)\n          call MPI_Finalize(ierr_mpi)\n          stop\n\n        end if\n\n        call mtr_global%init(iz, wzz, theta, gomg,                  &\n                             gdomgdx, gdomgdy, gdomgdz, ggxx, ggxy, &\n                             ggxz, ggyy, ggyz, ggzz, grootg_xyz,    &\n                             gdomgdr, gdomgdt, gdomgdq, ggrr, ggrt, &\n                             ggrq, ggtt, ggtq, ggqq, grootg_rtq)\n\n      end do   ! iz loop ends\n\n      call mtr_global%xyz2rtq\n      call mtr_fourier%init\n      call mtr_fourier%dft_rtq2coef(mtr_global)\n\n      call mtr_local%copy_global(mtr_global)\n\n      if ( rankg == 0 ) then\n        do iz = -global_nz, global_nz-1\n          write( omtr, fmt=\"(f15.8,SP,256E24.14e3)\") &\n            mtr_global%zz(iz), mtr_global%theta(iz),      &\n            mtr_global%omg(iz), mtr_global%domgdx(iz),    &\n            mtr_global%domgdy(iz), mtr_global%domgdz(iz), &\n            mtr_global%gxx(iz), mtr_global%gxy(iz),       &\n            mtr_global%gxz(iz), mtr_global%gyy(iz),       &\n            mtr_global%gyz(iz), mtr_global%gzz(iz),       &\n            mtr_global%rootg_xyz(iz)\n        end do\n        !call flush(omtr)\n        do iz = -global_nz, global_nz-1\n          write( omtf, fmt=\"(f15.8,SP,256E24.14e3)\") &\n            mtr_global%zz(iz), mtr_global%theta(iz),      &\n            mtr_global%omg(iz), mtr_global%domgdr(iz),    &\n            mtr_global%domgdt(iz), mtr_global%domgdq(iz), &\n            mtr_global%grr(iz), mtr_global%grt(iz),       &\n            mtr_global%grq(iz), mtr_global%gtt(iz),       &\n            mtr_global%gtq(iz), mtr_global%gqq(iz),       &\n            mtr_global%rootg_rtq(iz)\n        end do\n        !call flush(omtr)\n      end if\n\n     !%%% For debug %%%\n     ! do iz = -nz, nz-1\n     !   write( 990000000+rankg, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !     mtr_local%zz(iz), mtr_local%theta(iz),      &\n     !     mtr_local%omg(iz), mtr_local%domgdx(iz),    &\n     !     mtr_local%domgdy(iz), mtr_local%domgdz(iz), &\n     !     mtr_local%gxx(iz), mtr_local%gxy(iz),       &\n     !     mtr_local%gxz(iz), mtr_local%gyy(iz),       &\n     !     mtr_local%gyz(iz), mtr_local%gzz(iz),       &\n     !     mtr_local%rootg_xyz(iz)\n     ! end do\n     ! call mtr_global%rtq2xyz\n     ! call mtr_global%xyz2rtq\n     ! call mtr_local%init(mtr_fourier, time_shearflow=0._DP)\n     ! if ( rankg == 0 ) then\n     !   do iz = -global_nz, global_nz-1\n     !     write( 900000011, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !       mtr_global%zz(iz), mtr_global%theta(iz),      &\n     !       mtr_global%omg(iz), mtr_global%domgdx(iz),    &\n     !       mtr_global%domgdy(iz), mtr_global%domgdz(iz), &\n     !       mtr_global%gxx(iz), mtr_global%gxy(iz),       &\n     !       mtr_global%gxz(iz), mtr_global%gyy(iz),       &\n     !       mtr_global%gyz(iz), mtr_global%gzz(iz),       &\n     !       mtr_global%rootg_xyz(iz)\n     !   end do\n     !   do iz = -global_nz, global_nz-1\n     !     write( 900000012, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !       mtr_global%zz(iz), mtr_global%theta(iz),      &\n     !       mtr_global%omg(iz), mtr_global%domgdr(iz),    &\n     !       mtr_global%domgdt(iz), mtr_global%domgdq(iz), &\n     !       mtr_global%grr(iz), mtr_global%grt(iz),       &\n     !       mtr_global%grq(iz), mtr_global%gtt(iz),       &\n     !       mtr_global%gtq(iz), mtr_global%gqq(iz),       &\n     !       mtr_global%rootg_rtq(iz)\n     !   end do\n     ! end if\n     ! do iz = -nz, nz-1\n     !   write( 980000000+rankg, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !     mtr_local%zz(iz), mtr_local%theta(iz),      &\n     !     mtr_local%omg(iz), mtr_local%domgdx(iz),    &\n     !     mtr_local%domgdy(iz), mtr_local%domgdz(iz), &\n     !     mtr_local%gxx(iz), mtr_local%gxy(iz),       &\n     !     mtr_local%gxz(iz), mtr_local%gyy(iz),       &\n     !     mtr_local%gyz(iz), mtr_local%gzz(iz),       &\n     !     mtr_local%rootg_xyz(iz)\n     ! end do\n     ! do iz = -nz, nz-1\n     !   write( 970000000+rankg, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !     mtr_local%zz_labframe(iz), mtr_local%theta(iz),      &\n     !     mtr_local%omg(iz), mtr_local%domgdr(iz),    &\n     !     mtr_local%domgdt(iz), mtr_local%domgdq(iz), &\n     !     mtr_local%grr(iz), mtr_local%grt(iz),       &\n     !     mtr_local%grq(iz), mtr_local%gtt(iz),       &\n     !     mtr_local%gtq(iz), mtr_local%gqq(iz),       &\n     !     mtr_local%rootg_rtq(iz)\n     ! end do\n     !%%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE geom_init_metric\n \n\n!--------------------------------------\n  ", "SUBROUTINE geom_set_operators\n!--------------------------------------\n    implicit none\n    real(kind=DP) :: wzz    ! The rotating flux tube coordinate (= z'')\n    real(kind=DP) :: zz_lab ! The flux-coordinate theta in the lab frame (= z''+t*gamma_e/s_hat)\n    real(kind=DP) :: kkx, kky, domgdz, domgdx, domgdy\n    real(kind=DP) :: bb, kmo\n    real(kind=DP) :: gg0\n\n    real(kind=DP) :: cfsrf_l\n    real(kind=DP), dimension(1:3,1:3) :: gg\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw\n    real(kind=DP), dimension(:,:,:), allocatable :: ww\n\n    integer :: mx, my, iz, iv, im, is\n\n        do iz = -nz, nz-1\n\n          wzz = zz(iz)\n          zz_lab = mtr_local%zz_labframe(iz)\n          omg(iz)   = mtr_local%omg(iz)\n          domgdx    = mtr_local%domgdx(iz)\n          domgdy    = mtr_local%domgdy(iz)\n          domgdz    = mtr_local%domgdz(iz)\n          gg(1,1)   = mtr_local%gxx(iz)\n          gg(1,2)   = mtr_local%gxy(iz)\n          gg(1,3)   = mtr_local%gxz(iz)\n          gg(2,2)   = mtr_local%gyy(iz)\n          gg(2,3)   = mtr_local%gyz(iz)\n          gg(3,3)   = mtr_local%gzz(iz)\n          rootg(iz) = mtr_local%rootg_xyz(iz)\n          gg(2,1)   = gg(1,2)\n          gg(3,1)   = gg(1,3)\n          gg(3,2)   = gg(2,3)\n\n!!! for slab model\n          if ( trim(equib_type) == \"slab\") then\n\n            dpara(iz) = dz * q_0 * r_major\n\n            do im = 0, nm\n              vp(iz,im)  = sqrt( 2._DP * mu(im) )!* omg(iz) )\n              mir(iz,im) = 0._DP\n              do iv = 1, 2*nv\n                vdx(iz,iv,im) = 0._DP\n                vdy(iz,iv,im) = 0._DP\n                vsy(iz,iv,im) =                                           &\n                  - sgn(ranks) * tau(ranks) / Znum(ranks)                 & \n                  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                           + omg(iz)*mu(im) - 1.5_DP ) )\n              end do\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = kx(mx)**2 + ky(my)**2\n              end do\n            end do\n\n!!! for the concentric and large-aspect-ratio model !!!\n          else if( trim(equib_type) == \"analytic\" ) then\n\n            dpara(iz) = dz * q_0 * r_major\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n              mir(iz,im) = mu(im) * eps_r / ( q_0 * r_major )  &\n                       * ( sin(zz_lab)                                          &\n                         + eps_hor * lmmq   * sin( lmmq   * zz_lab - malpha )   &\n                         + eps_mor * lmmqm1 * sin( lmmqm1 * zz_lab - malpha )   &\n                         + eps_por * lmmqp1 * sin( lmmqp1 * zz_lab - malpha ) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im)=                                            &\n                      - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &\n                      * ( 0._DP * ( rdeps00 + rdeps1_0 * cos( zz_lab )             &\n                             + rdeps2_10 * cos( lmmq   * zz_lab - malpha )          &\n                             + rdeps1_10 * cos( lmmqm1 * zz_lab - malpha )          &\n                             + rdeps3_10 * cos( lmmqp1 * zz_lab - malpha ) )        &\n                             + ( 1._DP + s_hat * wzz * 0._DP )                 &\n                             * ( sin( zz_lab )                                      &\n                             + eps_hor * lprd   * sin( lmmq   * zz_lab - malpha )   &\n                             + eps_mor * lprdm1 * sin( lmmqm1 * zz_lab - malpha )   &\n                             + eps_por * lprdp1 * sin( lmmqp1 * zz_lab - malpha ) ) &\n                         ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im)=                                            &\n                      - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &\n                      * ( 1._DP * ( rdeps00 + rdeps1_0 * cos( zz_lab )             &\n                             + rdeps2_10 * cos( lmmq   * zz_lab - malpha )          &\n                             + rdeps1_10 * cos( lmmqm1 * zz_lab - malpha )          &\n                             + rdeps3_10 * cos( lmmqp1 * zz_lab - malpha ) )        &\n                             + ( 0._DP + s_hat * wzz * 1._DP )                 &\n                             * ( sin( zz_lab )                                      &\n                             + eps_hor * lprd   * sin( lmmq   * zz_lab - malpha )   &\n                             + eps_mor * lprdm1 * sin( lmmqm1 * zz_lab - malpha )   &\n                             + eps_por * lprdp1 * sin( lmmqp1 * zz_lab - malpha ) ) &\n                         ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 & \n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )\n\n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = ( kx(mx) + s_hat * wzz * ky(my) )**2 + ky(my)**2\n              end do\n            end do\n\n!!! for s-alpha !!! <--- the current version is the same as \"analytic\"\n          else if( trim(equib_type) == \"s-alpha\" .or. trim(equib_type) == \"s-alpha-shift\" ) then\n\n            dpara(iz) = dz* q_0 * r_major\n\n            kkx = -r_major * (q_0/q_bar) &\n                           * ( gg(1,1)*gg(2,3) - gg(1,2)*gg(1,3) )*domgdz\n            kky =  r_major * (q_bar/q_0) &\n                           * ( domgdx - ( gg(1,2)*gg(2,3) - gg(2,2)*gg(1,3) )*domgdz )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * (q_0/q_bar) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im) =                                     &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   \n                      * kkx                                             &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im) =                                     &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   \n                      * kky                                             &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  &\n                      * (q_bar/q_0)\n              end do\n\n            end do   ! im loop ends\n\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = ( kx(mx) + ( s_hat * wzz - alpha_MHD*sin(zz_lab) ) &\n                                * ky(my) )**2 + ky(my)**2 ! with Shafranov shift\n              end do\n            end do\n\n!!! for circular MHD equilibrium !!!\n          else if( trim(equib_type) == \"circ-MHD\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )\n            kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im)=                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &\n                      * kkx                                                     &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im)=                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &\n                      * kky                                                     &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  \n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &\n                              + 2._DP*kx(mx)*ky(my)*gg(1,2) &\n                              + (ky(my)**2)*gg(2,2)\n              end do\n            end do\n\n!  this is new vmec-BoozXform interface  by M. Nakata & M. Nunami  (Aug. 2016)\n          else if( trim(equib_type) == \"vmec\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )\n            kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kkx                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n\n                    vdy(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kky                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &\n                     - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term \n                      * ( beta*(R0_Ln(ranks) + R0_Lt(ranks)) )                   &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  \n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &\n                              + 2._DP*kx(mx)*ky(my)*gg(1,2) &\n                              + (ky(my)**2)*gg(2,2)\n              end do\n            end do\n\n          else if( trim(equib_type) == \"eqdsk\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )\n            kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kkx                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kky                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &\n                     - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term \n                      * ( beta*(R0_Ln(ranks) + R0_Lt(ranks)) )                   &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  \n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &\n                              + 2._DP*kx(mx)*ky(my)*gg(1,2) &\n                              + (ky(my)**2)*gg(2,2)\n              end do\n            end do\n\n!sakano_ring-dipole st 202303\n          else if( trim(equib_type) == \"ring\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx = 0._DP\n            kky = r_major*( domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n! r_major = 1 is assumed as the equilibrium length unit\n! B on the equatorial plane is also unity\n\n", "              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              !mir(iz,im) = mu(im) * ub_dot_grdb\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                vdx(iz,iv,im) = 0._DP\n                   \n                !vdy(iz,iv,im) =                                        &\n                !        ( vl(iv)**2 + omg(iz)*mu(im) )                 &\n                !      * ( ub_crs_grdb / omg(iz)**2 ) * sqrt( gg(2,2) ) &\n                !      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )      ! ion's vdy is negative y direction\n                vdy(iz,iv,im) =                                              &\n                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) ) &\n                      * kky                                                  &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) ) \n                vsy(iz,iv,im)=                                             &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)              &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2 &\n                                               + omg(iz)*mu(im) - 1.5_DP ) ) ! ion's vsy is negative y directuin\n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = ( kx(mx) * gg(1,1) )**2 + ( ky(my) * gg(2,2) )**2\n              end do\n            end do\n!sakano_ring-dipole end 202303\n\n          else\n\n            write( olog, * ) \" # wrong choice of the equilibrium \"\n            call flush(olog)\n            call MPI_Finalize(ierr_mpi)\n            stop\n\n          end if\n\n\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                kmo           = sqrt( 2._DP * ksq(mx,my,iz) * mu(im) / omg(iz) ) &\n                               * dsqrt( tau(ranks)*Anum(ranks) ) / Znum(ranks)\n                call math_j0( kmo, j0(mx,my,iz,im) )\n                call math_j1( kmo, j1(mx,my,iz,im) )\n                call math_j2( kmo, j2(mx,my,iz,im) )\n              end do\n            end do\n          end do\n\n\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              bb     = ksq(mx,my,iz) / omg(iz)**2 &\n                        * tau(ranks)*Anum(ranks)/(Znum(ranks)**2)\n              call math_g0( bb, g0(mx,my,iz) )\n            end do\n          end do\n\n        end do   ! iz loop ends\n\n        cfsrf   = 0._DP\n        cfsrf_l = 0._DP\n        do iz = -nz, nz-1\n          cfsrf_l   = cfsrf_l + rootg(iz)\n                                            ! normalization coefficient for \n                                            ! the surface average\n        end do\n        call MPI_Allreduce( cfsrf_l, cfsrf, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n\n        if ( vel_rank == 0 ) then\n          do iz = -nz, nz-1\n            dvp(iz)  = sqrt( 2._DP * (0.5_DP * dm**2) * omg(iz) )\n          end do\n        end if\n        call MPI_Bcast( dvp, 2*nz, MPI_DOUBLE_PRECISION, 0, &\n                        vel_comm_world, ierr_mpi )\n\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              fmx(iz,iv,im)   = exp( - 0.5_DP * vl(iv)**2 - omg(iz) * mu(im) ) &\n                              / sqrt( twopi**3 )\n            end do\n          end do\n        end do\n\n        allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n! --- GK polarization factor for efield calculation \n        fct_poisson(:,:,:) = 0._DP\n        fct_e_energy(:,:,:) = 0._DP\n\n        ww(:,:,:) = 0._DP\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n\n              if ( rankw == 0 .and. mx == 0 .and. my == 0 ) then !- (0,0) mode\n\n                fct_poisson(mx,my,iz) = 0._DP\n                fct_e_energy(mx,my,iz) = 0._DP\n\n              else\n\n                ww(mx,my,iz) = lambda_i * ksq(mx,my,iz)\n                do is = 0, ns-1\n                  bb   = ksq(mx,my,iz) / omg(iz)**2 &\n                          * tau(is)*Anum(is)/(Znum(is)**2)\n                  call math_g0( bb, gg0 )\n                  ww(mx,my,iz) = ww(mx,my,iz)  &\n                               + Znum(is) * fcs(is) / tau(is) * ( 1._DP - gg0 )\n                end do\n                fct_poisson(mx,my,iz) = 1._DP / ww(mx,my,iz)\n                fct_e_energy(mx,my,iz) = ww(mx,my,iz)\n\n              end if\n\n            end do\n          end do\n        end do\n\n\n! --- ZF-factor for adiabatic model\n        if ( ns == 1 ) then\n\n          ww(:,:,:) = 0._DP\n          do iz = -nz, nz-1\n            my = 0\n              do mx = -nx, nx\n                ww(mx,my,iz) = ( 1._DP - g0(mx,my,iz) )       &\n                             / ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )\n              end do\n          end do\n\n          call intgrl_fsrf ( ww, fctgt )\n\n          if ( rankw == 0 )  then\n            fctgt(0)   = ( 1._DP - g0(0,0,0) ) / ( 1._DP - g0(0,0,0) + tau(0)*tau_ad )\n                                              ! g0(0,0,iz) has no z dependence\n          endif\n\n        endif\n\n        deallocate( ww )\n\n        allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n        allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n        wf(:,:,:,:,:) = ( 0._DP, 0._DP )\n        nw(:,:,:) = ( 0._DP, 0._DP )\n\n! --- GK polarization factor for mfield calculation \n        fct_ampere(:,:,:) = 0._DP\n        fct_m_energy(:,:,:) = 0._DP\n\n        if ( beta .ne. 0._DP ) then\n       \n          do im = 0, nm\n            do iv = 1, 2*nv\n              do iz = -nz, nz-1\n                do my = ist_y, iend_y\n                  do mx = -nx, nx\n                    wf(mx,my,iz,iv,im) = Znum(ranks) * fcs(ranks) / Anum(ranks)  &\n                                       * vl(iv)**2 * j0(mx,my,iz,im)**2 * fmx(iz,iv,im)\n                  end do\n                end do\n              end do\n            end do\n          end do\n  \n          call intgrl_v0_moment_ms ( wf, nw )\n  \n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                fct_ampere(mx,my,iz) = 1._DP / real( ksq(mx,my,iz) + beta * nw(mx,my,iz), kind=DP )\n                fct_m_energy(mx,my,iz) = ksq(mx,my,iz) / beta\n              end do\n            end do\n          end do\n  \n          if ( rankw == 0 ) then\n            do iz = -nz, nz-1\n              fct_ampere(0,0,iz) = 0._DP\n              fct_m_energy(0,0,iz) = 0._DP\n            end do\n          end if\n\n        end if\n\n        deallocate( wf )\n        deallocate( nw )\n\n  END SUBROUTINE geom_set_operators\n\n!--------------------------------------\n  SUBROUTINE geom_reset_time(time_shearflow)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in) :: time_shearflow\n      call mtr_local%init(mtr_fourier, time_shearflow)\n      call geom_set_operators\n      !NOTE: colliimp_set_param in GKV_colliimp should also be updated.\n  END SUBROUTINE geom_reset_time\n\n!--------------------------------------\n  SUBROUTINE geom_increment_time(dt_shearflow)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in) :: dt_shearflow\n      call mtr_local%update(mtr_fourier, dt_shearflow)\n      call geom_set_operators\n      !NOTE: colliimp_set_param in GKV_colliimp should also be updated.\n  END SUBROUTINE geom_increment_time\n\n\n!--------------------------------------\n  SUBROUTINE metric_global_init(self, iz, wzz, theta, gomg,            &\n                                gdomgdx, gdomgdy, gdomgdz, ggxx, ggxy, &\n                                ggxz, ggyy, ggyz, ggzz, grootg_xyz,    &\n                                gdomgdr, gdomgdt, gdomgdq, ggrr, ggrt, &\n                                ggrq, ggtt, ggtq, ggqq, grootg_rtq)\n!--------------------------------------\n    implicit none\n    class(metric_global), intent(inout) :: self\n    integer, intent(in) :: iz\n    real(kind=DP), intent(in) :: wzz, theta, gomg\n    real(kind=DP), intent(in) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP), intent(in) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n\n      self%zz(iz)     = wzz\n      self%theta(iz)  = theta\n      self%omg(iz)    = gomg\n      self%domgdx(iz) = gdomgdx\n      self%domgdy(iz) = gdomgdy\n      self%domgdz(iz) = gdomgdz\n      self%gxx(iz) = ggxx\n      self%gxy(iz) = ggxy\n      self%gxz(iz) = ggxz\n      self%gyy(iz) = ggyy\n      self%gyz(iz) = ggyz\n      self%gzz(iz) = ggzz\n      self%rootg_xyz(iz) = grootg_xyz\n      self%domgdr(iz) = gdomgdr\n      self%domgdt(iz) = gdomgdt\n      self%domgdq(iz) = gdomgdq\n      self%grr(iz) = ggrr\n      self%grt(iz) = ggrt\n      self%grq(iz) = ggrq\n      self%gtt(iz) = ggtt\n      self%gtq(iz) = ggtq\n      self%gqq(iz) = ggqq\n      self%rootg_rtq(iz) = grootg_rtq\n\n  END SUBROUTINE metric_global_init\n\n\n!--------------------------------------\n  SUBROUTINE metric_global_xyz2rtq(self)\n!--------------------------------------\n    implicit none\n    class(metric_global), intent(inout) :: self\n    real(kind=DP) :: wzz\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz\n\n      do iz = -global_nz, global_nz-1\n       ! load (x,y,z)\n        wzz = self%zz(iz)\n        gdomgdx = self%domgdx(iz)\n        gdomgdy = self%domgdy(iz)\n        gdomgdz = self%domgdz(iz)\n        ggxx = self%gxx(iz)\n        ggxy = self%gxy(iz)\n        ggxz = self%gxz(iz)\n        ggyy = self%gyy(iz)\n        ggyz = self%gyz(iz)\n        ggzz = self%gzz(iz)\n        grootg_xyz = self%rootg_xyz(iz)\n\n       ! translate (x,y,z)->(r,t,q)=(rho,theta,zeta)\n       !   NOTE: cx*rho0/(cy*q_0=1) is used.\n        gdomgdr = cx*gdomgdx + cx*s_hat*wzz*gdomgdy\n        gdomgdt = gdomgdz + cy*q_0*gdomgdy\n        gdomgdq = - cy*gdomgdy\n        ggrr = ggxx/cx**2\n        ggrt = ggxz/cx\n        ggrq = (s_hat*wzz*ggxx-ggxy)/(cx*cy) + q_0*ggxz/cx\n        ggtt = ggzz\n        ggtq = (s_hat*wzz*ggxz-ggyz)/cy + q_0*ggzz\n        ggqq = (s_hat*wzz/cy)**2*ggxx - 2._DP*(s_hat*wzz/cy**2)*ggxy &\n             + 2._DP*(q_0*s_hat*wzz/cy)*ggxz + ggyy/cy**2            &\n             - 2._DP*(q_0/cy)*ggyz + q_0**2*ggzz\n        grootg_rtq = cx*cy*grootg_xyz\n\n       ! store (r,t,q)\n        self%domgdr(iz) = gdomgdr\n        self%domgdt(iz) = gdomgdt\n        self%domgdq(iz) = gdomgdq\n        self%grr(iz) = ggrr\n        self%grt(iz) = ggrt\n        self%grq(iz) = ggrq\n        self%gtt(iz) = ggtt\n        self%gtq(iz) = ggtq\n        self%gqq(iz) = ggqq\n        self%rootg_rtq(iz) = grootg_rtq\n      end do\n\n  END SUBROUTINE metric_global_xyz2rtq\n\n\n!--------------------------------------\n  SUBROUTINE metric_global_rtq2xyz(self)\n!--------------------------------------\n    implicit none\n    class(metric_global), intent(inout) :: self\n    real(kind=DP) :: wzz\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz\n\n      do iz = -global_nz, global_nz-1\n       ! load (r,t,q)=(rho,theta,zeta)\n        wzz = self%zz(iz)\n        gdomgdr = self%domgdr(iz)\n        gdomgdt = self%domgdt(iz)\n        gdomgdq = self%domgdq(iz)\n        ggrr = self%grr(iz)\n        ggrt = self%grt(iz)\n        ggrq = self%grq(iz)\n        ggtt = self%gtt(iz)\n        ggtq = self%gtq(iz)\n        ggqq = self%gqq(iz)\n        grootg_rtq = self%rootg_rtq(iz)\n\n       ! translate (r,t,q)->(x,y,z)\n       !   NOTE: cx*rho0/(cy*q_0=1) is used.\n        gdomgdx = gdomgdr/cx + s_hat*wzz*gdomgdq/cy\n        gdomgdy = - gdomgdq/cy\n        gdomgdz = gdomgdt + q_0*gdomgdq\n        ggxx = cx**2*ggrr\n        ggxy = cx**2*s_hat*wzz*ggrr + cx*cy*(q_0*ggrt - ggrq)\n        ggxz = cx*ggrt\n        ggyy = (cx*s_hat*wzz)**2*ggrr + 2._DP*cx*cy*s_hat*wzz*(q_0*ggrt-ggrq) &\n             + (cy*q_0)**2*ggtt - 2._DP*cy**2*q_0*ggtq + cy**2*ggqq\n        ggyz = cx*s_hat*wzz*ggrt + cy*q_0*ggtt - cy*ggtq\n        ggzz = ggtt\n        grootg_xyz = grootg_rtq/(cx*cy)\n\n       ! store (x,y,z)\n        self%domgdx(iz) = gdomgdx\n        self%domgdy(iz) = gdomgdy\n        self%domgdz(iz) = gdomgdz\n        self%gxx(iz) = ggxx\n        self%gxy(iz) = ggxy\n        self%gxz(iz) = ggxz\n        self%gyy(iz) = ggyy\n        self%gyz(iz) = ggyz\n        self%gzz(iz) = ggzz\n        self%rootg_xyz(iz) = grootg_xyz\n      end do\n\n  END SUBROUTINE metric_global_rtq2xyz\n\n\n!--------------------------------------\n  SUBROUTINE metric_fourier_init(self)\n!--------------------------------------\n    implicit none\n    class(metric_fourier), intent(inout) :: self\n    real(kind=DP) :: kzmin\n    integer :: iz\n\n      kzmin = 2._DP * pi / (2._DP * lz)\n      do iz = -global_nz, global_nz-1\n        self%kz(iz) = iz * kzmin\n      end do\n\n  END SUBROUTINE metric_fourier_init\n\n\n!--------------------------------------\n  SUBROUTINE forward_dft_globalz(zz_global,kz,fz,fk)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in),     &\n      dimension(-global_nz:global_nz-1) :: zz_global, kz, fz\n    complex(kind=DP), intent(out), & \n      dimension(-global_nz:global_nz-1) :: fk\n    integer :: iz, mz\n\n      fk(:) = (0._DP, 0._DP)\n      do mz = -global_nz, global_nz-1\n        do iz = -global_nz, global_nz-1\n          fk(mz) = fk(mz) + fz(iz)*exp(-ui*kz(mz)*zz_global(iz))*dz/(2._DP*lz)\n        end do\n      end do\n\n  END SUBROUTINE forward_dft_globalz\n\n\n!!--------------------------------------\n!  SUBROUTINE backward_dft_globalz(zz_global,kz,fk,fz)\n!!--------------------------------------\n!    implicit none\n!    real(kind=DP), intent(in),     &\n!      dimension(-global_nz:global_nz-1) :: zz_global, kz\n!    complex(kind=DP), intent(in), & \n!      dimension(-global_nz:global_nz-1) :: fk\n!    real(kind=DP), intent(out),     &\n!      dimension(-global_nz:global_nz-1) :: fz\n!    integer :: iz, mz\n!\n!      fz(:) = 0._DP\n!      do iz = -global_nz, global_nz-1\n!        do mz = -global_nz, global_nz-1\n!          fz(iz) = fz(iz) + real(fk(mz)*exp(ui*kz(mz)*zz_global(iz)), kind=DP)\n!        end do\n!      end do\n!\n!  END SUBROUTINE backward_dft_globalz\n\n\n!--------------------------------------\n  SUBROUTINE backward_dft_localz(zz_local,kz,fk,fz)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in),     &\n      dimension(-nz:nz-1) :: zz_local\n    real(kind=DP), intent(in),     &\n      dimension(-global_nz:global_nz-1) :: kz\n    complex(kind=DP), intent(in), & \n      dimension(-global_nz:global_nz-1) :: fk\n    real(kind=DP), intent(out),     &\n      dimension(-nz:nz-1) :: fz\n    integer :: iz, mz\n\n      fz(:) = 0._DP\n      do iz = -nz, nz-1\n        do mz = -global_nz, global_nz-1\n          fz(iz) = fz(iz) + real(fk(mz)*exp(ui*kz(mz)*zz_local(iz)), kind=DP)\n        end do\n      end do\n\n  END SUBROUTINE backward_dft_localz\n\n\n!--------------------------------------\n  ", "SUBROUTINE metric_fourier_dft_rtq2coef(self, mtr_g)\n!--------------------------------------\n    implicit none\n    class(metric_fourier), intent(inout) :: self\n    class(metric_global), intent(in) :: mtr_g\n    real(kind=DP), dimension(-global_nz:global_nz-1) :: theta_tilde\n\n    ! theta = zz + theta_tilde(zz), theta_tilde is a periodic function.\n      if (trim(equib_type) == \"vmec\") then\n        theta_tilde = mtr_g%theta - q_0 * mtr_g%zz! Axisymmetric toroidal angle phi_ax\n      else\n        theta_tilde = mtr_g%theta - mtr_g%zz\n      end if\n      call forward_dft_globalz(mtr_g%zz, self%kz, theta_tilde,   self%theta_tilde)\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%omg     , self%omg      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%domgdr  , self%domgdr   )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%domgdt  , self%domgdt   )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%domgdq  , self%domgdq   )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%grr     , self%grr      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%grt     , self%grt      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%grq     , self%grq      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%gtt     , self%gtt      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%gtq     , self%gtq      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%gqq     , self%gqq      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%rootg_rtq, self%rootg_rtq)\n     ! NOTE:\n     ! Arguments are (zz_global(in),kz_global(in),omg_global(in),coef_global(out))\n\n  END SUBROUTINE metric_fourier_dft_rtq2coef\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_dft_coef2rtq(self, mtr_f)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_fourier), intent(in) :: mtr_f \n    real(kind=DP), dimension(-nz:nz-1) :: theta_tilde\n\n    ! theta = zz + theta_tilde(zz), theta_tilde is a periodic function.\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%theta_tilde, theta_tilde )\n      if (trim(equib_type) == \"vmec\") then\n        self%theta = q_0 * self%zz_labframe + theta_tilde! Axisymmetric toroidal angle phi_ax = q_0*zz + phi_tilde(zz)\n      else\n        self%theta = self%zz_labframe + theta_tilde\n      end if\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%omg     , self%omg      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%domgdr  , self%domgdr   )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%domgdt  , self%domgdt   )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%domgdq  , self%domgdq   )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%grr     , self%grr      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%grt     , self%grt      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%grq     , self%grq      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%gtt     , self%gtt      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%gtq     , self%gtq      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%gqq     , self%gqq      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%rootg_rtq, self%rootg_rtq)\n     ! NOTE:\n     ! Arguments are (zz_local(in),kz_global(in), coef_global(in), omg_local(out)).\n     ! Fourier coefficients have been evaluated in the lab frame at t=0.\n     ! self%zz_labframe (= z''+t*gamma_e/s_hat) is the time-dependent flux-coordinate theta in the lab frame.\n\n  END SUBROUTINE metric_local_dft_coef2rtq\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_rtq2xyz(self)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    real(kind=DP) :: wzz\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz\n\n      do iz = -nz, nz-1\n      ! load (r,t,q)=(rho,theta,zeta)\n        wzz = self%zz(iz)\n        gdomgdr = self%domgdr(iz)\n        gdomgdt = self%domgdt(iz)\n        gdomgdq = self%domgdq(iz)\n        ggrr = self%grr(iz)\n        ggrt = self%grt(iz)\n        ggrq = self%grq(iz)\n        ggtt = self%gtt(iz)\n        ggtq = self%gtq(iz)\n        ggqq = self%gqq(iz)\n        grootg_rtq = self%rootg_rtq(iz)\n\n      ! translate (r,t,q)->(x,y,z)\n      !   NOTE: cx*rho0/(cy*q_0=1) is used.\n        gdomgdx = gdomgdr/cx + s_hat*wzz*gdomgdq/cy\n        gdomgdy = - gdomgdq/cy\n        gdomgdz = gdomgdt + q_0*gdomgdq\n        ggxx = cx**2*ggrr\n        ggxy = cx**2*s_hat*wzz*ggrr + cx*cy*(q_0*ggrt - ggrq)\n        ggxz = cx*ggrt\n        ggyy = (cx*s_hat*wzz)**2*ggrr + 2._DP*cx*cy*s_hat*wzz*(q_0*ggrt-ggrq) &\n             + (cy*q_0)**2*ggtt - 2._DP*cy**2*q_0*ggtq + cy**2*ggqq\n        ggyz = cx*s_hat*wzz*ggrt + cy*q_0*ggtt - cy*ggtq\n        ggzz = ggtt\n        grootg_xyz = grootg_rtq/(cx*cy)\n\n      ! store (x,y,z)\n        self%domgdx(iz) = gdomgdx\n        self%domgdy(iz) = gdomgdy\n        self%domgdz(iz) = gdomgdz\n        self%gxx(iz) = ggxx\n        self%gxy(iz) = ggxy\n        self%gxz(iz) = ggxz\n        self%gyy(iz) = ggyy\n        self%gyz(iz) = ggyz\n        self%gzz(iz) = ggzz\n        self%rootg_xyz(iz) = grootg_xyz\n      end do\n\n  END SUBROUTINE metric_local_rtq2xyz\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_copy_global(self, mtr_g)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_global), intent(in) :: mtr_g\n    integer :: iz, giz\n\n      do iz = -nz, nz-1\n        giz = iz - global_nz + 2*nz * rankz + nz\n        self%zz_labframe(iz) = mtr_g%zz(giz)    \n        self%zz(iz)        = mtr_g%zz(giz)    \n        self%theta(iz)     = mtr_g%theta(giz) \n        self%omg(iz)       = mtr_g%omg(giz)   \n        self%domgdx(iz)    = mtr_g%domgdx(giz)\n        self%domgdy(iz)    = mtr_g%domgdy(giz)\n        self%domgdz(iz)    = mtr_g%domgdz(giz)\n        self%gxx(iz)       = mtr_g%gxx(giz)\n        self%gxy(iz)       = mtr_g%gxy(giz)\n        self%gxz(iz)       = mtr_g%gxz(giz)\n        self%gyy(iz)       = mtr_g%gyy(giz)\n        self%gyz(iz)       = mtr_g%gyz(giz)\n        self%gzz(iz)       = mtr_g%gzz(giz)\n        self%rootg_xyz(iz) = mtr_g%rootg_xyz(giz)\n      end do\n\n  END SUBROUTINE metric_local_copy_global\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_init(self, mtr_f, time_shearflow)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_fourier), intent(in) :: mtr_f\n    real(kind=DP), intent(in) :: time_shearflow\n\n      self%zz(:) = zz(:)\n      self%zz_labframe(:) = zz(:) + time_shearflow * gamma_e / s_hat\n      call self%dft_coef2rtq(mtr_f)\n      call self%rtq2xyz\n      \n  END SUBROUTINE metric_local_init\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_update(self, mtr_f, dt_shearflow)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_fourier), intent(in) :: mtr_f\n    real(kind=DP), intent(in) :: dt_shearflow\n\n      self%zz_labframe(:) = self%zz_labframe(:) + dt_shearflow * gamma_e / s_hat\n      call self%dft_coef2rtq(mtr_f)\n      call self%rtq2xyz\n      \n  END SUBROUTINE metric_local_update\n\n      \nEND MODULE GKV_geom\n", "MODULE GKV_exb\n!-------------------------------------------------------------------------------\n!\n!    E x B term\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fft, only: &\n           plan_xf_y2zm, plan_xf_y2x, &\n           plan_xb_y2zm, plan_xb_y2x, &\n           plan_yf_y2zm, plan_yf_y2x, &\n           plan_yb_y2zm, plan_yb_y2x, &\n           planr_xf_y2zm, planr_xf_y2x, &\n           planr_xb_y2zm, planr_xb_y2x, &\n           planr_yf_y2zm, planr_yf_y2x, &\n           planr_yb_y2zm, planr_yb_y2x, &\n           plan_x_forward, plan_x_backward, &\n           plan_y_forward, plan_y_backward\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  real(kind=DP), save :: exb_maxvx_eachrank, exb_maxvy_eachrank\n\n  integer, parameter :: nbuff = ((2*nz)*(nm+1)-1)/nprocw + 1\n                            !if ( mod(2*nz*(nm+1),nprocw) == 0 ) then\n                            !  nbuff = 2*nz*(nm+1)/nprocw\n                            !else\n                            !  nbuff = 2*nz*(nm+1)/nprocw + 1\n                            !end if\n  real(kind=DP), dimension(0:global_ny), save :: gky\n  integer, save :: nchunk_zm = 1, nchunk_yb = 1, nchunk_xb = 1\n\n  integer, save :: nchunk_yzm = 1, nchunk_xzm = 1\n\n  complex(kind=DP), save, dimension(0:ny,0:2*nxw-1) :: uikx_y2x, uiky_y2x\n\n\n  public   exb_NL_term, exb_maxvx_eachrank, exb_maxvy_eachrank\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term(hh, psi, chi, pb)\n!--------------------------------------\n!  Nonlinear term calculation interface\n    implicit none\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: pb\n\n    real(kind=DP) :: dky\n    integer, save :: iflg\n    integer :: my\n!$  integer :: nthreads, omp_get_num_threads\n    data iflg / 0 /\n                                               !%%% For debug %%%\n                                               !complex(kind=DP) ::                        &\n                                               !  whh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm),   &\n                                               !  wpsi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm), &\n                                               !  wchi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)\n                                               !integer :: mx, iz, iv, im\n                                               !%%%%%%%%%%%%%%%%%\n\n    if( iflg == 0 ) then\n      iflg = 1\n      dky = ky(1) - ky(0)\n      do my = 0, global_ny\n        gky(my) = dky * real(my, kind=DP)\n      end do\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zm = ((2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_yb = ((global_ny+1)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_xb = ((2*nxw)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_yzm = ((iend_y-ist_y+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_xzm = ((iend_xw-ist_xw+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n    end if\n                                               !%%% For debug %%%\n                                               !whh(:,:,:,:,:) = (0._DP, 0._DP)\n                                               !wpsi(:,:,:,:) = (0._DP, 0._DP)\n                                               !wchi(:,:,:,:) = (0._DP, 0._DP)\n                                               !if (rankw == 0) then\n                                               !  whh(0,1,:,:,:) = (0.5_DP, 0._DP)\n                                               !  wpsi(2,0,:,:) = (0._DP, 0.5_DP)\n                                               !  wpsi(-2,0,:,:) = (0._DP, -0.5_DP)\n                                               !end if\n                                               !%%%%%%%%%%%%%%%%%\n\n    if (trim(calc_type) == \"nonlinear\") then\n\n#ifdef USE_TERM_Y2ZM\n        call exb_NL_term_y2zm(hh, psi, chi, pb)\n#else\n        call exb_NL_term_y2x(hh, psi, chi, pb)\n#endif\n\n    else\n\n!$OMP parallel workshare\n      pb(:,:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n    end if\n\n                                               !%%% For debug %%%\n                                               !if (rankz == 0 .and. rankv == 0 .and. rankm == 0 .and. ranks == 0) then\n                                               !  im = 0; iv = 1; iz = 0\n                                               !  do my = 0, ny\n                                               !    do mx = -nx, nx\n                                               !      write(80000+rankg,*) kx(mx), ky(my),  &\n                                               !  dble(whh(mx,my,iz,iv,im)), aimag(whh(mx,my,iz,iv,im)), &\n                                               !  dble(wpsi(mx,my,iz,im)), aimag(wpsi(mx,my,iz,im)), &\n                                               !  dble(pb(mx,my,iz,iv,im)), aimag(pb(mx,my,iz,iv,im))\n                                               !    end do\n                                               !    write(80000+rankg,*)\n                                               !  end do\n                                               !end if\n                                               !call MPI_Finalize(ierr_mpi)\n                                               !stop\n                                               !%%%%%%%%%%%%%%%%%\n\n\n  END SUBROUTINE exb_NL_term\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term_y2zm( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: &\n                      wc1o, wc2o, wc3o, wc4o,   wc1e, wc2e, wc3e, wc4e\n    complex(kind=DP), dimension(:,:,:), allocatable ::   &\n                         wwdxo, wwdyo, wwefo,      wwdxe, wwdye, wwefe\n\n    integer :: ix,iy,iz,im,ib,ip\n    integer :: iv\n\n      allocate(dpdx(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(dpdy(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(dadx(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(dady(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(wc1o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc2o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc3o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc4o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc1e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc2e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc3e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc4e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wwdxo(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwdyo(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwefo(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwdxe(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwdye(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwefe(0:nbuff-1,0:2*nxw-1,0:global_ny))\n\n!$OMP parallel default(none)                          &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)       &\n!$OMP shared(wc1o,wc2o,wc3o,wc4o,wc1e,wc2e,wc3e,wc4e) &\n!$OMP shared(wwdxo,wwdyo,wwefo,wwdxe,wwdye,wwefe)     &\n!$OMP private(iv)\n\n!$OMP workshare\n      wc1o(:,:,:,:) = (0._DP, 0._DP)\n      wc3o(:,:,:,:) = (0._DP, 0._DP)\n      wc1e(:,:,:,:) = (0._DP, 0._DP)\n      wc3e(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!      call exb_pack_psi_y2zm(psi,wc3o)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3o,wc4o)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n!!$OMP barrier\n!      call exb_pack_psi_y2zm(chi,wc3e)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3e,wc4e)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!        call exb_pack_hh_y2zm(iv,hh,wc1o)\n!!$OMP barrier\n!        call exb_transpose_y2zm(wc1o,wc2o)\n!!$OMP barrier\n!        call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n!!$OMP barrier\n!        call exb_realspcal_y2zm(iv,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n!!$OMP barrier\n!        call exb_pack_zm2y(wwefo,wc3o)\n!!$OMP barrier\n!        call exb_transpose_zm2y(wc3o,wc4o)\n!!$OMP barrier\n!        call exb_unpack_zm2y(iv,wc4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2zm(psi,wc3o)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3o,wc4o)\n      call exb_pack_psi_y2zm(chi,wc3e)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3e,wc4e)\n      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n      do iv = 1, 2*nv+6\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1e,wc2e)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3e,wc4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxe,wwdye,wwefe)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefo,wc3o)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1o,wc2o)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3o,wc4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2e,wwdxe,wwdye)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefe,wc3e)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2zm(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wc1o)\n      deallocate(wc2o)\n      deallocate(wc3o)\n      deallocate(wc4o)\n      deallocate(wc1e)\n      deallocate(wc2e)\n      deallocate(wc3e)\n      deallocate(wc4e)\n      deallocate(wwdxo)\n      deallocate(wwdyo)\n      deallocate(wwefo)\n      deallocate(wwdxe)\n      deallocate(wwdye)\n      deallocate(wwefe)\n\n  END SUBROUTINE exb_NL_term_y2zm\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2zm ( psi, wc4 )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2zm)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n!\n!    integer :: mx, my, iz, im, izm, ibuff, iprocw\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(2) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!\n!         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n!          izm = (2*nz)*im + (iz + nz)\n!          ibuff = mod(izm, nbuff)\n!          iprocw = izm / nbuff\n!          do my = ist_y, iend_y\n!            do mx = -nx, nx\n!              wc4(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n!            end do\n!          end do\n!         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2zm ( psi, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(ibuff,mx,my,iprocw) = psi(mx,my,iz,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2zm ( iv, hh, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(ibuff,mx,my,iprocw) = hh(mx,my,iz,iv,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_transpose_y2zm ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_y2zm ( wc4, wwdx, wwdy )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nx:nx) :: psi\n    complex(kind=DP), dimension(0:nbuff-1,0:global_ny,0:2*nxw-1) :: w1, w2\n    integer :: mx, my, ibuff, iprocw, global_my\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do global_my = 0, global_ny\n        iprocw = global_my / (ny+1)\n        my = mod(global_my, ny+1)\n        do mx = 0, nx\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = ui * kx(mx) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n        do mx = nx+1, 2*nxw-nx-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n        do mx = -nx,-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,2*nxw+mx) = ui * kx(mx) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xb_y2zm(ithd), w1, w2)\n\n      do global_my = 0, global_ny\n        do mx = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            wwdx(ibuff,mx,global_my) = w2(ibuff,global_my,mx)\n          end do\n        end do\n      end do\n\n      do global_my = 0, global_ny\n        iprocw = global_my / (ny+1)\n        my = mod(global_my, ny+1)\n        do mx = 0, nx\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = ui * gky(global_my) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n        do mx = nx+1, 2*nxw-nx-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n        do mx = -nx,-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,2*nxw+mx) = ui * gky(global_my) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xb_y2zm(ithd), w1, w2)\n\n      do global_my = 0, global_ny\n        do mx = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            wwdy(ibuff,mx,global_my) = w2(ibuff,global_my,mx)\n          end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_backwardfft_y2zm ( wwdx, wwdy, dpdx, dpdy )\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwdx, wwdy\n    real(kind=DP), intent(out), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(0:nbuff-1,0:2*nxw-1,0:nyw) :: w3\n    integer :: ix, ibuff\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n          w3(ibuff,ix,0:global_ny) = wwdx(ibuff,ix,0:global_ny)\n          w3(ibuff,ix,global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dpdx)\n\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n          w3(ibuff,ix,0:global_ny) = wwdy(ibuff,ix,0:global_ny)\n          w3(ibuff,ix,global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dpdy)\n\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2zm ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwdx, wwdy\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwef\n\n    complex(kind=DP), dimension(0:nbuff-1,0:2*nxw-1,0:nyw) :: w3\n    real(kind=DP), dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: ix, iy, ibuff, global_my\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do global_my = 0, global_ny\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = wwdx(ibuff,ix,global_my)\n          end do\n        end do\n      end do\n      do global_my = global_ny+1, nyw\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dhdx)\n\n      do global_my = 0, global_ny\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = wwdy(ibuff,ix,global_my)\n          end do\n        end do\n      end do\n      do global_my = global_ny+1, nyw\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dhdy)\n\n      do iy = 0, 2*nyw-1\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            pbxy(ibuff,ix,iy) = cef * ( & ! Normalization for 2D Forward FFT\n                       (dpdx(ibuff,ix,iy) - cs1 * vl(iv) * dadx(ibuff,ix,iy)) * dhdy(ibuff,ix,iy) &\n                     - (dpdy(ibuff,ix,iy) - cs1 * vl(iv) * dady(ibuff,ix,iy)) * dhdx(ibuff,ix,iy))\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_r2c(planr_yf_y2zm(ithd), pbxy, w3)\n\n      do global_my = 0, global_ny\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            wwef(ibuff,ix,global_my) = w3(ibuff,ix,global_my)\n          end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_zm2y ( wwef, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n\n    complex(kind=DP), dimension(0:nbuff-1,0:global_ny,0:2*nxw-1) :: w1, w2\n    complex(kind=DP), dimension(-nx:nx) :: ef\n    integer :: mx, my, ibuff, iprocw, global_my\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do global_my = 0, global_ny\n        do mx = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w2(ibuff,global_my,mx) = wwef(ibuff,mx,global_my) ! FFTW may destroy input array!\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xf_y2zm(ithd), w2, w1)\n\n      do global_my = 0, global_ny\n        iprocw = global_my / (ny+1)\n        my = mod(global_my, ny+1)\n        do mx = 0, nx\n          do ibuff = 0, nbuff-1\n            wc4(ibuff,mx,my,iprocw) = w1(ibuff,global_my,mx)\n          end do\n        end do\n        do mx = -nx, -1\n          do ibuff = 0, nbuff-1\n            wc4(ibuff,mx,my,iprocw) = w1(ibuff,global_my,2*nxw+mx)\n          end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_zm2y ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1440)\n                                         ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_zm2y ( iv, wc4, ef )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n    !complex(kind=DP), intent(inout), &\n    !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n    !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n    !      When the subroutine is called in a OpenMP parallel region, \n    !      the copied subarray may be treated as a thread-private variable.\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1450)\n                                         ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% UNPACK: (kx,ky,(z*,m*)*)->(kx,ky*,z*,m*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              ef(mx,my,iz,iv,im) = wc4(ibuff,mx,my,iprocw)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2zm ( dpdx, dpdy, dadx, dady )\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, ibuff, iv\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      iv = 2*nv\n!$OMP parallel default(none)                               &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)        &\n!$OMP shared(iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,ibuff,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n        do iy = 0, 2*nyw-1\n          do ix = 0, 2*nxw-1\n            do ibuff = 0, nbuff-1\n              wv_nl = abs(dpdy(ibuff,ix,iy) - cs1 * vl(iv) * dady(ibuff,ix,iy))\n              if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n        do iy = 0, 2*nyw-1\n          do ix = 0, 2*nxw-1\n            do ibuff = 0, nbuff-1\n              wv_nl = abs(dpdx(ibuff,ix,iy) - cs1 * vl(iv) * dadx(ibuff,ix,iy))\n              if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_NL_term_y2x( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: &\n                                   wdx1o, wdy1o, wdx2o, wdy2o, wef3o, wef4o, &\n                                   wdx1e, wdy1e, wdx2e, wdy2e, wef3e, wef4e\n    integer :: iv, iprocw\n    integer       :: mx, my\n    integer, save :: iflg = 0\n\n      allocate(dpdx(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(dpdy(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(dadx(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(dady(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(wdx1o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy1o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdx2o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy2o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef3o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef4o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdx1e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy1e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdx2e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy2e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef3e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef4e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n\n      if( iflg == 0 ) then\n        iflg = 1\n\n!       uikx_y2x(:,:) = ( 0._DP, 0._DP )\n!       uiky_y2x(:,:) = ( 0._DP, 0._DP )\n        do mx = 0, nx\n          do my = ist_y, iend_y\n            uikx_y2x(my,mx) = kx(mx) * ui\n            uiky_y2x(my,mx) = ky(my) * ui\n          end do\n        end do\n        do mx = -nx, -1\n          do my = ist_y, iend_y\n            uikx_y2x(my,2*nxw+mx) = kx(mx) * ui\n            uiky_y2x(my,2*nxw+mx) = ky(my) * ui\n          end do\n        end do\n      end if\n\n!$OMP parallel default(none)                      &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)   &\n!$OMP shared(wdx1o,wdy1o,wdx2o,wdy2o,wef3o,wef4o) &\n!$OMP shared(wdx1e,wdy1e,wdx2e,wdy2e,wef3e,wef4e) &\n!$OMP private(iv,iprocw)\n\n!$OMP workshare\n      ef(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3o(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3e(:,:,:,:,:) = (0._DP, 0._DP)\n      dpdx(:,:,:,:) = 0._DP\n      dpdy(:,:,:,:) = 0._DP\n      dadx(:,:,:,:) = 0._DP\n      dady(:,:,:,:) = 0._DP\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1o,wdx2o)\n!      call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!!$OMP barrier\n!      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1e,wdx2e)\n!      call exb_transpose_y2x(wdy1e,wdy2e)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!        call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n!!$OMP barrier\n!        call exb_transpose_y2x(wdx1o,wdx2o)\n!        call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!        call exb_realspcal_y2x(iv,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n!!$OMP barrier\n!        call exb_transpose_x2y(wef3o,wef4o)\n!!$OMP barrier\n!        call exb_unpack_x2y(iv,wef4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1o,wdx2o)\n      call exb_transpose_y2x(wdy1o,wdy2o)\n      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1e,wdx2e)\n      call exb_transpose_y2x(wdy1e,wdy2e)\n      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!$OMP barrier\n      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n      do iv = 1, 2*nv+4\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1e,wdx2e)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1e,wdy2e)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3e,wef4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1o,wdx2o)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1o,wdy2o)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3o,wef4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1e,wdy1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2e,wdy2e,wef3e)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2x(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wdx1o)\n      deallocate(wdy1o)\n      deallocate(wdx2o)\n      deallocate(wdy2o)\n      deallocate(wef3o)\n      deallocate(wef4o)\n      deallocate(wdx1e)\n      deallocate(wdy1e)\n      deallocate(wdx2e)\n      deallocate(wdy2e)\n      deallocate(wef3e)\n      deallocate(wef4e)\n\n  END SUBROUTINE exb_NL_term_y2x\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2x ( psi, wwdx, wwdy )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2x)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n!    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(3) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!          do my = ist_y, iend_y\n!\n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * kx(0:nx) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * ky(my) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!          enddo\n!        enddo\n!      enddo\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2x ( psi, wwdx, wwdy ) !done\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1a, w2a\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1b, w2b\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n    complex(kind=DP) :: ww\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do my = ist_y, iend_y\n        do ix = 0, nx\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = psi(ix,my,iz,im)\n          enddo\n          enddo\n        enddo\n      enddo\n      do my = ist_y, iend_y\n        do ix = nx+1, 2*nxw-nx-1\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          enddo\n          enddo\n        enddo\n      enddo\n      do my = ist_y, iend_y\n        do ix = -nx, -1\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,2*nxw+ix) = psi(ix,my,iz,im)\n          enddo\n          enddo\n        enddo\n      enddo\n\n      do my = ist_y, iend_y\n        do ix = 0, 2*nxw-1\n          do im = 0, nm\n          do iz = -nz, nz-1\n            ww = w1a(iz,im,my,ix)\n            w1a(iz,im,my,ix) = uikx_y2x(my,ix) * ww\n            w1b(iz,im,my,ix) = uiky_y2x(my,ix) * ww\n          enddo\n          enddo\n        enddo\n      enddo\n\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1a, w2a)\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1b, w2b)\n\n      do irank = 0, nprocw-1\n        ist_xw_g_rank  = (nxw_size+1)*irank\n        iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n        do my = ist_y, iend_y\n          do ix = ist_xw_g_rank, iend_xw_g_rank\n            do im = 0, nm\n              do iz = -nz, nz-1\n                wwdx(iz,im,ix-ist_xw_g_rank,my,irank) = w2a(iz,im,my,ix)\n                wwdy(iz,im,ix-ist_xw_g_rank,my,irank) = w2b(iz,im,my,ix)\n              enddo\n            enddo\n          enddo\n        enddo\n      enddo\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2x ( iv, hh, wwdx, wwdy ) !done\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1a, w2a\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1b, w2b\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n    complex(kind=DP) :: ww\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do my = ist_y, iend_y\n       do ix = 0, nx\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = hh(ix,my,iz,iv,im)\n          enddo\n        enddo\n       enddo\n      enddo\n      do my = ist_y, iend_y\n       do ix = nx+1, 2*nxw-nx-1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          enddo\n        enddo\n       enddo\n      enddo\n      do my = ist_y, iend_y\n       do ix = -nx, -1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,2*nxw+ix) = hh(ix,my,iz,iv,im)\n          enddo\n        enddo\n       enddo\n      enddo\n\n      do my = ist_y, iend_y\n       do ix = 0, 2*nxw-1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            ww = w1a(iz,im,my,ix)\n            w1a(iz,im,my,ix) = uikx_y2x(my,ix) * ww\n            w1b(iz,im,my,ix) = uiky_y2x(my,ix) * ww\n          enddo\n        enddo\n       enddo\n      enddo\n\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1a, w2a)\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1b, w2b)\n\n      do irank = 0, nprocw-1\n        ist_xw_g_rank  = (nxw_size+1)*irank\n        iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n        do my = ist_y, iend_y\n          do ix = ist_xw_g_rank, iend_xw_g_rank\n            do im = 0, nm\n              do iz = -nz, nz-1\n                wwdx(iz,im,ix-ist_xw_g_rank,my,irank) = w2a(iz,im,my,ix)\n                wwdy(iz,im,ix-ist_xw_g_rank,my,irank) = w2b(iz,im,my,ix)\n              enddo\n            enddo\n          enddo\n        enddo\n      enddo\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_y2x ( wwin, wwout ) !done\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2x\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_backwardfft_y2x ( wwdx, wwdy, dpdx, dpdy )!done\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n    real(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:nyw) :: w3\n    real(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:2*nyw-1) :: wtmp\n    integer :: ix, my, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdx(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n        do ix = ist_xw, iend_xw\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n          end do\n        end do\n      end do\n\n!!TBI!! call dfftw_execute_dft_c2r(plan_yb_y2x(ithd), w3, dpdx(0,ist_xw,iz,im))\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, wtmp)\n      do my = 0, 2*nyw-1\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n         do iz = -nz, nz-1\n          dpdx(iz,im,ix,my) = wtmp(iz,im,ix,my)\n         end do\n        end do\n       end do\n      end do\n\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdy(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n        do ix = ist_xw, iend_xw\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n          end do\n        end do\n      end do\n\n!!TBI!! call dfftw_execute_dft_c2r(plan_yb_y2x(ithd), w3, dpdy(0,ist_xw,iz,im))\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, wtmp)\n      do my = 0, 2*nyw-1\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n         do iz = -nz, nz-1\n          dpdy(iz,im,ix,my) = wtmp(iz,im,ix,my)\n         end do\n        end do\n       end do\n      end do\n\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2x ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )!done\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n    complex(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwef\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:nyw) :: w3\n    real(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: my, ix, iy, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdx(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n        end do\n       end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, dhdx)\n\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdy(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n        end do\n       end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, dhdy)\n\n!NEC$ NOINTERCHANGE\n      do iy = 0, 2*nyw-1\n!NEC$ NOINTERCHANGE\n        do ix = ist_xw, iend_xw\n!NEC$ NOINTERCHANGE\n          do im = 0, nm\n!NEC$ NOINTERCHANGE\n            do iz = -nz, nz-1\n              pbxy(iz,im,ix,iy) = cef * ( &! Normalization for 2D Forward FFT\n                         (dpdx(iz,im,ix,iy) - cs1 * vl(iv) * dadx(iz,im,ix,iy)) * dhdy(iz,im,ix,iy) &\n                       - (dpdy(iz,im,ix,iy) - cs1 * vl(iv) * dady(iz,im,ix,iy)) * dhdx(iz,im,ix,iy))\n            end do\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_r2c(planr_yf_y2x(ithd), pbxy, w3)\n\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                wwef(iz,im,ix,my-ist_y_g_rank,irank) = w3(iz,im,ix,my)\n              end do\n            end do\n          end do\n        end do\n      end do\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_x2y ( wwin, wwout )!done\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1440)\n                                        ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                        ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_x2y ( iv, wwef, ef )!done\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n   !complex(kind=DP), intent(inout), &\n   !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n   !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n   !      When the subroutine is called in a OpenMP parallel region, \n   !      the copied subarray may be treated as a thread-private variable.\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1450)\n                                        ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do irank = 0, nprocw-1\n        ist_xw_g_rank  = (nxw_size+1)*irank\n        iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n        do my = ist_y, iend_y\n          do ix = ist_xw_g_rank, iend_xw_g_rank\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w2(iz,im,my,ix) = wwef(iz,im,ix-ist_xw_g_rank,my,irank)\n              enddo\n            end do\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xf_y2x(ithd), w2, w1)\n\n      do my = ist_y, iend_y\n       do ix = 0, nx\n        do im = 0, nm\n          do iz = -nz, nz-1\n            ef(ix,my,iz,iv,im) = w1(iz,im,my,ix)\n          end do\n        end do\n       end do\n      end do\n      do my = ist_y, iend_y\n       do ix = -nx, -1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            ef(ix,my,iz,iv,im) = w1(iz,im,my,2*nxw+ix)\n          end do\n        end do\n       end do\n      end do\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2x ( dpdx, dpdy, dadx, dady )!done\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, iz, iv, im\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      im = 0\n        iv = 2*nv\n!$OMP parallel default(none)                                  &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)           &\n!$OMP shared(im,iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,iz,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n          do iy = 0, 2*nyw-1\n            do ix = ist_xw, iend_xw\n              do iz = -nz, nz-1\n                wv_nl = abs(dpdy(iz,im,ix,iy) - cs1 * vl(iv) * dady(iz,im,ix,iy))\n                if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n          do iy = 0, 2*nyw-1\n            do ix = ist_xw, iend_xw\n              do iz = -nz, nz-1\n                wv_nl = abs(dpdx(iz,im,ix,iy) - cs1 * vl(iv) * dadx(iz,im,ix,iy))\n                if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2x\n\n\nEND MODULE GKV_exb\n", " &cmemo memo=\"GKV-plus f0.61 developed for pre-exa-scale computing\", &end\n &calct calc_type=\"lin_freq\",\n        z_bound=\"outflow\",\n        z_filt=\"off\",\n        z_calc=\"cf4\",\n        art_diff=0.1d0,\n        init_random=.false.,\n        num_triad_diag=0, &end\n &triad mxt = 0, myt = 0/\n &equib equib_type = \"analytic\", &end\n &run_n inum=%%%,\n        ch_res =.false., &end\n &files f_log=\"%%DIR%%/log/gkvp.\",\n        f_hst=\"%%DIR%%/hst/gkvp.\",\n        f_phi=\"%%DIR%%/phi/gkvp.\",\n        f_fxv=\"%%DIR%%/fxv/gkvp.\",\n        f_cnt=\"%%DIR%%/cnt/gkvp.\", &end\n &runlm e_limit = 60.d0, &end\n &times tend = 200.d0,\n        dtout_fxv = 10.d0,\n        dtout_ptn = 0.1d0,\n        dtout_eng = 0.1d0,\n        dtout_dtc = 0.1d0, &end\n &deltt dt_max = 0.01d0,\n        adapt_dt =.true., \n        courant_num = 0.5d0,\n        time_advnc = \"auto_init\", &end\n &physp R0_Ln = 2.22d0,\n        R0_Lt = 6.92d0,\n        nu = 1.d0,\n        Anum = 1.d0,\n        Znum = 1.d0,\n        fcs = 1.d0,\n        sgn = 1.d0,\n        tau = 1.d0,\n        dns1 = 1.d-2,\n        tau_ad = 1.d0,\n        lambda_i = 0.d0,\n        beta = 0.d0,\n        ibprime = 0,\n        vmax = 4.5d0,\n        nx0 = 10000, &end\n &rotat mach = 0.d0,\n        uprime = 0.d0,\n        gamma_e = 0.d0, &end\n &nperi n_tht = 3, \n        kymin = 0.05d0, \n        m_j   = 1, \n        del_c = 0.d0, &end\n &confp eps_r    = 0.18d0,\n        eps_rnew = 1.d0,\n        q_0      = 1.4d0,\n        s_hat    = 0.8d0,\n        lprd     = 0.d0,\n        mprd     = 0.d0,\n        eps_hor  = 0.d0,\n        eps_mor  = 0.d0,\n        eps_por  = 0.d0,\n        rdeps00  = 0.d0,\n        rdeps1_0 = 1.d0,\n        rdeps1_10= 0.d0,\n        rdeps2_10= 0.d0,\n        rdeps3_10= 0.d0,\n        malpha   = 0.d0,    &end\n\n &ring  ring_a = 0.5d0,\n        kxmin  = 0.05d0, &end\n\n &vmecp s_input = 0.5d0,\n          nss = 501,\n          ntheta = 384,      \n          nzeta  = 0,      &end\n &bozxf f_bozx=\"%%DIR%%/vmec/\",  &end\n\n &igsp s_input = 0.5d0,\n          mc_type = 0,\n          q_type = 1,\n          nss = 101,\n          ntheta = 49,      &end\n &igsf f_igs=\"%%DIR%%/eqdsk/\",  &end\n\n &nu_ref Nref = 4.5d19,\n         Lref = 1.7d0,\n         Tref = 2.d0,\n         col_type = \"LB\",\n         iFLR = 1,\n         icheck = 0, &end\n", "### Fujitsu Fortran Compiler ###\nFC = mpifrtpx\nFFLAGS = -Kfast,parallel # Optimization\nFFLAGS += -X9 # Fortran95\nFFLAGS += -Koptmsg=2 -Nlst=t # Optimization report\nFFLAGS += -fw # Suppress message\nFFLAGS += -Kopenmp #-Nfjomplib # OpenMP\nFFLAGS += -mcmodel=large # Static memory larger than 2GB\n#FFLAGS += -Haefosux -NRtrap #-O0 # Debug\nOPTRPT = 'lst'\n#FFLAGS += -Nfjprof # Fujitsu profiler fapp\nFFLAGS += -Ksimd_nouse_multiple_structures # Specific option for compiler tcs1.2.26 to avoid slowing down GKV\nFFLAGS += -Knosch_pre_ra # Specific option for compiler tcs1.2.26 to avoid slowing down GKV\nINC = \nLIB =\n\n\nPROG = 'gkvp.exe'\n\nSRC =../src/\nMYL =../lib/\n\nMATH = gkvp_math_portable\n\nFFT = gkvp_fft_fftw\n### Usage of FFTW (module load fftw-tune)\nifeq ($(FFT),gkvp_fft_fftw)\n  #INC += -I$(FFTW_DIR)/include\n  #LIB += -L$(FFTW_DIR)/lib -lfftw3 -lm\n  LIB += -lfftw3 -lm\nendif\n\nFILEIO=gkvp_fileio_fortran\n#FILEIO=gkvp_fileio_netcdf\n### Usage of NetCDF (module load netcdf-fortran netcdf-c phdf5)\n### NetCDF does not work on the FLOW supercomputer for now, Jan 17 2021\nifeq ($(FILEIO),gkvp_fileio_netcdf)\n  #INC += -I$(NETCDF_FORTRAN_DIR)/include -I$(NETCDF_DIR)/include -I$(PHDF5_DIR)/include\n  #LIB += -L$(NETCDF_FORTRAN_DIR)/lib -L$(NETCDF_DIR)/lib -L$(PHDF5_DIR)/lib -lnetcdff -lnetcdf -lhdf5_hl -lhdf5\n  LIB += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5\nendif\n\n\ngkvp:\t$(SRC)gkvp_header.f90\\\n\t$(SRC)gkvp_mpienv.f90\\\n\t$(MYL)$(MATH).f90\\\n\t$(SRC)gkvp_clock.f90\\\n\t$(SRC)$(FILEIO).f90\\\n\t$(SRC)gkvp_intgrl.f90\\\n\t$(SRC)gkvp_tips.f90\\\n\t$(SRC)gkvp_vmecbzx.f90\\\n\t$(SRC)gkvp_igs.f90\\\n\t$(SRC)gkvp_ring.f90\\\n\t$(SRC)gkvp_bndry.f90\\\n\t$(SRC)gkvp_colli.f90\\\n\t$(SRC)$(FFT).f90\\\n\t$(SRC)gkvp_fld.f90\\\n\t$(SRC)gkvp_colliimp.f90\\\n\t$(SRC)gkvp_freq.f90\\\n\t$(SRC)gkvp_zfilter.f90\\\n\t$(SRC)gkvp_geom.f90\\\n\t$(SRC)gkvp_exb.f90\\\n\t$(SRC)gkvp_trans.f90\\\n\t$(SRC)gkvp_advnc.f90\\\n\t$(SRC)gkvp_shearflow.f90\\\n\t$(SRC)gkvp_dtc.f90\\\n\t$(SRC)gkvp_out.f90\\\n\t$(SRC)gkvp_set.f90\\\n\t$(SRC)gkvp_main.f90\n\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_header.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_mpienv.f90\n\t$(FC) $(FFLAGS) -c $(MYL)$(MATH).f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_clock.f90\n\t$(FC) $(FFLAGS) -c $(SRC)$(FILEIO).f90 $(INC)\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_intgrl.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_tips.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_vmecbzx.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_igs.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_ring.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_bndry.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_colli.f90\n\t$(FC) $(FFLAGS) -c $(SRC)$(FFT).f90 $(INC)\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_fld.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_colliimp.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_freq.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_zfilter.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_geom.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_exb.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_trans.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_advnc.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_shearflow.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_dtc.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_out.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_set.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_main.f90\n\n\t$(FC) $(FFLAGS)\t\\\n\t\t\tgkvp_header.o\\\n\t\t\tgkvp_mpienv.o\\\n\t\t\t$(MATH).o\\\n\t\t\tgkvp_clock.o\\\n\t\t\t$(FILEIO).o\\\n\t\t\tgkvp_intgrl.o\\\n\t\t\tgkvp_tips.o\\\n\t\t\tgkvp_vmecbzx.o\\\n\t\t\tgkvp_igs.o\\\n\t\t\tgkvp_ring.o\\\n\t\t\tgkvp_bndry.o\\\n\t\t\tgkvp_colli.o\\\n\t\t\t$(FFT).o\\\n\t\t\tgkvp_fld.o\\\n\t\t\tgkvp_colliimp.o\\\n\t\t\tgkvp_freq.o\\\n\t\t\tgkvp_zfilter.o\\\n\t\t\tgkvp_geom.o\\\n\t\t\tgkvp_exb.o\\\n\t\t\tgkvp_trans.o\\\n\t\t\tgkvp_advnc.o\\\n\t\t\tgkvp_shearflow.o\\\n\t\t\tgkvp_dtc.o\\\n\t\t\tgkvp_out.o\\\n\t\t\tgkvp_set.o\\\n                        gkvp_main.o\\\n\t\t\t-o $(PROG) $(LIB)\n\n\tcp *.o *.mod *.$(OPTRPT)../src/\n\trm -f *.o *.mod *.$(OPTRPT)\n\nclean:\n\trm -f../src/*.o../src/*.mod../src/*.$(OPTRPT)./*.exe./sub.q.*.o* \\\n\t     ./*.o./*.mod./*.$(OPTRPT)./*namelist.*./sub.q.*\n\nclear:\n\trm -f./*.o./*.mod./*.$(OPTRPT)./*namelist.*./sub.q.*\n \n", "#!/bin/sh\n\n###  NOTE  ###\n###  Flow supercomputer Type I sub-system, PRIMEHPC FX1000 (Nagoya Univ, 2020)\n###\n###  - Computation nodes(total 2304 nodes)\n###      CPU: A64FX (2.0GHz, 12coresx4CMG=48cores, 512bit SIMD) x1 per node\n###      Peak performance: DP 3.379 TFLOPS per node (Boost: 3.3792 TFLOPS)\n###      Cache L1: 64 KiB, 4 way\n###      Cache L1 Bandwidth: 230+ GB/s(load), 115+ GB/s (store)\n###      Cache L2: 8 MiB, 16 way per CMG(NUMA), 4CMG per node\n###      Cache L2 Bandwidth: 3.6+ TB/s per node\n###                          115+ GB/s(load), 57+ GB/s(store) per core\n###      Memory: HBM2 32 GiB\n###      Memory Bandwidth: 1024 GB/s per node\n###\n###      Therefore, a recommended GKV parallelization may be \n###          (MPI Processes)x(12 OpenMP Threads)\n###          =(12 cores per CMG)x(4 CMG)x(Node numbers)\n###      1 MPI process should be assigined to 1 CMG.\n###\n###  - Interconnect\n###      Tofu Interconnect D (28 Gbps x 2 lane x 10 port)\n###      [Performance] 8B Put latency: 0.49-0.54 usec\n###                    1MiB Put throughput: 6.35 GB/s\n###\n###  - Job class (May 2020)\n###      fx-debug  :  1 - 36  nodes,   1 hour,  50 run/300 submit\n###      fx-small  :  1 - 24  nodes, 168 hour, 100 run/300 submit\n###      fx-middle : 12 - 96  nodes,  72 hour,  50 run/300 submit\n###      fx-large  : 96 - 192 nodes,  72 hour,  25 run/300 submit\n###      fx-xlarge : 96 - 768 nodes,  24 hour,   5 run/300 submit\n###\n###  - Commands\n###      (Submit a batch job : \"pjsub sub.q\") Use shoot script for GKV.\n###      Check job status    : \"pjstat\" or \"pjstat -E\" for step jobs\n###      Delete job          : \"pjdel JOBID\"\n###      Show budget info    : \"charge\"\n###      Show disk usage     : \"lfs quota -u (YOUR ACCOUNT ID) /home\"\n###                          : \"lfs quota -u (YOUR ACCOUNT ID) /data\"\n##############\n\n#PJM --rsc-list \"rscgrp=fx-debug\"\n#PJM --rsc-list \"node=8\"       \n#### --rsc-list \"node=5x8x8\"       \n#PJM --rsc-list \"elapse=00:10:00\"\n#PJM --mpi \"proc=32\"           \n#### --mpi \"rank-map-bynode\"\n#### --mpi \"rank-map-hostfile=rankmapfile.dat\"\n#PJM -j                          \n#PJM -s                           \n\nNUM_NODES=${PJM_NODE}             # Nodes\nNUM_CORES=12                      # Cores per node\nNUM_PROCS=$(( ${NUM_NODES} * 4 )) # MPI processes\nexport OMP_NUM_THREADS=12         # OpenMP threads per MPI\n\n\necho \"                  Nodes: ${NUM_NODES}\"\necho \"         Cores per node: ${NUM_CORES}\"\necho \"          MPI Processes: ${NUM_PROCS}\"\necho \" OpenMP threads per MPI: ${OMP_NUM_THREADS}\"\n\n\n\n### Working directory \nDIR=%%DIR%%\nLDM=gkvp.exe\nNL=gkvp_namelist.%%%\n\nexport XOS_MMM_L_PAGING_POLICY=demand:demand:demand # For Largepage\n\nexport PLE_MPI_STD_EMPTYFILE=\"off\" # Suppress stdout of filesize-0\n\nmodule load fftw-tune phdf5 netcdf-c netcdf-fortran\n###module unload tcs\n###module load fftw/3.3.8\n###export PATH=/opt/FJSVxtclanga/tcsds-1.2.25/bin:$PATH\n###export LD_LIBRARY_PATH=/opt/FJSVxtclanga/tcsds-1.2.25/lib64:$LD_LIBRARY_PATH\n###export OPAL_PREFIX=/opt/FJSVxtclanga/tcsds-1.2.25\n\n\n#### Run\ndate\ncd ${DIR}\nexport fu05=${DIR}/${NL}\nmpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n   # -n        \"Total number of MPI processes\"\ndate\n\n\n##### Run with Fujitsu profiler fipp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#fipp -C -d ${DIR}/fjprof_dir/pa0 -Icpupa -Impi -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#date\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -Ceu\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -x\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Icpupa     -p0,limit=4 -o prof_cpupa.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Ibalance   -p0,limit=4 -o prof_balance.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"#fipppx -A -d pa0 -Icall      -p0,limit=4 -o prof_call.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Isrc:./src -p0,limit=4 -o prof_src.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n\n\n##### Run with Fujitsu profiler fapp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#Npa=1  # Elementary report\n##Npa=5  # Simple report\n##Npa=11 # Standard report\n##Npa=17 # Detailed report\n#for i in `seq 1 ${Npa}`; do\n#  echo \"pa\"${i} `date`\n#  fapp -C -d ${DIR}/fjprof_dir/pa${i} -Hevent=pa${i} -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#done\n#date\n#\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#for i in `seq 1 ${Npa}`; do\n#  echo \"fapppx -A -d./pa${i} -Icpupa,mpi -tcsv -o pa${i}.csv\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#done\n#echo \"cp /opt/FJSVxtclanga/tcsds-1.2.25/misc/cpupa/cpu_pa_report.xlsm./\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#\n#\n", "#!/bin/sh\n\n###  NOTE  ###\n###  Flow supercomputer Type I sub-system, PRIMEHPC FX1000 (Nagoya Univ, 2020)\n###\n###  - Computation nodes(total 2304 nodes)\n###      CPU: A64FX (2.0GHz, 12coresx4CMG=48cores, 512bit SIMD) x1 per node\n###      Peak performance: DP 3.379 TFLOPS per node (Boost: 3.3792 TFLOPS)\n###      Cache L1: 64 KiB, 4 way\n###      Cache L1 Bandwidth: 230+ GB/s(load), 115+ GB/s (store)\n###      Cache L2: 8 MiB, 16 way per CMG(NUMA), 4CMG per node\n###      Cache L2 Bandwidth: 3.6+ TB/s per node\n###                          115+ GB/s(load), 57+ GB/s(store) per core\n###      Memory: HBM2 32 GiB\n###      Memory Bandwidth: 1024 GB/s per node\n###\n###      Therefore, a recommended GKV parallelization may be \n###          (MPI Processes)x(12 OpenMP Threads)\n###          =(12 cores per CMG)x(4 CMG)x(Node numbers)\n###      1 MPI process should be assigined to 1 CMG.\n###\n###  - Interconnect\n###      Tofu Interconnect D (28 Gbps x 2 lane x 10 port)\n###      [Performance] 8B Put latency: 0.49-0.54 usec\n###                    1MiB Put throughput: 6.35 GB/s\n###\n###  - Job class (May 2020)\n###      fx-debug  :  1 - 36  nodes,   1 hour,  50 run/300 submit\n###      fx-small  :  1 - 24  nodes, 168 hour, 100 run/300 submit\n###      fx-middle : 12 - 96  nodes,  72 hour,  50 run/300 submit\n###      fx-large  : 96 - 192 nodes,  72 hour,  25 run/300 submit\n###      fx-xlarge : 96 - 768 nodes,  24 hour,   5 run/300 submit\n###\n###  - Commands\n###      (Submit a batch job : \"pjsub sub.q\") Use shoot script for GKV.\n###      Check job status    : \"pjstat\" or \"pjstat -E\" for step jobs\n###      Delete job          : \"pjdel JOBID\"\n###      Show budget info    : \"charge\"\n###      Show disk usage     : \"lfs quota -u (YOUR ACCOUNT ID) /home\"\n###                          : \"lfs quota -u (YOUR ACCOUNT ID) /data\"\n##############\n\n#PJM --rsc-list \"rscgrp=fx-debug\"\n#PJM --rsc-list \"node=8\"       \n#### --rsc-list \"node=5x8x8\"       \n#PJM --rsc-list \"elapse=00:10:00\"\n#PJM --mpi \"proc=32\"           \n#### --mpi \"rank-map-bynode\"\n#### --mpi \"rank-map-hostfile=rankmapfile.dat\"\n#PJM -j                          \n#PJM -s                           \n\nNUM_NODES=${PJM_NODE}             # Nodes\nNUM_CORES=12                      # Cores per node\nNUM_PROCS=$(( ${NUM_NODES} * 4 )) # MPI processes\nexport OMP_NUM_THREADS=12         # OpenMP threads per MPI\n\n\necho \"                  Nodes: ${NUM_NODES}\"\necho \"         Cores per node: ${NUM_CORES}\"\necho \"          MPI Processes: ${NUM_PROCS}\"\necho \" OpenMP threads per MPI: ${OMP_NUM_THREADS}\"\n\n\n\n### Working directory \nDIR=%%DIR%%\nLDM=gkvp.exe\nNL=gkvp_namelist.%%%\n\nexport XOS_MMM_L_PAGING_POLICY=demand:demand:demand # For Largepage\n\nexport PLE_MPI_STD_EMPTYFILE=\"off\" # Suppress stdout of filesize-0\n\nmodule load fftw-tune phdf5 netcdf-c netcdf-fortran\n###module unload tcs\n###module load fftw/3.3.8\n###export PATH=/opt/FJSVxtclanga/tcsds-1.2.25/bin:$PATH\n###export LD_LIBRARY_PATH=/opt/FJSVxtclanga/tcsds-1.2.25/lib64:$LD_LIBRARY_PATH\n###export OPAL_PREFIX=/opt/FJSVxtclanga/tcsds-1.2.25\n\n\n#### Run\ndate\ncd ${DIR}\nexport fu05=${DIR}/${NL}\nmpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n   # -n        \"Total number of MPI processes\"\ndate\n\n\n##### Run with Fujitsu profiler fipp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#fipp -C -d ${DIR}/fjprof_dir/pa0 -Icpupa -Impi -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#date\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -Ceu\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -x\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Icpupa     -p0,limit=4 -o prof_cpupa.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Ibalance   -p0,limit=4 -o prof_balance.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"#fipppx -A -d pa0 -Icall      -p0,limit=4 -o prof_call.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Isrc:./src -p0,limit=4 -o prof_src.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n\n\n##### Run with Fujitsu profiler fapp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#Npa=1  # Elementary report\n##Npa=5  # Simple report\n##Npa=11 # Standard report\n##Npa=17 # Detailed report\n#for i in `seq 1 ${Npa}`; do\n#  echo \"pa\"${i} `date`\n#  fapp -C -d ${DIR}/fjprof_dir/pa${i} -Hevent=pa${i} -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#done\n#date\n#\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#for i in `seq 1 ${Npa}`; do\n#  echo \"fapppx -A -d./pa${i} -Icpupa,mpi -tcsv -o pa${i}.csv\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#done\n#echo \"cp /opt/FJSVxtclanga/tcsds-1.2.25/misc/cpupa/cpu_pa_report.xlsm./\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#\n#\n", "#!/bin/sh\n#\n#  Script for step job submission\n#\n#     HOW TO USE:./shoot [START_NUMBER] [END_NUMBER]\n#\n#     When one wants to continue simulation runs after [JOB-ID],\n#                ./shoot [START_NUMBER] [END_NUMBER] [JOB-ID]\n#\n\nif [ $# -lt 2 ]; then\n  echo \"HOW TO USE:./shoot [START_NUMBER] [END_NUMBER] ([JOB-ID])\"\n  exit\nfi\n\n#### Environment setting\nDIR=/data/group1/z43460z/gkvp/f0.61/ITGae-lin\nLDM=gkvp.exe\nNL=gkvp_namelist\nSC=pjsub\nJS=sub.q\n### For VMEC, set VMCDIR including metric_boozer.bin.dat\n#VMCDIR=./input_vmec/vmec_sample_nss501ntheta1024nzeta0\n### For IGS, set IGSDIR including METRIC_{axi,boz,ham}.OUT\n#IGSDIR=../../input_eqdsk_for_eqdskbench/\n\n\n\n#### Create directories\nDIR=`echo ${DIR} | sed -e's/\\/$//'`\nmkdir -p ${DIR}/\nmkdir -p ${DIR}/log/\nmkdir -p ${DIR}/hst/\nmkdir -p ${DIR}/phi/\nmkdir -p ${DIR}/fxv/\nmkdir -p ${DIR}/cnt/\nif [! -e \"${LDM}\" ]; then\n  echo \"No EXE file!\"; exit\nfi\ncp./${LDM} ${DIR}\ncp./Makefile ${DIR}\ncp -r../src ${DIR}\ncp -r../lib ${DIR}\nif [! -z \"${VMCDIR}\" ]; then #$VMCDIR is neither undefined nor null.\n  mkdir -p ${DIR}/vmec/\n  cp ${VMCDIR}/* ${DIR}/vmec/\nfi\nif [! -z \"${IGSDIR}\" ]; then #$IGSDIR is neither undefined nor null.\n  mkdir -p ${DIR}/eqdsk/\n  cp ${IGSDIR}/METRIC*.OUT ${DIR}/eqdsk/\nfi\n\n\n\n#### Submit jobs\ni=$1\niend=$2\nj=$3\nwhile [ $i -le $iend ]\ndo\n\n  date\n\n  ## Creating a procedure file\n  ia=`echo $i | awk '{printf (\"%03d\",$1)}'`\n  fln_JS=`echo $JS\\.$ia`\n  fln_NL=`echo $NL\\.$ia`\n  cat ${JS} | sed -e \"s/%%%/$ia/\" | sed -e \"s|%%DIR%%|${DIR}|\" > ${fln_JS}\n  cat ${NL} | sed -e \"s/%%%/$ia/\" | sed -e \"s|%%DIR%%|${DIR}|\" > ${fln_NL}\n  chmod u+x ${fln_JS}\n  cp./${fln_NL} ${DIR}\n  cp./${fln_JS} ${DIR}\n\n  ## Submitting a job\n  #echo \"*** submit job ${fln_JS} ***\"\n  #${SC} ${fln_JS}\n  if [ -z \"$j\"  -a  $i -eq $1 ]; then\n    echo \"*** submit first step job ${fln_JS} ***\"\n    ${SC} --step --sparam \"sn=$i\" ${fln_JS} | tee shoottempfile\n    j=`awk '{sub(\"_.*\",\"\"); print $6}' shoottempfile`\n    rm shoottempfile\n  else\n    echo \"*** submit sequential step job ${fln_JS} ***\"\n    ${SC} --step --sparam \"jid=$j,sd=ec!=0:all\" ${fln_JS}\n  fi\n\n  sleep 1\n  i=$(( $i + 1 ))\n\ndone\n", "        j0zeros(1) = 2.404825557695770666e+00\n        j0zeros(2) = 5.520078110286304351e+00\n        j0zeros(3) = 8.653727912911024944e+00\n        j0zeros(4) = 1.179153443901426179e+01\n        j0zeros(5) = 1.493091770848781330e+01\n        j0zeros(6) = 1.807106396791089153e+01\n        j0zeros(7) = 2.121163662987926912e+01\n        j0zeros(8) = 2.435247153074934090e+01\n        j0zeros(9) = 2.749347913204029226e+01\n        j0zeros(10) = 3.063460646843199697e+01\n        j0zeros(11) = 3.377582021357356723e+01\n        j0zeros(12) = 3.691709835366403070e+01\n        j0zeros(13) = 4.005842576462820404e+01\n        j0zeros(14) = 4.319979171317667976e+01\n        j0zeros(15) = 4.634118837166175098e+01\n        j0zeros(16) = 4.948260989739775084e+01\n        j0zeros(17) = 5.262405184111491963e+01\n        j0zeros(18) = 5.576551075501990340e+01\n        j0zeros(19) = 5.890698392608085499e+01\n        j0zeros(20) = 6.204846919022708818e+01\n        j0zeros(21) = 6.518996480020678064e+01\n        j0zeros(22) = 6.833146932985670219e+01\n        j0zeros(23) = 7.147298160359363806e+01\n        j0zeros(24) = 7.461450064370174573e+01\n        j0zeros(25) = 7.775602563038796688e+01\n        j0zeros(26) = 8.089755587113752711e+01\n        j0zeros(27) = 8.403909077693809593e+01\n        j0zeros(28) = 8.718062984364107137e+01\n        j0zeros(29) = 9.032217263721040013e+01\n        j0zeros(30) = 9.346371878194467797e+01\n        j0zeros(31) = 9.660526795099617914e+01\n        j0zeros(32) = 9.974681985868051015e+01\n        j0zeros(33) = 1.028883742541947157e+02\n        j0zeros(34) = 1.060299309164515336e+02\n        j0zeros(35) = 1.091714896498053093e+02\n        j0zeros(36) = 1.123130502804948350e+02\n        j0zeros(37) = 1.154546126536668709e+02\n        j0zeros(38) = 1.185961766308724492e+02\n        j0zeros(39) = 1.217377420879508918e+02\n        j0zeros(40) = 1.248793089132328760e+02\n        j0zeros(41) = 1.280208770060082486e+02\n        j0zeros(42) = 1.311624462752138527e+02\n        j0zeros(43) = 1.343040166383053986e+02\n        j0zeros(44) = 1.374455880202841911e+02\n        j0zeros(45) = 1.405871603528542266e+02\n        j0zeros(46) = 1.437287335736896523e+02\n        j0zeros(47) = 1.468703076257965847e+02\n        j0zeros(48) = 1.500118824569546803e+02\n        j0zeros(49) = 1.531534580192278270e+02\n        j0zeros(50) = 1.562950342685334704e+02\n        j0zeros(51) = 1.594366111642630699e+02\n        j0zeros(52) = 1.625781886689466091e+02\n        j0zeros(53) = 1.657197667479549636e+02\n        j0zeros(54) = 1.688613453692357496e+02\n        j0zeros(55) = 1.720029245030781624e+02\n        j0zeros(56) = 1.751445041219026848e+02\n        j0zeros(57) = 1.782860842000737023e+02\n        j0zeros(58) = 1.814276647137309908e+02\n        j0zeros(59) = 1.845692456406386555e+02\n        j0zeros(60) = 1.877108269600493031e+02\n        j0zeros(61) = 1.908524086525814596e+02\n        j0zeros(62) = 1.939939907001090660e+02\n        j0zeros(63) = 1.971355730856613775e+02\n        j0zeros(64) = 2.002771557933323550e+02\n        j0zeros(65) = 2.034187388081985830e+02\n        j0zeros(66) = 2.065603221162444356e+02\n        j0zeros(67) = 2.097019057042940346e+02\n        j0zeros(68) = 2.128434895599494041e+02\n        j0zeros(69) = 2.159850736715339679e+02\n        j0zeros(70) = 2.191266580280405094e+02\n        j0zeros(71) = 2.222682426190842762e+02\n        j0zeros(72) = 2.254098274348592952e+02\n        j0zeros(73) = 2.285514124660987534e+02\n        j0zeros(74) = 2.316929977040385040e+02\n        j0zeros(75) = 2.348345831403831880e+02\n        j0zeros(76) = 2.379761687672755954e+02\n        j0zeros(77) = 2.411177545772679878e+02\n        j0zeros(78) = 2.442593405632956376e+02\n        j0zeros(79) = 2.474009267186527836e+02\n        j0zeros(80) = 2.505425130369699218e+02\n        j0zeros(81) = 2.536840995121930291e+02\n        j0zeros(82) = 2.568256861385643788e+02\n        j0zeros(83) = 2.599672729106044358e+02\n        j0zeros(84) = 2.631088598230954290e+02\n        j0zeros(85) = 2.662504468710658330e+02\n        j0zeros(86) = 2.693920340497760435e+02\n        j0zeros(87) = 2.725336213547049056e+02\n        j0zeros(88) = 2.756752087815374352e+02\n        j0zeros(89) = 2.788167963261530531e+02\n        j0zeros(90) = 2.819583839846148408e+02\n        j0zeros(91) = 2.850999717531595365e+02\n        j0zeros(92) = 2.882415596281876446e+02\n        j0zeros(93) = 2.913831476062551928e+02\n        j0zeros(94) = 2.945247356840649218e+02\n        j0zeros(95) = 2.976663238584588953e+02\n        j0zeros(96) = 3.008079121264110540e+02\n        j0zeros(97) = 3.039495004850205646e+02\n        j0zeros(98) = 3.070910889315049985e+02\n        j0zeros(99) = 3.102326774631949320e+02\n        j0zeros(100) = 3.133742660775278068e+02\n        j0zeros(101) = 3.165158547720428714e+02\n        j0zeros(102) = 3.196574435443761217e+02\n        j0zeros(103) = 3.227990323922555262e+02\n        j0zeros(104) = 3.259406213134966492e+02\n        j0zeros(105) = 3.290822103059985011e+02\n        j0zeros(106) = 3.322237993677395593e+02\n        j0zeros(107) = 3.353653884967741305e+02\n        j0zeros(108) = 3.385069776912284851e+02\n        j0zeros(109) = 3.416485669492980151e+02\n        j0zeros(110) = 3.447901562692439370e+02\n        j0zeros(111) = 3.479317456493901659e+02\n        j0zeros(112) = 3.510733350881205297e+02\n        j0zeros(113) = 3.542149245838763818e+02\n        j0zeros(114) = 3.573565141351537022e+02\n        j0zeros(115) = 3.604981037405010511e+02\n        j0zeros(116) = 3.636396933985170108e+02\n        j0zeros(117) = 3.667812831078482532e+02\n        j0zeros(118) = 3.699228728671874364e+02\n        j0zeros(119) = 3.730644626752712156e+02\n        j0zeros(120) = 3.762060525308784236e+02\n        j0zeros(121) = 3.793476424328284224e+02\n        j0zeros(122) = 3.824892323799792848e+02\n        j0zeros(123) = 3.856308223712263725e+02\n        j0zeros(124) = 3.887724124055006314e+02\n        j0zeros(125) = 3.919140024817673407e+02\n        j0zeros(126) = 3.950555925990248056e+02\n        j0zeros(127) = 3.981971827563027659e+02\n        j0zeros(128) = 4.013387729526614862e+02\n        j0zeros(129) = 4.044803631871903917e+02\n        j0zeros(130) = 4.076219534590068179e+02\n        j0zeros(131) = 4.107635437672553280e+02\n        j0zeros(132) = 4.139051341111062925e+02\n        j0zeros(133) = 4.170467244897552064e+02\n        j0zeros(134) = 4.201883149024216095e+02\n        j0zeros(135) = 4.233299053483480634e+02\n        j0zeros(136) = 4.264714958267995826e+02\n        j0zeros(137) = 4.296130863370626685e+02\n        j0zeros(138) = 4.327546768784445135e+02\n        j0zeros(139) = 4.358962674502723189e+02\n        j0zeros(140) = 4.390378580518924423e+02\n        j0zeros(141) = 4.421794486826699426e+02\n        j0zeros(142) = 4.453210393419876709e+02\n        j0zeros(143) = 4.484626300292459291e+02\n        j0zeros(144) = 4.516042207438616174e+02\n        j0zeros(145) = 4.547458114852677227e+02\n        j0zeros(146) = 4.578874022529127501e+02\n        j0zeros(147) = 4.610289930462603820e+02\n        j0zeros(148) = 4.641705838647887390e+02\n        j0zeros(149) = 4.673121747079899251e+02\n        j0zeros(150) = 4.704537655753698004e+02\n        j0zeros(151) = 4.735953564664470719e+02\n        j0zeros(152) = 4.767369473807532927e+02\n        j0zeros(153) = 4.798785383178322945e+02\n        j0zeros(154) = 4.830201292772396755e+02\n        j0zeros(155) = 4.861617202585426298e+02\n        j0zeros(156) = 4.893033112613193794e+02\n        j0zeros(157) = 4.924449022851589461e+02\n        j0zeros(158) = 4.955864933296608115e+02\n        j0zeros(159) = 4.987280843944345179e+02\n        j0zeros(160) = 5.018696754790993282e+02\n        j0zeros(161) = 5.050112665832840548e+02\n        j0zeros(162) = 5.081528577066266621e+02\n        j0zeros(163) = 5.112944488487739818e+02\n        j0zeros(164) = 5.144360400093815997e+02\n        j0zeros(165) = 5.175776311881131733e+02\n        j0zeros(166) = 5.207192223846409433e+02\n        j0zeros(167) = 5.238608135986445404e+02\n        j0zeros(168) = 5.270024048298114394e+02\n        j0zeros(169) = 5.301439960778367322e+02\n        j0zeros(170) = 5.332855873424221045e+02\n        j0zeros(171) = 5.364271786232769728e+02\n        j0zeros(172) = 5.395687699201168925e+02\n        j0zeros(173) = 5.427103612326643542e+02\n        j0zeros(174) = 5.458519525606483285e+02\n        j0zeros(175) = 5.489935439038034701e+02\n        j0zeros(176) = 5.521351352618711417e+02\n        j0zeros(177) = 5.552767266345980488e+02\n        j0zeros(178) = 5.584183180217368090e+02\n        j0zeros(179) = 5.615599094230457240e+02\n        j0zeros(180) = 5.647015008382879842e+02\n        j0zeros(181) = 5.678430922672324641e+02\n        j0zeros(182) = 5.709846837096530408e+02\n        j0zeros(183) = 5.741262751653284795e+02\n        j0zeros(184) = 5.772678666340423206e+02\n        j0zeros(185) = 5.804094581155829928e+02\n        j0zeros(186) = 5.835510496097431314e+02\n        j0zeros(187) = 5.866926411163201465e+02\n        j0zeros(188) = 5.898342326351156544e+02\n        j0zeros(189) = 5.929758241659353644e+02\n        j0zeros(190) = 5.961174157085893057e+02\n        j0zeros(191) = 5.992590072628911457e+02\n        j0zeros(192) = 6.024005988286587581e+02\n        j0zeros(193) = 6.055421904057137681e+02\n        j0zeros(194) = 6.086837819938813254e+02\n        j0zeros(195) = 6.118253735929902177e+02\n        j0zeros(196) = 6.149669652028728706e+02\n        j0zeros(197) = 6.181085568233648928e+02\n        j0zeros(198) = 6.212501484543054175e+02\n        j0zeros(199) = 6.243917400955366475e+02\n        j0zeros(200) = 6.275333317469040821e+02\n        j0zeros(201) = 6.306749234082564044e+02\n        j0zeros(202) = 6.338165150794449119e+02\n        j0zeros(203) = 6.369581067603240854e+02\n        j0zeros(204) = 6.400996984507512479e+02\n        j0zeros(205) = 6.432412901505866785e+02\n        j0zeros(206) = 6.463828818596929295e+02\n        j0zeros(207) = 6.495244735779357370e+02\n        j0zeros(208) = 6.526660653051829968e+02\n        j0zeros(209) = 6.558076570413053332e+02\n        j0zeros(210) = 6.589492487861758718e+02\n        j0zeros(211) = 6.620908405396701255e+02\n        j0zeros(212) = 6.652324323016656535e+02\n        j0zeros(213) = 6.683740240720428574e+02\n        j0zeros(214) = 6.715156158506839574e+02\n        j0zeros(215) = 6.746572076374735616e+02\n        j0zeros(216) = 6.777987994322983241e+02\n        j0zeros(217) = 6.809403912350471728e+02\n        j0zeros(218) = 6.840819830456107411e+02\n        j0zeros(219) = 6.872235748638820496e+02\n        j0zeros(220) = 6.903651666897555970e+02\n        j0zeros(221) = 6.935067585231283829e+02\n        j0zeros(222) = 6.966483503638988850e+02\n        j0zeros(223) = 6.997899422119672863e+02\n        j0zeros(224) = 7.029315340672358161e+02\n        j0zeros(225) = 7.060731259296085227e+02\n        j0zeros(226) = 7.092147177989907050e+02\n        j0zeros(227) = 7.123563096752899355e+02\n        j0zeros(228) = 7.154979015584149238e+02\n        j0zeros(229) = 7.186394934482760846e+02\n        j0zeros(230) = 7.217810853447856516e+02\n        j0zeros(231) = 7.249226772478571093e+02\n        j0zeros(232) = 7.280642691574055334e+02\n        j0zeros(233) = 7.312058610733474779e+02\n        j0zeros(234) = 7.343474529956007473e+02\n        j0zeros(235) = 7.374890449240847374e+02\n        j0zeros(236) = 7.406306368587202087e+02\n        j0zeros(237) = 7.437722287994291719e+02\n        j0zeros(238) = 7.469138207461351158e+02\n        j0zeros(239) = 7.500554126987624386e+02\n        j0zeros(240) = 7.531970046572372439e+02\n        j0zeros(241) = 7.563385966214865448e+02\n        j0zeros(242) = 7.594801885914388322e+02\n        j0zeros(243) = 7.626217805670236203e+02\n        j0zeros(244) = 7.657633725481714464e+02\n        j0zeros(245) = 7.689049645348140984e+02\n        j0zeros(246) = 7.720465565268846149e+02\n        j0zeros(247) = 7.751881485243169436e+02\n        j0zeros(248) = 7.783297405270462832e+02\n        j0zeros(249) = 7.814713325350085142e+02\n        j0zeros(250) = 7.846129245481409953e+02\n        j0zeros(251) = 7.877545165663817670e+02\n        j0zeros(252) = 7.908961085896700069e+02\n        j0zeros(253) = 7.940377006179458022e+02\n        j0zeros(254) = 7.971792926511502628e+02\n        j0zeros(255) = 8.003208846892251813e+02\n        j0zeros(256) = 8.034624767321133731e+02\n        j0zeros(257) = 8.066040687797589044e+02\n        j0zeros(258) = 8.097456608321060685e+02\n        j0zeros(259) = 8.128872528891005231e+02\n        j0zeros(260) = 8.160288449506886082e+02\n        j0zeros(261) = 8.191704370168174592e+02\n        j0zeros(262) = 8.223120290874350076e+02\n        j0zeros(263) = 8.254536211624899806e+02\n        j0zeros(264) = 8.285952132419319014e+02\n        j0zeros(265) = 8.317368053257113161e+02\n        j0zeros(266) = 8.348783974137787709e+02\n        j0zeros(267) = 8.380199895060864037e+02\n        j0zeros(268) = 8.411615816025866934e+02\n        j0zeros(269) = 8.443031737032325736e+02\n        j0zeros(270) = 8.474447658079782286e+02\n        j0zeros(271) = 8.505863579167780699e+02\n        j0zeros(272) = 8.537279500295875323e+02\n        j0zeros(273) = 8.568695421463621642e+02\n        j0zeros(274) = 8.600111342670588783e+02\n        j0zeros(275) = 8.631527263916348147e+02\n        j0zeros(276) = 8.662943185200474545e+02\n        j0zeros(277) = 8.694359106522554157e+02\n        j0zeros(278) = 8.725775027882176573e+02\n        j0zeros(279) = 8.757190949278939343e+02\n        j0zeros(280) = 8.788606870712442287e+02\n        j0zeros(281) = 8.820022792182293188e+02\n        j0zeros(282) = 8.851438713688105508e+02\n        j0zeros(283) = 8.882854635229497262e+02\n        j0zeros(284) = 8.914270556806092145e+02\n        j0zeros(285) = 8.945686478417520675e+02\n        j0zeros(286) = 8.977102400063416781e+02\n        j0zeros(287) = 9.008518321743417800e+02\n        j0zeros(288) = 9.039934243457169032e+02\n        j0zeros(289) = 9.071350165204321456e+02\n        j0zeros(290) = 9.102766086984527192e+02\n        j0zeros(291) = 9.134182008797447452e+02\n        j0zeros(292) = 9.165597930642743449e+02\n        j0zeros(293) = 9.197013852520084356e+02\n        j0zeros(294) = 9.228429774429143890e+02\n        j0zeros(295) = 9.259845696369598045e+02\n        j0zeros(296) = 9.291261618341128496e+02\n        j0zeros(297) = 9.322677540343421470e+02\n        j0zeros(298) = 9.354093462376166599e+02\n        j0zeros(299) = 9.385509384439058067e+02\n        j0zeros(300) = 9.416925306531794604e+02\n        j0zeros(301) = 9.448341228654078350e+02\n        j0zeros(302) = 9.479757150805615993e+02\n        j0zeros(303) = 9.511173072986116495e+02\n        j0zeros(304) = 9.542588995195294501e+02\n        j0zeros(305) = 9.574004917432866932e+02\n        j0zeros(306) = 9.605420839698557529e+02\n        j0zeros(307) = 9.636836761992090032e+02\n        j0zeros(308) = 9.668252684313190457e+02\n        j0zeros(309) = 9.699668606661595049e+02\n        j0zeros(310) = 9.731084529037035509e+02\n        j0zeros(311) = 9.762500451439253766e+02\n        j0zeros(312) = 9.793916373867991751e+02\n        j0zeros(313) = 9.825332296322993670e+02\n        j0zeros(314) = 9.856748218804009412e+02\n        j0zeros(315) = 9.888164141310791138e+02\n        j0zeros(316) = 9.919580063843093285e+02\n        j0zeros(317) = 9.950995986400674838e+02\n        j0zeros(318) = 9.982411908983298190e+02\n        j0zeros(319) = 1.001382783159072574e+03\n        j0zeros(320) = 1.004524375422272442e+03\n        j0zeros(321) = 1.007665967687906573e+03\n        j0zeros(322) = 1.010807559955952229e+03\n        j0zeros(323) = 1.013949152226387014e+03\n        j0zeros(324) = 1.017090744499188759e+03\n        j0zeros(325) = 1.020232336774335636e+03\n        j0zeros(326) = 1.023373929051805931e+03\n        j0zeros(327) = 1.026515521331578611e+03\n        j0zeros(328) = 1.029657113613632191e+03\n        j0zeros(329) = 1.032798705897946093e+03\n        j0zeros(330) = 1.035940298184499852e+03\n        j0zeros(331) = 1.039081890473272779e+03\n        j0zeros(332) = 1.042223482764245318e+03\n        j0zeros(333) = 1.045365075057397235e+03\n        j0zeros(334) = 1.048506667352709201e+03\n        j0zeros(335) = 1.051648259650161890e+03\n        j0zeros(336) = 1.054789851949735521e+03\n        j0zeros(337) = 1.057931444251412131e+03\n        j0zeros(338) = 1.061073036555172166e+03\n        j0zeros(339) = 1.064214628860998118e+03\n        j0zeros(340) = 1.067356221168870889e+03\n        j0zeros(341) = 1.070497813478772969e+03\n        j0zeros(342) = 1.073639405790686169e+03\n        j0zeros(343) = 1.076780998104593436e+03\n        j0zeros(344) = 1.079922590420476581e+03\n        j0zeros(345) = 1.083064182738319460e+03\n        j0zeros(346) = 1.086205775058104109e+03\n", "        j0zeros(347) = 1.089347367379814159e+03\n        j0zeros(348) = 1.092488959703433011e+03\n        j0zeros(349) = 1.095630552028943839e+03\n        j0zeros(350) = 1.098772144356331182e+03\n        j0zeros(351) = 1.101913736685578215e+03\n        j0zeros(352) = 1.105055329016669475e+03\n        j0zeros(353) = 1.108196921349589275e+03\n        j0zeros(354) = 1.111338513684322152e+03\n        j0zeros(355) = 1.114480106020852645e+03\n        j0zeros(356) = 1.117621698359165293e+03\n        j0zeros(357) = 1.120763290699245772e+03\n        j0zeros(358) = 1.123904883041078847e+03\n        j0zeros(359) = 1.127046475384649966e+03\n        j0zeros(360) = 1.130188067729944351e+03\n        j0zeros(361) = 1.133329660076948358e+03\n        j0zeros(362) = 1.136471252425646981e+03\n        j0zeros(363) = 1.139612844776026805e+03\n        j0zeros(364) = 1.142754437128073732e+03\n        j0zeros(365) = 1.145896029481774121e+03\n        j0zeros(366) = 1.149037621837114330e+03\n        j0zeros(367) = 1.152179214194080942e+03\n        j0zeros(368) = 1.155320806552660770e+03\n        j0zeros(369) = 1.158462398912840627e+03\n        j0zeros(370) = 1.161603991274607552e+03\n        j0zeros(371) = 1.164745583637948585e+03\n        j0zeros(372) = 1.167887176002851447e+03\n        j0zeros(373) = 1.171028768369302952e+03\n        j0zeros(374) = 1.174170360737291276e+03\n        j0zeros(375) = 1.177311953106803458e+03\n        j0zeros(376) = 1.180453545477828129e+03\n        j0zeros(377) = 1.183595137850352558e+03\n        j0zeros(378) = 1.186736730224365147e+03\n        j0zeros(379) = 1.189878322599854073e+03\n        j0zeros(380) = 1.193019914976807513e+03\n        j0zeros(381) = 1.196161507355214098e+03\n        j0zeros(382) = 1.199303099735062233e+03\n        j0zeros(383) = 1.202444692116341230e+03\n        j0zeros(384) = 1.205586284499039039e+03\n        j0zeros(385) = 1.208727876883145200e+03\n        j0zeros(386) = 1.211869469268648345e+03\n        j0zeros(387) = 1.215011061655538015e+03\n        j0zeros(388) = 1.218152654043803295e+03\n        j0zeros(389) = 1.221294246433433500e+03\n        j0zeros(390) = 1.224435838824418397e+03\n        j0zeros(391) = 1.227577431216747073e+03\n        j0zeros(392) = 1.230719023610409749e+03\n        j0zeros(393) = 1.233860616005395968e+03\n        j0zeros(394) = 1.237002208401695952e+03\n        j0zeros(395) = 1.240143800799299242e+03\n        j0zeros(396) = 1.243285393198196289e+03\n        j0zeros(397) = 1.246426985598377314e+03\n        j0zeros(398) = 1.249568577999832542e+03\n        j0zeros(399) = 1.252710170402552421e+03\n        j0zeros(400) = 1.255851762806527177e+03\n        j0zeros(401) = 1.258993355211747939e+03\n        j0zeros(402) = 1.262134947618204933e+03\n        j0zeros(403) = 1.265276540025889517e+03\n        j0zeros(404) = 1.268418132434791687e+03\n        j0zeros(405) = 1.271559724844903258e+03\n        j0zeros(406) = 1.274701317256214907e+03\n        j0zeros(407) = 1.277842909668717994e+03\n        j0zeros(408) = 1.280984502082403196e+03\n        j0zeros(409) = 1.284126094497262557e+03\n        j0zeros(410) = 1.287267686913287207e+03\n        j0zeros(411) = 1.290409279330468507e+03\n        j0zeros(412) = 1.293550871748798045e+03\n        j0zeros(413) = 1.296692464168267634e+03\n        j0zeros(414) = 1.299834056588868862e+03\n        j0zeros(415) = 1.302975649010593543e+03\n        j0zeros(416) = 1.306117241433433946e+03\n        j0zeros(417) = 1.309258833857381205e+03\n        j0zeros(418) = 1.312400426282428270e+03\n        j0zeros(419) = 1.315542018708566957e+03\n        j0zeros(420) = 1.318683611135789079e+03\n        j0zeros(421) = 1.321825203564087587e+03\n        j0zeros(422) = 1.324966795993454070e+03\n        j0zeros(423) = 1.328108388423881479e+03\n        j0zeros(424) = 1.331249980855362082e+03\n        j0zeros(425) = 1.334391573287888832e+03\n        j0zeros(426) = 1.337533165721453543e+03\n        j0zeros(427) = 1.340674758156049847e+03\n        j0zeros(428) = 1.343816350591669789e+03\n        j0zeros(429) = 1.346957943028306772e+03\n        j0zeros(430) = 1.350099535465953522e+03\n        j0zeros(431) = 1.353241127904602536e+03\n        j0zeros(432) = 1.356382720344247446e+03\n        j0zeros(433) = 1.359524312784880976e+03\n        j0zeros(434) = 1.362665905226496534e+03\n        j0zeros(435) = 1.365807497669087070e+03\n        j0zeros(436) = 1.368949090112646445e+03\n        j0zeros(437) = 1.372090682557167156e+03\n        j0zeros(438) = 1.375232275002643291e+03\n        j0zeros(439) = 1.378373867449068030e+03\n        j0zeros(440) = 1.381515459896435232e+03\n        j0zeros(441) = 1.384657052344738076e+03\n        j0zeros(442) = 1.387798644793969970e+03\n        j0zeros(443) = 1.390940237244125456e+03\n        j0zeros(444) = 1.394081829695197484e+03\n        j0zeros(445) = 1.397223422147180599e+03\n        j0zeros(446) = 1.400365014600067980e+03\n        j0zeros(447) = 1.403506607053853941e+03\n        j0zeros(448) = 1.406648199508532343e+03\n        j0zeros(449) = 1.409789791964097276e+03\n        j0zeros(450) = 1.412931384420542827e+03\n        j0zeros(451) = 1.416072976877863084e+03\n        j0zeros(452) = 1.419214569336052591e+03\n        j0zeros(453) = 1.422356161795104754e+03\n        j0zeros(454) = 1.425497754255014797e+03\n        j0zeros(455) = 1.428639346715776355e+03\n        j0zeros(456) = 1.431780939177384198e+03\n        j0zeros(457) = 1.434922531639832641e+03\n        j0zeros(458) = 1.438064124103116455e+03\n        j0zeros(459) = 1.441205716567229501e+03\n        j0zeros(460) = 1.444347309032167232e+03\n        j0zeros(461) = 1.447488901497923507e+03\n        j0zeros(462) = 1.450630493964493780e+03\n        j0zeros(463) = 1.453772086431872140e+03\n        j0zeros(464) = 1.456913678900053355e+03\n        j0zeros(465) = 1.460055271369032880e+03\n        j0zeros(466) = 1.463196863838804802e+03\n        j0zeros(467) = 1.466338456309364574e+03\n        j0zeros(468) = 1.469480048780706511e+03\n        j0zeros(469) = 1.472621641252826521e+03\n        j0zeros(470) = 1.475763233725718919e+03\n        j0zeros(471) = 1.478904826199379158e+03\n        j0zeros(472) = 1.482046418673802009e+03\n        j0zeros(473) = 1.485188011148983151e+03\n        j0zeros(474) = 1.488329603624917354e+03\n        j0zeros(475) = 1.491471196101599844e+03\n        j0zeros(476) = 1.494612788579026301e+03\n        j0zeros(477) = 1.497754381057191495e+03\n        j0zeros(478) = 1.500895973536091105e+03\n        j0zeros(479) = 1.504037566015720586e+03\n        j0zeros(480) = 1.507179158496075161e+03\n        j0zeros(481) = 1.510320750977150510e+03\n        j0zeros(482) = 1.513462343458942087e+03\n        j0zeros(483) = 1.516603935941445570e+03\n        j0zeros(484) = 1.519745528424655959e+03\n        j0zeros(485) = 1.522887120908569614e+03\n        j0zeros(486) = 1.526028713393181761e+03\n        j0zeros(487) = 1.529170305878488307e+03\n        j0zeros(488) = 1.532311898364484705e+03\n        j0zeros(489) = 1.535453490851167089e+03\n        j0zeros(490) = 1.538595083338530912e+03\n        j0zeros(491) = 1.541736675826572537e+03\n        j0zeros(492) = 1.544878268315286959e+03\n        j0zeros(493) = 1.548019860804670998e+03\n        j0zeros(494) = 1.551161453294720104e+03\n        j0zeros(495) = 1.554303045785430186e+03\n        j0zeros(496) = 1.557444638276797377e+03\n        j0zeros(497) = 1.560586230768817813e+03\n        j0zeros(498) = 1.563727823261487401e+03\n        j0zeros(499) = 1.566869415754802048e+03\n        j0zeros(500) = 1.570011008248758571e+03\n        j0zeros(501) = 1.573152600743352195e+03\n        j0zeros(502) = 1.576294193238579965e+03\n        j0zeros(503) = 1.579435785734437331e+03\n        j0zeros(504) = 1.582577378230921340e+03\n        j0zeros(505) = 1.585718970728027671e+03\n        j0zeros(506) = 1.588860563225752912e+03\n        j0zeros(507) = 1.592002155724093200e+03\n        j0zeros(508) = 1.595143748223044895e+03\n        j0zeros(509) = 1.598285340722604815e+03\n        j0zeros(510) = 1.601426933222768639e+03\n        j0zeros(511) = 1.604568525723533639e+03\n        j0zeros(512) = 1.607710118224895723e+03\n        j0zeros(513) = 1.610851710726851707e+03\n        j0zeros(514) = 1.613993303229397725e+03\n        j0zeros(515) = 1.617134895732531049e+03\n        j0zeros(516) = 1.620276488236247587e+03\n        j0zeros(517) = 1.623418080740543928e+03\n        j0zeros(518) = 1.626559673245417343e+03\n        j0zeros(519) = 1.629701265750863968e+03\n        j0zeros(520) = 1.632842858256880618e+03\n        j0zeros(521) = 1.635984450763464110e+03\n        j0zeros(522) = 1.639126043270611035e+03\n        j0zeros(523) = 1.642267635778318208e+03\n        j0zeros(524) = 1.645409228286582675e+03\n        j0zeros(525) = 1.648550820795400796e+03\n        j0zeros(526) = 1.651692413304769616e+03\n        j0zeros(527) = 1.654834005814686407e+03\n        j0zeros(528) = 1.657975598325147303e+03\n        j0zeros(529) = 1.661117190836149575e+03\n        j0zeros(530) = 1.664258783347690269e+03\n        j0zeros(531) = 1.667400375859766427e+03\n        j0zeros(532) = 1.670541968372374413e+03\n        j0zeros(533) = 1.673683560885511952e+03\n        j0zeros(534) = 1.676825153399175633e+03\n        j0zeros(535) = 1.679966745913362956e+03\n        j0zeros(536) = 1.683108338428070283e+03\n        j0zeros(537) = 1.686249930943295340e+03\n        j0zeros(538) = 1.689391523459034943e+03\n        j0zeros(539) = 1.692533115975286364e+03\n        j0zeros(540) = 1.695674708492046648e+03\n        j0zeros(541) = 1.698816301009312838e+03\n        j0zeros(542) = 1.701957893527082433e+03\n        j0zeros(543) = 1.705099486045352478e+03\n        j0zeros(544) = 1.708241078564120244e+03\n        j0zeros(545) = 1.711382671083383002e+03\n        j0zeros(546) = 1.714524263603138024e+03\n        j0zeros(547) = 1.717665856123382810e+03\n        j0zeros(548) = 1.720807448644114174e+03\n        j0zeros(549) = 1.723949041165330073e+03\n        j0zeros(550) = 1.727090633687027321e+03\n        j0zeros(551) = 1.730232226209203645e+03\n        j0zeros(552) = 1.733373818731856090e+03\n        j0zeros(553) = 1.736515411254982610e+03\n        j0zeros(554) = 1.739657003778580020e+03\n        j0zeros(555) = 1.742798596302646274e+03\n        j0zeros(556) = 1.745940188827178417e+03\n        j0zeros(557) = 1.749081781352174630e+03\n        j0zeros(558) = 1.752223373877631730e+03\n        j0zeros(559) = 1.755364966403547214e+03\n        j0zeros(560) = 1.758506558929919265e+03\n        j0zeros(561) = 1.761648151456744927e+03\n        j0zeros(562) = 1.764789743984021925e+03\n        j0zeros(563) = 1.767931336511747531e+03\n        j0zeros(564) = 1.771072929039920155e+03\n        j0zeros(565) = 1.774214521568536611e+03\n        j0zeros(566) = 1.777356114097594855e+03\n        j0zeros(567) = 1.780497706627092612e+03\n        j0zeros(568) = 1.783639299157027608e+03\n        j0zeros(569) = 1.786780891687397570e+03\n        j0zeros(570) = 1.789922484218199770e+03\n        j0zeros(571) = 1.793064076749432388e+03\n        j0zeros(572) = 1.796205669281092923e+03\n        j0zeros(573) = 1.799347261813179330e+03\n        j0zeros(574) = 1.802488854345689106e+03\n        j0zeros(575) = 1.805630446878620432e+03\n        j0zeros(576) = 1.808772039411970582e+03\n        j0zeros(577) = 1.811913631945737961e+03\n        j0zeros(578) = 1.815055224479919843e+03\n        j0zeros(579) = 1.818196817014514863e+03\n        j0zeros(580) = 1.821338409549520065e+03\n        j0zeros(581) = 1.824480002084933631e+03\n        j0zeros(582) = 1.827621594620753740e+03\n        j0zeros(583) = 1.830763187156977665e+03\n        j0zeros(584) = 1.833904779693603814e+03\n        j0zeros(585) = 1.837046372230629913e+03\n        j0zeros(586) = 1.840187964768054371e+03\n        j0zeros(587) = 1.843329557305874459e+03\n        j0zeros(588) = 1.846471149844088586e+03\n        j0zeros(589) = 1.849612742382694705e+03\n        j0zeros(590) = 1.852754334921690770e+03\n        j0zeros(591) = 1.855895927461074734e+03\n        j0zeros(592) = 1.859037520000844779e+03\n        j0zeros(593) = 1.862179112540998858e+03\n        j0zeros(594) = 1.865320705081534697e+03\n        j0zeros(595) = 1.868462297622451160e+03\n        j0zeros(596) = 1.871603890163745518e+03\n        j0zeros(597) = 1.874745482705416634e+03\n        j0zeros(598) = 1.877887075247461780e+03\n        j0zeros(599) = 1.881028667789879819e+03\n        j0zeros(600) = 1.884170260332668477e+03\n        j0zeros(601) = 1.887311852875826162e+03\n        j0zeros(602) = 1.890453445419350828e+03\n        j0zeros(603) = 1.893595037963240429e+03\n        j0zeros(604) = 1.896736630507493828e+03\n        j0zeros(605) = 1.899878223052108524e+03\n        j0zeros(606) = 1.903019815597083152e+03\n        j0zeros(607) = 1.906161408142415667e+03\n        j0zeros(608) = 1.909303000688104703e+03\n        j0zeros(609) = 1.912444593234147760e+03\n        j0zeros(610) = 1.915586185780544156e+03\n        j0zeros(611) = 1.918727778327291389e+03\n        j0zeros(612) = 1.921869370874387641e+03\n        j0zeros(613) = 1.925010963421831775e+03\n        j0zeros(614) = 1.928152555969621517e+03\n        j0zeros(615) = 1.931294148517755957e+03\n        j0zeros(616) = 1.934435741066232367e+03\n        j0zeros(617) = 1.937577333615050065e+03\n        j0zeros(618) = 1.940718926164206550e+03\n        j0zeros(619) = 1.943860518713701140e+03\n        j0zeros(620) = 1.947002111263531106e+03\n        j0zeros(621) = 1.950143703813695765e+03\n        j0zeros(622) = 1.953285296364193073e+03\n        j0zeros(623) = 1.956426888915021209e+03\n        j0zeros(624) = 1.959568481466179264e+03\n        j0zeros(625) = 1.962710074017664738e+03\n        j0zeros(626) = 1.965851666569476947e+03\n        j0zeros(627) = 1.968993259121613619e+03\n        j0zeros(628) = 1.972134851674073843e+03\n        j0zeros(629) = 1.975276444226855347e+03\n        j0zeros(630) = 1.978418036779957447e+03\n        j0zeros(631) = 1.981559629333377870e+03\n        j0zeros(632) = 1.984701221887115480e+03\n        j0zeros(633) = 1.987842814441168912e+03\n        j0zeros(634) = 1.990984406995536119e+03\n        j0zeros(635) = 1.994125999550216193e+03\n        j0zeros(636) = 1.997267592105207314e+03\n        j0zeros(637) = 2.000409184660508345e+03\n        j0zeros(638) = 2.003550777216117240e+03\n        j0zeros(639) = 2.006692369772033317e+03\n        j0zeros(640) = 2.009833962328254302e+03\n        j0zeros(641) = 2.012975554884779740e+03\n        j0zeros(642) = 2.016117147441607131e+03\n        j0zeros(643) = 2.019258739998736019e+03\n        j0zeros(644) = 2.022400332556164585e+03\n        j0zeros(645) = 2.025541925113891239e+03\n        j0zeros(646) = 2.028683517671914842e+03\n        j0zeros(647) = 2.031825110230233804e+03\n        j0zeros(648) = 2.034966702788847215e+03\n        j0zeros(649) = 2.038108295347753256e+03\n        j0zeros(650) = 2.041249887906951017e+03\n        j0zeros(651) = 2.044391480466438452e+03\n        j0zeros(652) = 2.047533073026215106e+03\n        j0zeros(653) = 2.050674665586278934e+03\n        j0zeros(654) = 2.053816258146629025e+03\n        j0zeros(655) = 2.056957850707263333e+03\n        j0zeros(656) = 2.060099443268182313e+03\n        j0zeros(657) = 2.063241035829382781e+03\n        j0zeros(658) = 2.066382628390863829e+03\n        j0zeros(659) = 2.069524220952625001e+03\n        j0zeros(660) = 2.072665813514664478e+03\n        j0zeros(661) = 2.075807406076980897e+03\n        j0zeros(662) = 2.078948998639573347e+03\n        j0zeros(663) = 2.082090591202440464e+03\n        j0zeros(664) = 2.085232183765580885e+03\n        j0zeros(665) = 2.088373776328993245e+03\n        j0zeros(666) = 2.091515368892676634e+03\n        j0zeros(667) = 2.094656961456630142e+03\n        j0zeros(668) = 2.097798554020851498e+03\n        j0zeros(669) = 2.100940146585340244e+03\n        j0zeros(670) = 2.104081739150095018e+03\n        j0zeros(671) = 2.107223331715115364e+03\n        j0zeros(672) = 2.110364924280398554e+03\n        j0zeros(673) = 2.113506516845944589e+03\n        j0zeros(674) = 2.116648109411752102e+03\n        j0zeros(675) = 2.119789701977819732e+03\n        j0zeros(676) = 2.122931294544146112e+03\n        j0zeros(677) = 2.126072887110730790e+03\n        j0zeros(678) = 2.129214479677572399e+03\n        j0zeros(679) = 2.132356072244669122e+03\n        j0zeros(680) = 2.135497664812020048e+03\n        j0zeros(681) = 2.138639257379624723e+03\n        j0zeros(682) = 2.141780849947482238e+03\n        j0zeros(683) = 2.144922442515590319e+03\n        j0zeros(684) = 2.148064035083948056e+03\n        j0zeros(685) = 2.151205627652554995e+03\n        j0zeros(686) = 2.154347220221410225e+03\n        j0zeros(687) = 2.157488812790511929e+03\n        j0zeros(688) = 2.160630405359859196e+03\n        j0zeros(689) = 2.163771997929451572e+03\n        j0zeros(690) = 2.166913590499287238e+03\n        j0zeros(691) = 2.170055183069364830e+03\n", "        j0zeros(692) = 2.173196775639684347e+03\n        j0zeros(693) = 2.176338368210244880e+03\n        j0zeros(694) = 2.179479960781043701e+03\n        j0zeros(695) = 2.182621553352081264e+03\n        j0zeros(696) = 2.185763145923356205e+03\n        j0zeros(697) = 2.188904738494867615e+03\n        j0zeros(698) = 2.192046331066614130e+03\n        j0zeros(699) = 2.195187923638594839e+03\n        j0zeros(700) = 2.198329516210808833e+03\n        j0zeros(701) = 2.201471108783255204e+03\n        j0zeros(702) = 2.204612701355932586e+03\n        j0zeros(703) = 2.207754293928840070e+03\n        j0zeros(704) = 2.210895886501977657e+03\n        j0zeros(705) = 2.214037479075343072e+03\n        j0zeros(706) = 2.217179071648935405e+03\n        j0zeros(707) = 2.220320664222755113e+03\n        j0zeros(708) = 2.223462256796799466e+03\n        j0zeros(709) = 2.226603849371068463e+03\n        j0zeros(710) = 2.229745441945560742e+03\n        j0zeros(711) = 2.232887034520276302e+03\n        j0zeros(712) = 2.236028627095212869e+03\n        j0zeros(713) = 2.239170219670369988e+03\n        j0zeros(714) = 2.242311812245747205e+03\n        j0zeros(715) = 2.245453404821343611e+03\n        j0zeros(716) = 2.248594997397157385e+03\n        j0zeros(717) = 2.251736589973188075e+03\n        j0zeros(718) = 2.254878182549435678e+03\n        j0zeros(719) = 2.258019775125897922e+03\n        j0zeros(720) = 2.261161367702574353e+03\n        j0zeros(721) = 2.264302960279464514e+03\n        j0zeros(722) = 2.267444552856567498e+03\n        j0zeros(723) = 2.270586145433881484e+03\n        j0zeros(724) = 2.273727738011406473e+03\n        j0zeros(725) = 2.276869330589141555e+03\n        j0zeros(726) = 2.280010923167085821e+03\n        j0zeros(727) = 2.283152515745237906e+03\n        j0zeros(728) = 2.286294108323597357e+03\n        j0zeros(729) = 2.289435700902163262e+03\n        j0zeros(730) = 2.292577293480935168e+03\n        j0zeros(731) = 2.295718886059911256e+03\n        j0zeros(732) = 2.298860478639091525e+03\n        j0zeros(733) = 2.302002071218475066e+03\n        j0zeros(734) = 2.305143663798060516e+03\n        j0zeros(735) = 2.308285256377847418e+03\n        j0zeros(736) = 2.311426848957835318e+03\n        j0zeros(737) = 2.314568441538022853e+03\n        j0zeros(738) = 2.317710034118409567e+03\n        j0zeros(739) = 2.320851626698994096e+03\n        j0zeros(740) = 2.323993219279776440e+03\n        j0zeros(741) = 2.327134811860754780e+03\n        j0zeros(742) = 2.330276404441929117e+03\n        j0zeros(743) = 2.333417997023298540e+03\n        j0zeros(744) = 2.336559589604862140e+03\n        j0zeros(745) = 2.339701182186619462e+03\n        j0zeros(746) = 2.342842774768568688e+03\n        j0zeros(747) = 2.345984367350710272e+03\n        j0zeros(748) = 2.349125959933043305e+03\n        j0zeros(749) = 2.352267552515565967e+03\n        j0zeros(750) = 2.355409145098278714e+03\n        j0zeros(751) = 2.358550737681180181e+03\n        j0zeros(752) = 2.361692330264269458e+03\n        j0zeros(753) = 2.364833922847546091e+03\n        j0zeros(754) = 2.367975515431009626e+03\n        j0zeros(755) = 2.371117108014659152e+03\n        j0zeros(756) = 2.374258700598493306e+03\n        j0zeros(757) = 2.377400293182511632e+03\n        j0zeros(758) = 2.380541885766713676e+03\n        j0zeros(759) = 2.383683478351098984e+03\n        j0zeros(760) = 2.386825070935666190e+03\n        j0zeros(761) = 2.389966663520414841e+03\n        j0zeros(762) = 2.393108256105344935e+03\n        j0zeros(763) = 2.396249848690454201e+03\n        j0zeros(764) = 2.399391441275743091e+03\n        j0zeros(765) = 2.402533033861210242e+03\n        j0zeros(766) = 2.405674626446856109e+03\n        j0zeros(767) = 2.408816219032678418e+03\n        j0zeros(768) = 2.411957811618677624e+03\n        j0zeros(769) = 2.415099404204852362e+03\n        j0zeros(770) = 2.418240996791203088e+03\n        j0zeros(771) = 2.421382589377727527e+03\n        j0zeros(772) = 2.424524181964426134e+03\n        j0zeros(773) = 2.427665774551298000e+03\n        j0zeros(774) = 2.430807367138341760e+03\n        j0zeros(775) = 2.433948959725557415e+03\n        j0zeros(776) = 2.437090552312944510e+03\n        j0zeros(777) = 2.440232144900502135e+03\n        j0zeros(778) = 2.443373737488229381e+03\n        j0zeros(779) = 2.446515330076125338e+03\n        j0zeros(780) = 2.449656922664190006e+03\n        j0zeros(781) = 2.452798515252423385e+03\n        j0zeros(782) = 2.455940107840823202e+03\n        j0zeros(783) = 2.459081700429389457e+03\n        j0zeros(784) = 2.462223293018122149e+03\n        j0zeros(785) = 2.465364885607019914e+03\n        j0zeros(786) = 2.468506478196081844e+03\n        j0zeros(787) = 2.471648070785308391e+03\n        j0zeros(788) = 2.474789663374698193e+03\n        j0zeros(789) = 2.477931255964250795e+03\n        j0zeros(790) = 2.481072848553965741e+03\n        j0zeros(791) = 2.484214441143841668e+03\n        j0zeros(792) = 2.487356033733879485e+03\n        j0zeros(793) = 2.490497626324076919e+03\n        j0zeros(794) = 2.493639218914433968e+03\n        j0zeros(795) = 2.496780811504951089e+03\n        j0zeros(796) = 2.499922404095625552e+03\n        j0zeros(797) = 2.503063996686458722e+03\n        j0zeros(798) = 2.506205589277448780e+03\n        j0zeros(799) = 2.509347181868596181e+03\n        j0zeros(800) = 2.512488774459899105e+03\n        j0zeros(801) = 2.515630367051357553e+03\n        j0zeros(802) = 2.518771959642971069e+03\n        j0zeros(803) = 2.521913552234739655e+03\n        j0zeros(804) = 2.525055144826661490e+03\n        j0zeros(805) = 2.528196737418736575e+03\n        j0zeros(806) = 2.531338330010964910e+03\n        j0zeros(807) = 2.534479922603344676e+03\n        j0zeros(808) = 2.537621515195876327e+03\n        j0zeros(809) = 2.540763107788558500e+03\n        j0zeros(810) = 2.543904700381392104e+03\n        j0zeros(811) = 2.547046292974374865e+03\n        j0zeros(812) = 2.550187885567506783e+03\n        j0zeros(813) = 2.553329478160787858e+03\n        j0zeros(814) = 2.556471070754217180e+03\n        j0zeros(815) = 2.559612663347793841e+03\n        j0zeros(816) = 2.562754255941517840e+03\n        j0zeros(817) = 2.565895848535388723e+03\n        j0zeros(818) = 2.569037441129405579e+03\n        j0zeros(819) = 2.572179033723567500e+03\n        j0zeros(820) = 2.575320626317874485e+03\n        j0zeros(821) = 2.578462218912326534e+03\n        j0zeros(822) = 2.581603811506921829e+03\n        j0zeros(823) = 2.584745404101660824e+03\n        j0zeros(824) = 2.587886996696542610e+03\n        j0zeros(825) = 2.591028589291567187e+03\n        j0zeros(826) = 2.594170181886733189e+03\n        j0zeros(827) = 2.597311774482040619e+03\n        j0zeros(828) = 2.600453367077489020e+03\n        j0zeros(829) = 2.603594959673077483e+03\n        j0zeros(830) = 2.606736552268805553e+03\n        j0zeros(831) = 2.609878144864673231e+03\n        j0zeros(832) = 2.613019737460680062e+03\n        j0zeros(833) = 2.616161330056824681e+03\n        j0zeros(834) = 2.619302922653107089e+03\n        j0zeros(835) = 2.622444515249527285e+03\n        j0zeros(836) = 2.625586107846083905e+03\n        j0zeros(837) = 2.628727700442776495e+03\n        j0zeros(838) = 2.631869293039605509e+03\n        j0zeros(839) = 2.635010885636569583e+03\n        j0zeros(840) = 2.638152478233668717e+03\n        j0zeros(841) = 2.641294070830902001e+03\n        j0zeros(842) = 2.644435663428268981e+03\n        j0zeros(843) = 2.647577256025770112e+03\n        j0zeros(844) = 2.650718848623403574e+03\n        j0zeros(845) = 2.653860441221169822e+03\n        j0zeros(846) = 2.657002033819068401e+03\n        j0zeros(847) = 2.660143626417097948e+03\n        j0zeros(848) = 2.663285219015258463e+03\n        j0zeros(849) = 2.666426811613549944e+03\n        j0zeros(850) = 2.669568404211971938e+03\n        j0zeros(851) = 2.672709996810523080e+03\n        j0zeros(852) = 2.675851589409203370e+03\n        j0zeros(853) = 2.678993182008012354e+03\n        j0zeros(854) = 2.682134774606950486e+03\n        j0zeros(855) = 2.685276367206015948e+03\n        j0zeros(856) = 2.688417959805208739e+03\n        j0zeros(857) = 2.691559552404528858e+03\n        j0zeros(858) = 2.694701145003974943e+03\n        j0zeros(859) = 2.697842737603547448e+03\n        j0zeros(860) = 2.700984330203245463e+03\n        j0zeros(861) = 2.704125922803069443e+03\n        j0zeros(862) = 2.707267515403017114e+03\n        j0zeros(863) = 2.710409108003089841e+03\n        j0zeros(864) = 2.713550700603286259e+03\n        j0zeros(865) = 2.716692293203606368e+03\n        j0zeros(866) = 2.719833885804049260e+03\n        j0zeros(867) = 2.722975478404614933e+03\n        j0zeros(868) = 2.726117071005302932e+03\n        j0zeros(869) = 2.729258663606112350e+03\n        j0zeros(870) = 2.732400256207043185e+03\n        j0zeros(871) = 2.735541848808095438e+03\n        j0zeros(872) = 2.738683441409268198e+03\n        j0zeros(873) = 2.741825034010560557e+03\n        j0zeros(874) = 2.744966626611972970e+03\n        j0zeros(875) = 2.748108219213504071e+03\n        j0zeros(876) = 2.751249811815155226e+03\n        j0zeros(877) = 2.754391404416924161e+03\n        j0zeros(878) = 2.757532997018810875e+03\n        j0zeros(879) = 2.760674589620815823e+03\n        j0zeros(880) = 2.763816182222938096e+03\n        j0zeros(881) = 2.766957774825176784e+03\n        j0zeros(882) = 2.770099367427531888e+03\n        j0zeros(883) = 2.773240960030003862e+03\n        j0zeros(884) = 2.776382552632590887e+03\n        j0zeros(885) = 2.779524145235292963e+03\n        j0zeros(886) = 2.782665737838110090e+03\n        j0zeros(887) = 2.785807330441042268e+03\n        j0zeros(888) = 2.788948923044088133e+03\n        j0zeros(889) = 2.792090515647247685e+03\n        j0zeros(890) = 2.795232108250520923e+03\n        j0zeros(891) = 2.798373700853906939e+03\n        j0zeros(892) = 2.801515293457405733e+03\n        j0zeros(893) = 2.804656886061016394e+03\n        j0zeros(894) = 2.807798478664739378e+03\n        j0zeros(895) = 2.810940071268573320e+03\n        j0zeros(896) = 2.814081663872518675e+03\n        j0zeros(897) = 2.817223256476574534e+03\n        j0zeros(898) = 2.820364849080740896e+03\n        j0zeros(899) = 2.823506441685017307e+03\n        j0zeros(900) = 2.826648034289402858e+03\n        j0zeros(901) = 2.829789626893898458e+03\n        j0zeros(902) = 2.832931219498502287e+03\n        j0zeros(903) = 2.836072812103214801e+03\n        j0zeros(904) = 2.839214404708035545e+03\n        j0zeros(905) = 2.842355997312964519e+03\n        j0zeros(906) = 2.845497589918000358e+03\n        j0zeros(907) = 2.848639182523143063e+03\n        j0zeros(908) = 2.851780775128393088e+03\n        j0zeros(909) = 2.854922367733749525e+03\n        j0zeros(910) = 2.858063960339211462e+03\n        j0zeros(911) = 2.861205552944779356e+03\n        j0zeros(912) = 2.864347145550453206e+03\n        j0zeros(913) = 2.867488738156231193e+03\n        j0zeros(914) = 2.870630330762114227e+03\n        j0zeros(915) = 2.873771923368101398e+03\n        j0zeros(916) = 2.876913515974192705e+03\n        j0zeros(917) = 2.880055108580387241e+03\n        j0zeros(918) = 2.883196701186685459e+03\n        j0zeros(919) = 2.886338293793086450e+03\n        j0zeros(920) = 2.889479886399590214e+03\n        j0zeros(921) = 2.892621479006196296e+03\n        j0zeros(922) = 2.895763071612903786e+03\n        j0zeros(923) = 2.898904664219713595e+03\n        j0zeros(924) = 2.902046256826624358e+03\n        j0zeros(925) = 2.905187849433636075e+03\n        j0zeros(926) = 2.908329442040748290e+03\n        j0zeros(927) = 2.911471034647961460e+03\n        j0zeros(928) = 2.914612627255273765e+03\n        j0zeros(929) = 2.917754219862686114e+03\n        j0zeros(930) = 2.920895812470197598e+03\n        j0zeros(931) = 2.924037405077808671e+03\n        j0zeros(932) = 2.927178997685517970e+03\n        j0zeros(933) = 2.930320590293325495e+03\n        j0zeros(934) = 2.933462182901231699e+03\n        j0zeros(935) = 2.936603775509234765e+03\n        j0zeros(936) = 2.939745368117335602e+03\n        j0zeros(937) = 2.942886960725533754e+03\n        j0zeros(938) = 2.946028553333828768e+03\n        j0zeros(939) = 2.949170145942220188e+03\n        j0zeros(940) = 2.952311738550707560e+03\n        j0zeros(941) = 2.955453331159290883e+03\n        j0zeros(942) = 2.958594923767970613e+03\n        j0zeros(943) = 2.961736516376744476e+03\n        j0zeros(944) = 2.964878108985613835e+03\n        j0zeros(945) = 2.968019701594578237e+03\n        j0zeros(946) = 2.971161294203636317e+03\n        j0zeros(947) = 2.974302886812788529e+03\n        j0zeros(948) = 2.977444479422034874e+03\n        j0zeros(949) = 2.980586072031374897e+03\n        j0zeros(950) = 2.983727664640807689e+03\n        j0zeros(951) = 2.986869257250333249e+03\n        j0zeros(952) = 2.990010849859951122e+03\n        j0zeros(953) = 2.993152442469662219e+03\n        j0zeros(954) = 2.996294035079464720e+03\n        j0zeros(955) = 2.999435627689359080e+03\n        j0zeros(956) = 3.002577220299345299e+03\n        j0zeros(957) = 3.005718812909422013e+03\n        j0zeros(958) = 3.008860405519589676e+03\n        j0zeros(959) = 3.012001998129847834e+03\n        j0zeros(960) = 3.015143590740196942e+03\n        j0zeros(961) = 3.018285183350635634e+03\n        j0zeros(962) = 3.021426775961163912e+03\n        j0zeros(963) = 3.024568368571782230e+03\n        j0zeros(964) = 3.027709961182489224e+03\n        j0zeros(965) = 3.030851553793284893e+03\n        j0zeros(966) = 3.033993146404169693e+03\n        j0zeros(967) = 3.037134739015142713e+03\n        j0zeros(968) = 3.040276331626203955e+03\n        j0zeros(969) = 3.043417924237352508e+03\n        j0zeros(970) = 3.046559516848588828e+03\n        j0zeros(971) = 3.049701109459912914e+03\n        j0zeros(972) = 3.052842702071323401e+03\n        j0zeros(973) = 3.055984294682820291e+03\n        j0zeros(974) = 3.059125887294404492e+03\n        j0zeros(975) = 3.062267479906074186e+03\n        j0zeros(976) = 3.065409072517830282e+03\n        j0zeros(977) = 3.068550665129671415e+03\n        j0zeros(978) = 3.071692257741598951e+03\n        j0zeros(979) = 3.074833850353611069e+03\n        j0zeros(980) = 3.077975442965707771e+03\n        j0zeros(981) = 3.081117035577889055e+03\n        j0zeros(982) = 3.084258628190155378e+03\n        j0zeros(983) = 3.087400220802505373e+03\n        j0zeros(984) = 3.090541813414939043e+03\n        j0zeros(985) = 3.093683406027456840e+03\n        j0zeros(986) = 3.096824998640057402e+03\n        j0zeros(987) = 3.099966591252741182e+03\n        j0zeros(988) = 3.103108183865507726e+03\n        j0zeros(989) = 3.106249776478357489e+03\n        j0zeros(990) = 3.109391369091289107e+03\n        j0zeros(991) = 3.112532961704302579e+03\n        j0zeros(992) = 3.115674554317397906e+03\n        j0zeros(993) = 3.118816146930575542e+03\n        j0zeros(994) = 3.121957739543833668e+03\n        j0zeros(995) = 3.125099332157173194e+03\n        j0zeros(996) = 3.128240924770593665e+03\n        j0zeros(997) = 3.131382517384094626e+03\n        j0zeros(998) = 3.134524109997675623e+03\n        j0zeros(999) = 3.137665702611337110e+03\n        j0zeros(1000) = 3.140807295225078633e+03\n        j0zeros(1001) = 3.143948887838899282e+03\n        j0zeros(1002) = 3.147090480452799511e+03\n        j0zeros(1003) = 3.150232073066778867e+03\n        j0zeros(1004) = 3.153373665680837803e+03\n        j0zeros(1005) = 3.156515258294974956e+03\n        j0zeros(1006) = 3.159656850909190325e+03\n        j0zeros(1007) = 3.162798443523484366e+03\n        j0zeros(1008) = 3.165940036137856168e+03\n        j0zeros(1009) = 3.169081628752305278e+03\n        j0zeros(1010) = 3.172223221366832604e+03\n        j0zeros(1011) = 3.175364813981437237e+03\n        j0zeros(1012) = 3.178506406596118268e+03\n        j0zeros(1013) = 3.181647999210876606e+03\n        j0zeros(1014) = 3.184789591825711341e+03\n        j0zeros(1015) = 3.187931184440622928e+03\n        j0zeros(1016) = 3.191072777055610004e+03\n        j0zeros(1017) = 3.194214369670673477e+03\n        j0zeros(1018) = 3.197355962285812893e+03\n        j0zeros(1019) = 3.200497554901026888e+03\n        j0zeros(1020) = 3.203639147516316825e+03\n        j0zeros(1021) = 3.206780740131681341e+03\n        j0zeros(1022) = 3.209922332747121345e+03\n        j0zeros(1023) = 3.213063925362635473e+03\n        j0zeros(1024) = 3.216205517978224179e+03\n        j0zeros(1025) = 3.219347110593887010e+03\n        j0zeros(1026) = 3.222488703209623964e+03\n        j0zeros(1027) = 3.225630295825434132e+03\n        j0zeros(1028) = 3.228771888441318424e+03\n        j0zeros(1029) = 3.231913481057275931e+03\n        j0zeros(1030) = 3.235055073673306197e+03\n        j0zeros(1031) = 3.238196666289409222e+03\n", "MODULE GKV_math\n!\n!  Mathematical functions using MATRIX/MPP library\n!\n!  This routine uses the unit number of 99 which \n!    should not be overlapped with others\n!\n!  T.-H. Watanabe (Feb 2011)\n!                 (May 2011) with new functions, \n!                            J1 and zero points of J0\n!\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random\n\n  integer, parameter :: DP = selected_real_kind(14)\n  integer, parameter :: ifnc = 99! unit number preserved \n                                 ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n\n    real(kind=DP) :: mdmj0m\n     \n      j0 = mdmj0m( x )\n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1 .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n\n    real(kind=DP) :: mdmj1m\n     \n      j1 = mdmj1m( x )\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n\n    real(kind=DP) :: mdmj0m\n    real(kind=DP) :: mdmj1m\n     \n      j0 = mdmj0m( x )\n      j1 = mdmj1m( x )\n\n      if (x /= 0._DP) then\n        j2 = 2._DP*mdmj1m(x)/x - mdmj0m(x)\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n\n    real(kind=DP) :: mdminm\n\n      if( 0._DP <= x .and.  x < 150._DP ) then\n        i0 = mdminm( 0, x )\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n\n    real(kind=DP), intent(inout), dimension(:) :: rr\n\n    integer(kind=8), save :: iseed \n    integer :: nr, ierr\n\n    data iseed / 211501 /\n\n      nr = size(rr)\n\n      call hdru3m( nr, iseed, rr, ierr )\n\n    return\n\n  END SUBROUTINE math_random\n\n\nEND MODULE GKV_math\n", "MODULE GKV_math\n!-------------------------------------------------------------------------------\n!\n!    Mathematical functions\n!\n!    Update history of gkvp_set.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Elliptic integrals math_eli1, math_eli2 are added.\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - random_seed is added for reproducibility.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random, &\n           math_eli1, math_eli2\n\n\n  integer, parameter :: ifnc = 99 ! unit number preserved \n                                  ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n!\n      j0 = dbesj0(x)\n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1  .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n!\n      j1 = dbesj1(x)\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     2nd-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n!\n      if (x /= 0._DP ) then \n        j2 = 2._DP*dbesj1(x)/x - dbesj0(x)\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n!\n      if( 0._DP <= x  .and.  x < 150._DP ) then\n        i0 = dbesi0(x)\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n  SUBROUTINE math_eli1( x, eli1 )\n!\n!     Complete elliptic integral of the first kind K\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: eli1\n!\n    real(kind=DP) :: sqrtx\n!\n      sqrtx = sqrt(x)\n      if( 0._DP <= sqrtx  .and.  sqrtx < 1._DP ) then\n        eli1 = ellipk(sqrtx)\n      else\n        print *, \"### math_eli1:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_eli1\n\n  SUBROUTINE math_eli2( x, eli2 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: eli2\n!\n    real(kind=DP) :: sqrtx\n!\n      sqrtx = sqrt(x)\n      if( 0._DP <= sqrtx  .and.  sqrtx < 1._DP ) then\n        eli2 = ellipe(sqrtx)\n      else\n        print *, \"### math_eli2:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_eli2\n\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n!\n    real(kind=DP), intent(inout), dimension(:) :: rr\n    integer :: n\n    integer, allocatable :: iseed(:)\n     call random_seed(size=n)\n     allocate(iseed(n))\n     iseed(:) = 211501\n     call random_seed(put=iseed)\n     deallocate(iseed)\n!\n      call random_number(rr)\n!\n    return\n\n  END SUBROUTINE math_random\n\n\n!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!%%%                                                                         %%%\n!%%%  Ooura's Bessel Functions Library                                       %%%\n!%%%                                                                         %%%\n!%%%    http://www.kurims.kyoto-u.ac.jp/~ooura/bessel.html                   %%%\n!%%%                                                                         %%%\n!%%%    Copyright(C) 1996 Takuya OOURA (email: ooura@mmm.t.u-tokyo.ac.jp).   %%%\n!%%%    You may use, copy, modify this code for any purpose and              %%%\n!%%%    without fee. You may distribute this ORIGINAL package.               %%%\n!%%%                                                                         %%%\n!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n! Bessel J_0(x) function in double precision\n!\n      function dbesj0(x)\n      !implicit integer (i - n)\n      !implicit real*8 (a - h, o - z)\n      !dimension a(0 : 7), b(0 : 64), c(0 : 69), d(0 : 51)\n      !parameter (pi4 = 0.78539816339744830962d0)\n      implicit none\n      real(kind=8), parameter :: pi4 = 0.78539816339744830962d0\n      real(kind=8) :: a(0:7), b(0:64), c(0:69), d(0:51)\n      real(kind=8) :: t, v, w, x, y, theta, dbesj0\n      integer :: i, k\n      data (a(i), i = 0, 7) /                                     &\n          -0.0000000000023655394d0, 0.0000000004708898680d0,      &\n          -0.0000000678167892231d0, 0.0000067816840038636d0,      &\n          -0.0004340277777716935d0, 0.0156249999999992397d0,      &\n          -0.2499999999999999638d0, 0.9999999999999999997d0 / \n      data (b(i), i = 0, 12) /                                    &\n          0.0000000000626681117d0, -0.0000000022270614428d0,      &\n          0.0000000662981656302d0, -0.0000016268486502196d0,      &\n          0.0000321978384111685d0, -0.0005005237733315830d0,      &\n          0.0059060313537449816d0, -0.0505265323740109701d0,      &\n          0.2936432097610503985d0, -1.0482565081091638637d0,      &\n          1.9181123286040428113d0, -1.1319199475221700100d0,      &\n          -0.1965480952704682000d0 / \n      data (b(i), i = 13, 25) /                                   &\n          0.0000000000457457332d0, -0.0000000015814772025d0,      &\n          0.0000000455487446311d0, -0.0000010735201286233d0,      &\n          0.0000202015179970014d0, -0.0002942392368203808d0,      &\n          0.0031801987726150648d0, -0.0239875209742846362d0,      &\n          0.1141447698973777641d0, -0.2766726722823530233d0,      &\n          0.1088620480970941648d0, 0.5136514645381999197d0,       &\n          -0.2100594022073706033d0 / \n      data (b(i), i = 26, 38) /                                   &\n          0.0000000000331366618d0, -0.0000000011119090229d0,      &\n          0.0000000308823040363d0, -0.0000006956602653104d0,      &\n          0.0000123499947481762d0, -0.0001662951945396180d0,      &\n          0.0016048663165678412d0, -0.0100785479932760966d0,      &\n          0.0328996815223415274d0, -0.0056168761733860688d0,      &\n          -0.2341096400274429386d0, 0.2551729256776404262d0,      &\n          0.2288438186148935667d0 / \n      data (b(i), i = 39, 51) /                                   &\n          0.0000000000238007203d0, -0.0000000007731046439d0,      &\n          0.0000000206237001152d0, -0.0000004412291442285d0,      &\n          0.0000073107766249655d0, -0.0000891749801028666d0,      &\n          0.0007341654513841350d0, -0.0033303085445352071d0,      &\n          0.0015425853045205717d0, 0.0521100583113136379d0,       &\n          -0.1334447768979217815d0, -0.1401330292364750968d0,     &\n          0.2685616168804818919d0 / \n      data (b(i), i = 52, 64) /                                   &\n          0.0000000000169355950d0, -0.0000000005308092192d0,      &\n          0.0000000135323005576d0, -0.0000002726650587978d0,      &\n          0.0000041513240141760d0, -0.0000443353052220157d0,      &\n          0.0002815740758993879d0, -0.0004393235121629007d0,      &\n          -0.0067573531105799347d0, 0.0369141914660130814d0,      &\n          0.0081673361942996237d0, -0.2573381285898881860d0,      &\n          0.0459580257102978932d0 / \n      data (c(i), i = 0, 13) /                                    &\n          -0.00000000003009451757d0, -0.00000000014958003844d0,   & \n          0.00000000506854544776d0, 0.00000001863564222012d0,     &\n          -0.00000060304249068078d0, -0.00000147686259937403d0,   & \n          0.00004714331342682714d0, 0.00006286305481740818d0,     &\n          -0.00214137170594124344d0, -0.00089157336676889788d0,   &\n          0.04508258728666024989d0, -0.00490362805828762224d0,    &\n          -0.27312196367405374426d0, 0.04193925184293450356d0 /   \n      data (c(i), i = 14, 27) /                                   &\n          -0.00000000000712453560d0, -0.00000000041170814825d0,   &\n          0.00000000138012624364d0, 0.00000005704447670683d0,     &\n          -0.00000019026363528842d0, -0.00000533925032409729d0,   &\n          0.00001736064885538091d0, 0.00030692619152608375d0,     &\n          -0.00092598938200644367d0, -0.00917934265960017663d0,   &\n          0.02287952522866389076d0, 0.10545197546252853195d0,     &\n          -0.16126443075752985095d0, -0.19392874768742235538d0 /  \n      data (c(i), i = 28, 41) /                                   &\n          0.00000000002128344556d0, -0.00000000031053910272d0,    &\n          -0.00000000334979293158d0, 0.00000004507232895050d0,    &\n          0.00000036437959146427d0, -0.00000446421436266678d0,    &\n          -0.00002523429344576552d0, 0.00027519882931758163d0,    &\n          0.00097185076358599358d0, -0.00898326746345390692d0,    &\n          -0.01665959196063987584d0, 0.11456933464891967814d0,    &\n          0.07885001422733148815d0, -0.23664819446234712621d0 /   \n      data (c(i), i = 42, 55) /                                   &\n          0.00000000003035295055d0, 0.00000000005486066835d0,     &\n          -0.00000000501026824811d0, -0.00000000501246847860d0,   &\n          0.00000058012340163034d0, 0.00000016788922416169d0,     &\n          -0.00004373270270147275d0, 0.00001183898532719802d0,    &\n          0.00189863342862291449d0, -0.00113759249561636130d0,    &\n          -0.03846797195329871681d0, 0.02389746880951420335d0,    &\n          0.22837862066532347461d0, -0.06765394811166522844d0 /   \n      data (c(i), i = 56, 69) /                                   &\n          0.00000000001279875977d0, 0.00000000035925958103d0,     &\n          -0.00000000228037105967d0, -0.00000004852770517176d0,   &\n          0.00000028696428000189d0, 0.00000440131125178642d0,     &\n          -0.00002366617753349105d0, -0.00024412456252884129d0,   &\n          0.00113028178539430542d0, 0.00708470513919789080d0,     &\n          -0.02526914792327618386d0, -0.08006137953480093426d0,   &\n          0.16548380461475971846d0, 0.14688405470042110229d0 /   \n      data (d(i), i = 0, 12) /                                    &\n          1.059601355592185731d-14, -2.71150591218550377d-13,     &\n          8.6514809056201638d-12, -4.6264028554286627d-10,        &\n          5.0815403835647104d-8, -1.76722552048141208d-5,         &\n          0.16286750396763997378d0, 2.949651820598278873d-13,     &\n          -8.818215611676125741d-12, 3.571119876162253451d-10,    &\n          -2.631924120993717060d-8, 4.709502795656698909d-6,      &\n          -5.208333333333283282d-3 / \n      data (d(i), i = 13, 25) /                                   &\n          7.18344107717531977d-15, -2.51623725588410308d-13,      &\n          8.6017784918920604d-12, -4.6256876614290359d-10,        &\n          5.0815343220437937d-8, -1.76722551764941970d-5,         &\n          0.16286750396763433767d0, 2.2327570859680094777d-13,    &\n          -8.464594853517051292d-12, 3.563766464349055183d-10,    &\n          -2.631843986737892965d-8, 4.709502342288659410d-6,      &\n          -5.2083333332278466225d-3 / \n      data (d(i), i = 26, 38) /                                   &\n          5.15413392842889366d-15, -2.27740238380640162d-13,      &\n          8.4827767197609014d-12, -4.6224753682737618d-10,        &\n          5.0814848128929134d-8, -1.76722547638767480d-5,         &\n          0.16286750396748926663d0, 1.7316195320192170887d-13,    &\n          -7.971122772293919646d-12, 3.544039469911895749d-10,    &\n          -2.631443902081701081d-8, 4.709498228695400603d-6,      &\n          -5.2083333315143653610d-3 / \n      data (d(i), i = 39, 51) /                                   &\n          3.84653681453798517d-15, -2.04464520778789011d-13,      &\n          8.3089298605177838d-12, -4.6155016158412096d-10,        &\n          5.0813263696466650d-8, -1.76722528311426167d-5,         &\n          0.16286750396650065930d0, 1.3797879972460878797d-13,    &\n          -7.448089381011684812d-12, 3.512733797106959780d-10,    &\n          -2.630500895563592722d-8, 4.709483934775839193d-6,      &\n          -5.2083333227940760113d-3 / \n      w = abs(x)\n      if (w .lt. 1) then\n          t = w * w\n          y = ((((((a(0) * t + a(1)) * t +                        &\n              a(2)) * t + a(3)) * t + a(4)) * t +                 &\n              a(5)) * t + a(6)) * t + a(7)\n      else if (w .lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = int(t)\n          t = t - (k + 0.5d0)\n          k = k * 13\n          y = (((((((((((b(k) * t + b(k + 1)) * t +               &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)\n      else ", "if (w .lt. 12.5d0) then\n          k = int(w)\n          t = w - (k + 0.5d0)\n          k = 14 * (k - 8)\n          y = ((((((((((((c(k) * t + c(k + 1)) * t +              &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * t + c(k + 9)) * t + c(k + 10)) * t +    &\n              c(k + 11)) * t + c(k + 12)) * t + c(k + 13)\n      else\n          v = 24 / w\n          t = v * v\n          k = 13 * (int(t))\n          y = ((((((d(k) * t + d(k + 1)) * t +                    &\n              d(k + 2)) * t + d(k + 3)) * t + d(k + 4)) * t +     &\n              d(k + 5)) * t + d(k + 6)) * sqrt(v)\n          theta = (((((d(k + 7) * t + d(k + 8)) * t +             &\n              d(k + 9)) * t + d(k + 10)) * t + d(k + 11)) * t +   &\n              d(k + 12)) * v - pi4\n          y = y * cos(w + theta)\n      end if\n      dbesj0 = y\n      end function dbesj0\n!\n! Bessel J_1(x) function in double precision\n!\n      function dbesj1(x)\n      !implicit integer (i - n)\n      !implicit real*8 (a - h, o - z)\n      !dimension a(0 : 7), b(0 : 64), c(0 : 69), d(0 : 51)\n      !parameter (pi4 = 0.78539816339744830962d0)\n      implicit none\n      real(kind=8), parameter :: pi4 = 0.78539816339744830962d0\n      real(kind=8) :: a(0:7), b(0:64), c(0:69), d(0:51)\n      real(kind=8) :: t, v, w, x, y, theta, dbesj1\n      integer :: i, k\n      data (a(i), i = 0, 7) /                                     &\n          -0.00000000000014810349d0, 0.00000000003363594618d0,    &\n          -0.00000000565140051697d0, 0.00000067816840144764d0,    &\n          -0.00005425347222188379d0, 0.00260416666666662438d0,    &\n          -0.06249999999999999799d0, 0.49999999999999999998d0 /   \n      data (b(i), i = 0, 12) /                                    &\n          0.00000000000243721316d0, -0.00000000009400554763d0,    &\n          0.00000000306053389980d0, -0.00000008287270492518d0,    &\n          0.00000183020515991344d0, -0.00003219783841164382d0,    &\n          0.00043795830161515318d0, -0.00442952351530868999d0,    &\n          0.03157908273375945955d0, -0.14682160488052520107d0,    &\n          0.39309619054093640008d0, -0.47952808215101070280d0,    &\n          0.14148999344027125140d0 /                              \n      data (b(i), i = 13, 25) /                                   &\n          0.00000000000182119257d0, -0.00000000006862117678d0,    &\n          0.00000000217327908360d0, -0.00000005693592917820d0,    &\n          0.00000120771046483277d0, -0.00002020151799736374d0,    &\n          0.00025745933218048448d0, -0.00238514907946126334d0,    &\n          0.01499220060892984289d0, -0.05707238494868888345d0,    &\n          0.10375225210588234727d0, -0.02721551202427354117d0,    &\n          -0.06420643306727498985d0 /                             \n      data (b(i), i = 26, 38) /                                   &\n          0.000000000001352611196d0, -0.000000000049706947875d0,  &\n          0.000000001527944986332d0, -0.000000038602878823401d0,  &\n          0.000000782618036237845d0, -0.000012349994748451100d0,  &\n          0.000145508295194426686d0, -0.001203649737425854162d0,  &\n          0.006299092495799005109d0, -0.016449840761170764763d0,  &\n          0.002106328565019748701d0, 0.058527410006860734650d0,   &\n          -0.031896615709705053191d0 /                            \n      data (b(i), i = 39, 51) /                                   &\n          0.000000000000997982124d0, -0.000000000035702556073d0,  &\n          0.000000001062332772617d0, -0.000000025779624221725d0,  &\n          0.000000496382962683556d0, -0.000007310776625173004d0,  &\n          0.000078028107569541842d0, -0.000550624088538081113d0,  &\n          0.002081442840335570371d0, -0.000771292652260286633d0,  &\n          -0.019541271866742634199d0, 0.033361194224480445382d0,  &\n          0.017516628654559387164d0 /                             \n      data (b(i), i = 52, 64) /                                   &\n          0.000000000000731050661d0, -0.000000000025404499912d0,  &\n          0.000000000729360079088d0, -0.000000016915375004937d0,  &\n          0.000000306748319652546d0, -0.000004151324014331739d0,  &\n          0.000038793392054271497d0, -0.000211180556924525773d0,  &\n          0.000274577195102593786d0, 0.003378676555289966782d0,   &\n          -0.013842821799754920148d0, -0.002041834048574905921d0, &\n          0.032167266073736023299d0 /                             \n      data (c(i), i = 0, 13) /                                    &\n          -0.00000000001185964494d0, 0.00000000039110295657d0,    &\n          0.00000000180385519493d0, -0.00000005575391345723d0,    &\n          -0.00000018635897017174d0, 0.00000542738239401869d0,    &\n          0.00001181490114244279d0, -0.00033000319398521070d0,    &\n          -0.00037717832892725053d0, 0.01070685852970608288d0,    &\n          0.00356629346707622489d0, -0.13524776185998074716d0,    &\n          0.00980725611657523952d0, 0.27312196367405374425d0 /    \n      data (c(i), i = 14, 27) /                                   &\n          -0.00000000003029591097d0, 0.00000000009259293559d0,    &\n          0.00000000496321971223d0, -0.00000001518137078639d0,    &\n          -0.00000057045127595547d0, 0.00000171237271302072d0,    &\n          0.00004271400348035384d0, -0.00012152454198713258d0,    &\n          -0.00184155714921474963d0, 0.00462994691003219055d0,    &\n          0.03671737063840232452d0, -0.06863857568599167175d0,    &\n          -0.21090395092505707655d0, 0.16126443075752985095d0 /   \n      data (c(i), i = 28, 41) /                                   &\n          -0.00000000002197602080d0, -0.00000000027659100729d0,   &\n          0.00000000374295124827d0, 0.00000003684765777023d0,     &\n          -0.00000045072801091574d0, -0.00000327941630669276d0,   &\n          0.00003571371554516300d0, 0.00017664005411843533d0,     &\n          -0.00165119297594774104d0, -0.00485925381792986774d0,   &\n          0.03593306985381680131d0, 0.04997877588191962563d0,     &\n          -0.22913866929783936544d0, -0.07885001422733148814d0 /  \n      data (c(i), i = 42, 55) /                                   &\n          0.00000000000516292316d0, -0.00000000039445956763d0,    &\n          -0.00000000066220021263d0, 0.00000005511286218639d0,    &\n          0.00000005012579400780d0, -0.00000522111059203425d0,    &\n          -0.00000134311394455105d0, 0.00030612891890766805d0,    &\n          -0.00007103391195326182d0, -0.00949316714311443491d0,   &\n          0.00455036998246516948d0, 0.11540391585989614784d0,     &\n          -0.04779493761902840455d0, -0.22837862066532347460d0 /  \n      data (c(i), i = 56, 69) /                                   &\n          0.00000000002697817493d0, -0.00000000016633326949d0,    &\n          -0.00000000433134860350d0, 0.00000002508404686362d0,    &\n          0.00000048528284780984d0, -0.00000258267851112118d0,    &\n          -0.00003521049080466759d0, 0.00016566324273339952d0,    &\n          0.00146474737522491617d0, -0.00565140892697147306d0,    &\n          -0.02833882055679300400d0, 0.07580744376982855057d0,    &\n          0.16012275906960187978d0, -0.16548380461475971845d0 /   \n      data (d(i), i = 0, 12) /                                    &\n          -1.272346002224188092d-14, 3.370464692346669075d-13,    &\n          -1.144940314335484869d-11, 6.863141561083429745d-10,    &\n          -9.491933932960924159d-8, 5.301676561445687562d-5,      &\n          0.1628675039676399740d0, -3.652982212914147794d-13,     &\n          1.151126750560028914d-11, -5.165585095674343486d-10,    &\n          4.657991250060549892d-8, -1.186794704692706504d-5,      &\n          1.562499999999994026d-2 /                               \n      data (d(i), i = 13, 25) /                                   &\n          -8.713069680903981555d-15, 3.140780373478474935d-13,    &\n          -1.139089186076256597d-11, 6.862299023338785566d-10,    &\n          -9.491926788274594674d-8, 5.301676558106268323d-5,      &\n          0.1628675039676466220d0, -2.792555727162752006d-13,     &\n          1.108650207651756807d-11, -5.156745588549830981d-10,    &\n          4.657894859077370979d-8, -1.186794650130550256d-5,      &\n          1.562499999987299901d-2 /                               \n      data (d(i), i = 26, 38) /                                   &\n          -6.304859171204770696d-15, 2.857249044208791652d-13,    &\n          -1.124956921556753188d-11, 6.858482894906716661d-10,    &\n          -9.491867953516898460d-8, 5.301676509057781574d-5,      &\n          0.1628675039678191167d0, -2.185193490132496053d-13,     &\n          1.048820673697426074d-11, -5.132819367467680132d-10,    &\n          4.657409437372994220d-8, -1.186794150862988921d-5,      &\n          1.562499999779270706d-2 /                               \n      data (d(i), i = 39, 51) /                                   &\n          -4.740417209792009850d-15, 2.578715253644144182d-13,    &\n          -1.104148898414138857d-11, 6.850134201626289183d-10,    &\n          -9.491678234174919640d-8, 5.301676277588728159d-5,      &\n          0.1628675039690033136d0, -1.755122057493842290d-13,     &\n          9.848723331445182397d-12, -5.094535425482245697d-10,    &\n          4.656255982268609304d-8, -1.186792402114394891d-5,      &\n          1.562499998712198636d-2 / \n      w = abs(x)\n      if (w .lt. 1) then\n          t = w * w\n          y = (((((((a(0) * t + a(1)) * t +                       &\n              a(2)) * t + a(3)) * t + a(4)) * t +                 &\n              a(5)) * t + a(6)) * t + a(7)) * w\n      else if (w .lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = int(t)\n          t = t - (k + 0.5d0)\n          k = k * 13\n          y = ((((((((((((b(k) * t + b(k + 1)) * t +              &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)) * w\n      else if (w .lt. 12.5d0) then\n          k = int(w)\n          t = w - (k + 0.5d0)\n          k = 14 * (k - 8)\n          y = ((((((((((((c(k) * t + c(k + 1)) * t +              &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * t + c(k + 9)) * t + c(k + 10)) * t +    &\n              c(k + 11)) * t + c(k + 12)) * t + c(k + 13)\n      else\n          v = 24 / w\n          t = v * v\n          k = 13 * (int(t))\n          y = ((((((d(k) * t + d(k + 1)) * t +                    &\n              d(k + 2)) * t + d(k + 3)) * t + d(k + 4)) * t +     &\n              d(k + 5)) * t + d(k + 6)) * sqrt(v)                 \n          theta = (((((d(k + 7) * t + d(k + 8)) * t +             &\n              d(k + 9)) * t + d(k + 10)) * t + d(k + 11)) * t +   &\n              d(k + 12)) * v - pi4\n          y = y * sin(w + theta)\n      end if\n      ", "if (x .lt. 0) y = -y\n      dbesj1 = y\n      end function dbesj1\n!\n! Bessel I_0(x) function in double precision\n!\n      function dbesi0(x)\n      !implicit integer (i - n)\n      !implicit real*8 (a - h, o - z)\n      !dimension a(0 : 64), b(0 : 69), c(0 : 44)\n      implicit none\n      real(kind=8) :: a(0:64), b(0:69), c(0:44)\n      real(kind=8) :: t, w, x, y, dbesi0\n      integer :: i, k\n      data (a(i), i = 0, 12) /                                    &\n          8.5246820682016865877d-11, 2.5966600546497407288d-9,    &\n          7.9689994568640180274d-8, 1.9906710409667748239d-6,     &\n          4.0312469446528002532d-5, 6.4499871606224265421d-4,     &\n          7.9012345761930579108d-3, 7.1111111109207045212d-2,     &\n          4.4444444444472490900d-1, 1.7777777777777532045d0,      &\n          4.0000000000000011182d0, 3.9999999999999999800d0,       &\n          1.0000000000000000001d0 /                                \n      data (a(i), i = 13, 25) /                                   &\n          1.1520919130377195927d-10, 2.2287613013610985225d-9,    &\n          8.1903951930694585113d-8, 1.9821560631611544984d-6,     &\n          4.0335461940910133184d-5, 6.4495330974432203401d-4,     &\n          7.9013012611467520626d-3, 7.1111038160875566622d-2,     &\n          4.4444450319062699316d-1, 1.7777777439146450067d0,      &\n          4.0000000132337935071d0, 3.9999999968569015366d0,       &\n          1.0000000003426703174d0 /                                \n      data (a(i), i = 26, 38) /                                   &\n          1.5476870780515238488d-10, 1.2685004214732975355d-9,    &\n          9.2776861851114223267d-8, 1.9063070109379044378d-6,     &\n          4.0698004389917945832d-5, 6.4370447244298070713d-4,     &\n          7.9044749458444976958d-3, 7.1105052411749363882d-2,     &\n          4.4445280640924755082d-1, 1.7777694934432109713d0,      &\n          4.0000055808824003386d0, 3.9999977081165740932d0,       &\n          1.0000004333949319118d0 /                                \n      data (a(i), i = 39, 51) /                                   &\n          2.0675200625006793075d-10, -6.1689554705125681442d-10,  &\n          1.2436765915401571654d-7, 1.5830429403520613423d-6,     &\n          4.2947227560776583326d-5, 6.3249861665073441312d-4,     &\n          7.9454472840953930811d-3, 7.0994327785661860575d-2,     &\n          4.4467219586283000332d-1, 1.7774588182255374745d0,      &\n          4.0003038986252717972d0, 3.9998233869142057195d0,       &\n          1.0000472932961288324d0 /                                \n      data (a(i), i = 52, 64) /                                   &\n          2.7475684794982708655d-10, -3.8991472076521332023d-9,   &\n          1.9730170483976049388d-7, 5.9651531561967674521d-7,     &\n          5.1992971474748995357d-5, 5.7327338675433770752d-4,     &\n          8.2293143836530412024d-3, 6.9990934858728039037d-2,     &\n          4.4726764292723985087d-1, 1.7726685170014087784d0,      &\n          4.0062907863712704432d0, 3.9952750700487845355d0,       &\n          1.0016354346654179322d0 /                                \n      data (b(i), i = 0, 13) /                                    &\n          6.7852367144945531383d-8, 4.6266061382821826854d-7,     &\n          6.9703135812354071774d-6, 7.6637663462953234134d-5,     &\n          7.9113515222612691636d-4, 7.3401204731103808981d-3,     &\n          6.0677114958668837046d-2, 4.3994941411651569622d-1,     &\n          2.7420017097661750609d0, 14.289661921740860534d0,       &\n          59.820609640320710779d0, 188.78998681199150629d0,       &\n          399.87313678256011180d0, 427.56411572180478514d0 /       \n      data (b(i), i = 14, 27) /                                   &\n          1.8042097874891098754d-7, 1.2277164312044637357d-6,     &\n          1.8484393221474274861d-5, 2.0293995900091309208d-4,     &\n          2.0918539850246207459d-3, 1.9375315654033949297d-2,     &\n          1.5985869016767185908d-1, 1.1565260527420641724d0,      &\n          7.1896341224206072113d0, 37.354773811947484532d0,       &\n          155.80993164266268457d0, 489.52113711585409180d0,       &\n          1030.9147225169564806d0, 1093.5883545113746958d0 /       \n      data (b(i), i = 28, 41) /                                   &\n          4.8017305613187493564d-7, 3.2613178439123800740d-6,     &\n          4.9073137508166159639d-5, 5.3806506676487583755d-4,     &\n          5.5387918291051866561d-3, 5.1223717488786549025d-2,     &\n          4.2190298621367914765d-1, 3.0463625987357355872d0,      &\n          18.895299447327733204d0, 97.915189029455461554d0,       &\n          407.13940115493494659d0, 1274.3088990480582632d0,       &\n          2670.9883037012547506d0, 2815.7166284662544712d0 /       \n      data (b(i), i = 42, 55) /                                   &\n          1.2789926338424623394d-6, 8.6718263067604918916d-6,     &\n          1.3041508821299929489d-4, 1.4282247373727478920d-3,     &\n          1.4684070635768789378d-2, 1.3561403190404185755d-1,     &\n          1.1152592585977393953d0, 8.0387088559465389038d0,       &\n          49.761318895895479206d0, 257.26842323135291380d0,       &\n          1066.8543146269566231d0, 3328.3874581009636362d0,       &\n          6948.8586598121634874d0, 7288.4893398212481055d0 /       \n      data (b(i), i = 56, 69) /                                   &\n          3.4093503681970328930d-6, 2.3079025203103376076d-5,     &\n          3.4691373283901830239d-4, 3.7949949772229085450d-3,     &\n          3.8974209677945602145d-2, 3.5949483804148783710d-1,     &\n          2.9522878893539528226d0, 21.246564609514287056d0,       &\n          131.28727387146173141d0, 677.38107093296675421d0,       &\n          2802.3724744545046518d0, 8718.5731420798254081d0,       &\n          18141.348781638832286d0, 18948.925349296308859d0 /       \n      data (c(i), i = 0, 8) /                                     &\n          2.5568678676452702768d-15, 3.0393953792305924324d-14,   &\n          6.3343751991094840009d-13, 1.5041298011833009649d-11,   &\n          4.4569436918556541414d-10, 1.7463930514271679510d-8,    &\n          1.0059224011079852317d-6, 1.0729838945088577089d-4,     &\n          5.1503226936425277380d-2 /                               \n      data (c(i), i = 9, 17) /                                    &\n          5.2527963991711562216d-15, 7.2021184814210056410d-15,   &\n          7.2561421229904797156d-13, 1.4823121466731042510d-11,   &\n          4.4602670450376245434d-10, 1.7463600061788679671d-8,    &\n          1.0059226091322347560d-6, 1.0729838937545111487d-4,     &\n          5.1503226936437300716d-2 /                               \n      data (c(i), i = 18, 26) /                                   &\n          1.3365917359358069908d-14, -1.2932643065888544835d-13,  &\n          1.7450199447905602915d-12, 1.0419051209056979788d-11,   &\n          4.5804788198059832600d-10, 1.7442405450073548966d-8,    &\n          1.0059461453281292278d-6, 1.0729837434500161228d-4,     &\n          5.1503226940658446941d-2 /                               \n      data (c(i), i = 27, 35) /                                   &\n          5.3771611477352308649d-14, -1.1396193006413731702d-12,  &\n          1.2858641335221653409d-11, -5.9802086004570057703d-11,  &\n          7.3666894305929510222d-10, 1.6731837150730356448d-8,    &\n          1.0070831435812128922d-6, 1.0729733111203704813d-4,     &\n          5.1503227360726294675d-2 /                               \n      data (c(i), i = 36, 44) /                                   &\n          3.7819492084858931093d-14, -4.8600496888588034879d-13,  &\n          1.6898350504817224909d-12, 4.5884624327524255865d-11,   &\n          1.2521615963377513729d-10, 1.8959658437754727957d-8,    &\n          1.0020716710561353622d-6, 1.0730371198569275590d-4,     &\n          5.1503223833002307750d-2 / \n      w = abs(x)\n      if (w .lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = 13 * (int(t))\n          y = (((((((((((a(k) * t + a(k + 1)) * t +               &\n              a(k + 2)) * t + a(k + 3)) * t + a(k + 4)) * t +     &\n              a(k + 5)) * t + a(k + 6)) * t + a(k + 7)) * t +     &\n              a(k + 8)) * t + a(k + 9)) * t + a(k + 10)) * t +    &\n              a(k + 11)) * t + a(k + 12)\n      else ", "if (w.lt. 12.5d0) then\n          k = int(w)\n          t = w - k\n          k = 14 * (k - 8)\n          y = ((((((((((((b(k) * t + b(k + 1)) * t +              &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)) * t + b(k + 13)\n      else\n          t = 60 / w\n          k = 9 * (int(t))\n          y = ((((((((c(k) * t + c(k + 1)) * t +                  &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * sqrt(t) * exp(w)\n      end if\n      dbesi0 = y\n      end function dbesi0\n!\n! Bessel I_1(x) function in double precision\n!\n      function dbesi1(x)\n     !implicit integer (i - n)\n     !implicit real*8 (a - h, o - z)\n     !dimension a(0 : 59), b(0 : 69), c(0 : 44)\n      implicit none\n      real(kind=8) :: a(0:59), b(0:69), c(0:44)\n      real(kind=8) :: t, w, x, y, dbesi1\n      integer :: i, k\n      data (a(i), i = 0, 11) /                                    &\n          1.2787464404046789181d-10, 3.5705860060088241077d-9,    &\n          9.9611537619347335040d-8, 2.2395070088633043177d-6,     &\n          4.0312466928887462346d-5, 5.6437387840203722356d-4,     &\n          5.9259259312934746096d-3, 4.4444444443499008870d-2,     &\n          2.2222222222232042719d-1, 6.6666666666666139867d-1,     &\n          1.0000000000000001106d0, 4.9999999999999999962d-1 /      \n      data (a(i), i = 12, 23) /                                   &\n          1.7281952384448634449d-10, 3.0647204559976390130d-9,    &\n          1.0237662138842827028d-7, 2.2299494417341498163d-6,     &\n          4.0335364374929326943d-5, 5.6433440269141349899d-4,     &\n          5.9259754885893798654d-3, 4.4444399410880397870d-2,     &\n          2.2222225112835026730d-1, 6.6666665422146063244d-1,     &\n          1.0000000032274936821d0, 4.9999999961866867205d-1 /      \n      data (a(i), i = 24, 35) /                                   &\n          2.3216048939948030996d-10, 1.7443372702334489579d-9,    &\n          1.1596478963485415499d-7, 2.1446755518623035147d-6,     &\n          4.0697440347437076195d-5, 5.6324394900433192204d-4,     &\n          5.9283484996093060678d-3, 4.4440673899150997921d-2,     &\n          2.2222638016852657860d-1, 6.6666358151576732094d-1,     &\n          1.0000013834029985337d0, 4.9999971643129650249d-1 /      \n      data (a(i), i = 36, 47) /                                   &\n          3.1013758938255172562d-10, -8.4813676145611694984d-10,  &\n          1.5544980187411802596d-7, 1.7811109378708045726d-6,     &\n          4.2945322199060856985d-5, 5.5344850176852353639d-4,     &\n          5.9590327716950614802d-3, 4.4371611097707060659d-2,     &\n          2.2233578241986401111d-1, 6.6654747300463315310d-1,     &\n          1.0000756505206705927d0, 4.9997803664415994554d-1 /      \n      data (a(i), i = 48, 59) /                                   &\n          4.1214758313965020365d-10, -5.3613317735347429440d-9,   &\n          2.4661360807517345161d-7, 6.7144593918926723203d-7,     &\n          5.1988027944945587571d-5, 5.0165568586065803067d-4,     &\n          6.1717530047005289953d-3, 4.3745229577317251404d-2,     &\n          2.2363147971477747996d-1, 6.6475469131117660240d-1,     &\n          1.0015686689447547657d0, 4.9941120439785391891d-1 /      \n      data (b(i), i = 0, 13) /                                    &\n          6.6324787943143095845d-8, 4.5125928898466638619d-7,     &\n          6.7937793134877246623d-6, 7.4580507871505926302d-5,     &\n          7.6866382927334005919d-4, 7.1185174803491859307d-3,     &\n          5.8721838073486424416d-2, 4.2473949281714196041d-1,     &\n          2.6396965606282079123d0, 13.710008536637016903d0,       &\n          57.158647688180932003d0, 179.46182892089389037d0,       &\n          377.57997362398478619d0, 399.87313678256009819d0 /       \n      data (b(i), i = 14, 27) /                                   &\n          1.7652713206027939711d-7, 1.1988179244834708057d-6,     &\n          1.8037851545747139231d-5, 1.9775785516370314656d-4,     &\n          2.0354870702829387283d-3, 1.8822164191032253600d-2,     &\n          1.5500485219010424263d-1, 1.1190100010560573210d0,      &\n          6.9391565185406617552d0, 35.948170579648649345d0,       &\n          149.41909525103032616d0, 467.42979492780642582d0,       &\n          979.04227423171290408d0, 1030.9147225169564443d0 /       \n      data (b(i), i = 28, 41) /                                   &\n          4.7022299276154507603d-7, 3.1878571710170115972d-6,     &\n          4.7940153875711448496d-5, 5.2496623508411440227d-4,     &\n          5.3968661134780824779d-3, 4.9837081920693776234d-2,     &\n          4.0979593830387765545d-1, 2.9533186922862948404d0,      &\n          18.278176130722516369d0, 94.476497150189121070d0,       &\n          391.66075612645333624d0, 1221.4182034643210345d0,       &\n          2548.6177980961291004d0, 2670.9883037012546541d0 /       \n      data (b(i), i = 42, 55) /                                   &\n          1.2535083724002034147d-6, 8.4845871420655708250d-6,     &\n          1.2753227372734042108d-4, 1.3950105363562648921d-3,     &\n          1.4325473993765291906d-2, 1.3212452778932829125d-1,     &\n          1.0849287786885151432d0, 7.8068089156260172673d0,       &\n          48.232254570679165833d0, 248.80659424902394371d0,       &\n          1029.0736929484210803d0, 3200.5629438795801652d0,       &\n          6656.7749162019607914d0, 6948.8586598121632302d0 /       \n      data (b(i), i = 56, 69) /                                   &\n          3.3439394490599745013d-6, 2.2600596902211837757d-5,     &\n          3.3955927589987356838d-4, 3.7105306061050972474d-3,     &\n          3.8065263634919156421d-2, 3.5068223415665236079d-1,     &\n          2.8760027832105027316d0, 20.665999500843274339d0,       &\n          127.47939148516390205d0, 656.43636874254000885d0,       &\n          2709.5242837932479920d0, 8407.1174233600734871d0,       &\n          17437.146284159740233d0, 18141.348781638831600d0 /       \n      data (c(i), i = 0, 8) /                                     &\n          -2.8849790431465382128d-15, -3.5125350943844774657d-14, &\n          -7.4850867013707419750d-13, -1.8383904048277485153d-11, &\n          -5.7303556446977223342d-10, -2.4449502737311496525d-8,  &\n          -1.6765373351766929724d-6, -3.2189516835265773471d-4,   &\n          5.1503226936425277377d-2 /                               \n      data (c(i), i = 9, 17) /                                    &\n          -5.8674306822281631119d-15, -9.4884898451194085565d-15, &\n          -8.5033865136600364340d-13, -1.8142997866945285736d-11, &\n          -5.7340238386338193949d-10, -2.4449138101742183665d-8,  &\n          -1.6765375646678855842d-6, -3.2189516826945356325d-4,   &\n          5.1503226936412017608d-2 /                               \n      data (c(i), i = 18, 26) /                                   &\n          -1.4723362506764340882d-14, 1.3945147385179042899d-13,  &\n          -1.9618041857586930923d-12, -1.3343606394065121821d-11, &\n          -5.8649674606973244159d-10, -2.4426060539669553778d-8,  &\n          -1.6765631828366988006d-6, -3.2189515191449587253d-4,   &\n          5.1503226931820146445d-2 /                               \n      data (c(i), i = 27, 35) /                                   &\n          -5.8203519372580372987d-14, 1.2266326995309845825d-12,  &\n          -1.3921625844526453237d-11, 6.2228025878281625469d-11,  &\n          -8.8636681342142794023d-10, -2.3661241616744818608d-8,  &\n          -1.6777870960740520557d-6, -3.2189402882677074318d-4,   &\n          5.1503226479551959376d-2 /                               \n      data (c(i), i = 36, 44) /                                   &\n          -4.5801527369223291722d-14, 6.7998819697143727209d-13,  &\n          -4.1624857909290468421d-12, -3.2849009406112440998d-11, &\n          -3.2478275690431118270d-10, -2.5739209934053714983d-8,  &\n          -1.6730566573215739195d-6, -3.2190010909008684076d-4,   &\n          5.1503229866932077150d-2 / \n      w = abs(x)\n      if (w.lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = 12 * (int(t))\n          y = (((((((((((a(k) * t + a(k + 1)) * t +               &\n              a(k + 2)) * t + a(k + 3)) * t + a(k + 4)) * t +     &\n              a(k + 5)) * t + a(k + 6)) * t + a(k + 7)) * t +     &\n              a(k + 8)) * t + a(k + 9)) * t + a(k + 10)) * t +    &\n              a(k + 11)) * w\n      else if (w.lt. 12.5d0) then\n          k = int(w)\n          t = w - k\n          k = 14 * (k - 8)\n          y = ((((((((((((b(k) * t + b(k + 1)) * t +              &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)) * t + b(k + 13)\n      else\n          t = 60 / w\n          k = 9 * (int(t))\n          y = ((((((((c(k) * t + c(k + 1)) * t +                  &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * sqrt(t) * exp(w)\n      end if\n      if (x.lt. 0) y = -y\n      dbesi1 = y\n      end function dbesi1\n!\nFUNCTION ellipk(k)\n!\n! Complete elliptic integral of the 1st kind\n!   K(k) = \\int_0^(pi/2) (1-k**2*sin(q)**2)**(-1/2) dq\n! where 0<=k<1.\n!\n! Algorithm based on Jacobi's nome q expansion [Refs1-3]\n! Implemented by S. Maeyama (July,2021)\n!\n! Ref1. T.Fukushima, \"Fast computation of complete elliptic integrals and \n!       Jacobian elliptic functions\", Celest. Mech. Dyn. Astr. 105,\n!       305-328 (2009). DOI 10.1007/s10569-009-9228-z\n! Ref2. J.Yamauchi, T.Uno, S.Ichimatsu, \"Denshikeisanki notameno\n!       suuchikeisanhou III\" (Baifukan, 1971), p.258. (Japanese)\n! Ref3. http://www.totoha.net/fc2_mirror2/Complete_Elliptical_Integral.pdf\n!\n  real(kind=8) :: ellipk\n  real(kind=8), intent(in) :: k\n\n  real(kind=8), parameter :: halfpi=2.d0*atan(1.d0)\n  real(kind=8), parameter :: piinv=1.d0/(2.d0*halfpi)\n  real(kind=8) :: kp2,kp,sqrtkp,eps,eps4,q,q4,q9,q16,q25,t3\n\n  if (k<0.7d0) then\n\n    kp2=1.d0-k*k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q4=q*q*q*q\n    q9=q4*q4*q\n    q16=q4*q4*q4*q4\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)\n    ellipk=halfpi*t3*t3\n\n  else\n\n    kp2=k*k! modify for large k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q4=q*q*q*q\n    q9=q4*q4*q\n    q16=q4*q4*q4*q4\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)\n    ellipk=halfpi*t3*t3\n    ellipk=-piinv*ellipk*log(q)! modify for large k\n\n  end if\n\n    return\n\nEND FUNCTION ellipk\n \n\nFUNCTION ellipe(k)\n!                                                                                                                                                                 \n! Complete elliptic integral of the 2nd kind\n!   E(k) = \\int_0^(pi/2) (1-k**2*sin(q)**\")**(1/2) dq\n! where 0<=k<1.\n!\n! Algorithm based on Jacobi's nome q expansion [Refs1-3]\n! Implemented by S. Maeyama (July,2021)\n!\n! Ref1. T.Fukushima, \"Fast computation of complete elliptic integrals and \n!       Jacobian elliptic functions\", Celest. Mech. Dyn. Astr. 105,\n!       305-328 (2009). DOI 10.1007/s10569-009-9228-z\n! Ref2. J.Yamauchi, T.Uno, S.Ichimatsu, \"Denshikeisanki notameno\n!       suuchikeisanhou III\" (Baifukan, 1971), p.258. (Japanese)\n! Ref3. http://www.totoha.net/fc2_mirror2/Complete_Elliptical_Integral.pdf\n!\n  real(kind=8) :: ellipe\n  real(kind=8), intent(in) :: k\n\n  real(kind=8), parameter :: piover6=2.d0*atan(1.d0)/3.d0\n  real(kind=8), parameter :: halfpi=2.d0*atan(1.d0)\n  real(kind=8), parameter :: piinv=1.d0/(2.d0*halfpi)\n  real(kind=8) :: kp2,kp,sqrtkp,eps,eps4,q,q2,q4,q6,q8,q9,&\n                  q10,q12,q14,q16,q18,q20,q22,q25,t3,t3sq,fac,wq\n  real(kind=8) :: ellipkp, ellipk, ellipep\n\n  if (k<0.7d0) then\n\n    kp2=1.d0-k*k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q2=q*q\n    q4=q2*q2\n    q6=q4*q2\n    q8=q4*q4\n    q9=q8*q\n    q10=q4*q6\n    q12=q6*q6\n    q14=q6*q8\n    q16=q8*q8\n    q18=q9*q9\n    q20=q10*q10\n    q22=q20*q2\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)!&\n    t3sq=t3*t3\n    fac=piover6/t3sq\n    wq=q2+3.d0*q4+4.d0*q6+7.d0*q8+6.d0*q10+12.d0*q12+8.d0*q14  &\n      +15.d0*q16+13.d0*q18+18.d0*q20+12.d0*q22\n    ellipe=fac*(1.d0+(1.d0+kp2)*t3sq*t3sq-24.d0*wq)\n\n  else\n\n    kp2=k*k! modify for large k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q2=q*q\n    q4=q2*q2\n    q6=q4*q2\n    q8=q4*q4\n    q9=q8*q\n    q10=q4*q6\n    q12=q6*q6\n    q14=q6*q8\n    q16=q8*q8\n    q18=q9*q9\n    q20=q10*q10\n    q22=q20*q2\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)\n    t3sq=t3*t3\n    fac=piover6/t3sq\n    wq=q2+3.d0*q4+4.d0*q6+7.d0*q8+6.d0*q10+12.d0*q12+8.d0*q14  &\n      +15.d0*q16+13.d0*q18+18.d0*q20+12.d0*q22\n    ellipep=fac*(1.d0+(1.d0+kp2)*t3sq*t3sq-24.d0*wq)! modify for large k\n    ellipkp=halfpi*t3sq                             ! modify for large k\n    ellipk=-piinv*ellipkp*log(q)                    ! modify for large k\n    ellipe=ellipk+(halfpi-ellipep*ellipk)/ellipkp   ! modify for large k\n\n  end if\n\n    return\n                                                                                                                                                                  \nEND FUNCTION ellipe\n\nEND MODULE GKV_math\n", "MODULE GKV_math\n!\n!  Mathematical functions using SSLII library\n!\n!  This routine uses the unit number of 99 which \n!    should not be overlapped with others\n!\n!  T.-H. Watanabe (Feb 2011)\n!                 (May 2011) with new functions, \n!                            J1 and zero points of J0\n!\n\n  use GKV_header\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random\n\n  integer, parameter :: ifnc = 99! unit number preserved \n                                 ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n    integer :: ierr\n!\n    real(kind=DP),external :: s17aef\n!\n\n!     call dbj0( x, j0, ierr )\n      ierr = 0\n      j0 = s17aef(x,ierr) \n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1 .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n    integer :: ierr\n!\n    real(kind=DP),external :: s17aff\n!\n\n!     call dbj1( x, j1, ierr )\n      ierr = 0\n      j1 = s17aff(x,ierr)\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n    integer :: ierr\n!\n    real(kind=DP),external :: s17aef\n    real(kind=DP),external :: s17aff\n!\n\n!     call dbj1( x, j1, ierr )\n      ierr = 0\n\n      if (x /= 0._DP ) then \n        j2 = 2._DP*s17aff(x,ierr)/x - s17aef(x,ierr)\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n    integer :: ierr\n!\n    real(kind=DP),external :: s18aef\n!\n\n      if( 0._DP <= x .and.  x < 150._DP ) then\n!       call dbi0( x, i0, ierr )\n        ierr = 0\n        i0 = s18aef(x,ierr)\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n!\n    use mkl_vsl\n!\n\n!! --- for MATRIX/MPP\n!!    real(kind=DP), intent(inout), dimension(:) :: rr\n\n! --- for SSL2\n!   real, intent(inout), dimension(:) :: rr\n!\n! --- for MKL\n    real(kind=8), intent(inout), dimension(:) :: rr\n\n    integer :: nr, ierr\n!\n!\n    integer(kind=4),parameter :: iseed = 7777777\n!   integer(kind=4),dimension(1:2),save :: stream\n    type(vsl_stream_state),save :: stream\n    integer(kind=4) :: iflag\n    real(kind=8) :: lb,rb\n!\n    data iflag / 0 /\n!\n      nr = size(rr)\n!    \n      if (iflag==0) then\n!\n!!!!         if ( ns == 1 ) then   \n           ierr = vslNewStream(stream,VSL_BRNG_MT2203,iseed)\n!!!!         else\n!!!!           ierr = vslNewStream(stream,VSL_BRNG_MT2203,iseed)\n!!!!!           ierr = vslNewStream(stream,VSL_BRNG_MT2203+rankg,iseed)\n!!!!         end if     \n!\n         iflag=1\n!\n      end if\n!\n      lb=0.d0\n      rb=1.d0\n      ierr = vdrnguniform(VSL_METHOD_SUNIFORM_STD,stream,nr,rr,lb,rb)\n!\n    return\n\n  END SUBROUTINE math_random\n\n\nEND MODULE GKV_math\n", "MODULE GKV_math\n!\n!  Mathematical functions using SSLII library\n!\n!  This routine uses the unit number of 99 which \n!    should not be overlapped with others\n!\n!  T.-H. Watanabe (Feb 2011)\n!                 (May 2011) with new functions, \n!                            J1 and zero points of J0\n!\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random\n\n  integer, parameter :: DP = selected_real_kind(14)\n  integer, parameter :: ifnc = 99! unit number preserved \n                                 ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n    integer :: ierr\n\n      call dbj0( x, j0, ierr )\n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1 .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n    integer :: ierr\n\n      call dbj1( x, j1, ierr )\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n    real(kind=DP)              :: j0, j1\n    integer :: ierr\n\n      call dbj0( x, j0, ierr )\n      call dbj1( x, j1, ierr )\n\n      if (x /= 0._DP) then \n        j2 = 2._DP*j1/x - j0\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n    integer :: ierr\n\n      if( 0._DP <= x .and.  x < 150._DP ) then\n        call dbi0( x, i0, ierr )\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n\n    real(kind=DP), intent(inout), dimension(:) :: rr\n\n    real(kind=4), dimension(:), allocatable :: rr1\n    integer(kind=4), save :: iseed \n    integer :: nr, ierr\n\n    data iseed / 211501 /\n\n      nr = size(rr)\n\n     !call ranu2( iseed, rr, nr, ierr )\n     !%%% ranu2 is valid for single precision real number %%%\n      allocate( rr1(nr) )\n      call ranu2( iseed, rr1, nr, ierr )\n      rr = real(rr1, kind=DP)\n      deallocate( rr1 )\n\n    return\n\n  END SUBROUTINE math_random\n\n\nEND MODULE GKV_math\n", "gkvp_f0.62                                              S. Maeyama     Mar 2023\n1) equib_type = \"ring\" is added for ring dipole geometry.\n\n2) Rotating flux-tube model is implemented to treat equilibrium shearflows,\n   available for torus: equib_type = \"s-alpha\", \"s-alpha-shift\", \"analytic\",\n   \"circMHD\", \"vmec\", \"igs\". (But not available for \"slab\", \"ring\")\n\n\n\ngkvp_f0.61                                              S. Maeyama     Mar 2021\n1) equib_type = \"s-alpha-shift\" is added. s-alpha model with Shafranov shift.\n\n2) random_seed is applied in lib/gkvp_math_portable.f90.\n\n3) Treat the tracer particle setting (fcs=0).\n\n\n\ngkvp_f0.60                                              S. Maeyama     Feb 2021\n1) NetCDF4+parallel HDF5 is added for optional output of GKV.\n\n\n\ngkvp_f0.59                                              S. Maeyama     Oct 2020\n1) NEC SX-Aurora Makefile/shoot/sub.q are added. Tuned source codes are used.\n\n2) Extension of diag (write NetCDF by out_netcdf.f90)\n\n\n\ngkvp_f0.58                                              S. Maeyama     Oct 2020\n1) Some benchmark data are added.\n\n2) init_randoma, to switch random number for initialization, is added to gkvp_namelist.\n\n\n\ngkvp_f0.57                                              S. Maeyama     Oct 2020\n1) Version number f0.** is removed from filename. \n   *** Update history should be clarified in each module files too. ***\n\n2) A bug at bias factor of collision, nu, is modified in colliimp module.\n\n3) equib_type = \"slab\" is added.\n\n4) Minor debugs:\n  - Padding region iend_y < my is carefully initalized.\n  - menergy(:,:)=0 for beta=0\n  - freq module is modified to support nx0=0.\n\n\n\ngkvp_f0.55                                              S. Maeyama     Dec 2019\n1) freq module is updated for kx /= 0 mode.\n\n2) set module is modified. When s_hat = 0.0, m_j = 0 and kxmin = kymin are enforced.\n\n3) For linear runs, tips_rescale_for_linear_runs are added to avoid divergence\n\n\n\ngkvp_f0.54                                              M. Nakata      Dec 2019\n1) Mean ExB shearing effect in Eulerian approach is added: \"shearflow\" module.  \n\n2) igs module is fixed for reading the tokamak geometry. \n\n\n\ngkvp_f0.53                                              M. Nakata      Jan 2019\n1) vmecbzx (and set) module is fixed for reading the stellarator geometry data for N_tht>1 cases. \n\n\n\ngkvp_f0.52                                              S. Maeyama     Sep 2018\n1) Optimizations for reduced memory usage and efficient commun.-comput. overlap.\n\n\n\n\n\ngkvp_f0.50                                              S. Maeyama     Sep 2017\n1) gkvp_f0.50_colliimp.f90 is added for implicit collision solver.\n\n2) lib/gkvp_f0.50_math_portable.f90 is added.\n\n\n\n\n\ngkvp_f0.48                                              S. Maeyama     Dec 2016\n1) gkvp_f0.48_vmecbzx.f90 is added in stead of gkvp_f0.48_vmecin.f90.\n\n2) Namelist is changed from (r_minor, q_d, n_alp) to (kymin, m_j, del_c).\n\n3) Re-organize output files.\n\n\n\n\n\ngkvp_f0.47                                              S. Maeyama     Nov 2016\n\n1) Triad transfer analysis subroutine trans_triad is added in trans module.\n\n2) math_random in lib/gkvp_f0.47_math_SSL2.f90 has been extended for double precision.\n\n\n\n\n\ngkvp_f0.46                                              S. Maeyama     May 2016\n\n1) 0-padding in bndry module is modified, for the case nzb>=3, z_bound=outflow.\n\n2) Remove OpenMP NOWAIT directive in intgrl module, which is the cause of\n   a error in the reduction against iv, im.\n\n3) Remove OpenMP NOWAIT directive in colli module, which is the cause of \n   a error in the reduction against is2. (This modification introduces the\n   implicit barrier synchronization among OpenMP threads, and thus prevent \n   computation-communication overlap by using OpenMP MASTER thread.\n   Improvement is required.)\n\n4) Step-job script \"shoot\" is added.\n\n5) Transform between ff and hh is contained in fld_ff2hh and fld_hh2ff.\n\n6) z_calc and art_diff is added in namelist.\n\n\n\n\n\ngkvp_f0.45                                               M. Nakata    July 2015\n\nModification from previous f0.40 ver. (Nakata July2015) \n\n1) OMP directives are corrected in colli-module: nowait-directive was missing.\n\n2) Overlap procedures in are corrected in caldlt_full routine in advnc-module: \nThe GK field-particle and non-isothermal collision terms are calculated together in GK_colli_CF_DT. \n\n3) dtc-module is upgraded so as to include the velocity-dependent collision frequency: \nHOWEVER, it is not always good time-step estimation due to the steepness of e-i collision frequency.  \n\n4) Neglect \"ic2zero\" flag in namelist: this was just for debug. \n\n5) calc_dh in advnc-module is modified: same as f0.30\n \n", "# GyroKinetic Vlasov simulation code: GKV\n\nGKV is an Vlasov simulation code based on delta-f gyrokinetic equations in a local flux-tube geometry. The code has been developed for analyzing plasma turbulence in magnetized plasmas, such as magnetic fusion and magnetosphere. The released version includes several key features: kinetic electrons/ions/impurities, electromagnetic fluctuations, MHD equilibrium interfaces, and a multi-species collision operator. The computational performance has been confirmed to achieve excellent strong scaling up to ~0.6 million cores.\n\n\n\n### License and Copyright\nCopyright (c) GKV Developers, since 2006.  \nGKV is a free software WITHOUT WARRANTY OF ANY KIND. You can use, redistribute, and modify it under the term of the GNU General Public License.\n\nWe politely request that you cite the original GKV paper when you use GKV in publications:\n\nTomo-Hiko Watanabe, and Hideo Sugama, \u201cVelocity-space structures of distribution function in toroidal ion temperature gradient turbulence\u201d, Nuclear Fusion, Vol. 46, No. 1, 24 (2006).\n\n\n\n### GKV homepage\nhttps://www.p.phys.nagoya-u.ac.jp/gkv/\n\nDocumentation is available.\n", "Updated for gkvp_f0.62                                  S. Maeyama   March 2023\nUpdated for gkvp_f0.61                                  S. Maeyama   March 2021\nUpdated for gkvp_f0.55                                   M. Nakata     Dec 2019\nUpdated for gkvp_f0.50                                  S. Maeyama     Sep 2017\nUpdated for gkvp_f0.48                                  S. Maeyama     Dec 2016\nUpdated for gkvp_f0.47                                  S. Maeyama     Nov 2016\nUpdated for gkvp_f0.46                                  S. Maeyama     May 2016\nUpdated for gkvp_f0.45                                   M. Nakata    July 2015\nUpdated for gkvp_f0.40                                   M. Nakata    June 2014\nNOTE for gkvp_f0.30                                     S. Maeyama   March 2013\n\n%%% How to run the code %%%\n\n1. make\n2../shoot start_num end_num (JOB_ID)\n\n   Examples: Single job submission (First, *.001)       - ./shoot 1 1\n             Single job submission (Second, *.002)      - ./shoot 2 2\n             Step job submission (from Third to Fifth)  - ./shoot 3 5\n             Sequential job submission                  - ./shoot 6 7 11223\n             (It is the case that there is a Fifth job in queue having \n              JOB_ID=11223, and you continue step jobs from Sixth to Seventh)\n\n\n\n%%% For multi-platforms %%%\n\n1. Create \"shoot\", \"Makefile\" and \"sub.q\" in \"run/\", which have already been\n   prepared for helios(IFERC), k(RIKEN), ps(NIFS), nu(Nagoya), oakleaf(Tokyo).\n2. Set the directory for output \"DIR\" in \"shoot\".\n3. Set node number, elapsed time limit, and so on in \"sub.q\".\n4. Compile and run the code.\n\n\n%%% For numerical and physical settings %%%\n\nGrid number and mpi process number are defined in \"gkvp_f0.50_header.f90\".\n\ncalc_type: \"linear\"    -  for linear runs\n           \"lin_freq\"  -  for linear runs with frequency check\n           \"nonlinear\" -  for nonlinear runs\n\nz_bound: \"zerofixed\"   -  fixed boundary in zz\n         \"outflow\"     -  outflow boundary in zz\n         \"mixed\"       -  outflow boundary in zz only for ff\n\nz_filt: \"on\"           -  enable 4th-order filtering in zz  \n        \"off\"          -  disable it \n\nz_calc: \"cf4\"          -  4th-order central finite difference for df/dz (nzb=2)\n        \"up5\"          -  5th-order upwind finite difference for df/dz (nzb=3)\n\nart_diff:              -  coefficient of artificial diffusion for z_calc=cf4\n\ninit_random:           - Switch on/off random number for initialization.\n\nnum_triad_diag:        - Number of triad transfer diagnostics, which should be \n                         consistent with the number of \"&triad mxt=**,myt=**/\".\n\n&triad mxt=**,myt=**/  - Diagnosed mode number of triad transfer analysis.\n                         Add lines of \"&triad mxt=**,myt=**/\" as desired.\n\nequib_type: \"analytic\" -  Analytic helical field with the metrics in cylinder\n            \"s-alpha\"  -  s-alpha model with alpha = 0 (cylindrical metrics)\n       \"s-alpha-shift\" -  s-alpha model with Shafranov shift\n            \"circ-MHD\" -  Concentric circular field with the consistent metrics \n            \"vmec\"     -  Tokamak/stellarator field from the VMEC code\n            \"eqdsk\"    -  Tokamak field (MEUDAS/TOPICS or G-EQDSK) via IGS code\n            \"slab\"     -  Shearless slab geometry\n            \"ring\"     -  Ring dipole geometry\n\ninum: current shot number\n\nch_res: Change perpendicular resolutions (Settings are somewhat complicated.)\n\nf_log: data directory for log data  \nf_hst: data directory for time-series data  \nf_phi: data directory for field quantity data   \nf_fxv: data directory for distribution function data  \nf_cnt: data directory for continue data  \n\ne_limit: Elapsed time limit [sec]\n\ntend: End of simulation time [L_ref/v_ref]\n\ndtout_fxv, dtout_ptn, dtout_eng: Time spacing for data output\n\ndtout_dtc: Time spacing for time-step-size adaption\n\ndt_max: Maximum time step size\n\nadapt_dt: Time-step-size adaption\n          (If adapt_dt =.false., time step size is set to be dt_max.)\n\ncourant_num: courant number for time-step-size adaption.\n\ntime_advnc: \"rkg4\"      - Explicit time integration by 4th-order Runge-Kutta-Gill method\n            \"imp_colli\" - 2nd-order operator split + 2nd-order implicit collision solver + 4th-order RKG method for collisionless physics\n            \"auto_init\" - If collision restrict linear time step size, time_advnc=\"imp_colli\". Otherwise, time_advnc=\"rkg4\"\n\n!!! NOTE THAT L_ref is set to the major radius on magnetic axis, Raxi, on GKV.!!! \n!!! NOTE THAT m_ref is set to the proton mass, mp, on GKV.!!! \n!!! NOTE THAT e_ref is set to the elementaly charge, e, on GKV.!!! \n!!! NOTE THAT n_ref is set to the local electron density, ne, on GKV.!!! \n!!! NOTE THAT T_ref is set to the first ion temperature, Ti, on GKV.!!! \n!!! NOTE THAT rho_ref is set to the thermal proton gyroradius, rho_tp (with v_ref = vtp = sqrt(Ti/mp)), on GKV.!!! \n\nR0_Ln: normalized density gradient parameter, L_ref/L_ne, L_ref/L_ni,...\n\nR0_Lt: normalized temperature gradient parameterm, L_ref/L_te, L_ref/L_ti,...\n\nnu: bias factor for LB collision model, e.g., 1.d0, 0.5d0, 2.d0,...\n!!! NOTE THAT, after ver. f0.40, the collision frequency is consistently calculated by (Nref, Tref, Lref), \n     and nu is just used as a bias factor only for LB case. Also, nu is not used in multi-species collisions (full).!!!    \n\nAnum: Mass number, m_e/m_ref, m_i/m_ref,...\n\nZnum: Atomic number, |e_e/e_ref|, |e_i/e_ref|,...\n\nfcs: charge fraction, |e_e*n_e/(e_ref*n_ref)|, |e_i*n_i/(e_ref*n_ref)|,...\n!!! NOTE THAT fcs for electron shoud be 1.0, and the summation of fcs over all ion species should also be 1.0.!!!\n\nsgn: sign of chaege, e_e/|e_e|, e_i/|e_i|,...\n\ntau: normalized temperature, T_e/T_ref, T_i/T_ref,...\n!!! NOTE THAT T_i/T_ref = 1 for the first ion species, because T_ref = T_i(first ion) in GKV!!! \n\ndns1: initial perturbation amplitude, (L_ref/rho_ref)*delta-n_e/n_ref, (L_ref/rho_ref)*delta-n_i/n_ref,...\n\ntau_ad: Ti/Te for single species ITG-ae(sgn=+1), Te/Ti for single species ETG-ai(sgn=-1) \n\nlambda_i: ratio of (Debey_length/rho_ref)^2 = epsilon_0*B_ref**2/(m_ref*n_ref)\n\nbeta: local beta value evaluated with B_ref, mu_0*n_ref*T_ref/B_ref*2\n\nibprime:   \"1\"  -  enable a grad-p (finete beta-prime) contribution on the magnetic drift kvd for equib_type = eqdsk\n           \"0\"  -  ignore it \n\nvmax: velocity domain size in the unit of each thermal speed vts, max[v/vts]\n\nnx0: the radial mode number assigned for the initial perturbation \n!!! NOTE that if nx0 exceeds nx, nx0 is reset to nx. \n       A sufficiently large value, thus, gives an uniform pertubation for entire kx-modes.!!!    \n\nmach: not used in f0.55\nuprime: not used in f0.55\n\ngamma_e: mean ExB shearing rate defined by the 2nd-order radial derivative: (1/B_ref)*d^2(Phi)/dx^2 / (V_ref/L_ref) (at x=0: fluxtube center), \n         where Phi(x) is the equilibrium electrostatic potential.\n\nntheta: the length of fluxtube, zz-domain = +/-pi times ntheta\n\nkymin: minimum poloidal wave number\n\nm_j: mode connection number in fluxtube model, kxmin = |2*pi*s_hat*kymin/m_j|\n\ndel_c: mode connection phase in fluxtube model\n\neps_r ~~ malpha : geometrical parameters such as safety factor, B-shear, etc.  \n\n&ring: parameters for ring dipole geometry\n      !  There is a ring current at R=a. The field line passing through (R,Z)=(R0,0) is picked up as a flux-tube domain.\n      !  The reference length is set to be R0 (not the ring current at R=a).\n      !  The reference magnetic field strength is B0 at (R,Z)=(R0,0).\n\nring_a: = a / R0, which specify a flux tube of the ring dipole.\n\nkxmin: Minimum wavenumber in kx, valid only when equib_type == \"ring\"\n\n&vmecp -- &bozxf : parameters for vmec equilibrium\n\n&igsp -- &igsf : parameters for tokamak (g-eqdsk) equilibrium\n\ns_input: reference radial flux surface, rho\n\nmc_type:   \"0\"  -  Axisymmetric\n           \"1\"  -  Boozer\n           \"2\"  -  Hamada\n\nq_type:    \"1\"  -  use consistent q-value on g-eqdsk equilibrium (Recommended)\n           \"0\"  -  use inconsistent, but given q_0 value described above.\n\nnss: the number of radial grids on METRIC data\nntheta: (the number of poloidal grids on METRIC data) + 1 = global_nz*2 + 1\n\nf_igs: file location of METRIC data produced by IGS code\n\n&nu_ref: parameters for collisions  \n\nNref: local electron density in m^-3\nLref: reference length (= Raxi) in m \nTref: main ion temperature in keV\n\ncol_type: \"LB\"      -  Lenard-Bernstein type collision operator \n          \"lorentz\" -  Lorentz model collision operator  \n          \"full\"    -  multi-species linearized collision operator  \n\niFLR:     \"1\"     -  enable the FLR terms (for LB and full)\n          \"0\"     -  disable it (DK-limit)\n\nicheck:   \"0\"     -  for production runs   \n          \"1\"     -  debug test with Maxwellian Annihilation (should be used with IFLR = 0)\n\n\n", "\\documentclass[10pt]{article}\n\\usepackage[utf8]{inputenc}\n\\usepackage[T1]{fontenc}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n\\usepackage{amssymb}\n\\usepackage[version=4]{mhchem}\n\\usepackage{stmaryrd}\n\\usepackage{hyperref}\n\\hypersetup{colorlinks=true, linkcolor=blue, filecolor=magenta, urlcolor=cyan,}\n\\urlstyle{same}\n\\usepackage{graphicx}\n\\usepackage[export]{adjustbox}\n\\graphicspath{ {./images/} }\n\\usepackage{bbold}\n\\usepackage{mathtools}\n\n\\title{GKW how and why }\n\n\\author{C. Angioni, E. Belli and F.J. Casson}\n\\date{}\n\n\n%New command to display footnote whose markers will always be hidden\n\\let\\svthefootnote\\thefootnote\n\\newcommand\\blfootnotetext[1]{%\n  \\let\\thefootnote\\relax\\footnote{#1}%\n  \\addtocounter{footnote}{-1}%\n  \\let\\thefootnote\\svthefootnote%\n}\n\n%Overriding the \\footnotetext command to hide the marker if its value is `0`\n\\let\\svfootnotetext\\footnotetext\n\\renewcommand\\footnotetext[2][?]{%\n  \\if\\relax#1\\relax%\n    \\ifnum\\value{footnote}=0\\blfootnotetext{#2}\\else\\svfootnotetext{#2}\\fi%\n  \\else%\n    \\if?#1\\ifnum\\value{footnote}=0\\blfootnotetext{#2}\\else\\svfootnotetext{#2}\\fi%\n    \\else\\svfootnotetext[#1]{#2}\\fi%\n  \\fi\n}\n\n\\begin{document}\n\\maketitle\nA.G. Peeters, R. Buchholz, Y. Camenen, F.J. Casson, S. Grosshauser, W.A. Hornsby, P. Manas, P. Migliano, M. Siccinio, A.P. Snodin, D. Strintzi, T. Sung, G. Szepesi, D. Zarzoso\n\nUpdated in 2015, work in progress. ${ }^{1}$\n\n\\section*{Preface}\nThis documentation comes with the GKW code. It is largely based on our 2009 paper in Computer Physics Communications Ref. [1], but contains additional material and descriptions of additional features that the code has aquired since that paper. In this manual GKW is presented with the aim of documenting the exact equations solved, presenting the essential benchmarks which document the proper numerical solution, and explaining the code structure and installation. This document is evolving along with the code, and currency and completeness presently take precedence over integration and polish of all sections. GKW developers are strongly urged to update this document (doc.tex) to reflect changes made in the code repository.\n\n\\section*{What is GKW?}\nGyrokinetic Workshop (GKW) is a code for the simulation of microinstabilities and turbulence in a magnetically confined plasma. The gyrokinetic model is is five dimensional partial differential equation and its solution requires a massively parallel approach. GKW is written in Fortran 95 and has been parallelised using MPI, which enables it to scale well up to $32768+$ cores. The code was initially developed at the University of Warwick in 2007 through the extension of the linear code LINART [2], and can be used both in the linear as well as in the nonlinear regime. In 2016 it has been renamed from 'Gyrokinetics at Warwick' to 'Gyrokinetic Workshop', to reflect the nonlocality of its developers and users. The code has been freely available online since 2010, and has been hosted at \\href{https://bitbucket.org/gkw/gkw}{https://bitbucket.org/gkw/gkw}, since 2015, where it is actively maintained.\n\n\\section*{Can I use GKW?}\nYou can obtain and use GKW for any purpose with minimal restrictions. Essentially you can make any changes to the source, and are not obliged to inform us or communicate these changes back to us (although we would welcome it if you did). Furthermore, you are free to redistribute the code to others under the terms of the license (see the LICENSE file), which is the GNU General Public License version 3.\n\nWe politely request that the effort made by us is recognised. In any publication that uses the results of GKW, either directly or indirectly, you should cite the CPC paper [1]. (If you want to be kind to us you could additionally cite the original LINART paper Ref. [2] and/or the first paper in which GKW has been used Ref. [3]).\n\n\\section*{References}\n\\begin{enumerate}\n  \\item A.G. Peeters, Y. Camenen, F.J. Casson, W.A. Hornsby, A.P. Snodin, D. Strintzi, G. Szepesi, Computer Physics Communications, 180, 2650, (2009)\n  \\item A.G. Peeters, D. Strintzi, Phys. Plasmas 11, 3748, (2004)\n  \\item A.G. Peeters, C. Angioni, D. Strintzi, Phys. Rev. Lett. 98, 265003, (2007)\n\\end{enumerate}\n\n\\section*{What does GKW do?}\nGKW aims at solving the turbulent transport problem arising in tokamak plasmas. It solves the gyrokinetic (the kinetic Vlasov equation averaged over the fast gyro-motion) equation on a fixed grid in the 5-dimensional space using a combination of finite difference and pseudo spectral methods. The solution of the kinetic equations governing this problem is an active area of research, with many groups worldwide contributing. The two approaches used are Particle in Cell (PIC) codes $[4,5,6,7,8,9,10]$, and Vlasov codes $[11,12,13,14,15]$. GKW obviously falls in the latter category, and reaches a standard that can be expected from a modern Vlasov code, i.e. it includes kinetic electrons, a general description of the geometry with a coupling to a MHD equilibrium solver, electro-magnetic effects, collisions, and the effect of ExB shearing. In addition the physics of toroidal plasma rotation is included through a formulation of the equations in the co-moving system. The physics of rotation is currently an active area of research and many of the applications of GKW have concentrated on the transport of toroidal momentum $[3,17,18,19,20,21,22,23,24]$, the influence of rotation on other transport channels [25, 26], and the interaction between turbulence and islands [27, 28].\n\n\\section*{Code summary}\n\\section*{Licensing provisions: GNU GPLv3}\nProgramming language: Fortran 95\\\\\nRAM: $\\sim 128 \\mathrm{MB}-1 \\mathrm{~GB}$ for a linear run; 25 GB for typical nonlinear kinetic run (30 million grid points).\\\\\nNumber of processors used: 1, although the program can efficiently utilise 4096+ processors (spectral), depending on problem and available computer. 128 processors is reasonable for a typical nonlinear kinetic run on the latest x86-64 machines. The nonspectral scheme can efficiently scale to $32768+$ processors.\n\nExternal routines/libraries: None required, although the functionality of the program is somewhat limited without a MPI implementation (preferably MPI-2) and the FFTW3 library. In addition, the nonspectral and implicit schemes require the UMFPACK and AMD libraries, and the eigenvalue solver requires the SLEPc and PETSc libraries.\n\nStandard solution method: Pseudo-spectral and finite difference with explicit time integration.\\\\\nRunning time: (On recent x86-64 hardware) 5 minutes for a short linear problem; 4000 hours for typical nonlinear kinetic run.\n\nGeometry Interface: The MHD equilibrium code CHEASE [42] is used for the general geometry calculations. This code has been developed in CRPP Lausanne and is not distributed together with GKW, but can be downloaded separately. The geometry module of GKW is based on the version 7.3 of CHEASE, which includes the output for Hamada coordinates.\n\n\\section*{Contents}\n1 Gyrokinetic theory ..... 7\\\\\n1.1 The gyrokinetic framework ..... 7\\\\\n1.2 Lagrangian ..... 8\\\\\n1.3 The gyrokinetic equation ..... 9\\\\\n1.4 Fully electromagnetic gyrokinetic equation ..... 11\\\\\n1.4.1 Gyrokinetic field equations ..... 13\\\\\n1.4.2 Field equations in GKW ..... 13\\\\\n2 Gyrokinetic practice ..... 15\\\\\n2.1 Normalisations ..... 15\\\\\n2.2 Geometry ..... 16\\\\\n2.2.1 $\\mathrm{s}-\\alpha$ ..... 18\\\\\n2.2.2 Circular geometry ..... 19\\\\\n2.2.3 Miller geometry ..... 23\\\\\n2.2.4 Sheared slab geometry ..... 33\\\\\n2.2.5 General geometry ..... 35\\\\\n2.2.6 Summary of the sign conventions in GKW ..... 36\\\\\n2.3 Spectral representation ..... 36\\\\\n2.4 The complete set of equations ..... 39\\\\\n3 Collisions ..... 42\\\\\n3.1 Collisions tutorial ..... 45\\\\\n3.1.1 Pitch-angle scattering ..... 45\\\\\n3.1.2 Energy scattering ..... 45\\\\\n3.1.3 Collisional friction ..... 46\\\\\n3.2 Velocity space boundary conditions ..... 46\\\\\n3.3 User defined collision-frequencies ..... 46\\\\\n3.4 Direct benchmarks ..... 48\\\\\n4 Rotation and poloidal asymmetries ..... 51\\\\\n4.1 Centrifugal potential ..... 51\\\\\n4.2 Background $E \\times B$ shear flow ..... 53\\\\\n4.3 Purely toroidal sheared rotation in general geometry ..... 55\\\\\n4.3.1 In comoving frame ..... 55\\\\\n4.3.2 Relation to lab frame ..... 56\\\\\n4.4 Poloidal asymmetries induced by anisotropic minorities ..... 56\\\\\n4.4.1 Reinke model ..... 57\\\\\n4.4.2 Bilato model ..... 57\\\\\n4.4.3 Transformations of input parameters ..... 58\\\\\n4.4.4 Implementation ..... 58\\\\\n5 Tearing modes ..... 61\\\\\n5.1 Spectral implementation of magnetic islands in toroidal geometry ..... 61\\\\\n5.2 Spectral implementation of islands in 2D sheared slab geometry ..... 63\\\\\n5.3 Nonspectral implementation of a magnetic island ..... 65\\\\\n5.4 Reconstruction of flux tube radial profiles and profile flattening in GKW ..... 66\\\\\n5.4.1 Density profiles ..... 66\\\\\n5.4.2 Pressure profiles ..... 67\\\\\n5.5 Frozen electrons ..... 68\\\\\n5.6 Dependence of the electrostatic potential on the island rotation frequency ..... 69\\\\\n6 Eigenvalue solver ..... 72\\\\\n6.1 Usage ..... 72\\\\\n6.2 Technical details ..... 76\\\\\n6.2.1 The actual eigenvalue problem ..... 77\\\\\n6.2.2 Transformation between eigenvalue and growth rate/frequency ..... 77\\\\\n6.2.3 User defined routines ..... 78\\\\\n6.3 FAQ ..... 78\\\\\n7 The non-spectral and global version of the code ..... 80\\\\\n7.1 Basic equation ..... 80\\\\\n7.1.1 Local limit ..... 83\\\\\n7.1.2 Toroidal momentum conservation ..... 84\\\\\n7.2 Normalization ..... 85\\\\\n7.3 The velocity nonlinearity ..... 88\\\\\n7.4 Krook operator ..... 88\\\\\n7.5 Profile functions in GKW ..... 89\\\\\n7.5.1 Density/Temperature profile option: cosh2 ..... 89\\\\\n7.5.2 Density/Temperature profile option: 'const' ..... 90\\\\\n7.5.3 Density/Temperature profile option: 'exp\\_tanh' ..... 90\\\\\n7.5.4 Density/Temperature profile option: exp\\_poly3 ..... 90\\\\\n7.5.5 Density/Temperature profile option: exp\\_poly6 ..... 91\\\\\n7.5.6 Density/Temperature profile option : orb ..... 91\\\\\n7.5.7 Density/Temperature profile option: 'orb3' ..... 92\\\\\n7.5.8 Density/Temperature profile option: 'tanh' ..... 92\\\\\n7.5.9 q-profile option: parabolic ..... 92\\\\\n7.5.10 q-profile option: parabolic2 ..... 93\\\\\n7.5.11 q-profile option: orb ..... 93\\\\\n7.5.12 q-profile option: wesson ..... 93\\\\\n7.5.13 q-profile option: rexp ..... 93\\\\\n7.5.14 q-profile option: mishchenko ..... 94\\\\\n8 Numerical implementation ..... 95\\\\\n8.1 Derivatives along the magnetic field line and in the parallel velocity direction ..... 95\\\\\n8.2 Boundary conditions along a field line ..... 96\\\\\n8.3 Parallel velocity grid - Trapping condition ..... 97\\\\\n8.4 The collision operator ..... 98\\\\\n8.5 The Fourier representation ..... 99\\\\\n8.6 Time integration ..... 99\\\\\n8.7 Poisson equation ..... 99\\\\\n8.8 Notes on individual routines ..... 101\\\\\n8.8.1 linear\\_terms.f90 ..... 101\\\\\n8.8.2 non\\_linear\\_terms.F90 ..... 103\\\\\n8.9 The code ..... 105\\\\\n8.9.1 Initialisation ..... 105\\\\\n8.9.2 Parallelisation: local grid ..... 106\\\\\n8.9.3 Memory layout and allocation ..... 106\\\\\n8.9.4 Linear terms ..... 107\\\\\n8.10 Code parallelisation ..... 107\\\\\n8.11 Parallel performance (pure MPI), Cray XT4 ..... 108\\\\\n8.12 Parallel performance (hybrid, MPI+OpenMP), BlueGene/P ..... 110\\\\\n8.13 Parallel nonspectral performance (pure MPI), Helios ..... 113\\\\\n9 Obtaining, building and running the code ..... 115\\\\\n9.1 Getting the code ..... 115\\\\\n9.2 Building the source code ..... 115\\\\\n9.2.1 Prerequisites and suggestions ..... 115\\\\\n9.2.2 Using the GNU makefile ..... 116\\\\\n9.2.3 Using the 'simple' makefile ..... 116\\\\\n9.2.4 Some important makefiles ..... 117\\\\\n9.2.5 Potential compilation issues ..... 117\\\\\n9.2.6 Additional libraries ..... 117\\\\\n9.3 Running GKW ..... 118\\\\\n9.3.1 Modes ..... 119\\\\\n9.3.2 Dissipation ..... 120\\\\\n9.3.3 Gridsizes ..... 120\\\\\n9.3.4 Species ..... 121\\\\\n9.3.5 Stability ..... 121\\\\\n9.3.6 $\\beta$ and $\\beta^{\\prime}$ ..... 121\\\\\n9.3.7 Generating a linear growth rate spectrum ..... 122\\\\\n9.3.8 Restarts and checkpoints ..... 123\\\\\n9.3.9 Tips and tricks ..... 124\\\\\n9.3.10 Hybrid scheme ..... 124\\\\\n9.4 Example GKW input file ..... 126\\\\\n10 Diagnostics ..... 127\\\\\n10.1 Fluxes (module diagnos\\_fluxes) ..... 127\\\\\n10.2 Fluxes in more detail (module diagnos\\_fluxes\\_vspace) ..... 128\\\\\n10.3 Growth rates, Frequencies (module diagnos\\_growth\\_freq) and Quasi-linear fluxes ..... 129\\\\\n10.4 Hermitian symmetry of binormal spectra ..... 129\\\\\n10.5 Tips for unit conversions ..... 130\\\\\n10.6 Output grids (module diagnos\\_grid) ..... 131\\\\\n10.7 Summary: diagnostic outputs and their data format ..... 131\\\\\n10.7.1 Mode structure (module diagnos\\_mode\\_struct) ..... 138\\\\\n10.8 Island torque and stabilization by the parallel current ..... 139\\\\\n10.9 Entropy (module diagnos\\_energetics and diagnos\\_eng) ..... 140\\\\\n10.9.1 Definition of the Total Entropy of the Simulated Box ..... 140\\\\\n10.9.2 Entropy Balance ..... 141\\\\\n10.9.3 Resulting entropy balance equation ..... 143\\\\\n10.9.4 Output quantities of the diagnostic ..... 143\\\\\n11 Benchmarks ..... 145\\\\\n11.1 Linear Benchmarks ..... 145\\\\\n11.2 Nonlinear benchmarks ..... 149\\\\\n11.2.1 Global Benchmarks ..... 151\\\\\nA Geometry - generalised ..... 153\\\\\nA. 1 Field aligned Hamada coordinates ..... 153\\\\\nA. 2 Caculating the Geometry tensors from the metric tensor and derivatives of coordinates and magnet\\\\\nA. 3 Periodicity ..... 156\\\\\nA. 4 Shifted metric ..... 157\\\\\nA. 5 Summary of the sign conventions in GKW ..... 158\\\\\nA. 6 Flux surface average ..... 159\\\\\nA.6.1 General ..... 159\\\\\nA.6.2 GKW coordinates ..... 159\\\\\nA.6.3 Alternative expression ..... 160\\\\\nA. 7 Use of fluxes in transport equations ..... 160\\\\\nB Transformation of transport coefficients in presence of poloidal asymmetries ..... 161\\\\\nB.0.1 Anisotropic minorities (Reinke model) ..... 165\\\\\nB.0.2 Anisotropic minorities (Bilato model)\n\n\\section*{Chapter 1}\n\\section*{Gyrokinetic theory}\n\\subsection*{1.1 The gyrokinetic framework}\nThe starting point of the equation for the evolution of the distribution function is the gyrokinetic theory formulated in Refs [29, 30, 31, 32]. In GKW these equations are solved up to first order in the Larmor radius over the major radius $\\rho_{*} \\ll 1$ (with the exception of the polarisation which enters in the field equations). In order to determine which of the terms in the original formulation of the theory (which is accurate up to second order in $\\rho_{*}$ ) must be kept, we will here briefly discuss the ordering. More details can be found in Ref. [20].\n\nA thermal velocity $\\left(v_{\\text {th }}\\right)$ and a major radius $(R)$ are used to normalise the length and time scales. For the gradients we assume\n\n\n\\begin{equation*}\nR \\nabla_{\\|} \\approx 1 \\quad R \\nabla_{\\perp} \\approx 1 / \\rho_{*} \\tag{1.1}\n\\end{equation*}\n\n\ni.e. the solution is assumed to have a length scale of the order of the system size along the field, but can have a length scale of the order of the Larmor radius perpendicular to the magnetic field. This difference in length scales means that the convecting velocities must be evaluated to a different order parallel and perpendicular to the field. The velocity along the field is to be evaluated in lowest order only (i.e. of the order of $v_{\\text {th }}$ ), but the perpendicular velocity must be evaluated up to first order (order $\\rho_{*} v_{\\mathrm{th}}$ ). In GKW the perturbations in the electro-static potential $\\phi$ as well as the vector potential $\\mathbf{A}$ are retained. For the latter it is, however, assumed that\n\n\n\\begin{equation*}\n\\mathbf{A}=A_{\\|} \\mathbf{b} \\tag{1.2}\n\\end{equation*}\n\n\nwhere $\\mathbf{b}$ is the unit vector in the direction of the unperturbed magnetic field. The assumption above means that no compressional effects of the magnetic field are retained in the description. Compressional effects are currently implemented in the code but are not yet described here. Note that the vector potential above is the perturbed vector potential not to be confused with the one connected with the equilibrium magnetic field. The equations will be formulated in the co-moving system of a toroidally rotating plasma. The $E \\times B$ drift velocity connected with this toroidal rotation is of the order of the thermal velocity in the laboratory frame, but the transformation to the co-moving frame removes this largest order $E \\times B$ velocity from the equations $[20,51]$. The transformation to the co-moving frame also introduces a background centrifugal potential $\\Phi$. The perturbed potential $\\phi$, perturbed vector potential $A_{\\|}$, and background potential $\\Phi$ in the co-moving frame can then be taken to be of the order\n\n\n\\begin{equation*}\n\\phi \\approx \\frac{T}{e} \\rho_{*} \\quad A_{\\|} \\approx \\frac{T}{e v_{\\mathrm{th}}} \\rho_{*} \\quad \\Phi \\approx \\frac{T}{e} \\tag{1.3}\n\\end{equation*}\n\n\nwhere $T$ is the temperature, and $e$ is the elementary charge. Since $\\Phi$ is an equilibrium quantity, the length scale of any variation is assumed large compared to the Larmor radius, whilst the perturbed quantities may have perpendicular gradient length scales on the order of the Larmor radius. The field gradients can then\\\\\nbe shown to be of the same order, with $\\nabla_{\\perp} \\phi \\approx \\nabla_{\\perp} \\Phi$. From these assumptions it can be derived that the $E \\times B$ velocity is of the order $\\rho_{*} v_{\\mathrm{th}}$.\n\nGyro-centre coordinates $\\left(\\mathbf{X}, \\mu, v_{\\|}\\right)$are used, with $\\mathbf{X}$ being the gyro-centre position, $v_{\\|}$the parallel (to the magnetic field) velocity, and $\\mu$ the magnetic moment $\\mu=m v_{\\perp}^{2} / 2 B$. Here $v_{\\perp}$ is the velocity component perpendicular to the equilibrium magnetic field $\\mathbf{B}, m$ is the particle mass and $B$ is the magnetic field strength. The magnetic moment is an invariant of motion, but the parallel velocity changes due to the electric field acceleration and mirror force. It turns out that for consistency one needs to keep both the lowest as well as the first order (in $\\rho_{*}$ ) contribution to the acceleration.\n\nFinally, the approximation known as the $\\delta f$ approximation is employed. This approximation assumes that the perturbed distribution $f$ is much smaller than the background distribution $F$, but has a perpendicular length scale of the order of the Larmor radius whereas the background varies on the length scale of the system size:\n\n\n\\begin{equation*}\nf \\approx \\rho_{*} F \\quad \\frac{\\partial f}{\\partial v_{\\|}} \\approx \\rho_{*} \\frac{\\partial F}{\\partial v_{\\|}} \\quad \\nabla f \\approx \\nabla F . \\tag{1.4}\n\\end{equation*}\n\n\nThe ordering assumption above removes the 'velocity non-linearity' (combinations of the electro-magnetic fields and the velocity space derivative of the perturbed distribution) from the evolution equation of the perturbed distribution. The disadvantage is that strict energy conservation no longer applies.\n\nWith the help of these approximations the gyrokinetic equation of Refs. [29, 31, 32] can be rewritten.\n\n\\subsection*{1.2 Lagrangian}\n(This section is not in the CPC paper which instead refers to Ref. [20] which contains the full derivation with centrifugal effects.) (CHECK CONSISTENCY)\n\nThe starting point is the Lagrangian\n\n\n\\begin{equation*}\n\\gamma=\\left(\\frac{e}{c} \\mathbf{A}+\\frac{e}{c} A_{\\|} \\mathbf{b}+m \\mathbf{v}\\right) \\cdot d \\mathbf{x}-\\left(\\frac{m}{2} v^{2}+e \\phi\\right) d t \\tag{1.5}\n\\end{equation*}\n\n\nThe coordinates are transformed into guiding center coordinates. The electrostatic guiding center Lagrangian is known, and can be found in Hahm 1988 [30]. For the magnetic perturbations we take that\n\n\n\\begin{equation*}\nA_{\\|}(\\mathbf{X}+\\rho) \\mathbf{b} \\cdot d(\\mathbf{X}+\\rho) \\tag{1.6}\n\\end{equation*}\n\n\nwhere $\\rho=\\rho(\\mathbf{X}, \\mu, \\theta)$. All the derivatives of $\\rho$ will give vectors perpendicular to the magnetic field. Thus if there is not a perpendicular magnetic potential perturbation, the only term that survives is\n\n$$\nA_{\\|} \\mathbf{b} \\cdot d \\mathbf{X}\n$$\n\nThen the guiding center Lagrangian is\n\n\n\\begin{equation*}\n\\gamma=\\left(\\frac{e}{c} \\mathbf{A}+\\frac{e}{c} A_{\\|} \\mathbf{b}+m v_{\\|} \\mathbf{b}\\right) \\cdot d \\mathbf{X}+\\mu d \\theta-\\left(\\frac{m}{2} v_{\\|}^{2}+\\mu B+e \\phi\\right) d t \\tag{1.7}\n\\end{equation*}\n\n\nThis Lagrangian is transformed in the gyrocenter coordinates with the Lie transforms. To the first order, if there are no perpendicular perturbations in the magnetic potential, we can just substitute the perturbations of the fields with the respective gyroaveraged quantities. This can also be derived rigorously with the Lie transforms. The new Lagrangian will be\n\n\n\\begin{equation*}\n\\Gamma=\\left(\\frac{e}{c} \\mathbf{A}+\\frac{e}{c}<A_{\\|}>\\mathbf{b}+m v_{\\|} \\mathbf{b}\\right) \\cdot d \\mathbf{X}+\\mu d \\theta-\\left(\\frac{m}{2} v_{\\|}^{2}+\\mu B+e<\\phi>\\right) d t \\tag{1.8}\n\\end{equation*}\n\n\nwhere now $\\mathbf{X}, \\mu, v_{\\|}, \\theta$ are the gyrocenter coordinates. From this one can derive the equations of motion using the Euler Lagrange equations\n\n\n\\begin{equation*}\n\\omega_{i j} \\frac{d z^{j}}{d t}=\\frac{\\partial H}{\\partial z^{i}}-\\frac{\\partial \\gamma_{i}}{\\partial t} \\tag{1.9}\n\\end{equation*}\n\n\nwhere $H$ is the Hamiltonian and\n\n\n\\begin{equation*}\n\\omega_{i j}=\\frac{\\partial \\gamma_{j}}{\\partial z^{i}}-\\frac{\\partial \\gamma_{i}}{\\partial z^{j}} \\tag{1.10}\n\\end{equation*}\n\n\nare the Lagrange brackets.\\\\\nThe Lagrange brackets that are of interest are\n\n\n\\begin{gather*}\n\\omega_{X_{i} X_{j}}=\\frac{e}{c} \\epsilon_{i j k} \\hat{B}_{k}  \\tag{1.11}\\\\\n\\omega_{\\mathbf{X} U}=-m \\mathbf{b} \\tag{1.12}\n\\end{gather*}\n\n\nwhere\n\n\n\\begin{equation*}\n\\hat{\\mathbf{B}}=\\nabla \\times \\mathbf{A}+\\nabla \\times A_{\\|} \\mathbf{b}+\\frac{m c}{e} v_{\\|} \\nabla \\times \\mathbf{b} \\tag{1.13}\n\\end{equation*}\n\n\nChoosing $i=U$ we get that\n\n\n\\begin{equation*}\nm \\mathbf{b} \\cdot \\dot{\\mathbf{X}}=m v_{\\|} \\tag{1.14}\n\\end{equation*}\n\n\nChoosing $i=\\mathbf{X}$ we get that\n\n\n\\begin{equation*}\nm \\dot{v}_{\\|} \\mathbf{b}-\\frac{e}{c} \\dot{\\mathbf{X}} \\times \\hat{\\mathbf{B}}=-e \\nabla<\\phi>-\\mu \\nabla B-\\frac{e}{c} \\frac{\\partial<A_{\\|}>}{\\partial t} \\mathbf{b} \\tag{1.15}\n\\end{equation*}\n\n\nand taking that\n\n\n\\begin{equation*}\n\\mathbf{E}=-\\nabla \\phi-\\frac{1}{c} \\frac{\\partial<A_{\\|}>}{\\partial t} \\mathbf{b} \\tag{1.16}\n\\end{equation*}\n\n\nwe get that\n\n\n\\begin{equation*}\nm \\dot{v}_{\\|} \\mathbf{b}-\\frac{e}{c} \\dot{\\mathbf{X}} \\times \\hat{\\mathbf{B}}=e \\mathbf{E}-\\mu \\nabla B \\tag{1.17}\n\\end{equation*}\n\n\nWe can cross this equation with $\\mathbf{b}$ to derive the equation for $\\dot{X}$. To derive the equation of GKW we have to approximate\n\n\n\\begin{equation*}\n\\nabla \\times\\left(<A_{\\|}>\\mathbf{b}\\right) \\approx \\nabla\\left(<A_{\\|}>\\right) \\times \\mathbf{b} \\tag{1.18}\n\\end{equation*}\n\n\nThen the equation of $\\dot{X}$ is.\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}=v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}+\\mathbf{v}_{E}+\\mathbf{v}_{\\delta B_{\\perp}} \\tag{1.19}\n\\end{equation*}\n\n\nTo derive the equation for $v_{\\|}$we dot with $\\dot{X}$. This gives\n\n\n\\begin{equation*}\nm v_{\\|} \\dot{v}_{\\|}=\\dot{\\mathbf{X}} \\cdot(e \\mathbf{E}-\\mu \\nabla B) \\tag{1.20}\n\\end{equation*}\n\n\n\\subsection*{1.3 The gyrokinetic equation}\nIn a rigidly rotating frame, the evolution of equation for the gyro-centre position $\\mathbf{X}$, and the parallel velocity are [20]\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}=v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}+\\mathbf{v}_{\\chi}, \\quad m v_{\\|} \\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t}=\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot\\left[Z e \\mathbf{E}-\\mu \\nabla B+m \\Omega^{2} R \\nabla R\\right], \\quad \\frac{\\mathrm{d} \\mu}{\\mathrm{~d} t}=0 \\tag{1.21}\n\\end{equation*}\n\n\nHere $Z$ is the particle charge, $R$ the local major radius, and $\\Omega$ the frame rotation frequency. $\\mathbf{E}$ is the gyro-averaged perturbed electric field plus the inertial electric field\n\n\n\\begin{equation*}\n\\mathbf{E}=-\\nabla\\langle\\phi\\rangle-\\frac{\\partial\\left\\langle A_{\\|}\\right\\rangle}{\\partial t} \\mathbf{b}-\\nabla\\langle\\Phi\\rangle \\tag{1.22}\n\\end{equation*}\n\n\nwhere the angle brackets denote the gyro-average. Since $\\Phi$ is an equilibrium quantity, the scale lengths of any variation are assumed large compared to the Larmor radius and we neglect the gyroaverage, taking $\\Phi \\approx\\langle\\Phi\\rangle$. (The full details of the calculation of $\\Phi$ are given in Sec. 4.1).\n\nThe velocities in Eq. 1.21 are from left to right: the parallel motion along the unperturbed field $\\left(v_{\\|} \\mathbf{b}\\right)$, the drift motion due to the inhomogeneous field $\\left(\\mathbf{v}_{D}\\right)$, and\n\n\n\\begin{equation*}\n\\mathbf{v}_{\\chi}=\\frac{\\mathbf{b} \\times \\nabla \\chi}{B} \\quad \\text { with } \\quad \\chi=\\langle\\phi\\rangle-v_{\\|}\\left\\langle A_{\\|}\\right\\rangle, \\tag{1.23}\n\\end{equation*}\n\n\nwhich is the combination of the $E \\times B$ velocity $\\left(\\mathbf{v}_{E}=\\mathbf{b} \\times \\nabla\\langle\\phi\\rangle / B\\right)$ and the parallel motion along the perturbed field line $\\left(\\mathbf{v}_{\\delta B}=-\\mathbf{b} \\times \\nabla v_{\\|}\\left\\langle A_{\\|}\\right\\rangle / B\\right)$. The drifts due to the inhomogeneous magnetic field and inertial terms can be written in the form\n\n\n\\begin{equation*}\n\\mathbf{v}_{D}=\\frac{1}{Z e}\\left[\\frac{m v_{\\|}^{2}}{B}+\\mu\\right] \\frac{\\mathbf{B} \\times \\nabla B}{B^{2}}+\\frac{m v_{\\|}^{2}}{2 Z e B} \\beta^{\\prime} \\mathbf{b} \\times \\nabla \\psi+\\frac{2 m v_{\\|}}{Z e B} \\boldsymbol{\\Omega}_{\\perp}+\\frac{1}{Z e B} \\mathbf{b} \\times \\nabla \\mathcal{E}_{\\Omega} \\tag{1.24}\n\\end{equation*}\n\n\nIn the equation above $\\psi$ is a radial coordinate (flux label) and $\\boldsymbol{\\Omega}_{\\perp}$ is the angular (toroidal) rotation vector perpendicular to the field, i.e. $\\boldsymbol{\\Omega}_{\\perp}=\\boldsymbol{\\Omega}-(\\boldsymbol{\\Omega} \\cdot \\mathbf{b}) \\mathbf{b}$. The first term on the right is the combination of the grad-B drift and curvature drift in the low beta approximation, whereas the second term, involving\n\n\n\\begin{equation*}\n\\beta^{\\prime}=\\frac{2 \\mu_{0}}{B^{2}} \\frac{\\partial p}{\\partial \\psi} \\tag{1.25}\n\\end{equation*}\n\n\nis the correction to the curvature drift due to the modification of the equilibrium associated with the pressure gradient. The penultimate term is the Coriolis drift derived in Ref. [3] using the formulation of the gyrokinetic equations in the co-moving frame [35]. The formulation of Ref. [3] was extended in Refs. [20, 51] to include the centrifugal force, and the first centrifugal results were published in Refs. [26, 51]. The last term combines the centrifugal drift and background potential in the (species dependent) centrifugal energy\n\n\n\\begin{equation*}\n\\mathcal{E}_{\\Omega}=Z e \\Phi-\\frac{1}{2} m \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right) \\tag{1.26}\n\\end{equation*}\n\n\nwhere $R_{0}$ is the major radius of the point on the flux surface at which the densities are defined.\\\\\nFrom the equations above the gyrokinetic equation in ( $\\mathbf{X}, v_{\\|}, \\mu$ ) coordinates can be derived: [29, 20]\n\n\n\\begin{equation*}\n\\frac{\\partial f_{\\mathrm{tot}}}{\\partial t}+\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\nabla_{\\mu} f_{\\mathrm{tot}}+\\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t} \\frac{\\partial f_{\\mathrm{tot}}}{\\partial v_{\\|}}=0 \\tag{1.27}\n\\end{equation*}\n\n\nThe distribution function $f_{\\text {tot }}$ in this equation is split in a background $F$ and a perturbed distribution $f$. As discussed in Section 1.1 the $\\delta f$ approximation will be employed. Consequently, the equation for $f$ can be written in the form [20]\n\n\n\\begin{equation*}\n\\frac{\\partial f}{\\partial t}+\\left(v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}+\\mathbf{v}_{\\chi}\\right) \\cdot \\nabla f-\\frac{\\mathbf{b}}{m} \\cdot\\left(\\mu \\nabla B+\\nabla \\mathcal{E}_{\\Omega}\\right) \\frac{\\partial f}{\\partial v_{\\|}}=S \\tag{1.28}\n\\end{equation*}\n\n\nwhere $S$ is determined by the background distribution function. The latter is assumed to be a Maxwellian $\\left(F_{M}\\right)$, with temperature $(T)$ and mean parallel velocity $\\left(u_{\\|}\\right)$being functions of the radial coordinate only. In the case of a rotating plasma the density in the flux surface varies as $n(\\theta)=n_{R_{0}} \\exp \\left(-\\mathcal{E}_{\\Omega}(\\theta) / T\\right)$ and is kept in the solution of the equilibrium equation [20].\n\n\n\\begin{equation*}\nF=F_{M}=\\frac{n_{R_{0}}}{\\pi^{3 / 2} v_{\\mathrm{th}}^{3}} \\exp \\left[-\\frac{\\left(v_{\\|}-\\left(R B_{t} / B\\right) \\omega_{\\phi}\\right)^{2}+2 \\mu B / m}{v_{\\mathrm{th}}^{2}}-\\mathcal{E}_{\\Omega} / T\\right] \\tag{1.29}\n\\end{equation*}\n\n\nHere $v_{\\mathrm{th}} \\equiv \\sqrt{2 T / m}$ is the thermal velocity (note that in this area of research the thermal velocity is usually defined without the $\\sqrt{2}$ factor). The appearance of an explicit rotation velocity $u_{\\|}$in the Maxwellian may\\\\\nbe confusing since the equations are formulated in the co-moving system in which the rotation vanishes. However, under experimental conditions the plasma rotation $\\omega(\\phi)$ has a radial gradient while the frame is chosen to rotate as a rigid body with a constant angular frequency $\\Omega$. Indeed a differential rotation of the frame would be impractical since the distance between two fixed points in the co-moving system would increase in time, i.e. the metric would be time dependent.\n\nThe local model constructed here chooses the rotation of the frame to be equal to the plasma rotation at one particular radius. Therefore $\\omega_{\\phi}$ in the above Maxwellian is zero at the radial location considered, but has a finite radial gradient. This gradient will enter the equations as $\\nabla \\omega_{\\phi}$. (for more details see Ref. [20]).\n\nThe term containing the derivative of the vector potential towards time presents a numerical difficulty. In the $\\delta f$ formalism it can, however, easily be combined with the time derivative of $f$. If one defines a 'new' distribution $g$\n\n\n\\begin{equation*}\ng=f+\\frac{Z e}{T} v_{\\|}\\left\\langle A_{\\|}\\right\\rangle F_{M} \\tag{1.30}\n\\end{equation*}\n\n\nand replaces the time derivative of $f$ in the gyrokinetic equation with the time derivative of $g$, the cumbersome time derivative of $\\left\\langle A_{\\|}\\right\\rangle$is removed. Using the equations above one arrives at the following equation for the distribution function $g$\n\n", "\n\\begin{equation*}\n\\frac{\\partial g}{\\partial t}+\\mathbf{v}_{\\chi} \\cdot \\nabla g+\\left(v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}\\right) \\cdot \\nabla f-\\frac{\\mathbf{b}}{m} \\cdot\\left(\\mu \\nabla B+\\nabla \\mathcal{E}_{\\Omega}\\right) \\frac{\\partial f}{\\partial v_{\\|}}=S \\tag{1.31}\n\\end{equation*}\n\n\nwhere $S$ is given by\n\n\n\\begin{equation*}\nS=-\\left(\\mathbf{v}_{\\chi}+\\mathbf{v}_{D}\\right) \\cdot\\left[\\frac{\\nabla n_{R_{0}}}{n_{R_{0}}}+\\left(\\frac{v_{\\|}^{2}}{v_{\\mathrm{th}}^{2}}+\\frac{\\left(\\mu B+\\mathcal{E}_{\\Omega}\\right)}{T}-\\frac{3}{2}\\right) \\frac{\\nabla T}{T}+\\frac{m v_{\\|}}{T} \\frac{R B_{t}}{B} \\nabla \\omega_{\\phi}\\right] F_{M}-\\frac{Z e}{T}\\left[v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}\\right] \\cdot \\nabla\\langle\\phi\\rangle F_{M} \\tag{1.32}\n\\end{equation*}\n\n\nNote that both $g$ and $f$ appear in this equation. Since any form of dissipation on the field variables leads to a numerical instability [15], it is preferable to use $f$ in any term that requires dissipation for stable numerical implementation. It should also be noted here that the Maxwellian is not an exact solution of the gyrokinetic equation in the limit of a zero perturbed electro-magnetic field. From the equation above it follows that $S$ is nonzero due to the drifts connected with the magnetic field inhomogeneity in the gradients of density temperature and velocity. The solution of the evolution equation will determine the deviation away from the Maxwellian as a nonzero perturbed distribution $f$. This perturbation is of the order $\\rho_{*} F_{M}$, and neglecting it as part of the background distribution is consistent with the ordering adopted. The drift term is $\\mathbf{v}_{D}$ in the first term of the equation above is nevertheless implemented in GKW since the perturbation it generates is responsible for the neo-classical transport. All physics and diagnostic of the neo-classical fluxes have been implemented in the code, but the implementation has not been benchmarked and should therefore not be used.\n\nTo close the set of equations, one needs to calculate the potential and vector potential through the (low frequency ordering) Maxwell equations. These have been formulated in the literature, and will be given in Section 7.37 when the full set of equations in normalised form is discussed.\n\n\\subsection*{1.4 Fully electromagnetic gyrokinetic equation}\nIn high beta tokamak plasmas the amplitude of the magnetic perturbations can become significant compared to the fluctuations of the electro-static potential. In such cases electro-magnetic effects should be taken into account in the Vlasov equation for an accurate gyrokinetic simulation. In this section the gyrokinetic Lagrangian, equations of motion, the Vlasov and Maxwell equations are summarized in the fully electromagnetic, collisionless case in a rotating frame of reference. The detailed derivation of the equations can be found in derivation.tex.\n\nThe gyrokinetic Lagrangian is\n\n\n\\begin{align*}\n\\bar{\\Gamma}= & \\left(m v_{\\|} \\mathbf{b}(\\mathbf{X})+Z e \\mathbf{A}_{0}(\\mathbf{X})+m \\mathbf{u}_{0}+Z e\\left\\langle\\mathbf{A}_{1}\\right\\rangle(\\mathbf{X})\\right) \\cdot \\mathrm{d} \\mathbf{X}+\\frac{2 \\mu m}{Z e} \\mathrm{~d} \\theta- \\\\\n& \\left(\\frac{1}{2} m\\left(v_{\\|}^{2}-u_{0}^{2}\\right)+Z e\\left(\\Phi_{0}(\\mathbf{X})+\\langle\\phi\\rangle(\\mathbf{X})\\right)+\\mu\\left(B_{0}(\\mathbf{X})+\\left\\langle B_{1 \\|}\\right\\rangle(\\mathbf{X})\\right)\\right) \\mathrm{d} t \\tag{1.33}\n\\end{align*}\n\n\nwhere $\\langle\\phi\\rangle=J_{0}(\\lambda) \\phi,\\left\\langle\\mathbf{A}_{1}\\right\\rangle=J_{0}(\\lambda) \\mathbf{A}_{1}$ and $\\left\\langle B_{1 \\|}\\right\\rangle=\\hat{J}_{1}(\\lambda) B_{1 \\|}$ are the gyroaveraged field perturbations. b is the unit vector along the equilibrium magnetic field, $\\mathbf{u}_{0}$ is the velocity of the rotating frame of reference, and $\\Phi_{0}$ is the equilibrium electro-static potential due to the plasma rotation. The bar over $\\bar{\\Gamma}$ distinguishes the gyro-centre Lagrangian from its guiding-centre version.\n\nThe equations of motion can be derived from the Euler-Lagrange equations and are written as\n\n\n\\begin{align*}\n\\dot{\\mathbf{X}}= & \\mathbf{b} v_{\\|}+\\frac{m v_{\\|}^{2}}{Z e B_{0}}(\\nabla \\times \\mathbf{b})_{\\perp}+\\frac{\\left\\langle\\mathbf{B}_{1 \\perp}\\right\\rangle}{B_{0}} v_{\\|}-\\frac{1}{B_{0}}\\langle\\mathbf{E}\\rangle \\times \\mathbf{b}+ \\\\\n& \\frac{\\mu}{Z e B_{0}} \\nabla\\left(B_{0}+\\left\\langle B_{1 \\|}\\right\\rangle\\right) \\times \\mathbf{b}+\\frac{2 m v_{\\|}}{Z e B_{0}} \\boldsymbol{\\Omega}_{\\perp}-\\frac{m R \\Omega^{2}}{Z e B_{0}} \\nabla R \\times \\mathbf{b} \\\\\n= & \\mathbf{b} v_{\\|}+\\underbrace{\\mathbf{v}_{\\left\\langle\\mathbf{B}_{1 \\perp}\\right\\rangle}+\\mathbf{v}_{\\langle\\mathbf{E}\\rangle \\times \\mathbf{B}_{0}}+\\mathbf{v}_{\\nabla\\left\\langle B_{1 \\|}\\right\\rangle}}_{\\mathbf{v}_{\\chi}}+\\underbrace{\\mathbf{v}_{\\mathrm{C}}+\\mathbf{v}_{\\nabla \\mathbf{B}_{0}}+\\mathbf{v}_{\\mathrm{co}}+\\mathbf{v}_{\\mathrm{cf}}}_{\\mathbf{v}_{\\mathrm{D}}} \\tag{1.34}\n\\end{align*}\n\n\nwhere $\\boldsymbol{\\Omega}$ is the angular momentum vector associated with the rotation of the reference frame, and\n\n\n\\begin{equation*}\n\\dot{v}_{\\|}=\\frac{\\dot{\\mathbf{X}}}{m v_{\\|}} \\cdot\\left(Z e\\langle\\mathbf{E}\\rangle-\\mu \\nabla\\left(B_{0}+\\left\\langle B_{1 \\|}\\right\\rangle\\right)+\\frac{1}{2} m \\nabla u_{0}^{2}\\right) \\tag{1.35}\n\\end{equation*}\n\n\nThe quantity $\\chi$, related to the drifts due to perturbations of the fields, can be now written as\n\n\n\\begin{equation*}\n\\chi=\\underbrace{\\Phi_{0}+\\langle\\phi\\rangle}_{\\langle\\Phi\\rangle}-v_{\\|}\\left\\langle A_{1 \\|}\\right\\rangle+\\frac{\\mu}{Z e}\\left\\langle B_{1 \\|}\\right\\rangle \\tag{1.36}\n\\end{equation*}\n\n\nand\n\n\n\\begin{equation*}\n\\mathbf{v}_{\\chi}=\\frac{\\mathbf{b} \\times \\nabla \\chi}{B_{0}}=\\mathbf{v}_{\\left\\langle\\mathbf{B}_{1 \\perp}\\right\\rangle}+\\mathbf{v}_{\\langle\\mathbf{E}\\rangle \\times \\mathbf{B}_{0}}+\\mathbf{v}_{\\nabla\\left\\langle B_{1 \\|}\\right\\rangle} . \\tag{1.37}\n\\end{equation*}\n\n\nThe Vlasov equation in presence of magnetic field compression takes the form\n\n\n\\begin{equation*}\n\\frac{\\partial g}{\\partial t}+\\mathbf{v}_{\\chi} \\cdot \\nabla g+\\left(v_{\\|} \\mathbf{b}+\\mathbf{v}_{\\mathrm{D}}\\right) \\cdot \\nabla \\delta f-\\frac{\\mu}{m} \\mathbf{b} \\cdot\\left(\\nabla \\Phi_{0}-m R \\Omega^{2} \\nabla R+\\nabla B_{0}\\right) \\frac{\\partial \\delta f}{\\partial v_{\\|}}=S \\tag{1.38}\n\\end{equation*}\n\n\nwith the source term being\n\n\n\\begin{equation*}\nS=-\\left(\\mathbf{v}_{\\chi}+\\mathbf{v}_{\\mathrm{D}}\\right) \\cdot \\nabla_{p} F_{M}+\\frac{F_{M}}{T}\\left(v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}\\right) \\cdot\\left(-Z e \\nabla\\langle\\phi\\rangle-\\mu \\nabla\\left\\langle B_{1 \\|}\\right\\rangle\\right) \\tag{1.39}\n\\end{equation*}\n\n\nwhere $g$ is the modified distribution function\n\n\n\\begin{equation*}\ng=\\delta f+\\frac{Z e v_{\\|}}{T}\\left\\langle A_{1 \\|}\\right\\rangle F_{\\mathrm{M}} \\tag{1.40}\n\\end{equation*}\n\n\nEquations 1.38 and 1.39 show that there are four new terms appearing due to the inclusion of $B_{1 \\|}$. These are related to the convection of the perturbed distribution function in phase space due to the grad-B drift in the fluctuating magnetic field (non-linear), the same convection of the equilibrium distribution function (linear), and a couple of additional mirror force terms in the direction of the parallel and drift velocities (linear). The normalised form of these terms can be found in section 2.4. The former two is included in the modified definition of $\\chi$ appearing in terms III and V (equations 2.263 and 2.265 ), the latter two are explicitly written in terms X and XI (equations 2.273 and 2.274).\n\n\\subsection*{1.4.1 Gyrokinetic field equations}\nThe normalised gyrokinetic field equations in presence of $B_{1 \\|}$ are listed here. The normalizing assumptions can be found in section 2.1. The equations are written in Fourier-space, the Fourier components of the fields and the distribution function are denoted by (.). $\\Gamma_{0}$ and $\\Gamma_{1}$ are modified Bessel-functions, $b_{\\mathrm{sp}}$ denotes their species dependent attributes in the Fourier-space.\n\nThe quasi-neutrality equation is\n\n\n\\begin{align*}\n& \\sum_{\\mathrm{sp}} Z_{\\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}}\\left[2 \\pi B_{\\mathrm{N}} \\int J_{0}\\left(k_{\\perp} \\rho_{\\mathrm{sp}}\\right) \\hat{g}_{\\mathrm{N}, \\mathrm{sp}} \\mathrm{~d} v_{\\| N} \\mathrm{~d} \\mu_{\\mathrm{N}}+\\right. \\\\\n& \\left.\\frac{Z_{\\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}} \\hat{\\phi}_{\\mathrm{N}}\\left(\\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}} \\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-1\\right)+\\frac{\\hat{B}_{1 \\| \\mathrm{N}}}{B_{\\mathrm{N}}} \\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}}\\left(\\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-\\Gamma_{1}\\left(b_{\\mathrm{sp}}\\right)\\right)\\right]=0 \\tag{1.41}\n\\end{align*}\n\n\nwhere $\\mathcal{E}$ is a combined energy term including the kinetic energy of the toroidal rotation of the plasma and the energy stored in the equilibrium electric field:\n\n\n\\begin{equation*}\n\\mathcal{E}=Z e\\left\\langle\\Phi_{0}\\right\\rangle-\\frac{1}{2} m \\omega_{\\varphi}^{2}\\left(R^{2}-R_{0}^{2}\\right) \\tag{1.42}\n\\end{equation*}\n\n\nThe parallel component of Amp\u00e8re's law gives\n\n\n\\begin{align*}\n& {\\left[k_{\\perp \\mathrm{N}}^{2}+\\beta_{\\mathrm{ref}} \\sum_{\\mathrm{sp}} \\frac{Z_{\\mathrm{sp}}^{2} n_{\\mathrm{R}, \\mathrm{sp}}}{m_{\\mathrm{R}, \\mathrm{sp}}} \\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}} \\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)\\right] \\hat{A}_{1 \\| \\mathrm{N}}=} \\\\\n& 2 \\pi B_{\\mathrm{N}} \\beta_{\\mathrm{ref}} \\sum_{\\mathrm{sp}} Z_{\\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}} v_{\\mathrm{R}, \\mathrm{sp}} \\int v_{\\| N} J_{0}\\left(k_{\\perp} \\rho_{\\mathrm{sp}}\\right) \\hat{g}_{\\mathrm{N}, \\mathrm{sp}} \\mathrm{~d} v_{\\| N} \\mathrm{~d} \\mu_{N} \\tag{1.43}\n\\end{align*}\n\n\nwhere $\\beta_{\\text {ref }}$ is the reference plasma beta:\n\n\n\\begin{equation*}\n\\beta_{\\mathrm{ref}}=\\frac{2 \\mu_{0} n_{\\mathrm{ref}} T_{\\mathrm{ref}}}{B_{\\mathrm{ref}}^{2}} \\tag{1.44}\n\\end{equation*}\n\n\nThe perpendicular component of Amp\u00e8re's law gives\n\n\n\\begin{align*}\n& {\\left[1+\\sum_{\\mathrm{sp}} \\frac{T_{\\mathrm{R}, \\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}}}{B_{\\mathrm{N}}^{2}} \\beta_{\\mathrm{ref}} \\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}}\\left(\\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-\\Gamma_{1}\\left(b_{\\mathrm{sp}}\\right)\\right)\\right] \\hat{B}_{1 \\| \\mathrm{N}}=} \\\\\n& \\quad-\\sum_{\\mathrm{sp}} \\beta_{\\mathrm{ref}}\\left[2 \\pi B_{\\mathrm{N}} T_{\\mathrm{R}, \\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}} \\int \\mu_{N} \\hat{J}_{1}\\left(k_{\\perp} \\rho_{\\mathrm{sp}}\\right) \\hat{g}_{\\mathrm{N}, \\mathrm{sp}} \\mathrm{~d} v_{\\| N} \\mathrm{~d} \\mu_{\\mathrm{N}}\\right. \\\\\n& \\left.\\quad+\\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}}\\left(\\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-\\Gamma_{1}\\left(b_{\\mathrm{sp}}\\right)\\right) \\frac{Z_{\\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}}}{2 B_{\\mathrm{N}}} \\hat{\\phi}_{\\mathrm{N}}\\right] \\tag{1.45}\n\\end{align*}\n\n\nwhere $\\hat{J}_{1}(z)=\\frac{2}{z} J_{1}(z)$ is a modified first order Bessel function of the first kind.\n\n\\subsection*{1.4.2 Field equations in GKW}\nThe gyrokinetic Poisson equation 1.41 and perpendicular Amp\u00e8re's law 1.45 are coupled through the fluctuating electro-static potential and magnetic compression appearing in both of them. For simpler numerical\\\\\ntreatment the two equations have to be decoupled. By introducing the notations\n\n$$\n\\begin{aligned}\nI_{1 \\mathrm{sp}} & =Z_{\\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}} 2 \\pi B_{\\mathrm{N}} \\int J_{0}\\left(k_{\\perp} \\rho_{\\mathrm{sp}}\\right) \\hat{g}_{\\mathrm{N}, \\mathrm{sp}} \\mathrm{~d} v_{\\| N} \\mathrm{~d} \\mu_{\\mathrm{N}} \\\\\nF_{1 \\mathrm{sp}} & =\\frac{Z_{\\mathrm{sp}}^{2} n_{\\mathrm{R}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}\\left(\\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}} \\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-1\\right) \\\\\nB_{1 \\mathrm{sp}} & =\\frac{Z_{\\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}}}{B_{\\mathrm{N}}} \\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}}\\left(\\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-\\Gamma_{1}\\left(b_{\\mathrm{sp}}\\right)\\right) \\\\\nI_{2 \\mathrm{sp}} & =\\beta_{\\mathrm{ref}} 2 \\pi B_{\\mathrm{N}} T_{\\mathrm{R}, \\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}} \\int \\mu_{N} \\hat{J}_{1}\\left(k_{\\perp} \\rho_{\\mathrm{sp}}\\right) \\hat{g}_{\\mathrm{N}, \\mathrm{sp}} \\mathrm{~d} v_{\\| N} \\mathrm{~d} \\mu_{\\mathrm{N}} \\\\\nF_{2 \\mathrm{sp}} & =\\frac{\\beta_{\\mathrm{ref}} Z_{\\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}}}{2 B_{\\mathrm{N}}} \\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}}\\left(\\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-\\Gamma_{1}\\left(b_{\\mathrm{sp}}\\right)\\right) \\\\\nB_{2 \\mathrm{sp}} & =\\frac{T_{\\mathrm{R}, \\mathrm{sp}} n_{\\mathrm{R}, \\mathrm{sp}}}{B_{\\mathrm{N}}^{2}} \\beta_{\\mathrm{ref}} \\mathrm{e}^{\\frac{-\\mathcal{E}_{\\mathrm{N}, \\mathrm{sp}}}{T_{\\mathrm{R}, \\mathrm{sp}}}}\\left(\\Gamma_{0}\\left(b_{\\mathrm{sp}}\\right)-\\Gamma_{1}\\left(b_{\\mathrm{sp}}\\right)\\right)\n\\end{aligned}\n$$\n\nequations 1.41 and 1.45 take the form\n\n$$\n\\begin{aligned}\n\\sum_{\\mathrm{sp}} I_{1 \\mathrm{sp}}+\\hat{\\phi}_{\\mathrm{N}} \\sum_{\\mathrm{sp}} F_{1 \\mathrm{sp}}+\\hat{B}_{1 \\| \\mathrm{N}} \\sum_{\\mathrm{sp}} B_{1 \\mathrm{sp}} & =0 \\\\\n\\left(1+\\sum_{\\mathrm{sp}} B_{2 \\mathrm{sp}}\\right) \\hat{B}_{1 \\| \\mathrm{N}}+\\sum_{\\mathrm{sp}} I_{2 \\mathrm{sp}}+\\hat{\\phi}_{\\mathrm{N}} \\sum_{\\mathrm{sp}} F_{2 \\mathrm{sp}} & =0\n\\end{aligned}\n$$\n\nAccordingly, the decoupled field equations for $\\hat{\\Phi}_{1}$ and $\\hat{B}_{1 \\| \\mathrm{N}}$ can be written as\n\n\n\\begin{align*}\n& {\\left[\\sum_{\\mathrm{sp}} F_{1 \\mathrm{sp}}\\left(1+\\sum_{\\mathrm{sp}} B_{2 \\mathrm{sp}}\\right)-\\sum_{\\mathrm{sp}} F_{2 \\mathrm{sp}} \\sum_{\\mathrm{sp}} B_{1 \\mathrm{sp}}\\right] \\hat{\\phi}_{\\mathrm{N}}+} \\\\\n& {\\left[\\sum_{\\mathrm{sp}} I_{1 \\mathrm{sp}}\\left(1+\\sum_{\\mathrm{sp}} B_{2 \\mathrm{sp}}\\right)-\\sum_{\\mathrm{sp}} I_{2 \\mathrm{sp}} \\sum_{\\mathrm{sp}} B_{1 \\mathrm{sp}}\\right]=0} \\tag{1.46}\n\\end{align*}\n\n\nand\n\n\n\\begin{align*}\n& {\\left[\\sum_{\\mathrm{sp}} F_{1 \\mathrm{sp}}\\left(1+\\sum_{\\mathrm{sp}} B_{2 \\mathrm{sp}}\\right)-\\sum_{\\mathrm{sp}} F_{2 \\mathrm{sp}} \\sum_{\\mathrm{sp}} B_{1 \\mathrm{sp}}\\right] \\hat{B}_{1 \\| \\mathrm{N}}+} \\\\\n& {\\left[\\sum_{\\mathrm{sp}} I_{2 \\mathrm{sp}} \\sum_{\\mathrm{sp}} F_{1 \\mathrm{sp}}-\\sum_{\\mathrm{sp}} I_{1 \\mathrm{sp}} \\sum_{\\mathrm{sp}} F_{2 \\mathrm{sp}}\\right]=0 .} \\tag{1.47}\n\\end{align*}\n\n\nThe implementation of the field equations in GKW follows the above notation.\n\n\\section*{Chapter 2}\n\\section*{Gyrokinetic practice}\n\\subsection*{2.1 Normalisations}\nOf course, all quantities in the code are normalised. Below, this normalisation is discussed in detail. The velocity will be normalised by the thermal velocity of each of the species. This has the advantage that the grid in velocity space can always be defined relative to the thermal velocity. Quantities like the potential, however, must be normalised by a reference temperature since it is species independent. A similar argument applies to the vector potential and the time.\n\nWe define a reference mass $m_{\\text {ref }}$, a reference thermal velocity $v_{\\text {thref }}$, a reference density $n_{\\text {ref }}$, a reference temperature $T_{\\text {ref }}$, a reference magnetic field $B_{\\text {ref }}$ evaluated on the magnetic axis, and a reference major radius $R_{\\text {ref }}$. These are not unrelated since\n\n\n\\begin{equation*}\nT_{\\mathrm{ref}}=\\frac{1}{2} m_{\\mathrm{ref}} v_{\\mathrm{thref}}^{2}, \\quad \\rho_{\\mathrm{ref}}=\\frac{m_{\\mathrm{ref}} v_{\\mathrm{thref}}}{e B_{\\mathrm{ref}}} \\tag{2.1}\n\\end{equation*}\n\n\nFurthermore we define a normalised Larmor radius to be\n\n\n\\begin{equation*}\n\\rho_{*}=\\rho_{\\mathrm{ref}} / R_{\\mathrm{ref}} . \\tag{2.2}\n\\end{equation*}\n\n\nThe reference values are used to define, for each species, a dimensionless mass $m_{R}$, a dimensionless thermal velocity $v_{R}$, a dimensionless density $n_{R}$, a dimensionless temperature $T_{R}$, and a dimensionless centrifugal energy $\\mathcal{E}_{R}$\n\n\n\\begin{equation*}\nm_{R}=\\frac{m}{m_{\\text {ref }}}, \\quad v_{R}=\\frac{v_{\\text {th }}}{v_{\\text {thref }}}, \\quad n_{R}=\\frac{n_{R_{0}}}{n_{\\text {ref }}}, \\quad T_{R}=\\frac{T}{T_{\\text {ref }}}, \\quad \\mathcal{E}_{R}=\\frac{\\mathcal{E}_{\\Omega}}{T_{R} T_{\\text {ref }}} . \\tag{2.3}\n\\end{equation*}\n\n\nThe fields are made dimensionless using only reference values\n\n\n\\begin{equation*}\n\\phi=\\rho_{*} \\frac{T_{\\mathrm{ref}}}{e} \\phi_{N}, \\quad A_{\\|}=B_{\\mathrm{ref}} R_{\\mathrm{ref}} \\rho_{*}^{2} A_{\\| N}, \\quad B_{1 \\|}=B_{\\mathrm{ref}} \\rho_{*} B_{1 \\| N} \\quad \\chi=\\rho_{*} \\frac{T_{\\mathrm{ref}}}{e} \\chi_{N}, \\quad \\Phi=\\frac{T_{\\mathrm{ref}}}{e} \\Phi_{N} \\tag{2.4}\n\\end{equation*}\n\n\nHere the index $N$ refers to a normalised quantity. Note that factors of $\\rho_{*}$ have been added in the definitions of the normalised perturbed fields. These factors are chosen such that the normalised quantities are of the order 1.\n\nAlso time $t$, magnetic field $B$, angular rotation frequency $\\Omega$, and the major radius $R$, are made dimensionless using the reference values\n\n\n\\begin{align*}\nt & =R_{\\text {ref }} t_{N} / v_{\\text {thref }}, & & B=B_{\\text {ref }} B_{N} \\\\\n\\Omega & =v_{\\text {thref }} \\Omega_{N} / R_{\\text {ref }}, & & R=R_{\\text {ref }} R_{N} . \\tag{2.5}\n\\end{align*}\n\n\nThe velocity space coordinates, however, are made dimensionless with the help of the thermal velocity of the species\n\n\n\\begin{equation*}\nv_{\\|}=v_{\\| N} v_{\\mathrm{th}}, \\quad \\mu=\\frac{m v_{\\mathrm{th}}^{2}}{B_{\\mathrm{ref}}} \\mu_{N} \\tag{2.6}\n\\end{equation*}\n\n\nIt is then convenient to normalise the distribution functions according to\n\n\n\\begin{equation*}\nf=\\rho_{*} \\frac{n_{R_{0}}}{v_{\\mathrm{th}}^{3}} f_{N}, \\quad F_{M}=\\frac{n_{R_{0}}}{v_{\\mathrm{th}}^{3}} F_{M N} . \\tag{2.7}\n\\end{equation*}\n\n\nThe gradient of density and temperature are made dimensionless using the density and temperature of the species under consideration, but the plasma rotation is largely a bulk motion of all the species together and its gradient is normalised using the reference thermal velocity $v_{\\text {thref }}$\n\n\n\\begin{equation*}\n\\frac{1}{L_{n, N}}=\\frac{R_{\\mathrm{ref}}}{L_{n}}=-\\frac{1}{n_{R_{0}}} \\frac{\\partial n_{R_{0}}}{\\partial \\psi}, \\quad \\frac{1}{L_{T, N}}=\\frac{R_{\\text {ref }}}{L_{T}}=-\\frac{1}{T} \\frac{\\partial T}{\\partial \\psi}, \\quad u_{N}^{\\prime}=-\\frac{R_{\\mathrm{ref}}}{v_{\\text {thref }}} \\frac{\\partial \\omega_{\\phi}}{\\partial \\psi} . \\tag{2.8}\n\\end{equation*}\n\n\nThe gradient length scales are normalised with $R_{\\text {ref }}$, but note that the same quantities are often written as $R / L_{n}$ and $R / L_{T}$ elsewhere in the literature. Note also that the radial coordinate $\\psi$ is normalised:\n\n\n\\begin{equation*}\n\\psi=\\frac{R_{\\max }-R_{\\min }}{2 R_{\\mathrm{ref}}} \\tag{2.9}\n\\end{equation*}\n\n\nwhere $R_{\\max }\\left(R_{\\min }\\right)$ is the maximum (minimum) major radius of the flux surface. For circular surfaces, for instance, $\\psi=r / R_{\\text {ref }}=\\epsilon$, where $r$ is the minor radius. For the $s-\\alpha$ geometry, you can take $R_{\\text {ref }}$ to have any value you like, but it is simplest to always use the magnetic axis. For the Circ, Miller and Chease $R_{\\text {ref }}$ has a specific meaning defined by the geometry. All gradients are normalised using the major radius $R_{\\text {ref }}$, i.e.\n\n\n\\begin{equation*}\n\\nabla=\\frac{1}{R_{\\mathrm{ref}}} \\nabla_{N} \\tag{2.10}\n\\end{equation*}\n\n\nThe poloidal flux $\\Psi$ used in the derivation of the metric tensors is normalised according to\n\n\n\\begin{equation*}\n\\Psi=R_{\\mathrm{ref}}^{2} B_{\\mathrm{ref}} \\Psi_{N} \\tag{2.11}\n\\end{equation*}\n\n\nThe strength of the electromagnetic effects is determined by the plasma beta ( $\\beta$ ). Although $\\beta$ is dimensionless we define a different dimensionless beta $\\left(\\beta_{N}\\right)$ for the use in the code. This $\\beta_{N}$ is directly related to the reference values\n\n\n\\begin{equation*}\n\\beta_{N}=\\frac{n_{\\mathrm{ref}} T_{\\mathrm{ref}}}{B_{\\mathrm{ref}}^{2} / 2 \\mu_{0}} \\tag{2.12}\n\\end{equation*}\n\n\nFinally, the wave vectors introduced in the spectral representation arise from the perpendicular gradient of a fluctuating quantity and will therefore be normalised to $\\rho_{\\mathrm{ref}}$ :\n\n\n\\begin{equation*}\nk=\\frac{k_{N}}{\\rho_{\\mathrm{ref}}} \\tag{2.13}\n\\end{equation*}\n\n\nIn all the following sections we will, of course, use only the normalised quantities. The index $N$ is then dropped for convenience.\n\n\\subsection*{2.2 Geometry}\nGKW is formulated in field aligned Hamada coordinates [36], i.e. the contravariant components of both the poloidal $B^{s}$ and toroidal magnetic field $B^{\\gamma}$ are flux functions. The safety factor is then determined by the ratio $q=B^{\\gamma} / B^{s}$. Starting from an orthogonal coordinate system $(\\psi, \\theta, \\varphi)$, where $\\psi$ is the radial coordinate\\\\\n(i.e. $\\mathbf{B} \\cdot \\nabla \\psi=0$ ), $\\theta$ is the poloidal angle (upward on the outboard midplane), and $\\varphi$ is the toroidal angle (clockwise when viewed from above), and using the transformations\n\n\n\\begin{equation*}\ns=s(\\psi, \\theta), \\quad \\gamma=\\gamma(\\psi, \\theta, \\varphi) \\tag{2.14}\n\\end{equation*}\n\n\none can derive [40, 41] (see Appendix A. 1 for more details):\n\n\n\\begin{align*}\n& s(\\theta, \\psi)=\\int_{0}^{\\theta} \\frac{\\mathrm{d} \\theta^{\\prime}}{\\mathbf{B} \\cdot \\nabla \\theta^{\\prime}} / \\oint \\frac{\\mathrm{d} \\theta^{\\prime}}{\\mathbf{B} \\cdot \\nabla \\theta^{\\prime}}  \\tag{2.15}\\\\\n& \\gamma=\\frac{\\varphi}{2 \\pi}+s_{\\mathrm{B}} \\frac{R B_{t}}{2 \\pi} \\int_{0}^{\\theta} \\frac{\\mathrm{d} \\theta^{\\prime}}{\\mathbf{B} \\cdot \\nabla \\theta^{\\prime}}\\left[\\left\\{\\frac{1}{R^{2}}\\right\\}-\\frac{1}{R^{2}}\\right] \\tag{2.16}\n\\end{align*}\n\n\nwith\n\n\n\\begin{equation*}\nB^{s}=1 / \\oint \\frac{\\mathrm{d} \\theta^{\\prime}}{\\mathbf{B} \\cdot \\nabla \\theta^{\\prime}} \\quad B^{\\gamma}=s_{\\mathrm{B}} \\frac{R B_{t}}{2 \\pi}\\left\\{\\frac{1}{R^{2}}\\right\\} . \\tag{2.17}\n\\end{equation*}\n\n\nIn the equations above, the magnetic field is decomposed as\n\n\n\\begin{equation*}\n\\mathbf{B}=s_{\\mathrm{B}} R B_{t} \\nabla \\varphi+s_{\\mathrm{j}} \\nabla \\varphi \\times \\nabla \\Psi \\tag{2.18}\n\\end{equation*}\n\n\nwhere $B_{t}>0$ is the toroidal component of the magnetic field, $s_{\\mathrm{B}}= \\pm 1$ and $s_{\\mathrm{j}}= \\pm 1$ the sign of the magnetic field and plasma current (positive in the direction of $\\nabla \\varphi$ ) and $\\Psi$ the normalised poloidal flux ( $\\nabla \\Psi$ points from the magnetic axis to the plasma edge). The brackets $\\}$ denote the flux surface average, which in the transformed coordinates can be written (more details in A.6) as\n\n\n\\begin{equation*}\n\\{g\\}=\\oint g \\mathrm{~d} s \\tag{2.19}\n\\end{equation*}\n\n\nThe normalising constants have been chosen such that the domain $[-1 / 2,1 / 2]$ in $s$ corresponds to one poloidal turn and the domain $[-1 / 2,1 / 2]$ in $\\gamma$ corresponds to one toroidal turn. Note that the transformations of Eq. (2.14) leave the angle $\\gamma$ to be an ignorable coordinate, since any quantity that is independent of $\\varphi$ will also be independent of $\\gamma$ after the transformation.\n\nThe coordinates given above are transformed using a simple linear transformation\n\n\n\\begin{equation*}\n\\zeta=q s-\\gamma \\quad \\text { where } \\quad q=\\frac{B^{\\gamma}}{B^{s}} \\tag{2.20}\n\\end{equation*}\n\n\nto make them field aligned, i.e. $\\mathbf{B} \\cdot \\nabla=B^{s} \\partial / \\partial s$ as $B^{\\zeta}=0$ and $B^{\\psi}=0$. Note that the coordinate transformation above flips the sign of the toroidal angle. The right handed coordinate system can therefore be defined as $(\\psi, \\zeta, s)$. The Jacobian of the new coordinate system can be expressed in terms of the original Jacobian through\n\n\n\\begin{equation*}\nJ_{\\psi \\zeta s}=2 \\pi \\mathbf{B} \\cdot \\nabla \\theta \\oint \\frac{\\mathrm{~d} \\theta^{\\prime}}{\\mathbf{B} \\cdot \\nabla \\theta^{\\prime}} J_{\\psi \\theta \\varphi} . \\tag{2.21}\n\\end{equation*}\n\n\nWe note here that the coordinates $\\psi, s$ and $\\zeta$ are chosen dimensionless with $\\psi$ being a normalised 'minor radius' of the flux surface, see Eq. (2.9). We shall refer to $\\zeta$ as the 'bi-normal' coordinate since it is neither strictly toroidal or poloidal.\n\nClose inspection of the gyrokinetic equation (1.31) shows that it contains parallel derivatives\n\n\n\\begin{equation*}\n\\mathbf{b} \\cdot \\nabla=\\mathcal{F} \\frac{\\partial}{\\partial s} \\quad \\rightarrow \\quad \\mathcal{F}=\\frac{B^{s}}{B} \\tag{2.22}\n\\end{equation*}\n\n\nand perpendicular drifts, with the latter all involving a cross product with the magnetic field. It is then convenient to define the tensor\n\n\n\\begin{equation*}\n\\mathcal{E}^{\\alpha \\beta}=\\frac{1}{2 B}\\left(\\nabla x_{\\alpha} \\times \\nabla x_{\\beta}\\right) \\cdot \\mathbf{b} . \\tag{2.23}\n\\end{equation*}\n\n\nThe convection connected with the velocity $\\mathbf{v}_{\\chi}$ can be directly expressed in this tensor times the derivatives of the potential towards $x_{\\alpha}$ and the distribution towards $x_{\\beta}$. It is worth noting that the magnetic field can be expressed as\n\n\n\\begin{equation*}\n\\mathbf{B}=2 \\pi s_{\\mathrm{j}} \\nabla \\Psi \\times \\nabla \\zeta \\tag{2.24}\n\\end{equation*}\n\n\nwhich immediately leads to\n\n\n\\begin{equation*}\n\\mathcal{E}^{\\psi \\zeta}=\\frac{s_{\\mathrm{j}}}{4 \\pi} \\frac{\\partial \\psi}{\\partial \\Psi} \\tag{2.25}\n\\end{equation*}\n\n\nshowing that $\\mathcal{E}^{\\psi \\zeta}$ is constant on a flux surface. For convenience we define two more quantities\n\n", "\n\\begin{equation*}\n\\mathcal{D}^{\\alpha}=-2 \\mathcal{E}^{\\alpha \\beta} \\frac{1}{B} \\frac{\\partial B}{\\partial x_{\\beta}}, \\quad \\mathcal{G}=\\mathcal{F} \\frac{\\partial \\ln B}{\\partial s} \\tag{2.26}\n\\end{equation*}\n\n\nwith $\\mathcal{D}$ related to the grad B drift, and $\\mathcal{G}$ to the trapping. Finally, the Coriolis drift and centrifugal drift will enter the equations through the one forms $\\mathcal{H}$ and $\\mathcal{I}$ respectively\n\n\n\\begin{equation*}\n\\mathcal{H}^{\\alpha}=-\\frac{s_{\\mathrm{B}}}{B \\Omega} \\boldsymbol{\\Omega}_{\\perp} \\cdot \\nabla x_{\\alpha}, \\quad \\mathcal{I}^{\\alpha}=\\frac{s_{\\mathrm{B}}}{2 B}\\left(\\nabla x_{\\alpha} \\times \\nabla R^{2}\\right) \\cdot \\mathbf{b} \\tag{2.27}\n\\end{equation*}\n\n\nand the centrifugal potential is calculated (see Sec. 4.1) using the quantities\n\n\n\\begin{equation*}\n\\mathcal{J}=R^{2}-R_{0}^{2}, \\quad \\mathcal{K}=\\left.\\frac{\\partial \\mathcal{J}}{\\partial \\psi}\\right|_{s}, \\quad \\mathcal{L}=\\left.\\frac{\\partial\\left(R_{0}^{2}\\right)}{\\partial \\psi}\\right|_{s} \\tag{2.28}\n\\end{equation*}\n\n\nFor transformations of the shearing rate we also define\n\n\n\\begin{equation*}\n\\mathcal{M}=\\frac{\\partial^{2} \\Psi}{\\partial \\psi^{2}}=\\frac{s_{\\mathrm{j}}}{4 \\pi} \\frac{\\partial}{\\partial \\psi}\\left(\\frac{1}{\\mathcal{E}^{\\psi \\zeta}}\\right) . \\tag{2.29}\n\\end{equation*}\n\n\nThe tensor elements defined above all have similar magnitude. It must be realised though that these elements are multiplied with the derivatives towards the respective coordinate. Since the derivatives along the field are much smaller than the derivatives in the perpendicular plane, the tensor elements containing the coordinate $s$ are usually neglected (i.e. $\\mathcal{D}^{s}=\\mathcal{E}^{s \\psi}=\\mathcal{E}^{s \\zeta}=\\mathcal{H}^{s}=0$ ), except in the case of those multiplied with the background potential $\\Phi$, or when higher $\\rho^{*}$ effects are included.\n\nGKW uses the local limit. Central to this approximation is the small scales of the turbulent fluctuations. All background plasma parameters are assumed homogeneous across the simulation domain perpendicular to the field, i.e. there is no dependence of the parameters on the coordinates $\\zeta$ and $\\psi$. The turbulence is homogeneous in the plane perpendicular to the magnetic field and periodic boundary conditions apply. Note that the dependence of equilibrium quantities on the 'parallel' coordinate $s$ are kept. All the tensors $\\mathcal{D}, \\mathcal{E}, \\mathcal{F}, \\mathcal{G}, \\mathcal{H}, \\mathcal{I}, \\mathcal{J}, \\mathcal{K}, \\mathcal{M}$ as well as the metric tensor, are therefore, functions of the parallel coordinate $s$ only.\n\n\\subsection*{2.2.1 $\\mathrm{s}-\\alpha$}\nThe simplified ' $s-\\alpha$ ' equilibrium (with $\\alpha=0$ ) is directly implemented in the code through pre-defined tensor elements. The latter model equilibrium is the simplest choice of the geometry of a tokamak with the flux surfaces being circular and having a small inverse aspect ratio $\\epsilon=r / R \\ll 1$, with $r$ being the minor radius of the surface and $R=R_{\\text {ref }}$. Only the lowest order in an $\\epsilon$ expansion is kept in the definition of all the tensors. The coordinates can then be approximated as\n\n\n\\begin{equation*}\n\\psi=\\epsilon=\\frac{r}{R}, \\quad \\zeta=\\frac{s_{\\mathrm{B}} s_{\\mathrm{j}}}{2 \\pi}[|q| \\theta-\\varphi], \\quad s=\\frac{\\theta}{2 \\pi} \\tag{2.30}\n\\end{equation*}\n\n\nwith the (normalised) gradients\n\n\n\\begin{equation*}\n\\nabla \\psi=\\mathbf{e}_{r}, \\quad \\nabla \\zeta=\\frac{s_{\\mathrm{B}} s_{\\mathrm{j}}|q|}{2 \\pi \\epsilon}\\left[\\mathbf{e}_{\\theta}+\\hat{s} \\theta \\mathbf{e}_{r}\\right], \\quad \\nabla s=\\frac{1}{2 \\pi \\epsilon} \\mathbf{e}_{\\theta} \\tag{2.31}\n\\end{equation*}\n\n\nwhere $\\hat{s}=(r / q) \\mathrm{d} q / \\mathrm{d} r$ is the magnetic shear. Note that the gradient of the toroidal angle is ordered small compared with the gradient of the poloidal angle (times q) and is neglected in the gradient of $\\zeta$. The contravariant components of the magnetic field are\n\n\n\\begin{equation*}\nB^{s}=s_{\\mathrm{j}} \\frac{B_{p}}{2 \\pi r} \\quad B^{\\zeta}=-s_{\\mathrm{B}} \\frac{B_{t}}{2 \\pi R} \\tag{2.32}\n\\end{equation*}\n\n\nwhere $B_{p}$ is the poloidal magnetic field. The gradient of the magnetic field strength is assumed to be in the direction of $\\nabla R$ and the drift term is approximated as\n\n\n\\begin{equation*}\n\\mathbf{B} \\times \\nabla B=-s_{\\mathrm{B}} B^{2}\\left[\\cos \\theta \\mathbf{e}_{\\theta}+\\sin \\theta \\mathbf{e}_{r}\\right] \\tag{2.33}\n\\end{equation*}\n\n\nUsing these expressions one can evaluate the tensors to be\n\n\n\\begin{align*}\n& \\mathcal{F}=\\frac{s_{\\mathrm{j}}}{2 \\pi|q|}, \\quad \\mathcal{D}^{\\psi}=-s_{\\mathrm{B}} \\sin (2 \\pi s), \\quad \\mathcal{D}^{\\zeta}=-\\frac{s_{\\mathrm{j}}|q|}{2 \\pi \\epsilon}[\\cos (2 \\pi s)+2 \\pi \\hat{s} s \\sin (2 \\pi s)],  \\tag{2.34}\\\\\n& \\mathcal{I}^{\\psi}=\\mathcal{H}^{\\psi}=\\mathcal{D}^{\\psi}, \\quad \\mathcal{I}^{\\zeta}=\\mathcal{H}^{\\zeta}=\\mathcal{D}^{\\zeta}, \\quad \\mathcal{G}=\\frac{s_{\\mathrm{j}} \\epsilon}{|q|} \\sin (2 \\pi s),  \\tag{2.35}\\\\\n& \\mathcal{E}^{\\psi \\zeta}=s_{\\mathrm{j}} \\frac{|q|}{4 \\pi \\epsilon}=-\\mathcal{E}^{\\zeta \\psi}, \\quad \\mathcal{E}^{\\psi s}=\\frac{s_{\\mathrm{B}}}{4 \\pi \\epsilon}, \\quad \\mathcal{E}^{\\zeta s}=\\frac{s_{\\mathrm{j}}|q|}{4 \\pi \\epsilon^{2}} \\hat{s} s, \\quad \\mathcal{M}=\\frac{1}{q}-\\frac{\\hat{s}}{q}  \\tag{2.36}\\\\\n& \\mathcal{J}=2 \\epsilon \\cos (2 \\pi s), \\quad \\mathcal{K}=2 \\cos (2 \\pi s)-\\mathcal{L} . \\tag{2.37}\n\\end{align*}\n\n\nwhere the two choices for $R_{0}$ (mag. axis $R$ and $R(s=0)$, see 4.1) give\n\n\n\\begin{equation*}\nR_{0}=1 \\Rightarrow \\mathcal{L}=0, \\quad R_{0}=1+\\epsilon \\Rightarrow \\mathcal{L}=2 \\tag{2.38}\n\\end{equation*}\n\n\nrespectively.\\\\\nFinally the metric elements are\n\n\n\\begin{equation*}\ng^{\\zeta \\zeta}=\\left(\\frac{q}{2 \\pi \\epsilon}\\right)^{2}+\\left(\\frac{q}{\\epsilon} \\hat{s} s\\right)^{2}, \\quad g^{\\zeta \\psi}=\\frac{s_{\\mathrm{B}} s_{\\mathrm{j}}|q|}{\\epsilon} \\hat{s} s, \\quad g^{\\psi \\psi}=1 . \\tag{2.39}\n\\end{equation*}\n\n\nAll numerical results presented in this manual have been obtained with the geometry coefficients given above, except the benchmark of the full geometry and Miller geometry treatment.\n\n\\subsection*{2.2.2 Circular geometry}\nThe $s-\\alpha$ model has been shown to be inconsistent in the $\\epsilon$ ordering of the different terms involved [44] and for some nonlinear runs can also be numerically unstable for the zonal mode. In GKW the improved ad-hoc circular equilibrium model of Ref. [44] is also implemented.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-020}\n\nFigure 2.1: Circular flux surface centred on $R=R_{\\mathrm{ref}}, Z=0$ and $(r, \\theta, \\varphi)$ coordinates.\n\nIn this section, unless explicitly denoted by a $N$ subscript, the various quantities are not normalised. The starting assumption of the model is that the flux surfaces are circular and concentric with the poloidal flux being a function of the radial coordinate only $\\Psi=\\Psi(r)$, see figure 2.1. This is a valid assumption in the case of small $\\epsilon$ and small $\\beta$. It simply means that the terms of order $\\epsilon^{2}$ are neglected and that the Shafranov shift is considered to be of order $\\epsilon^{2}$. For simplicity, the various terms are not expanded in $\\epsilon$ in the following calculation, but one has to remember that the results are only valid up to order $\\epsilon$. The second assumption of the model is that the radial derivative of the poloidal flux is given by:\n\n\n\\begin{equation*}\n\\frac{\\partial \\Psi}{\\partial r}=\\frac{r B_{\\mathrm{ref}}}{\\bar{q}} \\tag{2.40}\n\\end{equation*}\n\n\nwhere $B_{\\mathrm{ref}}$ is the value of the magnetic field at $R_{\\text {ref }}$ taken to be the major radius of the magnetic axis (i.e. the centre of the flux surfaces) and $\\bar{q}>0$ is a parameter directly related to the safety factor $q$. The flux surfaces are parametrised by $R=R_{\\mathrm{ref}}+r \\cos \\theta$ and $Z=r \\sin \\theta$ in the $(r, \\theta, \\varphi)$ coordinates system. The inverse aspect ratio is defined as $\\epsilon=r / R_{\\mathrm{ref}}$ and it might be worth reminding that:\n\n\n\\begin{equation*}\n\\nabla \\epsilon=\\frac{1}{R_{\\mathrm{ref}}} \\mathbf{e}_{\\mathbf{r}}, \\quad \\nabla \\theta=\\frac{1}{\\epsilon R_{\\mathrm{ref}}} \\mathbf{e}_{\\theta}, \\quad \\nabla \\varphi=\\frac{1}{R} \\mathbf{e}_{\\varphi} \\tag{2.41}\n\\end{equation*}\n\n\nAnother useful quantity is the Jacobian of the $(\\Psi, \\theta, \\varphi)$ coordinates system which can be expressed as\n\n\n\\begin{equation*}\nJ_{\\Psi \\theta \\varphi}{ }^{-1}=\\nabla \\Psi \\times \\nabla \\theta \\cdot \\nabla \\varphi=\\frac{\\partial \\Psi}{\\partial r} J_{r \\theta \\varphi}{ }^{-1}=\\frac{\\partial \\Psi}{\\partial r} \\frac{1}{r R}=\\frac{B_{\\mathrm{ref}}}{\\bar{q} R} \\tag{2.42}\n\\end{equation*}\n\n\nAs usual, the magnetic field is decomposed into its toroidal and poloidal components:\n\n\n\\begin{equation*}\n\\mathbf{B}=s_{\\mathrm{B}} F(\\Psi) \\nabla \\varphi+s_{\\mathrm{j}} \\nabla \\varphi \\times \\nabla \\Psi \\tag{2.43}\n\\end{equation*}\n\n\nOne furthermore assumes that $F(\\Psi)=R_{\\text {ref }} B_{\\text {ref }}$ and the magnetic field can then be written as\n\n\n\\begin{equation*}\n\\mathbf{B}=R_{\\mathrm{ref}} B_{\\mathrm{ref}}\\left[s_{\\mathrm{B}} \\nabla \\varphi+s_{\\mathrm{j}} \\frac{1}{\\bar{q}} \\frac{\\epsilon^{2}}{1+\\epsilon \\cos \\theta} \\nabla \\theta\\right] \\tag{2.44}\n\\end{equation*}\n\n\nThe definition of the safety factor is\n\n\n\\begin{equation*}\nq=\\frac{1}{2 \\pi} \\int_{0}^{2 \\pi} \\frac{\\mathbf{B} \\cdot \\nabla \\varphi}{\\mathbf{B} \\cdot \\nabla \\theta} \\mathrm{~d} \\theta \\tag{2.45}\n\\end{equation*}\n\n\nwhich in the model considered here leads to\n\n\n\\begin{equation*}\nq=\\frac{1}{2 \\pi} \\int_{0}^{2 \\pi} s_{\\mathrm{B}} s_{\\mathrm{j}} J_{\\Psi \\theta \\varphi} \\frac{R_{\\mathrm{ref}} B_{\\mathrm{ref}}}{R^{2}} \\mathrm{~d} \\theta=s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{\\bar{q}}{2 \\pi} \\int_{0}^{2 \\pi} \\frac{1}{1+\\epsilon \\cos \\theta} \\mathrm{d} \\theta=s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{\\bar{q}}{\\sqrt{1-\\epsilon^{2}}} \\tag{2.46}\n\\end{equation*}\n\n\nwhich makes explicit the relationship between $q$ and $\\bar{q}$.\\\\\nWe now have all the ingredients to derive the field aligned coordinates $(\\psi, \\zeta, s)$. In GKW, $\\psi$ is defined to be $\\epsilon$ and we will use this notation in the following to avoid possible confusion with the poloidal flux $\\Psi$. The definition of the parallel coordinate $s$ is\n\n\n\\begin{equation*}\ns=\\int_{0}^{\\theta} \\frac{\\mathrm{d} \\theta}{\\mathbf{B} \\cdot \\nabla \\theta} / \\int_{0}^{2 \\pi} \\frac{\\mathrm{~d} \\theta}{\\mathbf{B} \\cdot \\nabla \\theta} \\tag{2.47}\n\\end{equation*}\n\n\nSo, we first calculate\n\n\n\\begin{equation*}\n\\int_{0}^{\\theta} \\frac{\\mathrm{d} \\theta}{\\mathbf{B} \\cdot \\nabla \\theta}=\\int_{0}^{\\theta} s_{\\mathrm{j}} J_{\\Psi \\theta \\varphi} \\mathrm{d} \\theta=s_{\\mathrm{j}} \\bar{q} \\frac{R_{\\mathrm{ref}}}{B_{\\mathrm{ref}}} \\int_{0}^{\\theta}[1+\\epsilon \\cos \\theta] \\mathrm{d} \\theta=s_{\\mathrm{j}} \\bar{q} \\frac{R_{\\mathrm{ref}}}{B_{\\mathrm{ref}}}[\\theta+\\epsilon \\sin \\theta] \\tag{2.48}\n\\end{equation*}\n\n\nto get\n\n\n\\begin{equation*}\ns=\\frac{1}{2 \\pi}[\\theta+\\epsilon \\sin \\theta] \\tag{2.49}\n\\end{equation*}\n\n\nand\n\n\n\\begin{align*}\n\\frac{\\partial s}{\\partial \\epsilon} & =\\frac{1}{2 \\pi} \\sin \\theta  \\tag{2.50}\\\\\n\\frac{\\partial s}{\\partial \\theta} & =\\frac{1}{2 \\pi}[1+\\epsilon \\cos \\theta]  \\tag{2.51}\\\\\n\\frac{\\partial s}{\\partial \\varphi} & =0 \\tag{2.52}\n\\end{align*}\n\n\nThe definition of the $\\zeta$ coordinate is:\n\n\n\\begin{equation*}\n\\zeta=-\\frac{\\varphi}{2 \\pi}+s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{F}{2 \\pi} \\int_{0}^{\\theta} \\frac{J_{\\Psi \\theta \\varphi}}{R^{2}} \\mathrm{~d} \\theta \\tag{2.53}\n\\end{equation*}\n\n\nwhich in the ad-hoc circular model gives\n\n\n\\begin{equation*}\n\\zeta=-\\frac{\\varphi}{2 \\pi}+s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{\\bar{q}}{2 \\pi} \\int_{0}^{\\theta} \\frac{\\mathrm{d} \\theta}{1+\\epsilon \\cos \\theta} \\tag{2.54}\n\\end{equation*}\n\n\nNoticing that\n\n\n\\begin{equation*}\n\\int_{0}^{\\theta} \\frac{\\mathrm{d} \\theta}{1+\\epsilon \\cos \\theta}=\\frac{2}{\\sqrt{1-\\epsilon^{2}}} \\arctan \\left[\\sqrt{\\frac{1-\\epsilon}{1+\\epsilon}} \\tan \\frac{\\theta}{2}\\right] \\tag{2.55}\n\\end{equation*}\n\n\none gets\n\n\n\\begin{equation*}\n\\zeta=-\\frac{\\varphi}{2 \\pi}+s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{|q|}{\\pi} \\arctan \\left[\\sqrt{\\frac{1-\\epsilon}{1+\\epsilon}} \\tan \\frac{\\theta}{2}\\right] \\tag{2.56}\n\\end{equation*}\n\n\nand\n\n\n\\begin{align*}\n& \\frac{\\partial \\zeta}{\\partial \\epsilon}=s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{|q|}{\\epsilon \\pi}\\left[\\hat{s} \\arctan \\left[\\sqrt{\\frac{1-\\epsilon}{1+\\epsilon}} \\tan \\frac{\\theta}{2}\\right]-\\frac{\\epsilon \\tan \\frac{\\theta}{2}}{\\sqrt{1-\\epsilon^{2}}\\left(1+\\epsilon+(1-\\epsilon) \\tan ^{2} \\frac{\\theta}{2}\\right)}\\right],  \\tag{2.57}\\\\\n& \\frac{\\partial \\zeta}{\\partial \\theta}=s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{|q|}{2 \\pi} \\frac{\\sqrt{1-\\epsilon^{2}}}{1+\\epsilon \\cos \\theta}  \\tag{2.58}\\\\\n& \\frac{\\partial \\zeta}{\\partial \\varphi}=-\\frac{1}{2 \\pi} . \\tag{2.59}\n\\end{align*}\n\n\nFrom the decomposition of $\\nabla s$ and $\\nabla \\zeta$ as a function of $\\nabla \\epsilon, \\nabla \\theta$ and $\\nabla \\varphi$\n\n\n\\begin{align*}\n\\nabla s & =\\frac{\\partial s}{\\partial \\epsilon} \\nabla \\epsilon+\\frac{\\partial s}{\\partial \\theta} \\nabla \\theta+\\frac{\\partial s}{\\partial \\varphi} \\nabla \\varphi  \\tag{2.60}\\\\\n\\nabla \\zeta & =\\frac{\\partial \\zeta}{\\partial \\epsilon} \\nabla \\epsilon+\\frac{\\partial \\zeta}{\\partial \\theta} \\nabla \\theta+\\frac{\\partial \\zeta}{\\partial \\varphi} \\nabla \\varphi \\tag{2.61}\n\\end{align*}\n\n\nthe calculation of the metric tensor is straightforward:\n\n\n\\begin{align*}\n& g_{N}^{\\epsilon \\epsilon}=R_{\\mathrm{ref}}^{2} g^{\\epsilon \\epsilon}=1,  \\tag{2.62}\\\\\n& g_{N}^{\\epsilon \\zeta}=R_{\\mathrm{ref}}^{2} g^{\\epsilon \\zeta}=\\frac{\\partial \\zeta}{\\partial \\epsilon},  \\tag{2.63}\\\\\n& g_{N}^{\\epsilon S}=R_{\\mathrm{ref}}^{2} g^{\\epsilon S}=\\frac{1}{2 \\pi} \\sin \\theta,  \\tag{2.64}\\\\\n& g_{N}^{\\zeta \\zeta}=R_{\\mathrm{ref}}^{2} g^{\\zeta \\zeta}=\\left[\\frac{\\partial \\zeta}{\\partial \\epsilon}\\right]^{2}+\\left[\\frac{1}{2 \\pi} \\frac{1}{1+\\epsilon \\cos \\theta}\\right]^{2}\\left[1+\\frac{q^{2}}{\\epsilon^{2}}\\left(1-\\epsilon^{2}\\right)\\right]  \\tag{2.65}\\\\\n& g_{N}^{\\zeta s}=R_{\\mathrm{ref}}^{2} g^{\\zeta s}=\\frac{\\sin \\theta}{2 \\pi} \\frac{\\partial \\zeta}{\\partial \\epsilon}+s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{|q|}{(2 \\pi \\epsilon)^{2}} \\sqrt{1-\\epsilon^{2}}  \\tag{2.66}\\\\\n& g_{N}^{s s}=R_{\\mathrm{ref}}^{2} g^{s s}=\\frac{1}{4 \\pi^{2}}\\left[1+\\frac{2}{\\epsilon} \\cos \\theta+\\frac{1}{\\epsilon^{2}}\\right] . \\tag{2.67}\n\\end{align*}\n\n\nTo calculate the other metric elements one needs the norm of the magnetic field\n\n\n\\begin{equation*}\nB=\\sqrt{\\mathbf{B} \\cdot \\mathbf{B}}=\\frac{B_{\\mathrm{ref}}}{1+\\epsilon \\cos \\theta}\\left[1+\\frac{1}{q^{2}} \\frac{\\epsilon^{2}}{1-\\epsilon^{2}}\\right]^{1 / 2} \\tag{2.68}\n\\end{equation*}\n\n\nand its gradient\n\n\n\\begin{equation*}\n\\nabla B=\\frac{\\partial B}{\\partial \\epsilon} \\nabla \\epsilon+\\frac{\\partial B}{\\partial \\theta} \\nabla \\theta \\tag{2.69}\n\\end{equation*}\n\n\nwhich involves\n\n\n\\begin{align*}\n\\frac{\\partial B}{\\partial \\epsilon} & =\\left[-\\frac{\\cos \\theta}{1+\\epsilon \\cos \\theta}+\\frac{\\epsilon}{\\epsilon^{2}+q^{2}\\left(1-\\epsilon^{2}\\right)}\\left(1-\\hat{s}+\\frac{\\epsilon^{2}}{1-\\epsilon^{2}}\\right)\\right] B  \\tag{2.70}\\\\\n\\frac{\\partial B}{\\partial \\theta} & =\\frac{\\epsilon \\sin \\theta}{1+\\epsilon \\cos \\theta} B \\tag{2.71}\n\\end{align*}\n\n\nFrom the definition\n\n\n\\begin{equation*}\n\\mathcal{D}_{N}^{\\alpha}=\\frac{R_{\\mathrm{ref}}^{2}}{B^{2} B_{N}} \\mathbf{B} \\times \\nabla B \\cdot \\nabla x^{\\alpha} \\tag{2.72}\n\\end{equation*}\n\n\nand some straightforward algebra (which has to be understood as \"I am by far too lazy to write down all the steps in $\\mathrm{ET}_{\\mathrm{E}} \\mathrm{X} \"$ ) we get the components of the tensor related to the curvature and $\\nabla B$ drift:\n\n\n\\begin{align*}\n\\mathcal{D}_{N}^{\\epsilon} & =-s_{\\mathrm{B}} \\sin \\theta \\frac{1}{1+\\frac{1}{q^{2}} \\frac{\\epsilon^{2}}{1-\\epsilon^{2}}}  \\tag{2.73}\\\\\n\\mathcal{D}_{N}^{\\zeta} & =\\left[\\frac{s_{\\mathrm{j}}}{2 \\pi} \\frac{1}{B} \\frac{\\partial B}{\\partial \\epsilon}\\left(\\frac{|q| \\sqrt{1-\\epsilon^{2}}}{\\epsilon}+\\frac{\\epsilon}{|q| \\sqrt{1-\\epsilon^{2}}}\\right)-s_{\\mathrm{B}} \\frac{\\partial \\zeta}{\\partial \\epsilon} \\sin \\theta\\right] \\frac{1}{1+\\frac{1}{q^{2}} \\frac{\\epsilon^{2}}{1-\\epsilon^{2}}}  \\tag{2.74}\\\\\n\\mathcal{D}_{N}^{s} & =\\frac{s_{\\mathrm{B}}}{2 \\pi}\\left[\\frac{1}{\\epsilon B} \\frac{\\partial B}{\\partial \\epsilon}(1+\\epsilon \\cos \\theta)^{2}-\\sin ^{2} \\theta\\right] \\frac{1}{1+\\frac{1}{q^{2}} \\frac{\\epsilon^{2}}{1-\\epsilon^{2}}} \\tag{2.75}\n\\end{align*}\n\n\nThe tensor related to the $\\mathbf{E} \\times \\mathbf{B}$ drift can be obtained from the metric tensor elements:\n\n\n\\begin{equation*}\n\\mathcal{E}_{N}^{\\alpha \\beta}=s_{\\mathrm{j}} \\frac{\\pi R_{\\mathrm{ref}}^{2}}{B B_{N}} \\frac{\\partial \\Psi}{\\partial \\epsilon}\\left(g^{\\alpha \\epsilon} g^{\\beta \\zeta}-g^{\\alpha \\zeta} g^{\\beta \\epsilon}\\right) \\tag{2.77}\n\\end{equation*}\n\n\nwhich for the ad-hoc model gives:\n\n\n\\begin{equation*}\n\\mathcal{E}_{N}^{\\alpha \\beta}=s_{\\mathrm{j}} \\frac{\\pi}{B_{N}^{2}} \\frac{\\epsilon}{|q| \\sqrt{1-\\epsilon^{2}}}\\left(g_{N}^{\\alpha \\epsilon} g_{N}^{\\beta \\zeta}-g_{N}^{\\alpha \\zeta} g_{N}^{\\beta \\epsilon}\\right) \\tag{2.78}\n\\end{equation*}\n\n\nWe the calculate the tensor related to the parallel derivative\n\n\n\\begin{equation*}\n\\mathcal{F}_{N}=R_{\\mathrm{ref}} \\frac{\\mathbf{B} \\cdot \\nabla s}{B}=\\frac{s_{\\mathrm{j}}}{2 \\pi|q| B_{N}} \\frac{1}{\\sqrt{1-\\epsilon^{2}}} \\tag{2.79}\n\\end{equation*}\n\n\nand the tensor related to the trapping\n\n\n\\begin{equation*}\n\\mathcal{G}_{N}=\\frac{R_{\\mathrm{ref}} \\mathbf{B} \\cdot \\nabla B}{B^{2}}=s_{\\mathrm{j}} \\frac{\\epsilon B_{N} \\sin \\theta}{|q| \\sqrt{1-\\epsilon^{2}}} \\frac{1}{1+\\frac{1}{q^{2}} \\frac{\\epsilon^{2}}{1-\\epsilon^{2}}} . \\tag{2.80}\n\\end{equation*}\n\n\nFor the tensor related to the Coriolis drift\n\n\n\\begin{equation*}\n\\mathcal{H}_{N}^{\\alpha}=\\frac{R_{\\mathrm{ref}}}{B_{N} \\Omega} \\boldsymbol{\\Omega}_{\\perp} \\cdot \\nabla x^{\\alpha} \\tag{2.81}\n\\end{equation*}\n\n\nwe first decompose $\\boldsymbol{\\Omega}$ as\n\n\n\\begin{equation*}\n\\boldsymbol{\\Omega}=-s_{\\mathrm{B}} \\Omega \\nabla Z=-s_{\\mathrm{B}} R_{\\mathrm{ref}} \\Omega[\\sin \\theta \\nabla \\epsilon+\\epsilon \\cos \\theta \\nabla \\theta] \\tag{2.82}\n\\end{equation*}\n\n\nto get\n\n\n\\begin{equation*}\n\\boldsymbol{\\Omega} \\cdot \\mathbf{b}=-s_{\\mathrm{B}} s_{\\mathrm{j}} \\Omega \\frac{\\epsilon \\cos \\theta}{|q| \\sqrt{1-\\epsilon^{2}}} \\frac{R_{\\mathrm{ref}} B_{\\mathrm{ref}}}{R B} \\tag{2.83}\n\\end{equation*}\n\n\nand finally obtain\n\n\n\\begin{align*}\n\\mathcal{H}_{N}^{\\epsilon} & =-\\frac{s_{\\mathrm{B}}}{B_{N}} \\sin \\theta  \\tag{2.84}\\\\\n\\mathcal{H}_{N}^{\\zeta} & =-\\frac{s_{\\mathrm{B}}}{B_{N}} \\sin \\theta \\frac{\\partial \\zeta}{\\partial \\epsilon}-\\frac{s_{\\mathrm{j}}|q| \\cos \\theta}{2 \\pi \\epsilon B_{N}} \\frac{\\sqrt{1-\\epsilon^{2}}}{1+\\epsilon \\cos \\theta}  \\tag{2.85}\\\\\n\\mathcal{H}_{N}^{s} & =-\\frac{s_{\\mathrm{B}}}{2 \\pi B_{N}} \\sin ^{2} \\theta+\\frac{s_{\\mathrm{B}}}{2 \\pi B_{N}}(1+\\epsilon \\cos \\theta)\\left[-\\frac{\\cos \\theta}{\\epsilon}+\\frac{\\epsilon \\cos \\theta}{q^{2}\\left(1-\\epsilon^{2}\\right)} \\frac{1}{1+\\frac{1}{q^{2}} \\frac{\\epsilon^{2}}{1-\\epsilon^{2}}}\\right] . \\tag{2.86}\n\\end{align*}\n\n\nUsing\n\n\n\\begin{equation*}\n\\nabla R=R_{\\mathrm{ref}}[\\cos \\theta \\nabla \\epsilon-\\epsilon \\sin \\theta \\nabla \\theta] \\tag{2.87}\n\\end{equation*}\n\n\nthe tensor related to the centrifugal drift, can be expressed as\n\n\n\\begin{equation*}\n\\mathcal{I}_{N}^{\\alpha}=s_{\\mathrm{j}} \\frac{2 \\pi}{B_{N}^{2}} \\frac{\\epsilon(1+\\epsilon \\cos \\theta)}{|q| \\sqrt{1-\\epsilon^{2}}}\\left[g_{N}^{\\epsilon \\alpha}\\left[\\cos \\theta \\frac{\\partial \\zeta}{\\partial \\epsilon}-s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{|q|}{2 \\pi \\epsilon} \\frac{\\sin \\theta \\sqrt{1-\\epsilon^{2}}}{1+\\epsilon \\cos \\theta}\\right]-g_{N}^{\\zeta \\alpha} \\cos \\theta\\right] \\tag{2.88}\n\\end{equation*}\n\n\nWe also have\n\n\n\\begin{equation*}\n\\mathcal{M}=\\frac{1}{q \\sqrt{1-\\epsilon^{2}}}\\left(1-\\frac{\\epsilon}{1-\\epsilon^{2}}-\\frac{\\hat{s}}{q}\\right) . \\tag{2.89}\n\\end{equation*}\n\n\nFinally, the elements used to calculate the centrifugal potential are\n\n\n\\begin{equation*}\n\\mathcal{J}_{N}=(1+\\epsilon \\cos \\theta)^{2}-\\frac{R_{0}^{2}}{R_{\\mathrm{ref}}^{2}} \\quad \\mathcal{K}_{N}=\\left.\\frac{\\partial \\mathcal{J}_{N}}{\\partial \\epsilon}\\right|_{s}=2(\\cos \\theta+\\epsilon)-\\mathcal{L}_{N} \\tag{2.90}\n\\end{equation*}\n\n\nwhere the transformation between partial deriviatives at constant $\\theta$ and $s$ gives\n\n\n\\begin{equation*}\n\\left.\\frac{1}{R_{\\mathrm{ref}}} \\frac{\\partial R}{\\partial \\epsilon}\\right|_{s}=\\cos (\\theta)+\\frac{\\epsilon \\sin ^{2}(\\theta)}{1+\\epsilon \\cos (\\theta)} \\tag{2.91}\n\\end{equation*}\n\n\nwhich has been used to calculate $\\mathcal{K}$. The two choices for $R_{0}$ (magnetic axis value or $R(s=0)$ ) give\n\n\n\\begin{equation*}\nR_{0}=R_{\\mathrm{ref}} \\Rightarrow \\mathcal{L}_{N}=0, \\quad R_{0}=(1+\\epsilon) R_{\\mathrm{ref}} \\Rightarrow \\mathcal{L}_{N}=2(1+\\epsilon) \\tag{2.92}\n\\end{equation*}\n\n\nrespectively.\n\n\\subsection*{2.2.3 Miller geometry}\nMiller geometry is a good compromise between the flexibility of the circ geometry and the precision of a global equilibrium. In this section the Miller parametrisation first done in [37] is described. Then the derivation of the metric tensor in GKW coordinate system $(\\psi, \\zeta, s)$ and the derivatives of the magnetic field are shown using the implementation method of [38].\\\\\nTo avoid any confusion between the poloidal magnetic flux and the radial coordinate the latter will be called $r$ through the entire section. For the miller geometry, $R_{\\mathrm{ref}}=\\left(R_{\\max }+R_{\\min }\\right) / 2$ which is the geometric axis of the flux surface in question.\n\n\\section*{Parametrisation (Input List)}\nThe following parameters are used to describe a magnetic flux surface in (R,Z) plane : $\\kappa$ (elongation), $\\delta$ (triangularity), $\\zeta$ (squareness), $R_{\\text {mil }}, Z_{\\text {mil }}$, and their radial derivatives $s_{\\kappa}, s_{\\delta}$ (definition of $\\left.[37]\\right), s_{\\zeta}, \\frac{\\mathrm{d} R_{\\text {mil }}}{\\mathrm{d} r}, \\frac{\\mathrm{~d} Z_{\\text {mil }}}{\\mathrm{d} r}$ defined such that:\n\n\n\\begin{equation*}\ns_{\\kappa}=\\frac{r}{\\kappa} \\frac{\\mathrm{~d} \\kappa}{\\mathrm{~d} r}, \\quad s_{\\delta}=r \\frac{\\frac{\\mathrm{~d} \\delta}{\\mathrm{~d} r}}{\\sqrt{1-\\delta^{2}}}, \\quad s_{\\zeta}=r \\frac{\\mathrm{~d} \\zeta}{\\mathrm{~d} r} \\tag{2.93}\n\\end{equation*}\n\n\nParameters such as $\\frac{\\mathrm{d} p}{\\mathrm{~d} \\Psi}$ (pressure gradient), q (safety factor), $\\hat{s}$ (magnetic shear) and $\\epsilon\\left(\\right.$ aspect ratio $\\left.=\\frac{r}{R_{\\mathrm{mil}}}\\right)$ are also used. Flux surfaces geometry are then given by :\n\n\n\\begin{align*}\nR & =R_{\\mathrm{mil}}+r \\cos (\\theta+\\arcsin \\delta \\sin \\theta)  \\tag{2.94}\\\\\nZ & =Z_{\\mathrm{mil}}+r \\kappa \\sin (\\theta+\\zeta \\sin 2 \\theta) \\tag{2.95}\n\\end{align*}\n\n\nand the radial derivatives of R and Z by :\n\n\n\\begin{align*}\n& \\frac{\\partial R}{\\partial r}=\\frac{\\mathrm{d} R_{\\mathrm{mil}}}{\\mathrm{~d} r}+\\cos (\\theta+\\arcsin \\delta \\sin \\theta)-s_{\\delta} \\cos \\theta \\sin (\\theta+\\arcsin \\delta \\sin \\theta)  \\tag{2.96}\\\\\n& \\frac{\\partial Z}{\\partial r}=\\frac{\\mathrm{d} Z_{\\mathrm{mil}}}{\\mathrm{~d} r}+\\kappa \\sin (\\theta+\\zeta \\sin 2 \\theta)+s_{\\kappa} \\sin (\\theta+\\zeta \\sin 2 \\theta)+2 \\kappa s_{\\zeta} \\cos (2 \\theta) \\cos (\\theta+\\zeta \\sin 2 \\theta) \\tag{2.97}\n\\end{align*}\n\n\nThe pressure gradient can be computed from different parameters through the input gradp\\_type. The input list is also defined in the file input.dat.sample.\n\nThe normalisation is made such that:\n\n", "\n\\begin{align*}\nR_{N} & =1+\\epsilon \\cos (\\theta+\\arcsin \\delta \\sin \\theta)  \\tag{2.98}\\\\\nF_{N} & =1 \\tag{2.99}\n\\end{align*}\n\n\nWe have then $R_{\\text {ref }}=R_{\\text {mil }}$ and $B_{\\text {ref }}=B_{t}\\left(R_{\\text {mil }}\\right)$.\\\\\nThe normalisation for the plasma pressure gradient is given here using :\n\n\n\\begin{equation*}\n\\left(\\frac{\\mathrm{d} p}{\\mathrm{~d} \\Psi}\\right)_{N}=\\frac{2 \\mu_{0} R_{\\mathrm{ref}}^{2}}{B_{\\mathrm{ref}}} \\frac{\\mathrm{~d} p}{\\mathrm{~d} \\Psi} \\tag{2.100}\n\\end{equation*}\n\n\nThe normalised pressure gradient used in the code can be given by :\n\n\n\\begin{align*}\n\\left(\\frac{\\mathrm{d} p}{\\mathrm{~d} \\Psi}\\right)_{N} & =-\\alpha \\frac{\\left(2 \\pi^{2}\\right)}{\\left(\\partial_{\\Psi} V\\right)_{N}}\\left(\\frac{V_{N}}{2 \\pi^{2}}\\right)^{-1 / 2}  \\tag{2.101}\\\\\n\\left(\\frac{\\mathrm{~d} p}{\\mathrm{~d} \\Psi}\\right)_{N} & =\\frac{\\alpha_{M H D}}{\\epsilon^{2}}\\left(\\frac{\\mathrm{~d} \\Psi}{\\mathrm{~d} \\epsilon}\\right)_{N}  \\tag{2.102}\\\\\n\\left(\\frac{\\mathrm{~d} p}{\\mathrm{~d} \\Psi}\\right)_{N} & =\\frac{\\beta^{\\prime}}{2 \\frac{\\mathrm{~d} \\Psi_{N}}{\\mathrm{~d} \\epsilon}} \\tag{2.103}\n\\end{align*}\n\n\nwith $\\alpha$ taken from equation 42 in [37], $\\alpha_{M H D}$ from equation 141 [38] and $\\beta^{\\prime}$ is defined in section 9.3.6.\\\\\nFor centrifugal effects on the pressure gradient go to equation 2.140.\\\\\nThe equations used below are not normalised however they are in the code.\\\\\nIn the coordinate system $(r, \\theta, \\varphi)$ where the magnetic flux surfaces are described, the elements of the metric\\\\\ntensor are :\n\n\n\\begin{align*}\ng_{r r} & =\\left(\\frac{\\partial R}{\\partial r}\\right)^{2}+\\left(\\frac{\\partial Z}{\\partial r}\\right)^{2}  \\tag{2.104}\\\\\ng_{r \\theta} & =\\frac{\\partial R}{\\partial r} \\frac{\\partial R}{\\partial \\theta}+\\frac{\\partial Z}{\\partial r} \\frac{\\partial Z}{\\partial \\theta}  \\tag{2.105}\\\\\ng_{\\theta \\theta} & =\\left(\\frac{\\partial R}{\\partial \\theta}\\right)^{2}+\\left(\\frac{\\partial Z}{\\partial \\theta}\\right)^{2}  \\tag{2.106}\\\\\ng_{\\varphi \\varphi} & =R^{2} \\tag{2.107}\n\\end{align*}\n\n\nThe contravariant metric tensor, used to calculate the contravariant metric tensor of the GKW basis, is deduced from the relation $g_{i j} \\cdot g^{i j}=I$ with I the identity matrix.\n\n\\section*{Mercier-Luc coordinate system}\nAn expansion of the poloidal flux $\\Psi$ is needed. A coordinate system (introduced by Mercier-Luc) is defined such that the expansion is easy to use (orthogonal system $(\\rho, l, \\varphi)$ ). In addition to the plasma shape, the\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-026}\n\nFigure 2.2: Mercier-Luc coordinate system....from [38]\\\\\ngradient of the plasma pressure must also be specified, which in GKW can be done independently for the geometry, or by coupling to $\\beta^{\\prime}$.\n\n\n\\begin{align*}\n\\Psi & =\\Psi_{s}+\\rho \\Psi_{1}+\\rho^{2} \\Psi_{2}  \\tag{2.108}\\\\\nR & =R_{s}+\\rho \\cos u  \\tag{2.109}\\\\\nZ & =Z_{s}+\\rho \\sin u \\tag{2.110}\n\\end{align*}\n\n\nwith\n\n\n\\begin{align*}\n\\cos u & =\\frac{\\partial Z_{s}}{\\partial l}  \\tag{2.111}\\\\\n\\sin u & =-\\frac{\\partial R_{s}}{\\partial l} \\tag{2.112}\n\\end{align*}\n\n\nwhere the subscript s means the value on the surface of consideration.\\\\\nThe metric elements are:\n\n\n\\begin{align*}\ng_{\\rho \\rho} & =1  \\tag{2.113}\\\\\ng_{l l} & =\\left(1+\\frac{\\rho}{r_{c}}\\right)  \\tag{2.114}\\\\\ng_{\\varphi \\varphi} & =R^{2} \\tag{2.115}\n\\end{align*}\n\n\nThe Jacobian is then:\n\n\n\\begin{equation*}\nJ_{\\rho}=R\\left(1+\\frac{\\rho}{r_{c}}\\right) \\tag{2.116}\n\\end{equation*}\n\n\nwith $r_{c}$ being the curvature radius:\n\n\n\\begin{equation*}\nr_{c}=g_{\\theta \\theta}^{3 / 2}\\left(\\frac{\\partial R}{\\partial \\theta} \\frac{\\partial^{2} Z}{\\partial \\theta^{2}}-\\frac{\\partial Z}{\\partial \\theta} \\frac{\\partial^{2} R}{\\partial \\theta^{2}}\\right)^{-1} \\tag{2.117}\n\\end{equation*}\n\n\nTo switch from $(\\rho, l, \\varphi)$ to $(r, \\theta, \\varphi)$ the following relations are important (all quantities are taken on the flux surface) :\n\n\n\\begin{align*}\n\\frac{\\partial \\rho}{\\partial r} & =\\cos u \\frac{\\partial R}{\\partial r}+\\sin u \\frac{\\partial Z}{\\partial r}  \\tag{2.118}\\\\\n\\frac{\\partial l}{\\partial r} & =\\cos u \\frac{\\partial Z}{\\partial r}-\\sin u \\frac{\\partial R}{\\partial r}  \\tag{2.119}\\\\\n\\frac{\\partial \\rho}{\\partial \\theta} & =0  \\tag{2.120}\\\\\n\\frac{\\partial l}{\\partial \\theta} & =\\sqrt{g_{\\theta \\theta}} \\tag{2.121}\n\\end{align*}\n\n\nFrom the definition of the poloidal magnetic field:\n\n\n\\begin{equation*}\nB_{p}^{2}=|\\nabla \\varphi|^{2}|\\nabla \\Psi|^{2}=\\frac{\\Psi_{1}^{2}}{R_{s}^{2}} \\tag{2.122}\n\\end{equation*}\n\n\none finds\n\n\n\\begin{equation*}\n\\Psi_{1}=R_{s} B_{p s} \\tag{2.123}\n\\end{equation*}\n\n\n$\\Psi_{2}$ is obtained from the Grad-Shafranov equation for the expansion of $\\Psi$ :\n\n\n\\begin{equation*}\nR \\nabla \\cdot \\frac{\\nabla \\Psi}{R^{2}}=-\\mu_{0} R^{2} p^{\\prime}(\\Psi)-F F^{\\prime}(\\Psi) \\tag{2.124}\n\\end{equation*}\n\n\nwith ' corresponding to the derivative toward the poloidal magnetic flux. One can easily obtain:\n\n\n\\begin{equation*}\n\\Psi_{2}=\\frac{1}{2}\\left(B_{p} \\cos u-\\frac{B_{p} R}{r_{c}}-\\mu_{0} R^{2} p^{\\prime}-F F^{\\prime}\\right) \\tag{2.125}\n\\end{equation*}\n\n\nFrom this point we see that we have other parameters : $F$ (see the normalisation section), $F^{\\prime}, p^{\\prime}, \\frac{d \\Psi}{d r}$ that we need to link to our first set of parameters. The relation for $F^{\\prime}$ will be expressed later (it is not trivial).\n\n\\section*{Relations for $p^{\\prime}$ and $\\frac{d \\Psi}{d r}$}\n$\\frac{d \\Psi}{d r}$ is obtained from the definition of $q$ :\n\n\n\\begin{equation*}\nq=\\frac{1}{2 \\pi} \\int_{0}^{2 \\pi} \\frac{\\mathbf{B} \\cdot \\nabla \\varphi}{\\mathbf{B} \\cdot \\nabla \\theta} \\mathrm{~d} \\theta \\tag{2.126}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{equation*}\n\\mathbf{B}=s_{B} F \\nabla \\varphi+s_{J} \\nabla \\varphi \\times \\nabla \\Psi \\tag{2.127}\n\\end{equation*}\n\n\nIt follows :\n\n\n\\begin{equation*}\nq=s_{B} s_{J} \\frac{F}{2 \\pi \\frac{\\mathrm{~d} \\Psi}{\\mathrm{~d} r}} \\int_{0}^{2 \\pi} \\frac{J_{r}}{R^{2}} \\mathrm{~d} \\theta \\tag{2.128}\n\\end{equation*}\n\n\nyields\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\Psi}{\\mathrm{~d} r}=s_{B} s_{J} \\frac{F}{2 \\pi q} \\int_{0}^{2 \\pi} \\frac{J_{r}}{R^{2}} \\mathrm{~d} \\theta \\tag{2.129}\n\\end{equation*}\n\n\nNumerical integrals are implemented using Simpson's method.\\\\\n$p^{\\prime}$ is given from the relation in [37]:\n\n\n\\begin{equation*}\n\\alpha=-\\frac{2 \\frac{\\partial V}{\\partial \\Psi}}{(2 \\pi)^{2}}\\left(\\frac{V}{2 \\pi^{2} R_{\\mathrm{mil}}}\\right)^{1 / 2} \\mu_{0} p^{\\prime} \\tag{2.130}\n\\end{equation*}\n\n\nV is the volume defined by the magnetic flux surface :\n\n\n\\begin{equation*}\nV=2 \\pi S R_{G} \\tag{2.131}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{align*}\nR_{G} & =\\frac{\\int_{0}^{2 \\pi} R \\sqrt{\\left(\\frac{\\partial R}{\\partial \\theta}\\right)^{2}+\\left(\\frac{\\partial Z}{\\partial \\theta}\\right)^{2}} \\mathrm{~d} \\theta}{\\int_{0}^{2 \\pi} \\sqrt{\\left(\\frac{\\partial R}{\\partial \\theta}\\right)^{2}+\\left(\\frac{\\partial Z}{\\partial \\theta}\\right)^{2}} \\mathrm{~d} \\theta}  \\tag{2.132}\\\\\nS & =\\int_{0}^{2 \\pi} Z \\frac{\\partial R}{\\partial \\theta} \\tag{2.133}\n\\end{align*}\n\n\n$\\frac{\\partial V}{\\partial \\Psi}$ can easily be defined analytically by differentiating towards $r$ and using $\\frac{\\mathrm{d} \\Psi}{\\mathrm{d} r}$\n\n\\section*{Effect of toroidal rotation on the magnetic equilibrium}\nForce balance equation for species a:\n\n\n\\begin{equation*}\nm_{a} n_{a}\\left(\\frac{\\partial}{\\partial t}+V_{a} \\cdot \\nabla\\right) V_{a}=-\\nabla p_{a}-\\nabla \\cdot \\pi_{a}+e_{a} n_{a}\\left(E+V_{a} \\times B\\right)+R_{a} \\tag{2.134}\n\\end{equation*}\n\n\nViscosity $\\nabla \\cdot \\pi_{a}$ and friction $R_{a}$ are being neglected.\\\\\nA two species model with singly (for now) charged ions is considered (trace species can be added but won't affect the magnetic equilibrium: $m_{t} n_{t} \\ll m_{i} n_{i}$, i being the main ion species). Using $m_{e} \\ll m_{i}$ and taking the dot product of force balance equation with $\\mathbf{b}$, one obtains:\n\n\n\\begin{align*}\n& n_{e}=n_{R_{0}, e} \\exp \\left(\\frac{e \\Phi}{T_{e}}\\right)  \\tag{2.135}\\\\\n& n_{i}=n_{R_{0}, i} \\exp \\left(\\frac{-e \\Phi}{T_{i}}+\\frac{m_{i} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right)}{2 T_{i}}\\right) \\tag{2.136}\n\\end{align*}\n\n\n$T_{i}$ is supposed to be a flux function (might not be always the case [39])\\\\\nUsing Quasineutrality and $T_{e} \\sim T_{i}$ :\n\n\n\\begin{equation*}\ne \\phi=\\frac{T_{e}}{T_{e}+T_{i}} \\frac{m_{i}}{T_{i}} \\frac{1}{2} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right) \\tag{2.137}\n\\end{equation*}\n\n\nThe total pressure is then:\n\n\n\\begin{equation*}\np=T n \\exp \\left(\\frac{m_{i} \\Omega^{2}}{2 T}\\left(R^{2}-R_{0}^{2}\\right)\\right) \\tag{2.138}\n\\end{equation*}\n\n\nwith $T=T_{e}+T_{i}$.\\\\\nFurthermore the Grad-Shafranov is modified ( $\\Psi$ and $R^{2}$ are regarded as independant variables [39]):\n\n\n\\begin{equation*}\nR^{2} \\nabla \\cdot\\left(\\frac{\\nabla \\Psi}{R^{2}}\\right)=-\\mu_{0} R^{2} \\frac{\\partial p\\left(\\Psi, R^{2}\\right)}{\\partial \\Psi}-F F^{\\prime} \\tag{2.139}\n\\end{equation*}\n\n\nIn normalised units one gets\n\n\n\\begin{align*}\n\\left(\\frac{\\partial p}{\\partial \\Psi}\\right)_{N} & =\\frac{1}{2}\\left[\\beta^{\\prime}+\\beta_{N} n_{R} m_{R, i}\\left(\\left(R_{N}^{2}-R_{0}^{2}\\right)\\left(-2 u_{N}^{\\prime} \\Omega+\\frac{T_{R, e} \\frac{R}{L_{T_{e}}}+T_{R, i} \\frac{R}{L_{T_{i}}}}{\\left(T_{R, e}+T_{R, i}\\right)}\\right)\\right.\\right. \\\\\n& \\left.\\left.\\left.-R_{0} \\frac{\\partial R_{0}}{\\partial \\epsilon} \\Omega^{2}\\right)\\right)\\right]\\left(\\frac{d \\psi}{d \\Psi}\\right)_{N} \\exp \\left(\\frac{m_{R, i} \\Omega_{N}^{2}}{\\left(T_{R, e}+T_{R, i}\\right)}\\left(R_{N}^{2}-R_{0}^{2}\\right)\\right) \\tag{2.140}\n\\end{align*}\n\n\nFrom this definition, it enters normalised Grad-Shafranov equation through:\n\n\n\\begin{equation*}\n\\left(R^{2} \\nabla \\cdot\\left(\\frac{\\nabla \\Psi}{R^{2}}\\right)\\right)_{N}=-R_{N}^{2}\\left(\\frac{\\partial p\\left(\\Psi, R^{2}\\right)}{\\partial \\Psi}\\right)_{N}-F_{N} F_{N}^{\\prime} \\tag{2.141}\n\\end{equation*}\n\n\n$\\beta^{\\prime}$ is given in SPCGENERAL. $\\beta_{N}$ can be taken from SPCGENERAL but can also be given using the GEOM parameter beta\\_rota\\_miller\\_type = 'geom' and specifying the value in beta\\_rota\\_miller. The other parameters are taken from SPECIES and ROTATION namelists.\n\n\\section*{Modification of the curvature drift}\nThe magnetic curvature can be recast as:\n\n\n\\begin{align*}\n\\kappa & =-\\mathbf{b} \\times\\left(\\nabla \\times \\frac{\\mathbf{B}}{B}\\right)  \\tag{2.142}\\\\\n\\kappa & =-\\frac{1}{B} \\mathbf{b} \\times(\\nabla \\times \\mathbf{B})-\\mathbf{b} \\times\\left[\\nabla\\left(\\frac{1}{B}\\right) \\times \\mathbf{B}\\right]  \\tag{2.143}\\\\\n\\kappa & =\\frac{\\mu_{0} J \\times B}{B^{2}}+\\frac{\\nabla_{\\perp} \\mathbf{B}}{B} \\tag{2.144}\n\\end{align*}\n\n\nWe will now only consider:\n\n\n\\begin{equation*}\n\\kappa_{1}=\\mu_{0} \\frac{J \\times B}{B^{2}} \\tag{2.146}\n\\end{equation*}\n\n\nsince the term $\\nabla_{\\perp} B$ is not modified by rotation.\n\nWithout rotation\n\n\n\\begin{equation*}\nJ \\times B=\\nabla p \\tag{2.147}\n\\end{equation*}\n\n\nwhich leads to the $\\beta^{\\prime}$ correction.\\\\\nFor strong toroidal rotation one obtains for a two fluid model with singly charged ions:\n\n\n\\begin{equation*}\nJ \\times B=-m_{i} n_{i} R \\Omega^{2} \\nabla R+\\frac{\\partial p}{\\partial \\Psi} \\frac{d \\Psi}{d \\psi} \\nabla \\psi+\\frac{\\partial p}{\\partial R^{2}} \\nabla R^{2} \\tag{2.148}\n\\end{equation*}\n\n\nThe curvature enters Vlasov equation through\n\n\n\\begin{equation*}\n\\left(\\kappa_{1} \\times \\nabla f\\right) \\cdot \\mathbf{b}=\\frac{\\mu_{0}}{B^{2}}\\left[\\left(m_{i} n_{i} \\Omega^{2}-2 \\frac{\\partial p}{\\partial R^{2}}\\right)\\left(B s_{B} \\frac{\\partial f}{\\partial x_{\\alpha}} \\mathcal{I}^{\\alpha}\\right)+2 \\frac{\\partial p}{\\partial \\Psi} \\frac{d \\Psi}{d \\psi} \\frac{\\partial f}{\\partial x_{\\beta}} \\mathcal{E}^{\\psi \\beta}\\right] \\tag{2.149}\n\\end{equation*}\n\n\n\\section*{Determination of $\\nabla s$}\nWe start from the expression of the magnetic field to express the contravariant component $B^{s}$ in the coordinate system $(\\Psi, l, \\varphi)$.\n\n\n\\begin{align*}\nB^{s}(\\Psi) & =B \\cdot \\nabla s  \\tag{2.150}\\\\\n& =B \\cdot \\nabla l \\frac{\\partial s}{\\partial l}  \\tag{2.151}\\\\\n\\frac{\\partial s}{\\partial l} & =B^{s} \\frac{1}{B \\cdot \\nabla l} \\tag{2.152}\n\\end{align*}\n\n\nFurthermore :\n\n\n\\begin{equation*}\n\\int_{0}^{L} \\frac{\\partial s}{\\partial l^{\\prime}} \\mathrm{d} l^{\\prime}=1=B^{s} \\int_{0}^{L} \\frac{1}{B \\cdot \\nabla l^{\\prime}} \\mathrm{d} l^{\\prime} \\tag{2.153}\n\\end{equation*}\n\n\nwith L being the arclength corresponding to $\\theta=2 \\pi$. Hence\n\n\n\\begin{equation*}\nB^{s}=\\frac{1}{\\int_{0}^{L} \\frac{1}{B \\cdot \\nabla l^{\\prime}} \\mathrm{d} l^{\\prime}} \\tag{2.154}\n\\end{equation*}\n\n\nOne gets the expression of $s$ in this basis:\n\n\n\\begin{equation*}\ns=B^{s} \\int_{0}^{l} \\frac{1}{B \\cdot \\nabla l^{\\prime}} \\mathrm{d} l^{\\prime} \\tag{2.155}\n\\end{equation*}\n\n\nUsing the expansion of the magnetic flux:\n\n\n\\begin{align*}\nB \\cdot \\nabla l & =s_{B} F \\nabla \\varphi \\cdot \\nabla l+s_{j} \\nabla \\varphi \\times\\left[\\left(\\Psi_{1}+2 \\rho \\Psi_{2}\\right) \\nabla \\rho+\\rho \\frac{\\partial \\Psi_{1}}{\\partial l} \\nabla l\\right] \\cdot \\nabla l  \\tag{2.156}\\\\\nB \\cdot \\nabla l & =s_{j} \\frac{\\Psi_{1}+2 \\rho \\Psi_{2}}{J_{\\rho}}  \\tag{2.157}\\\\\nB \\cdot \\nabla l & =s_{j} \\frac{\\Psi_{1}+2 \\rho \\Psi_{2}}{\\left(R_{s}+\\rho \\cos u\\right)\\left(1+\\frac{\\rho}{r_{c}}\\right)} \\tag{2.158}\n\\end{align*}\n\n\nThen\n\n\n\\begin{equation*}\n\\frac{1}{B \\cdot \\nabla l}=\\frac{s_{j}}{\\Psi_{1}}\\left[R_{s}+\\rho\\left(\\cos u+\\frac{R_{s}}{r_{c}}-2 R_{s} \\frac{\\Psi 2}{\\Psi 1}\\right)\\right] \\tag{2.159}\n\\end{equation*}\n\n\nOne can write $\\nabla s$ as\n\n\n\\begin{equation*}\n\\nabla s=\\frac{\\partial s}{\\partial \\Psi} \\nabla \\Psi+\\frac{\\partial s}{\\partial l} \\nabla l \\tag{2.160}\n\\end{equation*}\n\n\nWe need then to determine $\\frac{\\partial s}{\\partial \\Psi}$. Using the Mercier-Luc expansion of $\\Psi$ one gets the second order equation in $\\rho$ :\n\n\n\\begin{equation*}\n\\Psi_{2} \\rho^{2}+\\Psi_{1} \\rho+\\Psi_{s}-\\Psi=0 \\tag{2.161}\n\\end{equation*}\n\n\nAt $\\Psi=\\Psi_{s}, \\rho=0$. We have then $\\rho$ as a function of $\\Psi$\n\n\n\\begin{equation*}\n\\rho=\\frac{-\\Psi_{1}+\\sqrt{\\Psi_{1}^{2}-4 \\Psi_{2}\\left(\\Psi_{s}-\\Psi\\right)}}{2 \\Psi_{2}} \\tag{2.162}\n\\end{equation*}\n\n\nFor $\\Psi=\\Psi_{s}, \\frac{\\partial \\rho}{\\partial \\Psi}=\\frac{1}{\\Psi_{1}}$. We define the two following integrals:\n\n\n\\begin{align*}\nA_{1}(l) & =\\int_{0}^{l} s_{j} \\frac{R_{s}}{\\Psi_{1}} \\mathrm{~d} l^{\\prime}  \\tag{2.163}\\\\\nA_{2}(l) & =\\int_{0}^{l} \\frac{s_{j}}{\\Psi_{1}} \\frac{\\partial \\rho}{\\partial \\Psi}\\left(\\cos u+\\frac{R_{s}}{r_{c}}-2 \\frac{R_{s} \\Psi_{2}}{\\Psi_{1}}\\right) \\mathrm{d} l^{\\prime} \\tag{2.164}\n\\end{align*}\n\n\nAt $\\Psi=\\Psi_{s}$ we then have:\n\n\n\\begin{equation*}\n\\frac{\\partial s}{\\partial \\Psi}=\\frac{A_{2}(l)}{A_{1}(L)}-\\frac{A_{2}(L) A_{1}(l)}{A_{1}(L)^{2}} \\tag{2.165}\n\\end{equation*}\n\n\n$\\nabla s$ is then given on the flux surface by :\n\n\n\\begin{equation*}\n\\nabla s=\\left(\\frac{\\partial s}{\\partial \\Psi} \\frac{\\mathrm{~d} \\Psi}{\\partial \\mathrm{~d} r}+\\frac{\\partial s}{\\partial l} \\frac{\\partial l}{\\partial r}\\right) \\nabla r+\\frac{\\partial s}{\\partial l} \\frac{\\partial l}{\\partial \\theta} \\nabla \\theta \\tag{2.166}\n\\end{equation*}\n\n\n\\section*{Determination of $\\nabla \\zeta$}\nThe magnetic field can be written as:\n\n\n\\begin{equation*}\n\\mathbf{B}=s_{J} 2 \\pi \\nabla \\Psi \\times \\nabla \\zeta \\tag{2.167}\n\\end{equation*}\n\n\nUsing the following expansion for the zeta coordinate [38]:\n\n\n\\begin{equation*}\n\\zeta=\\zeta_{s}(l)+\\rho \\zeta_{1}(l)-\\frac{\\varphi}{2 \\pi}+\\mathcal{O}\\left(\\rho^{2}\\right) \\tag{2.168}\n\\end{equation*}\n\n\none gets\n\n\n\\begin{align*}\nF & =F_{s}+\\rho \\Psi_{1} F_{s}^{\\prime}+\\mathcal{O}\\left(\\rho^{2}\\right)  \\tag{2.169}\\\\\n\\nabla \\Psi & =\\left(\\Psi_{1}+2 \\rho \\Psi_{2}\\right) \\nabla \\rho+\\rho \\frac{\\partial \\Psi_{1}}{\\partial l} \\nabla l+\\mathcal{O}\\left(\\rho^{2}\\right)  \\tag{2.170}\\\\\n\\nabla \\zeta & =\\zeta_{1} \\nabla \\rho+\\left(\\frac{\\partial \\zeta_{s}}{\\partial l}+\\rho \\frac{\\partial \\zeta_{1}}{\\partial l}\\right) \\nabla l+\\frac{\\nabla \\varphi}{2 \\pi}+\\mathcal{O}\\left(\\rho^{2}\\right) \\tag{2.171}\n\\end{align*}\n\n\nFrom the two expressions of B:\n\n\n\\begin{equation*}\n2 s_{J} \\pi \\nabla \\Psi \\times \\nabla \\zeta=s_{B} F \\nabla \\varphi+s_{J} \\nabla \\Psi \\times \\nabla \\varphi \\tag{2.172}\n\\end{equation*}\n\n\ndotting with $\\nabla \\varphi$ yields\n\n\n\\begin{equation*}\n\\frac{2 \\pi s_{J}}{J_{\\rho}}\\left[\\left(\\Psi_{1}+2 \\rho \\Psi_{2}\\right)\\left(\\frac{\\partial \\zeta_{s}}{\\partial l}+\\rho \\frac{\\partial \\zeta_{1}}{\\partial l}\\right)-\\rho \\zeta_{1} \\frac{\\partial \\Psi_{1}}{\\partial l}\\right]=s_{B} \\frac{F_{s}+\\rho \\Psi_{1} F_{s}^{\\prime}}{\\left(R_{s}+\\rho \\cos u\\right)^{2}} \\tag{2.173}\n\\end{equation*}\n\n\nAt zeroth order in $\\rho$ :\n\n\n\\begin{equation*}\n\\frac{\\partial \\zeta_{s}}{\\partial l}=s_{J} s_{B} \\frac{F_{s}}{2 R_{s} \\Psi_{1} \\pi} \\tag{2.174}\n\\end{equation*}\n\n\nat first order :\n\n\n\\begin{equation*}\n2 s_{J} s_{B} \\pi\\left(\\Psi_{1} \\frac{\\partial \\zeta_{1}}{\\partial l}-\\zeta_{1} \\frac{\\partial \\Psi_{1}}{\\partial l}+2 \\Psi_{2} \\frac{\\partial \\zeta_{s}}{\\partial l}\\right)=\\frac{F_{s}}{R_{s}}\\left(\\frac{1}{r_{c}}-\\frac{\\cos u}{R_{s}}\\right)+\\frac{F_{s}^{\\prime} \\Psi_{1}}{R_{s}} \\tag{2.175}\n\\end{equation*}\n\n\nhence\n\n\n\\begin{equation*}\n\\Psi_{1}^{2} s_{J} s_{B} \\frac{\\partial}{\\partial l}\\left(\\frac{\\zeta_{1}}{\\Psi_{1}}\\right)=\\frac{1}{2 \\pi}\\left[\\frac{F_{s}}{R_{s}}\\left(\\frac{1}{r_{c}}-\\frac{\\cos u}{R_{s}}\\right)+\\frac{F_{s}^{\\prime} \\Psi_{1}}{R_{s}}\\right]-2 \\Psi_{2} \\frac{\\partial \\zeta_{s}}{\\partial l} \\tag{2.176}\n\\end{equation*}\n\n\n$\\zeta_{s}$ and $\\zeta_{1}$ are then defined by:\n\n\n\\begin{align*}\n\\zeta_{s}(l) & =s_{J} s_{B} \\int_{0}^{l} \\frac{F_{s}}{2 \\pi R_{s} \\Psi_{1}} \\mathrm{~d} l^{\\prime}  \\tag{2.177}\\\\\n\\zeta_{1}(l) & =s_{J} s_{B} \\Psi_{1} \\int_{0}^{l}\\left(\\frac{1}{2 \\pi}\\left[\\frac{F_{s}}{R_{s}}\\left(\\frac{1}{r_{c}}-\\frac{\\cos u}{R_{s}}\\right)+\\frac{F_{s}^{\\prime} \\Psi_{1}}{R_{s}}\\right]-\\frac{\\Psi_{2} F_{s}}{\\pi R_{s} \\Psi_{1}}\\right) \\frac{1}{\\Psi_{1}^{2}} \\mathrm{~d} l^{\\prime} \\tag{2.178}\n\\end{align*}\n\n\nreplacing $\\Psi_{2}$ by its value one can define the following integrals:\n\n\n\\begin{align*}\nD_{0}(l) & =\\int_{0}^{l} \\frac{F_{s}}{\\pi \\Psi_{1}^{2} R_{s}}\\left(\\frac{1}{r_{c}}-\\frac{\\cos u}{R_{s}}\\right) \\mathrm{d} l^{\\prime}  \\tag{2.179}\\\\\nD_{1}(l) & =\\int_{0}^{l}\\left(\\frac{F_{s}^{2}}{2 \\pi R_{s} \\Psi_{1}^{3}}+\\frac{1}{2 \\pi R_{s} \\Psi_{1}}\\right) \\mathrm{d} l^{\\prime}  \\tag{2.180}\\\\\nD_{2}(l) & =\\int_{0}^{l} \\frac{\\mu_{0} R_{s} F_{s}}{2 \\pi \\Psi_{1}^{3}} \\mathrm{~d} l^{\\prime} \\tag{2.181}\n\\end{align*}\n\n\n$\\zeta_{1}(l)$ can be then written in the form:\n\n\n\\begin{equation*}\n\\zeta_{1}(l)=s_{J} s_{B} \\Psi_{1}\\left(D_{0}(l)+D_{1}(l) F^{\\prime}+D_{2}(l) p^{\\prime}\\right) \\tag{2.182}\n\\end{equation*}\n\n\nWarning: If the plasma rotation is taken into account through $p^{\\prime}$, it will depend on $R$ and therefore on $l . p^{\\prime}$ is then in $D_{2}(l)$\\\\\n$F^{\\prime}$ has not yet been linked to the input parameters. Once we have $F^{\\prime}$ we see that $\\frac{\\partial \\zeta}{\\partial l}=\\zeta_{s}$ and $\\frac{\\partial \\zeta}{\\partial \\rho}=\\zeta_{1}$. $\\nabla \\zeta$ is then given on the flux surface by:\n\n\n\\begin{equation*}\n\\nabla \\zeta=\\left(\\zeta_{s} \\frac{\\partial l}{\\partial r}+\\zeta_{1} \\frac{\\partial \\rho}{\\partial r}\\right) \\nabla r+\\zeta_{s} \\frac{\\partial l}{\\partial \\theta} \\nabla \\theta \\tag{2.183}\n\\end{equation*}\n\n\n\\section*{Relation for $\\mathbf{F}^{\\prime}$}\nUsing the expression of q and the specific boundary condition [38]:\n\n\n\\begin{equation*}\n\\zeta(\\Psi, 0, \\varphi)=F I X M E \\tag{2.184}\n\\end{equation*}\n\n\none gets\n\n\n\\begin{equation*}\n\\zeta(\\Psi, 2 \\pi, \\varphi)=-2 \\pi q(\\Psi) \\tag{2.185}\n\\end{equation*}\n\n\nusing the expansion of $\\Psi$ we have the following equation:\n\n\n\\begin{equation*}\n-2 \\pi\\left(q_{s}+q_{s}^{\\prime} \\rho \\Psi_{1}\\right)+\\mathcal{O}\\left(\\rho^{2}\\right)=\\zeta_{s}(L)+\\rho \\zeta_{1}(L)+\\mathcal{O}\\left(\\rho^{2}\\right) \\tag{2.186}\n\\end{equation*}\n\n\nWe then have:\n\n\n\\begin{equation*}\nF_{s}^{\\prime}=\\frac{2 \\pi \\hat{s} \\frac{q}{r}-D_{0}(L)-D_{2}(L) p^{\\prime}}{D_{1}(L)} \\tag{2.187}\n\\end{equation*}\n\n\n\\section*{Contravariant metric tensor of $(r, \\zeta, s)$}\nWe can then deduce the contravariant metric tensor in the GKW basis.\n\n\n\\begin{align*}\ng^{r \\zeta} & =g^{\\zeta r}=\\frac{\\partial \\zeta}{\\partial r} g^{r r}+\\frac{\\partial \\zeta}{\\partial \\theta} g^{r \\theta}  \\tag{2.188}\\\\\ng^{r s} & =g^{s r}=\\frac{\\partial s}{\\partial r} g^{r r}+\\frac{\\partial s}{\\partial \\theta} g^{r \\theta}  \\tag{2.189}\\\\\ng^{\\zeta \\zeta} & =\\left(\\frac{\\partial \\zeta}{\\partial r}\\right)^{2} g^{r r}+\\left(\\frac{\\partial \\zeta}{\\partial \\theta}\\right)^{2} g^{\\theta \\theta}+2 \\frac{\\partial \\zeta}{\\partial r} \\frac{\\partial \\zeta}{\\partial \\theta} g^{r \\theta}+\\frac{1}{4 \\pi^{2}} g^{\\varphi \\varphi}  \\tag{2.190}\\\\\ng^{s s} & =\\left(\\frac{\\partial s}{\\partial r}\\right)^{2} g^{r r}+\\left(\\frac{\\partial s}{\\partial \\theta}\\right)^{2} g^{\\theta \\theta}+2 \\frac{\\partial s}{\\partial r} \\frac{\\partial s}{\\partial \\theta} g^{r \\theta}  \\tag{2.191}\\\\\ng^{\\zeta s} & =g^{s \\zeta}=\\left(\\frac{\\partial \\zeta}{\\partial r} \\frac{\\partial s}{\\partial r}\\right) g^{r r}+\\left(\\frac{\\partial \\zeta}{\\partial \\theta} \\frac{\\partial s}{\\partial \\theta}\\right) g^{\\theta \\theta}+\\left(\\frac{\\partial \\zeta}{\\partial r} \\frac{\\partial s}{\\partial \\theta}+\\frac{\\partial \\zeta}{\\partial \\theta} \\frac{\\partial s}{\\partial r}\\right) g^{r \\theta} \\tag{2.192}\n\\end{align*}\n\n\n\\section*{Derivatives of the magnetic field strength}\nTo obtain the derivatives of the magnetic field strength B we start from [38]:\n\n\n\\begin{align*}\nB_{p}^{2} & =|\\nabla \\varphi|^{2}|\\nabla \\Psi|^{2}  \\tag{2.193}\\\\\nB_{t}^{2} & =\\left|\\frac{F(\\Psi)}{R}\\right| \\tag{2.194}\n\\end{align*}\n\n\nUsing the expansion of the magnetic flux one obtains:\n\n\n\\begin{align*}\nR^{2} B_{p}^{2} & =\\left(\\Psi_{1}+2 \\rho \\Psi_{2}\\right)^{2} g^{\\rho \\rho}+\\left(\\rho \\frac{\\partial \\Psi_{1}^{2}}{\\partial l} g^{l l}\\right)  \\tag{2.195}\\\\\n& =\\Psi_{1}^{2}+4 \\rho \\Psi_{1} \\Psi_{2}+\\mathcal{O}\\left(\\rho^{2}\\right)  \\tag{2.196}\\\\\nR^{2} B_{t}^{2} & =F_{s}^{2}+2 \\rho \\Psi_{1} F_{s} F_{s}^{\\prime}+\\mathcal{O}\\left(\\rho^{2}\\right) \\tag{2.197}\n\\end{align*}\n\n\nUsing now the expansion on $R$ and differentiating by $\\rho$ and $l$\n\n", "\n\\begin{align*}\n\\frac{\\partial B_{p}^{2}}{\\partial \\rho} & =\\frac{1}{R_{s}^{2}}\\left(4 \\Psi_{1} \\Psi_{2}-2 \\frac{\\Psi_{1}^{2}}{R_{s}} \\cos u\\right)  \\tag{2.198}\\\\\n\\frac{\\partial B_{t}^{2}}{\\partial \\rho} & =\\frac{1}{R_{s}^{2}}\\left(2 F_{s} F_{s}^{\\prime} \\Psi_{1}-2 \\frac{F_{s}^{2}}{R_{s}} \\cos u\\right)  \\tag{2.199}\\\\\n\\frac{\\partial B_{p}^{2}}{\\partial l} & =\\frac{1}{R_{s}^{2}}\\left(2 \\Psi_{1} \\frac{\\partial \\Psi_{1}}{\\partial l}-2 \\frac{\\partial R_{s}}{\\partial l} \\frac{\\Psi_{1}^{2}}{R_{s}}\\right)  \\tag{2.200}\\\\\n\\frac{\\partial B_{t}^{2}}{\\partial l} & =-\\frac{2}{R_{s}^{2}} \\frac{\\partial R_{s}}{\\partial l} \\frac{F^{2}}{R_{s}} \\tag{2.201}\n\\end{align*}\n\n\nWe can then deduce the derivatives of B by summing the previous equations\n\n\n\\begin{align*}\n\\frac{\\partial\\left(B^{2}\\right)}{\\partial \\rho} & =\\frac{1}{R_{s}^{2}}\\left(4 \\Psi_{1} \\Psi_{2}-2 \\cos u \\frac{\\Psi_{1}}{R_{s}^{2}}+2 F_{s} F_{s}^{\\prime} \\Psi_{1}-2 \\frac{F_{s}^{2}}{R_{s} \\cos u}\\right)  \\tag{2.202}\\\\\n\\frac{\\partial\\left(B^{2}\\right)}{\\partial l} & =\\frac{1}{R_{s}^{2}}\\left(2 \\Psi_{1} \\frac{\\partial \\Psi_{1}}{\\partial l}-2 \\frac{\\partial R_{s}}{\\partial l}\\left(\\frac{\\Psi_{1}^{2}}{R_{s}}-\\frac{F^{2}}{R_{s}}\\right)\\right) \\tag{2.203}\n\\end{align*}\n\n\nA successful benchmark of the Miller geometry against GS2 is presented in Sec. 11.1.\n\n\\subsection*{2.2.4 Sheared slab geometry}\nFor consistency with the way the geometry and boundary conditions are treated in the code here we derive Hamada field aligned slab coordinates.\n\nWe require that $\\boldsymbol{B} \\cdot \\nabla s=B^{s}$ is a flux function.\\\\\nThe normalised coordinate along the field line is defined similary to the toroidal case, where:\n\n\n\\begin{equation*}\ns=\\frac{z}{l_{s}} \\tag{2.204}\n\\end{equation*}\n\n\nWhere s varied between $-1 / 2$ and $1 / 2$. The components of the magnetic field are written as:\n\n\n\\begin{align*}\n\\boldsymbol{B} \\cdot \\nabla s & =\\boldsymbol{B} \\cdot \\nabla x \\frac{\\partial s}{\\partial x}+\\boldsymbol{B} \\cdot \\nabla y \\frac{\\partial s}{\\partial y}+\\boldsymbol{B} \\cdot \\nabla z \\frac{\\partial s}{\\partial z}  \\tag{2.205}\\\\\n\\boldsymbol{B} \\cdot \\nabla z & =B^{z} \\frac{\\partial s}{\\partial z}=B^{z} / l_{z}=B^{s}  \\tag{2.206}\\\\\nB^{s} & =B^{z} / l_{z} \\tag{2.207}\n\\end{align*}\n\n\nWhere $l_{x}, l_{y}$ and $l_{z}$ are the computational box sizes in each of the three directions.\\\\\nThe perpendicular component has the form:\n\n\n\\begin{equation*}\n\\boldsymbol{B} \\cdot \\nabla \\zeta=\\boldsymbol{B} \\cdot \\nabla y \\frac{\\partial \\zeta}{\\partial y}+\\boldsymbol{B} \\cdot \\nabla z \\frac{\\partial \\zeta}{\\partial z}=0 \\tag{2.208}\n\\end{equation*}\n\n\nWhich gives:\n\n\n\\begin{equation*}\nB^{y} \\frac{\\partial \\zeta}{\\partial y}+B^{z} \\frac{\\partial \\zeta}{\\partial z}=0 \\tag{2.209}\n\\end{equation*}\n\n\nIf we say that the binormal coordinate is a linear function of the x and z directions\n\n\n\\begin{equation*}\n\\zeta=\\alpha y+\\beta z \\tag{2.210}\n\\end{equation*}\n\n\nwe choose $\\alpha=-1$, which gives:\n\n\n\\begin{equation*}\n\\beta=\\frac{B^{y}}{B^{z}} \\tag{2.211}\n\\end{equation*}\n\n\nThe field aligned, sheared slab coordinate transform from cartesian coordinates $\\mathrm{x}, \\mathrm{y}, \\mathrm{z}$ can be written as:\n\n\n\\begin{align*}\n\\psi & =x \\\\\n\\zeta & =-y+\\frac{B^{y}}{B^{z}} z \\\\\ns & =z \\tag{2.212}\n\\end{align*}\n\n\nThe negative sign in the definition of $\\zeta$ is used to obtain the same right handed set $(\\psi, \\zeta, s)$ as in the toroidal geometry. CAUTION: This means that the set $(x, y, z)$ is left handed. Here $y$ corresponds to $\\gamma$.\n\nWe expand the y component $\\left(B_{0}^{y}=0\\right)$ giving:\n\n\n\\begin{equation*}\nB^{y}=\\left(B_{y}^{\\prime}\\right) \\psi \\tag{2.213}\n\\end{equation*}\n\n\nwhere the prime denotes the radial derivative, and as such we define\n\n\n\\begin{equation*}\n\\hat{s}=\\frac{1}{\\boldsymbol{B} \\cdot \\nabla z} \\frac{\\partial}{\\partial x}(\\boldsymbol{B} \\cdot \\nabla y) \\tag{2.214}\n\\end{equation*}\n\n\nWhen we normalise the y direction, we get a perpendicular component of the form:\n\n\n\\begin{equation*}\n\\zeta_{N}=-\\frac{y}{l_{y}}-\\hat{s}_{N} \\frac{l_{x} l_{z}}{l_{y}} \\psi s \\tag{2.215}\n\\end{equation*}\n\n\n(signs ???) where\n\n\n\\begin{equation*}\n\\hat{s}_{N}=\\frac{l_{x} l_{z}}{l_{y}} \\hat{s} \\tag{2.216}\n\\end{equation*}\n\n\nThis is the same as having the magnetic field of the form:\n\n\n\\begin{equation*}\n\\boldsymbol{B}=B_{0}(\\hat{z}+\\hat{s} x \\hat{y}) \\tag{2.217}\n\\end{equation*}\n\n\nWith this form it can be shown that:\n\n\n\\begin{equation*}\n\\boldsymbol{b} \\cdot \\nabla=\\frac{\\partial}{\\partial s} \\tag{2.218}\n\\end{equation*}\n\n\nThe differentials have the form:\n\n\n\\begin{align*}\n\\nabla \\psi & =\\frac{\\partial x^{\\prime}}{\\partial x} \\hat{x}=\\hat{x}  \\tag{2.219}\\\\\n\\nabla \\zeta & =-\\hat{y}+\\hat{s} z \\hat{x}+\\hat{s} x \\hat{z}  \\tag{2.220}\\\\\n\\nabla s & =\\hat{z} \\tag{2.221}\n\\end{align*}\n\n\nIn the slab model, the input parameters $\\epsilon$ and $q$ do not affect the geometry but must both be set to 1 for correct $k_{x}$ mode spacing with mode\\_box $=T$. It can be seen that to obtain correspondance with the toroidal geometries, we must set $q=\\hat{s} \\psi$.\n\n\\section*{Parallel Boundary Conditions}\nThe slab is always defined to be periodic in the 'radial' ( x ) and 'poloidal' ( y ) directions. We may also wish to maintain the parallel ( z ) periodicity and shear boundary conditions as in the toroidal case (Sec. 2.3), i.e.\n\n\n\\begin{equation*}\nf(\\psi, \\zeta, s+1 / 2)=f(\\psi, \\zeta, s-1 / 2) \\tag{2.222}\n\\end{equation*}\n\n\nThe mode amplitudes\n\n\n\\begin{equation*}\nA \\exp \\imath k_{\\zeta} \\zeta=A_{-1 / 2} \\exp \\imath k_{\\zeta} \\zeta_{0}-\\imath k_{\\zeta} 1 / 2 \\hat{s} x=A_{1 / 2} \\exp \\imath k_{\\zeta} \\zeta_{0}+\\imath k_{\\zeta} 1 / 2 \\hat{s} x \\tag{2.223}\n\\end{equation*}\n\n\nand as such\n\n\n\\begin{equation*}\n\\Delta k_{x}=k_{\\zeta} \\frac{\\hat{s}}{i_{k}} \\tag{2.224}\n\\end{equation*}\n\n\nwhere $i_{k}$ is an integer. To allow the slab periodicity condition to be equivalent with the condition in toroidal geometry, we must set $q=1$ and $\\epsilon=1$ in the slab case (c.f eq. 2.255 ). This makes the toroidal $\\hat{s}$ equivalent to the one defined above, allowing the same numerical implementation for all geometries. The periodic slab is selected in GKW as the geometry 'slab\\_periodic', for use with mode box only. See also Hammett et Al 1993.\n\nAlternatively the slab model can be chosen to be not periodic but infinite in the parallel direction. In GKW the 'slab' model has no periodicity (the boundary condition is flappy, the same as at the \"end\" of the toroidal field line). For 'slab' only, nperiod $>1$ can therefore be run with mode box. Without mode box, 'slab' and 'slab\\_periodic' are identical.\n\n\\section*{Geometry tensors}\nWARNING: The signs in this section are incorrect and need to be fixed. The $S_{B}$ and $S_{j}$ were added by anaolgy with the toroidal case and are not kept in the derivation above.\n\nWe now calculate the geometry tensors, first the diagonal terms are as follows,\n\n\n\\begin{align*}\ng^{\\psi \\psi} & =\\nabla \\psi \\cdot \\nabla \\psi=1  \\tag{2.225}\\\\\ng^{\\zeta \\zeta} & =\\nabla \\zeta \\cdot \\nabla \\zeta=1+(\\hat{s} s)^{2}+(s x)^{2}=1+(\\hat{s} s)^{2}  \\tag{2.226}\\\\\ng^{s s} & =\\nabla s \\cdot \\nabla s=1 \\tag{2.227}\n\\end{align*}\n\n\nthen the off diagonal:\n\n\n\\begin{align*}\ng^{\\psi \\zeta} & =\\nabla \\psi \\cdot \\nabla \\zeta=-s_{B} s_{j} \\hat{s} s=g^{\\zeta \\psi}  \\tag{2.229}\\\\\ng^{\\psi s} & =g^{s \\psi}=0  \\tag{2.230}\\\\\ng^{\\zeta s} & =g^{s \\zeta}=-\\hat{s} x=0 \\tag{2.231}\n\\end{align*}\n\n\nfinally the derived tensors\n\n\\[\n\\begin{array}{ll} \n& \\mathcal{D}=\\mathcal{G}=\\mathcal{H}=\\mathcal{I}=0 \\\\\n\\mathcal{F}=s_{j}, \\quad & \\mathcal{E}^{\\psi \\zeta}=-\\mathcal{E}^{\\zeta \\psi}=-\\frac{s_{j}}{2} \\tag{2.233}\n\\end{array}\n\\]\n\nwith all other components of $\\mathcal{E}=0$.\\\\\nWe maintain the local approximation and the above tensors are evaluated at the centre of the computational domain, which is set to $x=0$.\n\n\\subsection*{2.2.5 General geometry}\nThe metric elements for general toroidal MHD equilibria can be obtained from the CHEASE code [42]. The sign of the magnetic field and plasma current are not taken into account into CHEASE which always consider that $\\mathbf{B}$ and $\\mathbf{j}$ are in the direction opposite to $\\nabla \\varphi$ (here $\\nabla \\varphi=\\nabla \\varphi_{\\mathrm{GKW}}$, as everywhere in this document). The sign of $\\mathbf{B}$ and $\\mathbf{j}$ are therefore specified in GKW, in the GEOM namelist using the variables SIGNB and SIGNJ defined as in the previous section by $s_{\\mathrm{B}}=\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla \\varphi)$ and $s_{\\mathrm{j}}=\\operatorname{sign}(\\mathbf{j} \\cdot \\nabla \\varphi)$. The flux surface of interest is also specified in the GEOM namelist using the EPS parameter. Depending on the value (1 or 2) of the EPS\\_TYPE parameter, EPS is either the local inverse aspect ratio (i.e. the $\\psi$ coordinate of GKW) or $\\rho_{\\Psi}$ the square root of the normalised poloidal flux ( $\\rho_{\\Psi}=0$ on the axis and $\\rho_{\\Psi}=1$ on the last closed flux surface). When CHEASE is used, the absolute value of the safety factor and magnetic shear (used for the periodicity condition and to set the radial wave vector grid) is taken from the equilibrium reconstruction and the values specified in the namelist GEOM are not read.\n\nWhen wished, the values of $\\beta$ and $\\beta^{\\prime}$ consistent with the MHD equilibrium can be used as inputs in GKW as detailed in Sec. 9.3.6.\n\nFor the CHEASE geometry, $R_{\\text {ref }}=R 0 E X P$ which is specified by CHEASE. It may be near the magnetic axis, but you should always check the value used in the hamada.dat output of CHEASE. The seperate document RunChease.tex contains more information on running CHEASE for GKW.\n\nThe $R_{0}=R_{\\text {axis }}$ option for the centrifugal terms is not quite exact for the general geometry, since an $s$ point on the axis may not exist. The nearest $s$ point to $\\theta=\\pi / 2$ is taken (the TOP intersection of the flux surface\\\\\nwith the magnetic axis). For heavy impurities, this approximation could be innaccurate. The $R_{0}=R_{\\text {LFS }}$ option is exact for $R_{0}=R(s=0)$, which may not be at $\\theta=0$ The value of the poloidal angle used is output to screen, and the actual $R_{0}$ used is written to geom.dat.\n\n\\subsection*{2.2.6 Summary of the sign conventions in GKW}\nIn GKW, the cylindrical coordinate system $(R, Z, \\varphi)$ is right handed, which means that $\\varphi$ is increasing clockwise when the torus is viewed from above.\\\\\nThe toroidal rotation is defined positive for a plasma flowing in the direction of $\\mathbf{B}$.\\\\\nThe mode frequency is defined positive for a perturbation evolving in the direction opposite to $\\nabla \\zeta$. This corresponds to the ion $\\nabla B$ drift direction if $s_{\\mathrm{j}}=1$ and to the electron $\\nabla B$ drift direction if $s_{\\mathrm{j}}=-1$. See also Fig. 10.1\\\\\nCoordinate system:\n\n\\begin{itemize}\n  \\item $\\psi=\\varepsilon=\\left(R_{\\max }-R_{\\min }\\right) /\\left(2 R_{\\mathrm{ref}}\\right)$ is always increasing from the plasma center to the plasma edge.\n  \\item $s$ is always increasing upwards from the low field side midplane. It is zero at the height of the magnetic axis, on the low field side midplane.\n  \\item $\\zeta$ is always increasing in the direction opposite to $\\varphi$ (i.e. anticlockwise when viewed from above) at constant $\\psi$ and $s$. The direction of $\\nabla \\zeta$ in the poloidal plane is given by $\\operatorname{sign}(\\nabla s \\cdot \\nabla \\zeta)=\\operatorname{sign}(\\nabla \\zeta \\cdot \\nabla \\theta)=$ $s_{\\mathrm{B}} s_{\\mathrm{j}}$\n\\end{itemize}\n\n\n\\begin{align*}\n\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla \\varphi) & \\equiv s_{\\mathrm{B}}  \\tag{2.235}\\\\\n\\operatorname{sign}(\\mathbf{j} \\cdot \\nabla \\varphi) & \\equiv s_{\\mathrm{j}}  \\tag{2.236}\\\\\n\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla \\theta) & =s_{\\mathrm{j}}  \\tag{2.237}\\\\\n\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla s) & =s_{\\mathrm{j}}  \\tag{2.238}\\\\\n\\operatorname{sign}(\\nabla \\varphi \\cdot \\nabla \\zeta) & =-1  \\tag{2.239}\\\\\n\\operatorname{sign}(\\nabla s \\cdot \\nabla \\theta) & =1  \\tag{2.240}\\\\\n\\operatorname{sign}(\\nabla \\theta \\cdot \\nabla \\zeta) & =s_{\\mathrm{B}} s_{\\mathrm{j}}  \\tag{2.241}\\\\\n\\operatorname{sign}\\left(B_{\\theta} \\nabla \\theta \\cdot \\nabla \\zeta\\right) & =s_{\\mathrm{B}}  \\tag{2.242}\\\\\n\\operatorname{sign}(\\nabla s \\cdot \\nabla \\zeta) & =s_{\\mathrm{B}} s_{\\mathrm{j}}  \\tag{2.243}\\\\\n\\mathbf{B} \\cdot \\nabla \\zeta & =0  \\tag{2.244}\\\\\n\\Omega & =-s_{\\mathrm{B}} \\Omega \\nabla z  \\tag{2.245}\\\\\nu & =R \\Omega \\tag{2.246}\n\\end{align*}\n\n\n\\subsection*{2.3 Spectral representation}\nGKW uses a combination of finite difference techniques and pseudo-spectral methods (similar to GS2 [11, 12]). Due to the homogeneous nature of the turbulence all perturbed quantities in the plane perpendicular to the magnetic field are represented by a sum over Fourier modes\n\n\n\\begin{equation*}\nf(\\psi, \\zeta, s)=\\sum_{k_{\\zeta} k_{\\psi}} \\hat{f}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta} \\zeta / \\rho_{*}+\\mathrm{i} k_{\\psi} \\psi / \\rho_{*}\\right]=\\mathcal{T}^{-1}(\\hat{f}), \\tag{2.247}\n\\end{equation*}\n\n\nwhere the normalised Larmor radius $\\left(\\rho_{*}\\right)$ has been added for convenient normalisation so that\n\n\n\\begin{equation*}\n\\rho_{*} \\frac{\\partial}{\\partial x_{\\alpha}} \\rightarrow \\mathrm{i} k_{\\alpha} \\tag{2.248}\n\\end{equation*}\n\n\nBecause the distribution function is real, the Fourier amplitude of the mode with wave vector $\\left(k_{\\zeta}, k_{\\psi}\\right)$ is equal to the complex conjugate of the mode with the wave vector $\\left(-k_{\\zeta},-k_{\\psi}\\right)$. Internally, the code, therefore, calculates the evolution of the modes with $k_{\\zeta} \\geq 0$ only, whereas both positive as well as negative radial wave vectors $\\left(k_{\\psi}\\right)$ are used. For $k_{\\zeta}>0$ both signs of the wave vector are, therefore, not represented internally, whereas for $k_{\\zeta}=0$ they are. Consequently the real valued distribution function, when expressed in the modes evaluated in the code is\n\n\n\\begin{align*}\nf(\\psi, \\zeta, s)= & \\sum_{k_{\\zeta}>0, k_{\\psi}}\\left[\\hat{f}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta} \\zeta / \\rho_{*}+\\mathrm{i} k_{\\psi} \\psi / \\rho_{*}\\right]+\\hat{f}^{\\dagger}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\exp \\left[-\\mathrm{i} k_{\\zeta} \\zeta / \\rho_{*}+\\mathrm{i} k_{\\psi} \\psi / \\rho_{*}\\right]\\right] \\\\\n& +\\sum_{k_{\\zeta}=0, k_{\\psi}} \\hat{f}\\left(k_{\\psi}, k_{\\zeta}=0, s\\right) \\exp \\left[\\mathrm{i} k_{\\psi} \\psi / \\rho_{*}\\right] \\tag{2.249}\n\\end{align*}\n\n\nwhere the dagger denotes the complex conjugate. For the correct calculation of quadratic quantities like the fluxes, for instance, this representation must be considered and can lead to additional factors of two, when compared with the straightforward Fourier representation (see also section 10.4).\n\nIn what follows a $\\hat{\\sim}$ indicates the Fourier representation of a quantity and $\\mathcal{T}$ and $\\mathcal{T}^{-1}$ represent the forward and inverse Fourier transform operations, respectively. The use of Fourier harmonics means that the boundary conditions in the perpendicular plane are periodic. The periodicity of the torus is, however, not automatically satisfied. The condition of toroidal periodicity can be formulated as\n\n\n\\begin{equation*}\nf(\\psi, \\zeta+1, s)=f(\\psi, \\zeta, s) \\quad \\rightarrow \\quad \\frac{k_{\\zeta}}{2 \\pi \\rho_{*}}=N \\tag{2.250}\n\\end{equation*}\n\n\nwhere $N$ is an integer. Since $\\rho_{*}$ is small, this condition can in general be satisfied with very small changes to $k_{\\zeta}$ or $\\rho_{*}$. In the local limit employed here, the final equations are independent of $\\rho_{*}$ and it is assumed that the relation above is satisfied. The poloidal periodicity translates to\n\n\n\\begin{equation*}\nf(\\psi, \\zeta+q / 2,1 / 2)=f(\\psi, \\zeta-q / 2,-1 / 2) \\tag{2.251}\n\\end{equation*}\n\n\nThis condition translates to\n\n\n\\begin{align*}\n& \\sum_{\\mathbf{k}} \\hat{f}\\left(k_{\\psi}, k_{\\zeta}, \\frac{1}{2}\\right) \\exp \\left[\\frac{\\mathrm{i} k_{\\zeta}}{\\rho_{*}}+\\frac{\\mathrm{i} k_{\\psi} \\psi}{\\rho_{*}}+\\frac{\\mathrm{i} q k_{\\zeta}}{2 \\rho_{*}}\\right] \\\\\n= & \\sum_{\\mathbf{k}} \\hat{f}\\left(k_{\\psi}, k_{\\zeta},-\\frac{1}{2}\\right) \\exp \\left[\\frac{\\mathrm{i} k_{\\zeta}}{\\rho_{*}}+\\frac{\\mathrm{i} k_{\\psi} \\psi}{\\rho_{*}}-\\frac{\\mathrm{i} q k_{\\zeta}}{2 \\rho_{*}}\\right] \\tag{2.252}\n\\end{align*}\n\n\nExpanding the safety factor around a reference value $q_{R}$ (value at the centre of the radial domain)\n\n\n\\begin{equation*}\n\\frac{q k_{\\zeta}}{\\rho_{*}}=\\frac{q_{R} k_{\\zeta}}{\\rho_{*}}+k_{\\zeta} \\frac{\\partial q}{\\partial \\psi} \\frac{\\psi}{\\rho_{*}}+\\frac{1}{2} k_{\\zeta} \\rho_{*} \\frac{\\partial^{2} q}{\\partial \\psi^{2}}\\left(\\frac{\\psi}{\\rho_{*}}\\right)^{2} \\tag{2.253}\n\\end{equation*}\n\n\nand neglecting the second derivative correction (which gives only a $\\rho_{*}$ variation over the size of the box) one can see that this condition can be satisfied if also $q_{R} k_{\\zeta} / 2 \\pi \\rho_{*}$ is assumed to be an integer and if\n\n\n\\begin{equation*}\n\\hat{f}\\left(k_{\\psi}, k_{\\zeta}, \\frac{1}{2}\\right)=\\hat{f}\\left(k_{\\psi}+k_{\\zeta} \\frac{\\partial q}{\\partial \\psi}, k_{\\zeta},-\\frac{1}{2}\\right) \\tag{2.254}\n\\end{equation*}\n\n\ni.e. on the boundary of the $s$ domain one simply connects the mode with the appropriate higher $k_{\\psi}$ mode. In the code, this boundary condition is implemented in the routine connect\\_parallel. This formulation is close to the 'ballooning transform' [43], and has previously been employed in GS2 [11, 12]. The above boundary condition for the Fourier amplitudes implies that a convenient choice for the spacing of the $k_{\\psi}$ modes in any discrete Fourier representation is\n\n\n\\begin{equation*}\n\\Delta k_{\\psi}=k_{\\zeta, \\min } \\frac{\\partial q}{\\partial \\psi} \\frac{1}{i_{k}} \\tag{2.255}\n\\end{equation*}\n\n\nwhere $i_{k}$ is some integer (IKXSPACE in the code). The integer $i_{k}$ allows for a control over the spacing between the radial modes which otherwise would be dictated by the magnetic shear.\n\nIn order to specify the wave vector in normalised form, the expression\n\n\n\\begin{equation*}\n\\left(k_{\\theta} \\rho_{\\mathrm{ref}}\\right)^{2}=g^{\\zeta \\zeta} k_{\\zeta}^{2} \\tag{2.256}\n\\end{equation*}\n\n\nis evaluated at the low field side midplane $(s=0)$ to determine $k_{\\zeta}$ from the value of $k_{\\theta} \\rho_{\\mathrm{ref}}$ given as an input. Note that $\\rho_{\\text {ref }}$ is defined on the flux surface at the major radius of the magnetic axis. Here $k_{\\theta}$ is an unnormalised dimensional quantity, but $k_{\\zeta}$ and $g^{\\zeta \\zeta}$ are normalised.\n\nThe $k_{\\theta}$ notation used is historical but sometimes misleading; strictly speaking it would be more accurate to describe $k_{\\theta}$ as \" $k_{\\perp}$ at the low field side for a radial mode\". It is related to the toroidal mode number $n$ by\n\n\n\\begin{equation*}\nn=\\frac{k_{\\theta} \\rho_{\\mathrm{ref}}}{2 \\pi \\rho_{*} \\sqrt{\\left.g^{\\zeta \\zeta}\\right|_{s=0}}}=\\frac{k_{\\zeta}}{2 \\pi \\rho_{*}} \\tag{2.257}\n\\end{equation*}\n\n\nwhere $\\sqrt{\\left.g^{\\zeta \\zeta \\mid}\\right|_{s=0}}$ is output in geom.dat as kthnorm. Note that only in the $s-\\alpha$ geometry does $k_{\\theta} \\rho_{*}=n q / r$, in other cases particular care should be taken when comparing with other codes, with the toroidal mode number the least ambiguous quantity for comparison.\n\nThe full perpendicular wave vector is given by\n\n\n\\begin{equation*}\nk_{\\perp}^{2}=g^{\\alpha \\beta} k_{\\alpha} k_{\\beta} \\tag{2.258}\n\\end{equation*}\n\n\nOne of the main advantages of the Fourier representation is that the gyro-average becomes an algebraic operation\n\n\n\\begin{equation*}\n\\widehat{\\langle\\phi\\rangle}=J_{0}\\left(k_{\\perp} \\rho\\right) \\widehat{\\phi}, \\tag{2.259}\n\\end{equation*}\n\n\nwhere $J_{0}$ is the Bessel function and\n\n\n\\begin{equation*}\n\\left(k_{\\perp} \\rho\\right)^{2}=\\frac{m_{R} T_{R}}{Z^{2} B^{2}} g^{\\alpha \\beta} k_{\\alpha} k_{\\beta} \\tag{2.260}\n\\end{equation*}\n\n\nIn the equation above $Z$ is the charge number of the species considered. GKW can run with an arbitrary number of species, which have arbitrary mass and charge.\n\n\\subsection*{2.4 The complete set of equations}\nIn this section we give the complete set of equations for a collisionless rotating plasma based on the material introduced in the previous sections. The gyrokinetic equation can be written in the form\n\n\n\\begin{equation*}\n\\frac{\\partial g}{\\partial t}=\\mathrm{I}+\\mathrm{II}+\\mathrm{III}+\\mathrm{IV}+\\mathrm{V}+\\mathrm{VI}+\\mathrm{VII}+\\mathrm{VIII} \\tag{2.261}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{align*}\n& \\mathrm{I}=-v_{\\|} \\mathbf{b} \\cdot \\nabla f \\rightarrow-v_{R} v_{\\|} \\mathcal{F} \\frac{\\partial \\hat{f}}{\\partial s}, \\\\\n& \\mathrm{II}=-\\mathbf{v}_{D} \\cdot \\nabla f \\rightarrow \\\\\n& -\\frac{\\mathrm{i}}{Z}\\left[T_{R} E_{D} \\mathcal{D}^{\\alpha}+T_{R} v_{\\|}^{2} \\beta^{\\prime} \\mathcal{E}^{\\psi \\alpha}+2 m_{R} v_{R} v_{\\|} \\Omega \\mathcal{H}^{\\alpha}+m_{R} \\Omega^{2} I^{\\alpha}+Z \\mathcal{E}^{\\beta \\alpha} \\frac{\\partial \\Phi}{\\partial x_{\\beta}}\\right] k_{\\alpha} \\hat{f}+ \\\\\n& -\\frac{\\rho_{*}}{Z}\\left[T_{R} E_{D} \\mathcal{D}^{s}+T_{R} v_{\\|}^{2} \\beta^{\\prime} \\mathcal{E}^{\\psi s}+2 m_{R} v_{R} v_{\\|} \\Omega \\mathcal{H}^{s}+m_{R} \\Omega^{2} I^{s}+Z \\mathcal{E}^{\\beta s} \\frac{\\partial \\Phi}{\\partial x_{\\beta}}\\right] \\frac{\\partial \\hat{f}}{\\partial s}  \\tag{2.262}\\\\\n& \\text { III }=-\\mathbf{v}_{\\chi} \\cdot \\nabla g \\rightharpoonup-\\rho_{*}^{2} \\frac{\\partial \\chi}{\\partial x_{\\beta}} \\mathcal{E}^{\\beta \\alpha} \\frac{\\partial g}{\\partial x_{\\alpha}}=\\rho_{*}^{2} \\mathcal{E}^{\\psi \\zeta}\\left(\\frac{\\partial \\chi}{\\partial \\zeta} \\frac{\\partial g}{\\partial \\psi}-\\frac{\\partial g}{\\partial \\zeta} \\frac{\\partial \\chi}{\\partial \\psi}\\right) \\\\\n& \\rightharpoondown \\mathcal{T}\\left(\\mathcal{E}^{\\psi \\zeta}\\left[\\mathcal{T}^{-1}\\left(i k_{\\zeta} \\hat{\\chi}\\right) \\mathcal{T}^{-1}\\left(i k_{\\psi} \\hat{g}\\right)-\\mathcal{T}^{-1}\\left(i k_{\\zeta} \\hat{g}\\right) \\mathcal{T}^{-1}\\left(i k_{\\psi} \\hat{\\chi}\\right)\\right]\\right),  \\tag{2.263}\\\\\n& \\mathrm{IV}=+\\frac{\\mathbf{b}}{m} \\cdot\\left(\\mu \\nabla B+\\nabla \\mathcal{E}_{\\Omega}\\right) \\frac{\\partial f}{\\partial v_{\\|}} \\rightarrow v_{R}\\left(\\mu B \\mathcal{G}+\\frac{1}{2} \\frac{\\partial \\mathcal{E}_{R}}{\\partial s} \\mathcal{F}\\right) \\frac{\\partial \\hat{f}}{\\partial v_{\\|}},  \\tag{2.264}\\\\\n& \\mathrm{V}=-\\mathbf{v}_{\\chi} \\cdot \\nabla F_{M} \\rightarrow \\mathrm{i} k_{\\alpha} \\hat{\\chi} \\mathcal{E}^{\\alpha \\psi}\\left[\\frac{1}{L_{n}}+\\frac{m_{R} \\Omega^{2}}{T_{R}} \\mathcal{L}+E_{T} \\frac{1}{L_{T}}+\\frac{2 v_{\\|}}{v_{R}} \\frac{R B_{t}}{B} u^{\\prime}\\right] F_{M} \\\\\n& +\\rho_{*} \\frac{\\partial \\hat{\\chi}}{\\partial s} \\mathcal{E}^{s \\psi}\\left[\\frac{1}{L_{n}}+\\frac{m_{R} \\Omega^{2}}{T_{R}} \\mathcal{L}+E_{T} \\frac{1}{L_{T}}+\\frac{2 v_{\\|}}{v_{R}} \\frac{R B_{t}}{B} u^{\\prime}\\right] F_{M},  \\tag{2.265}\\\\\n& \\mathrm{VI}=-\\mathbf{v}_{D} \\cdot \\nabla F_{M} \\rightarrow \\frac{1}{Z}\\left[T_{R} E_{D} \\mathcal{D}^{\\psi}+2 m_{R} v_{R} v_{\\|} \\Omega \\mathcal{H} \\mathcal{H}^{\\psi}+m_{R} \\Omega^{2} I^{\\psi}+Z \\mathcal{E}^{s \\psi} \\frac{\\partial \\Phi}{\\partial s}\\right] \\\\\n& \\times\\left[\\frac{1}{L_{n}}+\\frac{m_{R} \\Omega^{2}}{T_{R}} \\mathcal{L}+E_{T} \\frac{1}{L_{T}}+\\frac{2 v_{\\|}}{v_{R}} \\frac{R B_{t}}{B} u^{\\prime}\\right] F_{M},  \\tag{2.266}\\\\\n& \\mathrm{VII}=-\\frac{Z e}{T} v_{\\|} \\mathbf{b} \\cdot \\nabla\\langle\\phi\\rangle F_{M} \\rightarrow-\\frac{Z}{T_{R}} v_{R} v_{\\|} \\mathcal{F} \\frac{\\partial \\widehat{\\phi \\phi\\rangle}}{\\partial s} F_{M},  \\tag{2.267}\\\\\n& \\text { VIII }=-\\frac{Z e}{T} \\mathbf{v}_{D} \\cdot \\nabla\\langle\\phi\\rangle F_{M} \\rightarrow \\\\\n& -\\mathrm{i}\\left[E_{D} \\mathcal{D}^{\\alpha}+\\beta^{\\prime} v_{\\|}^{2} \\mathcal{E}^{\\psi \\alpha}+\\frac{2 m_{R} v_{R}}{T_{R}} v_{\\|} \\Omega \\mathcal{H}^{\\alpha}+\\frac{m_{R} \\Omega^{2}}{T_{R}} \\mathcal{I}^{\\alpha}+\\frac{Z}{T_{R}} \\mathcal{E}^{\\beta \\alpha} \\frac{\\partial \\Phi}{\\partial x_{\\beta}}\\right] k_{\\alpha} \\widehat{\\langle\\phi\\rangle} F_{M}+ \\\\\n& -\\rho_{*}\\left[E_{D} \\mathcal{D}^{s}+\\beta^{\\prime} v_{\\|}^{2} \\mathcal{E}^{\\psi s}+\\frac{2 m_{R} v_{R}}{T_{R}} v_{\\|} \\Omega \\mathcal{H}^{s}+\\frac{m_{R} \\Omega^{2}}{T_{R}} \\mathcal{I}^{s}+\\frac{Z}{T_{R}} \\mathcal{E}^{\\beta s} \\frac{\\partial \\Phi}{\\partial x_{\\beta}}\\right] \\frac{\\partial \\widehat{\\langle\\phi\\rangle}}{\\partial s} F_{M} \\tag{2.268}\n\\end{align*}\n\n\nwhere the arrows represent the transformations to normalised $(\\neg)$ and Fourier $(\\neg)$ quantities and where\n\n\n\\begin{equation*}\n\\hat{\\chi}=\\widehat{\\langle\\phi\\rangle}-2 v_{R} v_{\\|} \\widehat{\\left.A_{\\|}\\right\\rangle}, \\tag{2.269}\n\\end{equation*}\n\n\nand\n\n\n\\begin{align*}\n& \\hat{g}=\\hat{f}+\\frac{2 Z}{T_{\\mathrm{R}}} v_{\\mathrm{R}} v_{\\|} \\widehat{\\left\\langle A_{\\|}\\right\\rangle} F_{M},  \\tag{2.270}\\\\\n& E_{D}=v_{\\|}^{2}+\\mu B, \\quad E_{T}=v_{\\|}^{2}+2 \\mu B+\\mathcal{E}_{R}-\\frac{3}{2} . \\tag{2.271}\n\\end{align*}\n\n\nThe equations above apply to each of the species individually.\\\\\nIn presence of magnetic field compression $\\hat{\\chi}$ becomes\n\n", "\n\\begin{equation*}\n\\hat{\\chi}=\\widehat{\\langle\\phi\\rangle}+\\frac{2 \\mu T_{R}}{Z} \\widehat{\\left\\langle B_{1 \\|}\\right\\rangle}-2 v_{R} v_{\\|} \\widehat{\\left\\langle A_{\\|}\\right\\rangle} \\tag{2.272}\n\\end{equation*}\n\n\nand there are two additional linear terms which take the form\n\n\n\\begin{align*}\n\\mathrm{X}=-\\frac{F_{M}}{T} v_{\\|} \\mathbf{b} \\cdot\\left(\\mu \\nabla\\left\\langle B_{1 \\|}\\right\\rangle\\right) \\rightarrow & -2 v_{R} v_{\\|} \\mu F_{M} \\mathcal{F} \\frac{\\partial \\widehat{\\left\\langle B_{1 \\|}\\right\\rangle}}{\\partial s}  \\tag{2.273}\\\\\n\\mathrm{XI}=-\\frac{F_{M}}{T} \\mathbf{v}_{D} \\cdot\\left(\\mu \\nabla\\left\\langle B_{1 \\|}\\right\\rangle\\right) \\rightarrow & -\\frac{i}{Z} F_{M} 2 T_{R} \\mu\\left(E_{D} \\mathcal{D}^{\\beta}+v_{\\|}^{2} \\beta^{\\prime} \\mathcal{E}^{\\psi \\beta}\\right) k_{\\beta} \\widehat{\\left\\langle_{1 \\|}\\right\\rangle}  \\tag{2.274}\\\\\n& -\\rho_{*} \\frac{1}{Z} F_{M} 2 T_{R} \\mu\\left(E_{D} \\mathcal{D}^{s}+v_{\\|}^{2} \\beta^{\\prime} \\mathcal{E}^{\\psi s}\\right) k_{\\beta} \\widehat{\\left\\langle_{\\left.B_{1 \\|}\\right\\rangle}\\right\\rangle}\n\\end{align*}\n\n\nThe only nonlinearity in the equations is the $\\mathbf{v}_{\\chi} \\cdot \\nabla g$ term (term III, Eq. (2.263)). Linear stability can be investigated by removing this term. In the linear case the bi-normal modes are decoupled, but different radial modes can still be coupled over the parallel boundary conditions. An unstable mode will grow to infinite amplitude, and GKW therefore applies a scaling of the equations at every time-step to obtain a stationary solution. The nonlinear term (III) is implemented using FFTs. The velocity $\\mathbf{v}_{\\chi}$ and $\\nabla g$ are calculated in Fourier space, then transformed to real space and multiplied. The product is transformed back into Fourier space.\n\nThe fields $\\phi$ and $A_{\\|}$have to be obtained through a solution of the Poisson equation and Ampere's law. These can be found in the literature [33]. Using the normalisations of GKW the Poisson equation can be written in the form\n\n\n\\begin{equation*}\n\\sum_{s p} Z_{s p} n_{R_{0}, s p}\\left[2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}+\\frac{Z_{s p}}{T_{R s p}}\\left[\\Gamma\\left(b_{s p}\\right)-1\\right] \\exp \\left(-\\mathcal{E}_{R \\mathrm{sp}}\\right) \\hat{\\phi}\\right]=0 \\tag{2.275}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{equation*}\nb=\\frac{1}{2} m_{R} T_{R}\\left(k_{\\perp} \\rho_{*} R_{\\mathrm{ref}} / Z B^{2}\\right)^{2}=\\overbrace{\\frac{1}{2} \\frac{k_{\\perp}^{2} m^{2} v_{\\mathrm{th}}^{2}}{e^{2} B^{2}}}^{\\text {in original units }} \\tag{2.276}\n\\end{equation*}\n\n\nThis equation differs from the literature [33] only in the polarisation term which includes the rotational density variation in the Maxwellian [51]. An often employed approximation for the electron dynamics is the so called adiabatic response. In the adiabatic electron limit only the ion dynamics is simulated and the Poisson equation above is evaluated as\n\n$$\n\\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p}\\left[2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}+\\frac{Z_{s p}}{T_{R s p}}\\left[\\Gamma\\left(b_{s p}\\right)-1\\right] \\exp \\left(-\\mathcal{E}_{R \\mathrm{sp}}\\right) \\hat{\\phi}\\right]=\\frac{n_{R_{0}, e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}(\\hat{\\phi}-\\widehat{\\{\\phi\\}}(\\mathcal{Y}, 277)\n$$\n\nwhere the index $e$ refers to the electrons, and the sum on the left hand side of the equation is over all ion species. Further details on the evaluation of this equation are given in Section 8.7.\n\nThe vector potential must be calculated from Ampere's law\n\n\n\\begin{equation*}\n\\left(k_{\\perp}^{2}+\\beta \\sum_{s p} \\frac{Z_{s p}^{2} n_{R_{0}, s p}}{m_{R s p}} \\exp \\left(\\mathcal{E}_{R \\mathrm{sp}}\\right) \\Gamma\\left(b_{s p}\\right)\\right) \\hat{A}_{\\|}=\\beta \\sum_{s p} Z_{s p} v_{R s p} n_{R_{0}, s p} \\times 2 \\pi B \\int \\mathrm{~d} v_{\\|} \\int \\mathrm{d} \\mu v_{\\|} J_{0} \\hat{g}_{s p} \\tag{2.278}\n\\end{equation*}\n\n\nNote that both field equations are formulated for $\\hat{g}$ rather than $f$. The reason is that it is $g$ which is integrated forward in time. Only after the fields are calculated for the new time point, can $f$ be reconstructed. The Maxwell correction in $g$ leads to the second term in the brackets on the left hand side of the equation above. This term can lead to a cancellation problem, and the integral over the Maxwellian is therefore performed numerically in a similar manner as the term on the right hand side [15] rather than the analytic form which is given above.\n\nThe field equations in the fully electromagnetic case can be found in section 1.4.1.\n\n\\section*{Chapter 3}\n\\section*{Collisions}\nThe previous sections have neglected the collision operator. In this section we describe the collisions as implemented in GKW. The present implementation neglects the finite Larmor radius effects. The collisions enter the evolution equation as an additional term\n\n\n\\begin{equation*}\n\\frac{\\partial \\hat{f}_{a}}{\\partial t}=C\\left(\\hat{f}_{a}\\right) \\tag{3.1}\n\\end{equation*}\n\n\nHere we have added the index $a$ to denote the species. Useful expressions for the collision operator $(C)$ have been published in the literature, usually in the $(v, \\theta)$ coordinate system, where $v$ is the velocity and $\\theta$ is the pitch angle. Since the perturbed distribution function is small $f \\approx \\rho_{*} F_{M}$, GKW uses a linearised collision operator with the Maxwellian as background. This operator has the following form [46]\n\n\n\\begin{equation*}\nC\\left(\\hat{f}_{a}\\right)=\\sum_{b} \\frac{1}{v^{2}} \\frac{\\partial}{\\partial v}\\left[v^{2}\\left(D_{v v}^{a / b} \\frac{\\partial \\hat{f}_{a}}{\\partial v}-F_{v}^{a / b} \\hat{f}_{a}\\right)\\right]+\\frac{1}{v \\sin \\theta} \\frac{\\partial}{\\partial \\theta}\\left[\\sin \\theta D_{\\theta \\theta}^{a / b} \\frac{1}{v} \\frac{\\partial \\hat{f}_{a}}{\\partial \\theta}\\right] \\tag{3.2}\n\\end{equation*}\n\n\nHere the sum is over all species $b . D_{\\theta \\theta}$ represents the pitch angle scattering, while $D_{v v}$ is the energy scattering and $F_{v}$ is the slowing down force. For convenience we split this collision operator in three parts\n\n\n\\begin{equation*}\nC(\\hat{f})=C_{\\theta}(\\hat{f})+C_{v v}(\\hat{f})+C_{v}(\\hat{f}) \\tag{3.3}\n\\end{equation*}\n\n\nwhere the first part is due to $D_{\\theta \\theta}$, the second due to $D_{v v}$ and the third due to $F_{v}$. The normalisation of the collision operator follows from the normalisation of the gyrokinetic equation as set out in section 2.1, giving $C_{N}\\left(\\hat{f}_{a}\\right)=\\frac{R_{\\text {ref }} v_{t h a}^{3}}{n_{a} \\rho_{*} v_{\\text {thref }}} C\\left(\\hat{f}_{a}\\right)$ with the diffusion and friction force coefficients made dimensionless accordingly.\n\nThe coefficients can be obtained from the literature [46] (and the references cited therein) and written in normalised form, suppressing the subscript N for the normalised quantities:\n\n\n\\begin{align*}\n& D_{\\theta \\theta}^{a}=\\sum_{b} \\frac{\\Gamma^{a / b}}{4 v_{a}}\\left[\\left(2-\\frac{1}{v_{b}^{2}}\\right) \\operatorname{erf}\\left(v_{b}\\right)+\\frac{1}{v_{b}} \\operatorname{erf}^{\\prime}\\left(v_{b}\\right)\\right]  \\tag{3.4}\\\\\n& D_{v v}^{a}=\\sum_{b} \\frac{\\Gamma^{a / b}}{2 v_{a}}\\left[\\frac{1}{v_{b}^{2}} \\operatorname{erf}\\left(v_{b}\\right)-\\frac{1}{v_{b}} \\operatorname{erf}^{\\prime}\\left(v_{b}\\right)\\right]  \\tag{3.5}\\\\\n& F_{v}^{a}=-\\sum_{b} \\frac{\\Gamma^{a / b}}{v_{a}^{2}} \\frac{m_{R a}}{m_{R b}}\\left[\\operatorname{erf}\\left(v_{b}\\right)-v_{b} \\operatorname{erf}^{\\prime}\\left(v_{b}\\right)\\right] \\tag{3.6}\n\\end{align*}\n\n\nwhere erf is the standard definition of the error function. The normalised velocity in these equations is defined as\n\n\n\\begin{equation*}\nv_{\\gamma}=\\frac{v_{R a}}{v_{R \\gamma}}\\left[v_{\\|}^{2}+2 \\mu B\\right]^{1 / 2}, \\tag{3.7}\n\\end{equation*}\n\n\nwith $\\gamma=a$ or $\\gamma=b$. The error function is\n\n\n\\begin{align*}\n& \\operatorname{erf}(u)=\\frac{2}{\\sqrt{\\pi}} \\int_{0}^{u} \\exp \\left[-x^{2}\\right] \\mathrm{d} x  \\tag{3.8}\\\\\n& \\operatorname{erf}^{\\prime}(u)=\\frac{2}{\\sqrt{\\pi}} \\exp \\left[-u^{2}\\right] \\tag{3.9}\n\\end{align*}\n\n\nFinally the constant $\\Gamma^{a / b}$ is given by\n\n\n\\begin{equation*}\n\\Gamma^{a / b}=\\frac{R_{\\mathrm{ref}} n_{b} Z_{a}^{2} Z_{b}^{2} e^{4} \\ln \\Lambda^{a / b}}{4 \\pi \\epsilon_{0}^{2} m_{a}^{2} v_{t h a}^{4}}=6.5141 \\cdot 10^{-5} \\frac{R_{\\mathrm{ref}} n_{\\mathrm{ref}}^{19}}{\\left(T_{\\mathrm{ref}}^{k}\\right)^{2}} \\frac{n_{R b} Z_{a}^{2} Z_{b}^{2} \\ln \\Lambda^{a / b}}{T_{R a}^{2}} \\tag{3.10}\n\\end{equation*}\n\n\nwhere $R_{\\text {ref }}$ must be given in meters, $n_{\\text {ref }}^{19}$ is the reference density in units of $10^{19} \\mathrm{~m}^{-3}$, and $T_{\\text {ref }}^{k}$ is the reference temperature in units keV . The Coulomb logarithm is calculated as\n\n\n\\begin{align*}\n\\ln \\Lambda^{e / e} & =14.9-\\frac{1}{2} \\ln \\left[0.1 n_{\\mathrm{R}}^{e} n_{\\mathrm{ref}}^{19}\\right]+\\ln \\left[T_{\\mathrm{R}}^{e} T_{\\mathrm{ref}}^{k}\\right]  \\tag{3.11}\\\\\n\\ln \\Lambda^{e / i} & =17.2-\\frac{1}{2} \\ln \\left[0.1 Z^{2} n_{\\mathrm{R}}^{e} n_{\\mathrm{ref}}^{19}\\right]+1.5 \\ln \\left[T_{\\mathrm{R}}^{e} T_{\\mathrm{ref}}^{k}\\right] \\quad \\text { if } T_{e}<10 Z^{2} \\mathrm{eV}  \\tag{3.12}\\\\\n\\ln \\Lambda^{e / i} & =14.8-\\frac{1}{2} \\ln \\left[0.1 n_{\\mathrm{R}}^{e} n_{\\mathrm{ref}}^{19}\\right]+\\ln \\left[T_{\\mathrm{R}}^{e} T_{\\mathrm{ref}}^{k}\\right] \\quad \\text { if } T_{e} \\geq 10 Z^{2} \\mathrm{eV}  \\tag{3.13}\\\\\n\\ln \\Lambda^{i / e} & =\\ln \\Lambda^{e / i}  \\tag{3.14}\\\\\n\\ln \\Lambda^{i_{1} / i_{2}} & =17.3-\\ln \\left[\\frac{Z_{1} Z_{2}\\left(m_{1}+m_{2}\\right)}{m_{1} T_{\\mathrm{R} 2} T_{\\mathrm{ref}}^{k}+m_{2} T_{\\mathrm{R} 1} T_{\\mathrm{ref}}^{k}}\\right]-\\frac{1}{2} \\ln \\left[0.1 \\frac{n_{\\mathrm{ref}}^{19}}{T_{\\mathrm{ref}}^{k}}\\right]-\\frac{1}{2} \\ln \\left[\\frac{n_{\\mathrm{R} 1} Z_{1}^{2}}{T_{\\mathrm{R} 1}}+\\frac{n_{\\mathrm{R} 2} Z_{2}^{2}}{T_{\\mathrm{R} 2}}\\right] \\tag{3.15}\n\\end{align*}\n\n\nwhere the superscripts $e$ and $i$ stand for electron and ion, respectively.\\\\\nNote that the reference density and temperature are defined independently for the collisions and do not need to be equal to the reference density and temperature used in Sec. 2.1 for the species parameters. However, the electron density entering the calculation of the Coulomb logarithm is taken to be $n_{\\mathrm{R}}^{e} n_{\\mathrm{ref}}^{19}$ and therefore depends on the normalised electron density given as in an input in the species namelist. The same comments pertains for the temperatures entering the calculation of the Coulomb logarithm.\n\nUsing the relation between $(v, \\theta)$ and the normalised coordinates $\\left(v_{\\|}, \\mu\\right)$ used in GKW, and performing the coordinate transform, one arrives at the explicit expressions given below. The pitch angle scattering term is\n\n\n\\begin{align*}\nC_{\\theta} & \\rightarrow 2 v_{R} \\frac{\\partial}{\\partial v_{\\|}}\\left[\\frac{\\mu D_{\\theta \\theta}}{v_{\\|}^{2}+2 \\mu B}\\left(B \\frac{\\partial \\hat{f}}{\\partial v_{\\|}}-v_{\\|} \\frac{\\partial \\hat{f}}{\\partial \\mu}\\right)\\right] \\\\\n& +\\frac{2 v_{R}}{B} \\frac{\\partial}{\\partial \\mu}\\left[\\frac{v_{\\|} \\mu D_{\\theta \\theta}}{v_{\\|}^{2}+2 \\mu B}\\left(-B \\frac{\\partial \\hat{f}}{\\partial v_{\\|}}+v_{\\|} \\frac{\\partial \\hat{f}}{\\partial \\mu}\\right)\\right] . \\tag{3.16}\n\\end{align*}\n\n\nThe energy scattering yields\n\n\n\\begin{align*}\nC_{v v} & \\rightarrow v_{R} \\frac{\\partial}{\\partial v_{\\|}}\\left[\\frac{v_{\\|} D_{v v}}{v_{\\|}^{2}+2 \\mu B}\\left(v_{\\|} \\frac{\\partial \\hat{f}}{\\partial v_{\\|}}+2 \\mu \\frac{\\partial \\hat{f}}{\\partial \\mu}\\right)\\right] \\\\\n& +v_{R} \\frac{\\partial}{\\partial \\mu}\\left[\\frac{2 \\mu D_{v v}}{v_{\\|}^{2}+2 \\mu B}\\left(v_{\\|} \\frac{\\partial \\hat{f}}{\\partial v_{\\|}}+2 \\mu \\frac{\\partial \\hat{f}}{\\partial \\mu}\\right)\\right] . \\tag{3.17}\n\\end{align*}\n\n\nThe slowing down can be written as\n\n$$\nC_{v} \\quad \\rightarrow-v_{R} \\frac{\\partial}{\\partial v_{\\|}}\\left[\\frac{v_{\\|} F_{v}}{\\left[v_{\\|}^{2}+2 \\mu B\\right]^{1 / 2}} \\hat{f}\\right]\n$$\n\n\n\\begin{equation*}\n-v_{R} \\frac{\\partial}{\\partial \\mu}\\left[\\frac{2 \\mu F_{v}}{\\left[v_{\\|}^{2}+2 \\mu B\\right]^{1 / 2}} \\hat{f}\\right] . \\tag{3.18}\n\\end{equation*}\n\n\nThe linearised form of the Fokker-Planck collision operator above conserves particle number but does not conserve like particle momentum or energy. The conservation of parallel momentum and energy can be reintroduced using the following simplified model. We are interested in momentum conservation for like particle collisions. The change in parallel momentum due to the collision operator above is\n\n\n\\begin{equation*}\n2 \\pi B \\int \\mathrm{~d} v_{\\|} \\int \\mathrm{d} \\mu v_{\\|} C(\\hat{f}) \\tag{3.19}\n\\end{equation*}\n\n\nThis loss of momentum can be corrected for by adding an ad hoc correction term\n\n\n\\begin{equation*}\n\\frac{\\partial \\hat{f}}{\\partial t}=C_{m o m} v_{\\|} F_{M} \\tag{3.20}\n\\end{equation*}\n\n\nbut the energy term isn't simply\n\n\n\\begin{equation*}\n\\frac{\\partial \\hat{f}}{\\partial t}=C_{e n e}\\left(v_{\\|}^{2}+2 \\mu B\\right) F_{M} \\tag{3.21}\n\\end{equation*}\n\n\nas this would have the effect of adding particles, conservation of which is accounted for by the differencing and boundary conditions. Therefore we use\n\n\n\\begin{equation*}\n\\frac{\\partial \\hat{f}}{\\partial t}=C_{e n e}\\left(\\left(v_{\\|}^{2}+2 \\mu B\\right)-A\\right) F_{M} \\tag{3.22}\n\\end{equation*}\n\n\nwhere $A$ is calculated by taking the zeroth moment of the equation\n\n\n\\begin{equation*}\n\\frac{\\partial \\hat{f}}{\\partial t}=C(\\hat{f})+C_{e n e}\\left(\\left(v_{\\|}^{2}+2 \\mu B\\right)-A\\right) F_{M} \\tag{3.23}\n\\end{equation*}\n\n\nand setting the change in density to zero. Since particle conservation is determined by the differencing and boundary conditions, then the coefficient $A$ turns out to be simply:\n\n\n\\begin{equation*}\nA=\\frac{\\int \\mathrm{d} v_{\\|} \\int \\mathrm{d} \\mu v^{2} F_{M}}{\\int \\mathrm{~d} v_{\\|} \\int \\mathrm{d} \\mu F_{M}} \\tag{3.24}\n\\end{equation*}\n\n\nwhich analytically can be shown to be $\\frac{3 T}{2}$, but in GKW is calculated numerically to ensure highest precision conservation.\n\nThe constant $C_{\\text {mom }}$ then follows from working out the momentum change due to this term.\n\n\n\\begin{equation*}\n2 \\pi B C_{\\text {mom }} \\int \\mathrm{d} v_{\\|} \\mathrm{d} \\mu v_{\\|}^{2} F_{M}+2 \\pi B \\int \\mathrm{~d} v_{\\|} \\int \\mathrm{d} \\mu v_{\\|} C(\\hat{f})=0 \\tag{3.25}\n\\end{equation*}\n\n\nwhile the constant $C_{\\text {ene }}$ is determined by taking the energy moment $\\frac{m v^{2}}{2}$,\n\n\n\\begin{equation*}\n2 \\pi B C_{e n e} \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu v^{2}\\left(v^{2}-A\\right) F_{M}+2 \\pi B \\int \\mathrm{~d} v_{\\|} \\int \\mathrm{d} \\mu\\left(v_{\\|}^{2}+2 \\mu B\\right) C(\\hat{f})=0 \\tag{3.26}\n\\end{equation*}\n\n\nhere we have suppressed the $m / 2$ factors as they cancel.\\\\\nThe present form of the collision operator drives the distribution towards a Maxwellian with the specified temperature. In the local problem one specifies the temperature as an input parameter and no evolution in the temperature is retained. A collision operator that maintains this temperature can therefore be considered acceptable. The steady state distribution function for various velocity space resolutions is plotted in Fig.3.3.\n\nTo switch on the conservation terms, which can be switched on or off independently, the parameters mom\\_conservation $=$.true. and ene\\_conservation $=$.true.. However it must be noted that for energy conservation to machine accuracy, the parameter mass\\_conserve $=$.true. must also be set, to enforce conservation at the velocity boundaries (although this may not be the most physical boundary condition).\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-046}\n\nFigure 3.1: Snapshot of velocity space as three different time intervals showing the effect of pitch angle scattering on the velocity space. Coordinates are $v_{\\|}$horizontally and $v_{\\perp}$ vertically. All data shown in this chapter was run with 100 parallel velocity points and $50 \\mu$ points non-equally spaced.\n\nIn GKW the $\\mu$-direction grid is non-uniform which represents a problem when differencing the collision terms, however it is seen that while non-uniform in $\\mu$ it is uniform in the $v_{\\perp}$ coordinate ( $m u=v_{\\perp}^{2} / 2 B$ ) and as such the collision operator is solved using this as the coordinate as this ensures machine accurate flux conservation and momentum conservation. To get the collision operator in this form the following simple transformation must be performed:\n\n\n\\begin{align*}\n2 \\mu B & =v_{\\perp}^{2}  \\tag{3.27}\\\\\n2 \\mu \\partial / \\partial \\mu & =\\partial / \\partial v_{\\perp} \\tag{3.28}\n\\end{align*}\n\n\n\\subsection*{3.1 Collisions tutorial}\nIn the previous section we derived the form of the three terms of the Fokker-Plank operator. Here we will show, using data produced by GKW and our implementation of the previous to show what effect the operator has on the velocity space structure.\n\nWhen running GKW, collisions are included if collisions $=$.true. in the CONTROL namelist\n\n\\subsection*{3.1.1 Pitch-angle scattering}\nThis effect is switched on by setting pitch\\_angle $=$.true. in the collisions input deck. Pitch-angle scattering conserves momentum and therefore will have the effect of isotropising the distribution function along arcs of constant velocity $v=\\sqrt{v_{\\|}^{2}+2 \\mu B}$.\\\\\nIf we initialise the code with narrow, shifted gaussian in velocity space, then as time progresses then pitchangle scattering will have the effect of producing a ring in velocity space (As seen in figure 3.1).\n\n\\subsection*{3.1.2 Energy scattering}\nThis effect is switched on by setting en\\_scatter $=$.true. in the collisions input deck. The energy scattering term spreads the distribution function in energy.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-047}\n\nFigure 3.2: Snapshot of velocity space as four different time intervals showing the effect of all the terms in the collision operator on the velocity space. The final state is a Maxwellian centred on zero.\n\n\\subsection*{3.1.3 Collisional friction}\nThis effect is switched on by setting friction\\_coll $=$.true. in the collisions input deck. The collisional friction term advects the distribution function towards the origin in velocity space.\n\nWhen you combine all three effects we get an evolution of the distribution function towards a Maxwellian centred on zero and with a width of a single normalised thermal velocity.\n\n\\subsection*{3.2 Velocity space boundary conditions}\nThere are currently two options for the boundary conditions in velocity space. The input deck parameter mass\\_conserve changes between open boundary conditions (when set to .false., default) and zero flux boundary conditions (when set to .true.). The former is more physical, but the latter is useful for testing of conservation properties to machine precision. The difference in mass conservation between the two is very small.\n\n\\subsection*{3.3 User defined collision-frequencies}\nThe collision frequency can be defined in two ways. Firstly by specifying nref which is the particle density in units of $10^{19}$ particles per $m^{3}$, tref, the temperature in keV and rref which is the toroidal major radius. These parameters are what the corresponding parameters are normalised to in the code and are never usually specified. The normalised collision frequency $\\Gamma^{a / b}=\\nu_{a b} R_{\\mathrm{ref}} / v_{\\mathrm{thref}}$ is given by,\n\n\n\\begin{equation*}\n\\Gamma_{N}^{a / b}=\\frac{R_{\\mathrm{ref}} n_{b} Z_{a}^{2} Z_{b}^{2} e^{4} \\ln \\Lambda^{a / b}}{4 \\pi \\epsilon_{0}^{2} m_{a}^{2} v_{t h a}^{4}}=6.5141 \\cdot 10^{-5} \\frac{R_{\\mathrm{ref}} n_{\\mathrm{ref}}^{19}}{\\left(T_{\\mathrm{ref}}^{k}\\right)^{2}} \\frac{n_{R b} Z_{a}^{2} Z_{b}^{2} Z_{\\mathrm{eff}}^{a / b} \\ln \\Lambda^{a / b}}{T_{R a}^{2}} \\tag{3.29}\n\\end{equation*}\n\n\nwhere $Z_{\\text {eff }}^{a / b}=1.0$ unless $b=i$ (main ion species) as determined by the species density and $a=e$ as determined by the charge on the species. The value of $Z_{\\text {eff }}^{e / i}$ is adjusted by the parameter zeff in the collisions namelist which is 1.0 by default. Note that if impurity species are included kinetically, then the scaling factor will be automatically modified to be\n\n\n\\begin{equation*}\nZ_{\\mathrm{eff}}^{e / i}=1+\\left(z e f f-Z_{\\mathrm{eff}}^{\\mathrm{sp}}\\right) \\frac{n_{e}}{n_{i} Z_{i}^{2}} \\tag{3.30}\n\\end{equation*}\n\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_11_06_cb0545ccfb9614bb7b3dg-048(1)}\n\\end{center}\n\nFigure 3.3: Figure showing the logarithm of the distribution function as a function of $v^{2}$ for varying velocity space resolutions. A reference Maxwellian is also plotted for comparison.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-048}\n\nFigure 3.4: (left) Figure shows the electron particle mass for when (blue) flux conserving boundaries and (red) open boundaries are used. When the former is chosen the particle number is conserved to machine precision. Note the y-axis scale. (Right) Shows the parallel momentum for runs with the same initial conditions for (blue) fully conservative (green) self collisions conservative and (red) no conservation at all. Again, the momentum is conserved to machine precision.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-049}\n\nFigure 3.5: Figure shows the energy in the electron distribution for three different initial conditions (green and blue had the same initial width but with a different parallel velocity sign, red was gaussian centered different initial parallel velocity). All three converge on the same value. (Inlay is the parallel momentum)\\\\\nwith $Z_{\\mathrm{eff}}^{\\mathrm{sp}}=\\frac{1}{n_{e}} \\sum_{s} n_{s} Z_{s}^{2}$ and the sum on 's' performed on all ion species\\\\\nHowever if freq\\_override $=$.true. then,\n\n\n\\begin{equation*}\n\\Gamma_{N}^{a / b}=Z_{a}^{2} Z_{b}^{2} \\nu_{\\mathrm{ref}} \\frac{n_{R b}}{T_{R a}^{2}} \\frac{\\ln \\Lambda^{a / b}}{\\ln \\Lambda^{i / i}} \\tag{3.31}\n\\end{equation*}\n\n\nWhere $\\nu_{\\text {ref }}$ is the user defined frequency defined as collfreq in the input deck. This is assumed to be the singly charged ion - ion (proton or deuteron) collision frequency. To get agreement with the first method this can be set to $6.5141 \\cdot 10^{-5} R_{\\mathrm{ref}} n_{\\mathrm{ref}}^{19} \\ln \\Lambda^{i / i} /\\left(T_{\\mathrm{ref}}^{k}\\right)^{2}$. This value is then scaled to all the other species respectively. For this to work the first species in the input deck should be singly charged ions.\n\n\\subsection*{3.4 Direct benchmarks}\nHere outlined is a direct analytical benchmark of the collision operator. The frictional slowing down of a particle can be calculated analytically, and accuratly approximated in the code by using a very narrow, high energy gaussian in velocity space. The velocity of this pulse can then be tracked and compared with the analytic expression.\n\nThe slowing down time of a particle can be written as:\n\n\n\\begin{equation*}\n\\tau^{s}=-\\frac{U}{\\frac{\\partial U}{\\partial t}} \\tag{3.32}\n\\end{equation*}\n\n\nwhere $\\tau^{s}=1 / \\nu_{S}$, which is defined as (we consider only ion-ion collisions):\n\n\n\\begin{equation*}\n\\nu_{S}^{a / b}=-\\left[\\left(1+\\frac{m_{a}}{m_{b}}\\right) \\psi(x)\\right] \\nu_{0}^{a / b} \\tag{3.33}\n\\end{equation*}\n\n\nwhere $\\nu_{0}^{a / b}=\\Gamma_{N}^{a / b}=\\frac{R_{\\mathrm{ref}} n_{b} Z_{a}^{2} Z_{b}^{2} e^{4} \\ln \\Lambda^{a / b}}{4 \\pi \\epsilon_{0}^{2} m_{a}^{2} v_{a}^{3}}$, where $\\psi(x)$ is the Maxwell integral and can be shown to be $\\psi(x)=\\operatorname{erf}(x)-x \\frac{\\partial \\operatorname{erf}(x)}{\\partial x}$. and x is defined as $v^{a} / v_{t h}^{b}$. This ordinary differential equation can then be solved\\\\\nusing standard methods. The comparison between GKW and this result is shown in Fig. 3.6. Agreement between the two curves is very good, implying that the friction and energy scatter terms are operating correctly in the current implementation. A benchmark of the pitch angle scattering against another code is presented in Sec. 11.1.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-051}\n\nFigure 3.6: Measurement of the velocity of a highly localised pulse in velocity space as a function of time. The result from GKW is shown utilising two methods, one is the first moment of the distribution function, while the other is simply a trace of the spike. The blue line is the solution of the ODE described above.\n\n\\section*{Chapter 4}\n\\section*{Rotation and poloidal asymmetries}\nThe co-moving system employed in GKW corresponds to a frame that rotates as a rigid body with constant frequency $\\Omega$. The Coriolis drift, centrifugal drift, centrifugal trapping and centrifugal potential due to the rotation of the plasma are all incorporated in the complete set of equations described above. The possible radial gradient in the toroidal rotation is treated through a radial gradient in the averaged parallel velocity $u^{\\prime}$ of the background. The radial gradient of the perpendicular velocity ( $E \\times B$ shear flow) has so far been ignored, but is known to play an important role in the saturation of the turbulence.\n\nIn this chapter we describe how the centrifugal potential is calculated from the species inputs, and how the the $E \\times B$ shearing is treated in GKW. Much of this Chapter appears in greater detail in Ref. [51].\n\n\\subsection*{4.1 Centrifugal potential}\nWe recall that the rotation of the plasma leads to an equilibrium density variation within a flux surface\n\n\n\\begin{equation*}\nn(s)=n_{R_{0}, s} \\exp \\left(\\frac{-Z_{s}\\langle\\Phi\\rangle}{T_{R, s}}+\\frac{m_{s} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right)}{T_{R, s}}\\right) \\tag{4.1}\n\\end{equation*}\n\n\n(normalised units). The background equilibrium potential $\\Phi$ in the rotating frame is found by applying the quasi-neutrality condition over all the species\n\n\n\\begin{equation*}\nQ(\\Phi)=\\sum_{s} Z_{s} n_{R_{0}, s} \\exp \\left(\\frac{-Z_{s}\\langle\\Phi\\rangle}{T_{R, s}}\\right) \\exp \\left(\\frac{m_{s} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right)}{T_{R, s}}\\right)=0 \\tag{4.2}\n\\end{equation*}\n\n\nSince there is only one negative species and the exponential function is monotonically increasing, the equation $Q(\\Phi)=0$ will always have exactly one root. In GKW, $\\Phi$ is calculated numerically for arbitrary species combinations from the quasi-neutrality condition by an iterative root finding bisection algorithm. The calculation is done once for each point in $s$ during the initialisation phase of the code. The terms II, VI, and VIII $(2.262,2.266,2.268)$ also require the $\\psi$ and $s$ derivatives of $\\Phi$, which are calculated using a fourth-order finite difference.\n\nThe bisection algorithm begins with an upper limit estimate $\\Phi_{a}$ for $\\Phi$. The initial value used in GKW is (somewhat arbitrarily) taken as\n\n\n\\begin{equation*}\n\\left[\\max \\left\\{\\log \\left(1+\\left|Z_{s} n_{s}\\right|\\right)\\right\\}+\\max \\left\\{m_{s} \\log \\left(1+n_{s}\\right)\\right\\}\\right] \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right)+0.1 \\tag{4.3}\n\\end{equation*}\n\n\nwhich should always contain the root, but be small enough to prevent exponentiation overflows. It is possible that extreme species input data could break the solver, and the upper limit estimate might need to be adjusted for those cases.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-053}\n\nFigure 4.1: Numerical experiment to determine optimum $\\Delta \\psi$ for calculating the radial derivative of the centrifugal potential $\\Phi$ for the singly charged ions Waltz standard case. The experiment was conducted in double precision and the fractional error is calculated against the analytic result Eq. 4.5.\n\nThe starting lower limit is estimated as $\\Phi_{b}=-\\Phi_{a}$. The value is chosen to ensure that the root lies in the range $\\left(\\Phi_{b}, \\Phi_{a}\\right)$. In each step the mid value $\\Phi_{\\text {est }}=\\left(\\Phi_{a}+\\Phi_{b}\\right) / 2$ is taken and the value of $Q\\left(\\Phi_{\\text {est }}\\right)$ is calculated. If $Q\\left(\\Phi_{\\text {est }}\\right)>0$, then the upper estimate is updated $\\left(\\Phi_{a}=\\Phi_{\\text {est }}\\right)$, and if $Q\\left(\\Phi_{\\text {est }}\\right)<0$, then the lower estimate is updated $\\left(\\Phi_{b}=\\Phi_{\\text {est }}\\right)$. The process repeats until the solution has converged to within machine accuracy. The bisection algorithm, while not the fastest possible, is guaranteed to converge as long as the bounds are appropriate and the function $Q$ has only one root in the initial range. In practice, the convergence occurs in about 55 iterations using the initial estimates specified above. The function $Q(\\Phi, s, \\psi)$ is evaluated in module components as cf\\_quasineutral called from the bisection algorithm centrifugal\\_energy in module rotation.\n\n", "In the local flux tube model, the gyrokinetic equation is solved only on one flux surface (i.e. at one position in $\\psi$ ), keeping radial derivatives of equilibrium quantities. To consistently calculate the radial derivative of $\\Phi$, equation 4.2 is also solved numerically on adjacent flux surfaces using $Q(\\Phi, s, \\psi+\\Delta \\psi)$, using the radial derivatives of the species quantities to calculate the temperature and densities on adjacent flux surfaces.\n\nThe choice of $\\Delta \\psi$ used in the code is motivated by a compromise between machine precision when dividing by small numbers, and the accuracy of the finite difference as $\\Delta \\psi \\rightarrow 0$. The discrepancy between the root finding algorithm and the analytic solution (Eq. 4.5) is plotted in figure 4.1. The value of $\\Delta \\psi=1 e-4$ is implemented as a permanent choice, which for the case investigated minimises the error to less than $10^{-11}$ in double precision.\n\nIn the case of a plasma of only singly charged ions, Eq. 4.2 solves exactly to give\n\n\n\\begin{equation*}\n\\Phi=\\underbrace{\\frac{T_{e} T_{i}}{T_{e}+T_{i}}\\left(\\frac{m_{i}}{T_{i}}-\\frac{m_{e}}{T_{e}}\\right)}_{\\text {cf_mass_weight }} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right) . \\tag{4.4}\n\\end{equation*}\n\n\nwith radial derivative\n\n\n\\begin{equation*}\n\\frac{\\partial \\Phi}{\\partial \\psi}=\\underbrace{\\left[\\frac{m_{i} \\frac{\\partial T_{e}}{\\partial \\psi}-m_{e} \\frac{\\partial T_{i}}{\\partial \\psi}}{T_{e}+T_{i}}+\\frac{m_{e} T_{i}-m_{i} T_{e}}{\\left(T_{e}+T_{i}\\right)^{2}}\\left(\\frac{\\partial T_{e}}{\\partial \\psi}+\\frac{\\partial T_{i}}{\\partial \\psi}\\right)\\right]}_{\\text {cf_dtf1 }} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right)+2 \\Omega^{2} \\underbrace{\\left[\\frac{m_{i} T_{e}-m_{e} T_{i}}{T_{e}+T_{i}}\\right]}_{\\text {cf_mass_weight }}\\left(R \\frac{\\partial R}{\\partial \\psi}-R_{0} \\frac{\\partial R_{0}}{\\partial \\psi}\\right) \\tag{4.5}\n\\end{equation*}\n\n\nIf the bulk ion species is singly charged, these quantities are evaluated in the code in rotation with the labelled function provided by components to provide a check on the solution of the root finding algorithm.\n\nThe density $n_{R}$ and density gradient $1 / L_{n}=\\left(1 / L_{n}\\right)_{R_{0}}$ (Eq. 2.8) are defined for each species at the point on the flux surface at which $R=R_{0}$. Two choices for the definition of $R_{0}$ are available in the code, which are selected by the input variable R0\\_loc in the geom namelist. The option RO\\_loc='axis' sets $R_{0}$ as the major radius of the magnetic axis (but the reference point is not on the axis itself), whilst the default\n\nRO\\_loc='LFS' sets $R_{0}$ to be the value of $R$ at $s=0$, in the plane of the magnetic axis at the low field side (for general geometry this may not be equivalent to the maximum $R$ ). This choice alters only the definition of the geometry quantities $\\mathcal{J}$ and $\\mathcal{K}$. In the rotating case, the effective density gradient varies over the flux surface and there is no longer one obvious definition of the density gradient as a dimensionless quantity. For instance\n\n\n\\begin{equation*}\n\\frac{1}{L_{n}^{E}}=-\\frac{1}{n} \\frac{\\partial n}{\\partial \\psi}, \\quad \\frac{1}{L_{n}^{e 1}}=-\\frac{1}{\\{n\\}} \\frac{\\partial n}{\\partial \\psi}, \\quad \\frac{1}{L_{n}^{e 2}}=-\\frac{1}{n_{R_{0}}} \\frac{\\partial n}{\\partial \\psi} \\tag{4.6}\n\\end{equation*}\n\n\ncan each be argued to be a relevant quantity. The most appropriate may be determined by the nature of the particular instability being examined. These definitions can be evaluated to be\n\n\n\\begin{equation*}\n\\frac{1}{L_{n}^{e}}=\\frac{\\partial \\mathcal{E}_{R}}{\\partial \\psi}+\\mathcal{E}_{R} \\frac{1}{L_{T}}+\\left.\\frac{1}{L_{n}}\\right|_{R_{0}}, \\quad \\frac{1}{L_{n}^{e 1}}=\\frac{1}{L_{n}^{e}} \\frac{\\exp \\left(-\\mathcal{E}_{R}\\right)}{\\left\\{\\exp \\left(-\\mathcal{E}_{R}\\right)\\right\\}}, \\quad \\frac{1}{L_{n}^{e 2}}=\\frac{1}{L_{n}^{e}} \\exp \\left(-\\mathcal{E}_{R}\\right) \\tag{4.7}\n\\end{equation*}\n\n\nSince the density gradient is an important parameter for determining the stability of many modes, GKW calculates $1 / L_{N}^{E}$ and $1 / L_{n}^{e 1}$ and $n / n_{R_{0}}$ for each species as a function along the field, which is written to the file cfdens.dat, and as a flux surface average and at the outboard midplane, which is written to screen during the initialisation phase of the code. $1 / L_{n}^{e 2}$ can be trivially calculated from the other two. It should be noted that whilst the input $1 /\\left.L_{n}\\right|_{R_{0}}$ must always be the same for every species in order to satisfy quasi-neutrality, the effective $1 / L_{n}^{E}$ can differ for each species. For typical parameters of a deuterium plasma, the variation in effective density and gradient can be $30 \\%$ at $\\Omega=1$, increasing rapidly for $\\Omega>1$.\n\n\\subsection*{4.2 Background $E \\times B$ shear flow}\nThe sheared $E \\times B$ velocity leads to a stabilisation of turbulence through the breaking up of eddy structures. This $E \\times B$ shearing is always present for a purely toroidally rotating plasma but can, of course, also be related to a sheared poloidal rotation.\n\nThe equilibrium $E \\times B$ rotation\n\n\n\\begin{equation*}\n\\mathbf{v}_{s}(\\psi)=\\frac{\\mathbf{b} \\times \\nabla \\bar{\\Phi}}{B} \\tag{4.8}\n\\end{equation*}\n\n\nlies inside the flux surface. The shearing rate in the normalised units is defined to be\n\n\n\\begin{equation*}\n\\gamma_{E}^{N}=\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial^{2} \\bar{\\Phi}_{N}}{\\partial \\psi^{2}} \\tag{4.9}\n\\end{equation*}\n\n\nwhere the normalisation $\\bar{\\Phi}=\\rho_{*} \\frac{T_{\\text {ref }}}{e} \\bar{\\Phi}_{N}$ is as for the perturbed potential Eq. (2.4). The factor $1 / 2$ is present due to the definition of the reference thermal velocity. Since GKW treats the $E \\times B$ shear independently from the centrifugal effects, we use $\\bar{\\Phi}$ to distinguish the background potential of the shearing from the background potential of the rotating frame. In physical units the shearing rate is\n\n\n\\begin{equation*}\n\\gamma_{E}=\\frac{v_{\\text {thref }}}{R_{\\text {ref }}} \\gamma_{E}^{N}=\\frac{1}{B_{\\mathrm{ref}}} \\frac{\\partial^{2} \\bar{\\Phi}}{\\partial r^{2}}, \\tag{4.10}\n\\end{equation*}\n\n\nwhere $r=\\left(R_{\\max }-R_{\\min }\\right) / 2$. The GKW shearing rate is assumed radially constant and is defined as a flux function. At the radial centre of the flux tube $\\mathbf{v}_{\\mathbf{s}}$ is chosen to be zero, with the result that there is no net flow over the domain. In the local limit with the approximations of the ' $s-\\alpha$ ' model geometry the shearing rate is then equivalent to the familiar definition [58, 59]:\n\n\n\\begin{equation*}\n\\gamma_{E} \\approx \\frac{\\left(R B_{p}\\right)^{2}}{B_{t}} \\frac{\\partial^{2} \\bar{\\Phi}}{\\partial \\Psi^{2}} \\approx \\frac{d v_{s}}{d r} \\tag{4.11}\n\\end{equation*}\n\n\nThe flow velocity is normalised as $v_{s}^{N}=v_{s} / v_{\\text {thref }}$, and as before the index $N$ is dropped in what follows. The sign convention here is opposite to Eq. (2.8), so $\\gamma_{E}<0$ corresponds to $\\nabla E_{0}$ radially outwards.\n\nOnly the Doppler shift of the background $E \\times B$ rotation is kept in the description, i.e. the background $E \\times B$ rotation is added as an additional convective term for the perturbed distribution $\\left(\\mathbf{v}_{s} \\cdot \\nabla g\\right)$ in the gyrokinetic equation (7.37), and we neglect the acceleration due to the background potential $\\left(\\mathbf{v}_{D} \\cdot \\nabla \\bar{\\phi} F_{M}\\right)$. By omitting the latter term, the flow is implemented in conservative form and provides no drive to the turbulence, so that the stabilising effect may be studied in isolation. If the acceleration term were kept, it would provide a Kelvin-Helmholtz drive to the turbulence. This drive is likely to be small compared to the parallel shear drive (which is kept in term VIII), but could be the subject of future work.\n\nWith zero net flow across the flux tube one obtains\n\n\n\\begin{equation*}\n\\text { III.B }=-\\mathbf{v}_{s} \\cdot \\nabla g \\rightharpoonup-\\rho_{*}^{2} \\frac{\\partial \\bar{\\Phi}}{\\partial \\psi} \\mathcal{E}^{\\psi \\zeta} \\frac{\\partial g}{\\partial \\zeta}=-2 \\gamma_{E} \\psi \\mathcal{E}^{\\psi \\zeta} \\frac{\\partial g}{\\partial \\zeta} \\tag{4.12}\n\\end{equation*}\n\n\nDefining $\\bar{\\gamma}_{E}=2 \\gamma_{E} \\mathcal{E}^{\\psi \\zeta}$ and taking the Fourier transform, the term can be written as a derivative in Fourier space\n\n\n\\begin{equation*}\n\\mathcal{T}\\left(-\\bar{\\gamma}_{E} \\psi \\frac{\\partial g}{\\partial \\zeta}\\right)=\\bar{\\gamma}_{E} k_{\\zeta} \\frac{\\partial \\hat{g}}{\\partial k_{\\psi}} \\tag{4.13}\n\\end{equation*}\n\n\nThe derivative represents a continuous advection (and shearing) in Fourier space in $k_{\\psi}$.\\\\[0pt]\nThere are a number of subtleties associated with numerical evaluation of this derivative. A finite difference approximation cannot resolve the fine scale structure in Fourier space. The 'harmonic derivative' [60, 61] is a full convolution over all modes and is equivalent to a pseudo-spectral implementation using FFTs (as was used for the nonlinear term in Eq. (2.263)). Although it correctly implements the $E \\times B$ shearing term inside the computational domain, it does not represent a homogeneous shear flow because the flow profile does not satisfy the periodicity of the discrete Fourier transform; any turbulent structure passing through the radial boundary will experience a discontinuity in the flow profile (which in the periodic domain has a sawtooth form). Since the local limit requires that the turbulence has no preference for the boundary, periodicity at the boundary must be preserved. The 'shear-periodic' boundary condition [62, 63, 64] that moves with the mean flow accomplishes this for a finite difference representation in the radial direction, but does not naturally translate to the spectral representation.\n\nIn coordinates that move with the flow $[65,66,67]$, the 'radial' wavenumbers become time dependent:\n\n\n\\begin{align*}\n\\psi^{\\prime}=\\psi, & \\zeta^{\\prime}=\\zeta-\\psi \\bar{\\gamma}_{E} t  \\tag{4.14}\\\\\nk_{\\zeta}^{\\prime}=k_{\\zeta}, & k_{\\psi}^{\\prime}=k_{\\psi}-k_{\\zeta} \\bar{\\gamma}_{E} t \\tag{4.15}\n\\end{align*}\n\n\nIn these coordinates, the derivative in Fourier space becomes part of the time derivative.\\\\[0pt]\nFor a gyrokinetic code, a time dependent wave vector requires the re-evaluation of the linear terms and Bessel functions at every time-step and would be computationally prohibitive. By discretising the time dependence of the wavenumbers as a remapping of the solution vector between the original fixed wavevectors, this expensive re-evaluation can be avoided [68]. Using only the fixed wavevector grid, the advection in Fourier space occurs in jumps only when the boundary periodicity is satisfied for a given mode. Explicitly, the remapping is implemented by tracking the number of times each wavevector has been remapped $i_{r}\\left(k_{\\zeta}\\right)$, and (for $\\bar{\\gamma}_{E}>0$ ) remapping the solution vector\n\n\n\\begin{equation*}\n\\hat{g}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\rightarrow \\hat{g}\\left(k_{\\psi}-\\Delta k_{\\psi}, k_{\\zeta}, s\\right) \\tag{4.16}\n\\end{equation*}\n\n\nwhen the inequality\n\n\n\\begin{equation*}\n\\operatorname{Int}\\left(k_{\\zeta} \\bar{\\gamma}_{E} t / \\delta k_{\\psi}\\right)>i_{r}\\left(k_{\\zeta}\\right) \\tag{4.17}\n\\end{equation*}\n\n\nis satisfied. Here, Int is the function which returns the nearest integer. At the low $k_{\\psi}$ limit the solution vector is discarded. This means that the method is non-conservative, but since the turbulence is characterised by a peaked spectrum (Fig. 11.1), the losses are negligible if the range of radial wavenumbers is suitably wide. For numerical stability, the remapping must occur at the same time for all points along the flux tube. As the metric tensor $\\mathcal{E}^{\\psi \\zeta}$ is a flux function, see Eq. (2.24), this condition is always satisfied for a constant shear rate along the field line.\n\nThe method in GKW differs from the standard spectral methods to model homogeneous shear flows in fluid turbulence of Refs. [65, 66, 67], where the wavenumbers must be recalculated and re-meshing occurs for all wavevectors at the same time. In GKW the method used is the one proposed by Hammett et al. in Ref. [68]. Here the 're-meshing' occurs continually (and at different times for each $k_{\\zeta}$ ), and the wavenumbers stay on their original fixed grid. The accuracy of the method has been argued to be second order on average [68] and is able to capture the physics effects of a background shear flow whilst allowing the desirable features of the flux tube model to be retained.\n\nConvergence of the remap method in $L_{x} / L_{y}$ should be checked (particularly by for the modes with lowest $k_{\\zeta}$ ) by decreasing $\\Delta k_{\\psi} / k_{\\zeta \\min }$ (increasing $N_{x}$ and $p$ (IKXSPACE) whilst holding $N_{\\text {mod }}$ constant (defined later)).\n\n\\subsection*{4.3 Purely toroidal sheared rotation in general geometry}\nFor this section only, we adopt the superscript ${ }^{L}$ to represent quantities in the laboratory frame. All quantities without a superscript should be interpreted as being in the rotating frame (as in all other sections). The same coupling condition is derived by two routes to make clear the relationship between the frames.\n\nThe rotating frame is constructed [20] such that rigid body rotation $\\Omega$ of the frame matches the plasma rotation $\\omega_{\\phi}^{L}$ on the local flux surface. The angular rotation then transforms as\n\n\n\\begin{equation*}\n\\omega_{\\phi}(\\psi)=\\omega_{\\phi}^{L}(\\psi)-\\Omega \\tag{4.18}\n\\end{equation*}\n\n\nsuch that $\\omega_{\\phi}(\\psi)=0$ (and hence $\\mathbf{v}_{\\mathbf{s}}=0$ ) at the centre of the radial domain.\n\n\\subsection*{4.3.1 In comoving frame}\nFor a purely toroidal rotation, decomposing the toroidal flow into its parallel and perpendicular components gives\n\n\n\\begin{equation*}\nu_{\\|} \\mathbf{b}+\\mathbf{v}_{\\mathbf{s}}=s_{\\mathrm{B}} R \\omega_{\\phi}(\\psi) R \\nabla \\varphi \\tag{4.19}\n\\end{equation*}\n\n\nwhere $\\varphi$ is the toroidal angle. Since Eq. 4.19 is written in the comoving frame, it reads $0+0=0$ in the centre of the flux tube. From the normalisations above, one can show that in the normalised units\n\n\n\\begin{equation*}\n\\mathbf{v}_{\\mathbf{s}}=\\frac{1}{2} \\rho_{*}^{2} \\frac{\\mathbf{b} \\times \\nabla \\psi}{B} \\frac{\\partial \\bar{\\Phi}}{\\partial \\psi} \\tag{4.20}\n\\end{equation*}\n\n\nTaking the bi-normal component of Eq. 4.19 one finds\n\n\n\\begin{equation*}\nu_{\\|} \\underbrace{\\mathbf{b} \\cdot \\nabla \\zeta}_{=0}+\\frac{1}{2} \\rho_{*}^{2} \\underbrace{\\frac{\\mathbf{b} \\times \\nabla \\psi}{B} \\cdot \\nabla \\zeta}_{=2 \\mathcal{E} \\psi \\zeta} \\frac{\\partial \\bar{\\Phi}}{\\partial \\psi}=s_{\\mathrm{B}} R^{2} \\omega_{\\phi}(\\psi) \\underbrace{\\nabla \\phi \\cdot \\nabla \\zeta}_{=-1 / 2 \\pi R^{2}}, \\tag{4.21}\n\\end{equation*}\n\n\nhence\n\n\n\\begin{equation*}\n\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial \\bar{\\Phi}}{\\partial \\psi}=-\\frac{s_{\\mathrm{B}}}{4 \\pi} \\frac{1}{\\mathcal{E} \\psi \\zeta} \\omega_{\\phi}(\\psi) \\tag{4.22}\n\\end{equation*}\n\n\nwhich upon differentiation gives the coupling relation\n\n\n\\begin{equation*}\n\\underbrace{\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial^{2} \\bar{\\Phi}}{\\partial \\psi^{2}}}_{\\gamma_{E}}=-\\frac{s_{\\mathrm{B}}}{4 \\pi}[\\frac{1}{\\mathcal{E}^{\\psi \\zeta}} \\underbrace{\\frac{\\partial \\omega_{\\phi}}{\\partial \\psi}}_{\\mathbf{u}^{\\prime}}+\\underbrace{\\omega_{\\phi}}_{=0} \\frac{\\partial}{\\partial \\psi}\\left(\\frac{1}{\\mathcal{E}^{\\psi \\zeta}}\\right)] \\tag{4.23}\n\\end{equation*}\n\n\nNote that the second term on the right is zero when evaluated at the centre of the flux tube. All quantities in the above equation are flux functions, hence the shear rate will always be a flux function, as required for the discrete remapping method.\n\n\\subsection*{4.3.2 Relation to lab frame}\nIn the laboratory frame Eq. 4.19 becomes\n\n\n\\begin{equation*}\nu_{\\|}^{L} \\boldsymbol{b}+\\mathbf{v}_{s}^{L}=s_{\\mathrm{B}} R \\omega_{\\phi}^{L}(\\psi) R \\nabla \\varphi . \\tag{4.24}\n\\end{equation*}\n\n\nTaking the binormal component leads to\n\n\n\\begin{equation*}\n\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial \\bar{\\Phi}^{L}}{\\partial \\psi}=-\\frac{s_{\\mathrm{B}}}{4 \\pi} \\frac{1}{\\mathcal{E} \\psi \\zeta} \\omega_{\\phi}^{L}(\\psi) \\tag{4.25}\n\\end{equation*}\n\n\nand taking the radial derivative gives\n\n\n\\begin{equation*}\n\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial^{2} \\bar{\\Phi}^{L}}{\\partial \\psi^{2}}=-\\frac{s_{\\mathrm{B}}}{4 \\pi}\\left[\\frac{1}{\\mathcal{E} \\psi \\zeta} \\frac{\\partial \\omega_{\\phi}^{L}}{\\partial \\psi}+\\omega_{\\phi}^{L} \\frac{\\partial}{\\partial \\psi}\\left(\\frac{1}{\\mathcal{E} \\psi \\zeta}\\right)\\right] \\tag{4.26}\n\\end{equation*}\n\n\nwhich has the same form as Eq. 4.23 but different values.\\\\\nTo make explicit the relationships between the quantities, the previous equation is rewritten (using Eq. 4.18) in terms of the rotating frame quantities. Since the frame rotates rigidly, $\\frac{\\partial \\Omega}{\\partial \\psi}=0$ and $\\partial \\omega / \\partial \\psi=\\partial \\omega^{L} / \\partial \\psi=u^{\\prime}$. The tensor component $\\mathcal{E}^{\\psi \\zeta}$ is invariant under the transformation. The electric field transforms [20] as\n\n\n\\begin{equation*}\n\\bar{\\Phi}=\\bar{\\Phi}^{L}+s_{\\mathrm{B}} s_{\\mathrm{j}} \\frac{2}{\\rho_{*}^{2}} \\Psi \\Omega \\tag{4.27}\n\\end{equation*}\n\n\nwhere $\\Psi$ is the (frame independent) poloidal flux with $\\nabla \\Psi$ radially outward, and the factor of $2 / \\rho_{*}^{2}$ arises from the normalisation of $\\bar{\\Phi}$ (see Sec. 2.2 .6 for clarification of signs). The coupling condition can then be written as\n\n\n\\begin{equation*}\n\\underbrace{\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial^{2} \\bar{\\Phi}}{\\partial \\psi^{2}}-s_{\\mathrm{B}} s_{\\mathrm{j}} \\Omega \\frac{\\partial^{2} \\Psi}{\\partial \\psi^{2}}}_{\\gamma_{E}^{L}}=-\\frac{s_{\\mathrm{B}}}{4 \\pi}\\left[\\frac{1}{\\mathcal{E}^{\\psi \\zeta}} \\frac{\\partial \\omega_{\\phi}}{\\partial \\psi}+\\Omega \\frac{\\partial}{\\partial \\psi}\\left(\\frac{1}{\\mathcal{E}^{\\psi \\zeta}}\\right)\\right], \\tag{4.28}\n\\end{equation*}\n\n\nwhen evaluated in the centre of the flux tube where $\\omega_{\\psi}=0$. Since $\\Psi=f(\\psi)$ only, from the relation 2.25 it follows that\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial \\psi}\\left(\\frac{1}{\\mathcal{E} \\psi \\zeta}\\right)=s_{\\mathrm{j}} 4 \\pi \\frac{\\partial^{2} \\Psi}{\\partial \\psi^{2}} \\tag{4.29}\n\\end{equation*}\n\n\nhence cancellation gives\n\n\n\\begin{equation*}\n\\underbrace{\\frac{1}{2} \\rho_{*}^{2} \\frac{\\partial^{2} \\bar{\\Phi}}{\\partial \\psi^{2}}}_{=\\gamma_{E}}=-\\frac{s_{\\mathrm{B}}}{4 \\pi} \\frac{1}{\\mathcal{E}^{\\psi \\zeta}} \\underbrace{\\frac{\\partial \\omega_{\\phi}}{\\partial \\psi}}_{=u^{\\prime}}, \\tag{4.30}\n\\end{equation*}\n\n\nwhich is the same as Eq. 4.23 when evaluated at the centre of the flux tube. The shearing rates in the two frames are therefore related by\n\n\n\\begin{equation*}\n\\gamma_{E}^{L}=\\gamma_{E}-s_{\\mathrm{B}} s_{\\mathrm{j}} \\Omega \\underbrace{\\frac{\\partial^{2} \\bar{\\Psi}}{\\partial \\psi^{2}}}_{\\mathcal{M}}, \\tag{4.31}\n\\end{equation*}\n\n\nbut presently only $\\gamma_{E}$ is implemented in the code.\n\n\\subsection*{4.4 Poloidal asymmetries induced by anisotropic minorities}\nIn this section, all units are dimensional, except those indicated with a superscript $N$, which denotes a dimensionless quantity using the GKW normalisations defined in Section 2.1.\\\\[0pt]\nRecent experiments have observed poloidal asymmetries in heavy impurities in the presence of ion cyclotron resonance heating (ICRH) of a light minority ion [78]. This phenomena is believed to be due to the anisotropy of the heated species, which sets up an equilibrium potential.\n\n\\subsection*{4.4.1 Reinke model}\nIn the rotating frame of reference, the parallel force balance for an anisotropic species $m$ (generalisation of Eq 3 of Ref. [78] with a sign correction for the second term) is\n\n\n\\begin{equation*}\n\\nabla_{\\|} p_{\\|}-\\frac{p_{\\|}-p_{\\perp}}{B} \\nabla_{\\|} B+n_{m} Z_{m} e \\nabla_{\\|} \\Phi-n_{m} m_{m} \\Omega^{2} R \\nabla R=0 \\tag{4.32}\n\\end{equation*}\n\n\nAssuming $\\nabla_{\\|} T_{\\|}=0$, one finds on integration\n\n\n\\begin{equation*}\nn_{m}=A B^{-\\eta} \\exp \\left(-\\frac{e Z_{m} \\Phi}{T_{\\|}}+\\frac{m_{m} \\Omega^{2} R^{2}}{2 T_{\\|}}\\right) \\tag{4.33}\n\\end{equation*}\n\n\nwhere $\\eta=T_{\\perp} / T_{\\|}-1$, and $A$ is a constant of integration (with dimensions of $\\left[n B^{\\eta}\\right]$ ) to be determined. In Ref. [78], $A=\\{n\\} /\\left\\{B^{-\\eta}\\right\\}$, but this choice is actually inconsistent with the definition of the flux surface average $\\}$; the correct definition (when $\\Omega=0$ ) would actually require\n\n\n\\begin{equation*}\nA_{\\mathrm{FSA}}=\\frac{\\left\\{n_{m}\\right\\}}{\\left\\{B^{-\\eta} \\exp \\left(-e Z_{m} \\Phi / T_{\\|}\\right)\\right\\}} \\tag{4.34}\n\\end{equation*}\n\n\nAlthough the difference between this and the normalisation of Eq. 3 of Ref. [78] is small for typical parameters, the deviation is enough to break quasi-neutrality and so the approximate normalisation of Ref. [78] is not possible to use in a code which contains a field solver. Furthermore, defining the constant $A$ correctly as in Eq. 4.34 would require repeated iterations of the root finding quasi-neutrality solver condition over the whole flux surface, which although possible is probably unnecessary for this problem. Instead, to be consistent with the previous definition of $n_{R 0}$ as the density at $R=R_{0}$, we must have $A=n_{R 0} B_{R 0}^{\\eta}$ and thus we have\n\n\n\\begin{equation*}\nn_{m}=n_{R 0, m}\\left(\\frac{B}{B_{R 0}}\\right)^{-\\eta} \\exp \\left(-\\frac{e Z_{m} \\Phi}{T_{\\|}}+\\frac{m_{m} \\Omega^{2}\\left(R^{2}-R_{0}^{2}\\right)}{2 T_{\\|}}\\right) \\tag{4.35}\n\\end{equation*}\n\n\nFor the minority species it is also convenient to define a generalised poloidal asymmetry energy\n\n\n\\begin{equation*}\n\\mathcal{E}_{\\Omega, \\eta}=\\mathcal{E}_{\\Omega}+T_{\\|} \\eta \\ln \\left(B / B_{R_{0}}\\right) \\tag{4.36}\n\\end{equation*}\n\n\nwhich in the GKW normalisations is\n\n\n\\begin{equation*}\n\\mathcal{E}_{R, \\eta}^{N}=\\mathcal{E}_{R}^{N}+T_{\\|}^{N} \\eta \\ln \\left(B / B_{R_{0}}\\right) \\tag{4.37}\n\\end{equation*}\n\n\nwhere $T_{\\|}^{N}=T_{\\|} / T_{R}^{N} T_{\\text {ref }}$ (set = 1 in the approximations below). This fits into the previous formalism such that\n\n\n\\begin{equation*}\nn_{m}=n_{R 0} \\exp \\left(-\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}\\right) \\tag{4.38}\n\\end{equation*}\n\n\nThe definition of $\\mathcal{E}_{\\Omega}$ is unchanged for all other species (although the value of $\\Phi$ inside $\\mathcal{E}_{\\Omega}$ will be).\n\n\\subsection*{4.4.2 Bilato model}\nThe Reinke model makes another approximation, by taking $p_{\\perp}$ as a flux function. The self-consistent solution worked out by Bilato [79] gives a reduction in the asymmetry compared to the Reinke model roughly equivalent to transforming $\\eta \\rightarrow \\eta^{3 / 4}$. This model is also implemented in GKW, and is selected by using an input value of $\\frac{T_{\\perp R 0}}{T_{\\|}}<0$, where the absolute value is used by the code.\n\nThe exact solution is\n\n\n\\begin{equation*}\nn_{m}=n_{R 0, m} \\frac{T_{\\perp}(\\theta)}{T_{\\perp R 0}} \\exp \\left(-\\frac{e Z_{m} \\Phi}{T_{\\|}}+\\frac{m_{m} \\Omega^{2} R^{2}}{2 T_{\\|}}\\right) \\tag{4.39}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{equation*}\n\\frac{T_{\\perp}(\\theta)}{T_{\\perp R 0}}=\\left[\\frac{T_{\\perp R 0}}{T_{\\|}}+\\left(1-\\frac{T_{\\perp R 0}}{T_{\\|}}\\right) \\frac{B_{R 0}}{B}\\right]^{-1} . \\tag{4.40}\n\\end{equation*}\n\n\nThe generalised asymmetry energy for the minority is then defined such that Eq. 4.38 still holds, with\n\n\n\\begin{equation*}\n\\mathcal{E}_{\\Omega, \\eta}=\\mathcal{E}_{\\Omega}+T_{\\|} \\ln \\left(T_{\\perp R 0} / T_{\\perp}(\\theta)\\right) \\tag{4.41}\n\\end{equation*}\n\n\nwhich in the GKW normalisations is\n\n\n\\begin{equation*}\n\\mathcal{E}_{R, \\eta}^{N}=\\mathcal{E}_{R}^{N}+T_{\\|}^{N} \\ln \\left(T_{\\perp R 0} / T_{\\perp}(\\theta)\\right) \\tag{4.42}\n\\end{equation*}\n\n\nwhere $T_{\\|}^{N}=T_{\\|} / T_{R}^{N} T_{\\text {ref }}$ (set =1 in the approximations below).\n\n\\subsection*{4.4.3 Transformations of input parameters}\nIf, as is usual in GKW, we take $R_{0}=R_{\\text {LFS }}$, then the consequence is that the minority fraction $f_{\\text {min }}=$ $\\left\\{n_{m}\\right\\} /\\left\\{n_{e}\\right\\}$ differs strongly from the value of $n_{R 0, m} / n_{R 0, e}$ in the presence of anisotropy.\\\\\nHowever, in some cases, (particularly those of a strongly anistropic minority species) it is desirable that the code density inputs can be specified in the form of flux surface averages, because this is the canoncial conserved quantity in the absence of radial transport. Such an input specification also removes the need for post-processing of the output quantities as dsecribed in B.0.1.\n\nFor the reasons given in the preceding section, defining $n_{\\text {input }}=\\{n\\}$ and $r l_{\\text {input }}=R_{\\text {ref }} / L_{\\{n\\}}=1 /\\{n\\} \\partial\\{n\\} / \\partial \\psi$ using the flux surface averaged densities requires an extra layer of iterative numerical solutions.\n\nITERATIVE transformation scheme under development, to be documented shortly....\n\n\\subsection*{4.4.4 Implementation}\nUsing the generalised quasi-neutrality root finding solver for $Q(\\Phi)=0$ described in Sec. 4.1 above, it is then straightforward to insert the additional $B^{-\\eta}$ dependence for a minority species. Since GKW also requires and computes radial derivatives of $\\Phi$, a maximum of 7 parameters are potentially required:\n\n\n\\begin{equation*}\n\\left(n_{\\text {input }, \\mathrm{m}} / n_{\\text {ref }}, \\quad T_{\\perp} R 0 / T_{\\|}, \\quad \\partial\\left(T_{\\perp R 0} / T_{\\|}\\right) / \\partial \\psi, \\quad T_{\\|}, \\quad \\partial T_{\\|} / \\partial \\psi, \\quad Z_{m}, \\quad m_{m}\\right) \\tag{4.43}\n\\end{equation*}\n\n\nWe remind the reader that $\\psi=r / R_{\\text {ref }}$ is the dimensionless radial coordinate used in GKW. Note that the minority mass is not required as an input in the case when $\\Omega=0$.\n\nIn addition, it can be useful to include the asymmetric potential generated by the minority species without simulating it as a separate gyrokinetic species (combination method: NOT PRESENTLY WORKING CORRECTLY). For this purpose, although treated separately in the background quasi-neutrality solve, the minority species is after-wards combined with the bulk ion species $(i)$. Since $Z e \\Phi / T_{\\|} \\ll 1$ and $f_{\\min } \\ll 1$ only ever appear in combination if the exponential is expanded as series, the values of $T_{\\|}$and $\\partial T_{\\|} / \\partial \\psi$ make a negligible impact on the results (tested for $f_{\\min }=0.1$ and $T_{\\|} / T_{\\perp R 0}=10.0$ ). For simplicity, these parameters are therefore neglected in the combination method, and where required, the code makes the assumption that $T_{i}=T_{\\|}$. (This assumption is required to have a value in the code, but in reality it does not affect the results). Only one mass is used for the combined species. Since the mass does not appear in the anisotropy effect, the average mass of the minority plus bulk should be given to model the centrifugal and kinetic effects correctly, but using the assumption $m_{m}=m_{i}$ will likely give almost identical results for most parameters. Outside the quasi-neutrality solve, the two species are combined, with $n_{R 0, t}=n_{R 0, i}+n_{R 0, m} Z_{m} / Z_{i}$ such that $n_{t}=n_{i}+n_{m} Z_{m} / Z_{i}$ everywhere, which gives a resulting asymmetry energy of\n\n\n\\begin{equation*}\n\\mathcal{E}_{\\Omega, \\eta, t}=-\\ln \\left(n_{R_{0}, i} \\exp \\left(-\\mathcal{E}_{\\Omega, i}\\right)+\\frac{n_{R_{0}, m} Z_{m}}{Z_{i}} \\exp \\left(-\\mathcal{E}_{\\Omega, \\eta, m}\\right)\\right)+\\ln \\left(n_{R_{0}, t}\\right) \\tag{4.44}\n\\end{equation*}\n\n\nsuch that quasi-neutrality is still satisfied everywhere for the reduced set of species.\\\\\nBecause the combination option means that the asymmetry does not require an additional gyrokinetic species, the input parameters $n_{\\text {input }, \\mathrm{m}} / n_{\\text {ref }}, T_{\\perp R 0} / T_{\\|}, \\partial\\left(T_{\\perp R 0} / T_{\\|}\\right) / \\partial \\psi^{N}, Z_{\\min }$ are separated from the individual species inputs and appear in the SPCGENERAL namelist as the array icrh\\_params(1,2,3,4). respectively.\n\nIf instead the minority is treated as a full gyrokinetic species (independent method), the species is identified with background='ICRH' in the species namelist. This allows the fully general case without the (mild) assumptions on the parameters $m_{m}, T_{\\|}$and $\\partial T_{\\|} / \\partial \\psi^{N}$ required for the combination option. In this case, $n_{\\text {input }, \\mathrm{m}} / n_{\\text {ref }}$ and $Z_{\\min }$ are taken from the species inputs dens and $Z$ respectively (the first and last inputs icrh\\_params(1,4) are not used), and the species inputs temp and rlt describe $T_{\\|}^{N}$. In the gyrokinetic equation, this species is then treated as a Maxwellian with temperature $T=T_{\\|}$(i.e., there is no bi-Maxwellian option implemented for $F_{0}$ ). Strictly, a more accurate approximation would be a Maxwellian with $T=\\left(T_{\\|} T_{\\perp}^{2}\\right)^{1 / 3}$, which might be more accurate for collisions or neoclassics.\n\nAfter the solver completes, the code runs self-consistency checks on the quasi-neutrality of the gradients of the flux surface averages, which is a strong test on the consistency of the solver, using both the diagnostics in Eq. 4.6, and the transformations described in Sec. B.0.1. The gradient of the flux surface average\n\n", "\n\\begin{equation*}\n-\\frac{1}{\\{n\\}} \\frac{\\partial\\{n\\}}{\\partial \\psi}=\\left\\{1 / L_{n}^{e 1}\\right\\} \\tag{4.45}\n\\end{equation*}\n\n\nfor the minority is calcuated using\n\n\n\\begin{equation*}\n\\frac{1}{L_{n}^{e, N}}=\\frac{\\partial \\mathcal{E}_{R, \\eta}}{\\partial \\psi}+\\mathcal{E}_{R} \\frac{1}{L_{T}^{N}}+\\left.\\frac{1}{L_{n}^{N}}\\right|_{R_{0}} \\tag{4.46}\n\\end{equation*}\n\n\n(note, the second term does NOT use the generalised energy $\\mathcal{E}_{R, \\eta}$ ) with\n\n\n\\begin{equation*}\n\\frac{1}{L_{n}^{e, 1, N}}=\\frac{1}{L_{n}^{e, N}} \\frac{\\exp \\left(-\\mathcal{E}_{R}\\right)}{\\left\\{\\exp \\left(-\\mathcal{E}_{R}\\right)\\right\\}} \\tag{4.47}\n\\end{equation*}\n\n\nwhich is the generalisation of Eq. 4.7). The first term in Eq. 4.46 is evaluated with the derivatives appearing in Sec. B.0.1, or Sec. ??, and the results of the checks are output to screen.\n\n\\section*{Examples of anisotropic minority input setup}\nSince the quasi-neutrality solver is only activated for centrifugal effects, the switch cf\\_trap $=T$ must also be set even in the absence of rotation. Here we present two example input setups for a $5 \\%$ helium- 4 minority with $T_{\\perp} / T_{\\|}=4$ and $\\partial\\left(T_{\\perp} / T_{\\|}\\right) / \\partial \\psi=-8.5$. First treating the minority species as a gyrokinetic species, (independent method) we have:\n\n\\begin{verbatim}\n&GRIDSIZE\nnumber_of_species = 4\n/\n&SPCGENERAL\nicrh_params = 999, 4.0, -8.5, 999 ! First and last not used\n/\n&SPECIES ! D ions\nmass = 1.0000, dens = 0.90, z = 1.00, rlt = 5.5, rln = 2.5, temp = 1.0, uprim = 0.0\n/\n&SPECIES ! electrons\nmass = 2.7e-4, dens = 1.00, z = -1.0, rlt = 4.5, rln = 2.5, temp = 1.2, uprim = 0.0\n/\n&SPECIES ! Molby trace impurity\nmass = 48.000, dens = 0.00, z = 32.0, rlt = 6.5, rln = 1.5, temp = 1.0, uprim = 0.0\n/\n&SPECIES ! He ICRH minority\nmass = 2.0000, dens = 0.05, z = 2.00, rlt = 9.9, rln = 2.5, temp = 2.0, uprim = 0.0\nbackground = 'ICRH'\n/\n&ROTATION\ncf_trap = .true.\n/\n\\end{verbatim}\n\nor, alternatively, treating the minority in combination with the bulk ions (combination method), and giving practically identical results for $\\Phi$ and its deriviatives:\n\n\\begin{verbatim}\n&GRIDSIZE\nnumber_of_species = 3\n/\n&SPCGENERAL\nicrh_params = 0.05, 4.0, -8.5, 2.0 ! minority fraction, Tp/T|l, d(Tperp/T|l)/dpsi, Z_m\n/\n&SPECIES ! D ions + He minority (treated with Z = 1 in Possion and GK equations)\nmass = 1.0527, dens = 1.00, z = 1.00, rlt = 5.5, rln = 2.5, temp = 1.0, uprim = 0.0\n/\n&SPECIES ! electrons\nmass = 2.7e-4, dens = 1.00, z = -1.0, rlt = 4.5, rln = 2.5, temp = 1.2, uprim = 0.0\n/\n&SPECIES ! Molby trace impurity\nmass = 48.000, dens = 0.00, z = 32.0, rlt = 6.5, rln = 1.5, temp = 1.0, uprim = 0.0\n/\n&ROTATION\ncf_trap = .true.\n/\n\\end{verbatim}\n\n\\section*{Tests}\n\\begin{itemize}\n  \\item The combination method and the independent method give identical asymmetries.\n  \\item Quasi-neutrality is always satisfied everywhere, with all $\\eta$, and all $\\Omega$, all geometries, for both $R_{0}$ choices, and arbitrary non-trace species combinations.\n  \\item Quasi-neutrality in the gradients is satisfied at all locations, and in the flux surface average density, checked using the formulae of Sec. B.0.1.\n  \\item The $\\Phi$ asymmetry scales linearly with $f_{m}, Z_{m}$ and $\\eta$, and is practically independent of $T_{\\|}$.\n  \\item High-Z impurity asymmetries are of the same magnitude as in Ref. [78] for the given parameters.\n\\end{itemize}\n\n\\section*{Chapter 5}\n\\section*{Tearing modes}\nHere are some brief notes that describe how an imposed magnetic island is included in GKW (self-consistent tearing modes can occur naturally given correct inputs and thus do not require a description of their implementation here). The previous version (Refs [27, 28]) assumed that the island is always initialised in the largest poloidal mode. To have the island in a larger wavevector there are some subtleties to the initialisation. For a recent description of the implementation and benchmarks in slab geometry, see Zarzoso et al,. PoP, 2015.\n\n\\subsection*{5.1 Spectral implementation of magnetic islands in toroidal geometry}\nIf we initially assume a constant poloidal flux perturbation with a given helicity\n\n\n\\begin{equation*}\nA_{\\|}=A_{\\| 0} \\exp [2 \\pi \\mathrm{i}(m s-n \\gamma)] \\tag{5.1}\n\\end{equation*}\n\n\nwhere $s$ and $\\gamma$ are the poloidal and toroidal angles, respectively. Introducing the helical coordinate $\\zeta=q s-\\gamma$ and expanding the safety factor up to first order\n\n\n\\begin{equation*}\nq=m / n+\\Delta \\psi \\partial q / \\partial \\psi \\tag{5.2}\n\\end{equation*}\n\n\nin the centre of the box (i.e. the mode is resonant at this position). We need to transform this representation to the $(\\psi, \\zeta, s)$ coordinate system which gives,\n\n\n\\begin{equation*}\nA_{\\|}=A_{\\| 0} \\exp \\left[2 \\pi \\mathrm{i}\\left(n \\zeta-\\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi\\right)\\right] \\tag{5.3}\n\\end{equation*}\n\n\nFrom which it directly follows that\n\n\n\\begin{equation*}\nk_{\\zeta}=2 \\pi n \\rho_{*} \\tag{5.4}\n\\end{equation*}\n\n\nis the toroidal mode of the island. However for generality we assume that this may not be the largest wavelength within the domain, this is $k_{\\zeta}^{\\min }=2 \\pi \\rho_{*}$.\\\\\nIn the helical field line co-ordinate system the x-points only appear in the $\\zeta$ direction. In the toroidal and poloidal angles, x-points appear in both. From the periodicity constraint connected with the parallel boundary conditions it follows that the radial wavevectors are given by\n\n\n\\begin{equation*}\nk_{\\psi}=\\left(p / i_{k}\\right) k_{\\zeta} \\frac{\\partial q}{\\partial \\psi}=\\left(p / i_{k}\\right) 2 \\pi \\rho_{*} \\frac{\\partial q}{\\partial \\psi} \\tag{5.5}\n\\end{equation*}\n\n\nwhere $p$ is a set of integers in the range $\\left[-N_{x} / 2, N_{x} / 2\\right]$ and $i_{k}$ is the parameter that determines the radial mode spacing. From $p=1$ one directly obtains the radial size of the box\n\n\n\\begin{equation*}\n\\psi=\\left[-\\frac{i_{k}}{2 \\partial q / \\partial \\psi}, \\frac{i_{k}}{2 \\partial q / \\partial \\psi}\\right] \\cdot \\frac{1}{k_{\\zeta}^{\\min }} \\tag{5.6}\n\\end{equation*}\n\n\nThe Fourier amplitudes of the different radial modes then can be calculated by integrating over the radial domain\n\n\n\\begin{align*}\n\\hat{A}\\left(k_{\\psi}, k_{\\zeta}, s\\right) & =A_{\\| 0} \\exp \\left(i n k_{\\zeta}^{\\min } \\zeta\\right) \\int \\mathrm{d} \\Delta \\psi \\exp \\left[i \\Delta \\psi\\left(k_{\\psi}+n s k_{\\zeta}^{\\min } d q / d \\psi\\right)\\right] \\\\\n& =\\frac{A_{\\| 0} i_{k}}{\\pi n \\partial q / \\partial \\psi} \\frac{\\sin \\left[\\pi\\left(n i_{k} s+p\\right)\\right]}{n i_{k} s+p} \\\\\n& =C \\frac{i_{k}}{n} \\frac{\\sin \\left[\\pi s^{\\circ}\\right]}{s^{\\circ}} \\tag{5.7}\n\\end{align*}\n\n\nwhere we have used the ballooning angle $s^{\\circ}=n i_{k} s+p$ in the last step and $n$ is the poloidal wave mode (determined by the input parameter isl\\_mode).\\\\\nOne point to note at this point is that this perturbation is not periodic in the radial domain of GKW for all values of $s$. This manifests itself as a discontinuity in the parallel vector potential at the radial edge of the computational domain. A solution to this problem is to relax the constant flux approximation and therefore write the perturbation as,\n\n\n\\begin{equation*}\nA_{\\|}=C \\frac{i_{k}}{n} \\exp i k_{\\zeta} \\zeta \\sum_{p=N_{x} / 2}^{N_{x} / 2} A^{p}(s) \\exp i p k_{\\psi} \\Delta \\psi \\tag{5.8}\n\\end{equation*}\n\n\nWhere $A^{p}(s)$ includes a damping function. We have chosen a Gaussian profile to reduce any ringing. This gives\n\n\n\\begin{equation*}\nA^{p}(s)=\\exp \\left(\\left(-\\left(n i_{k} s+p\\right)^{2} / L_{s}^{2}\\right)\\right) \\frac{\\sin \\pi\\left(n i_{k} s+p\\right)}{\\left(n i_{k} s+p\\right)} \\tag{5.9}\n\\end{equation*}\n\n\nWhere L is half width of the gaussian envelope. This approximation leads to a more satisfactory shape for the vector potential, where the value of L can be tuned to that the damping of the small k modes is negligible and the of high k modes sufficiently strongly to prevent the occurance of a jump at the boundary.\n\nThus the full implemented vector potential has the form,\n\n\n\\begin{equation*}\nA_{\\|}=C \\frac{i_{k}}{n} \\exp \\left(i k_{\\zeta} \\zeta-i \\omega t\\right) \\sum_{p=N_{x} / 2}^{N_{x} / 2} \\exp \\left(-\\frac{\\left(n i_{k} s+p\\right)^{2}}{L_{s}^{2}}\\right) \\frac{\\sin \\pi\\left(\\left(n i_{k} s+p\\right)\\right)}{\\left(n i_{k} s+p\\right)} \\exp \\left(i p k_{\\psi} \\Delta \\psi\\right) \\tag{5.10}\n\\end{equation*}\n\n\nwhere $\\omega$ is the poloidal rotation frequency of the island. Note that only a single binormal mode is used. The island half-width is defined in dimensional units (Wesson) as\n\n\n\\begin{equation*}\nW=2 \\sqrt{\\frac{r q \\tilde{B}_{r}}{m B_{p}(d q / d r)}}=2 \\sqrt{\\frac{r \\tilde{A}_{\\|}}{B_{p} \\hat{s}}}=2 \\sqrt{\\frac{q R \\tilde{A}_{\\|}}{B_{t} \\hat{s}}} \\tag{5.11}\n\\end{equation*}\n\n\nwhere $B_{p}$ is the poloidal component of the background magnetic field ${ }^{1}$. The island width determines the amplitude of the island perturbation: The factor $d q / d r=q \\hat{s} / r$ is obtained from the magnetic shear and $m$ is the poloidal mode number. Using the fact that the peturbed radial magnetic field is prescribed as $\\tilde{B}_{r}=m \\tilde{\\Psi} / r R$, and that for the $s-\\alpha$ model equilibrium the perturbed magnetic flux is given by $\\tilde{\\Psi}=R \\tilde{A}_{\\| 0}$, and $q=r B_{t} / R B_{p}$, the amplitude of the island vector potential (now in GKW normalised units) is given by\n\n\n\\begin{equation*}\n\\tilde{A}_{\\| 0 N}=\\frac{W_{N}^{2} B_{t N} \\hat{s}}{4 q R_{N}}, \\quad C=\\frac{W_{N}^{2} B_{t N} \\epsilon}{4 \\pi q^{2} R_{N}} \\tag{5.12}\n\\end{equation*}\n\n\nwhere $B_{t}^{N}$ is taken at the low field side in order to define the island width at the same location, and $W=W_{N} \\rho_{\\mathrm{ref}}$. Note that the amplitude of C given in equation 5.12 is divided by 2 , due to the form of the Fourier representation described in Sec. 2.3.\n\n\\footnotetext{${ }^{1}$ The correspondance with the literature on the sheared slab by Smolyakov and others is as follows: They have $W^{2}=$ $4 L_{s} A_{\\|} / B_{0}$, but $\\psi$ is the vector potential in their notation. The toroidal result used in GKW can be obtained by inserting $1 / L_{s}=(1 / q)(d q / d r)$, and $B_{0}=B_{p}$.\n}\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-064}\n\nFigure 5.1: Magnetic Island Geometry for an island with a half width of 30 ion gyro-radii\n\nTo run GKW with a magnetic island present the following options must be used: Firstly, the code must be set to run electro-magnetically by setting nlapar=.true.. In the SPCGENERAL namelist, tearingmode must be set to .true., which adds the magnetic island as a perturbation of the equilibrium field. The half width of the island is determined by the input parameter wstar which is the island width normalised to $\\rho_{\\text {ref }}$ (usually the ion gyro-radius). A point of note is that this island width can not exceed (and should be smaller than) the radial extent of the computational box due to the periodicity constraints of a pseudo-spectral code. The rotation frequency of the island $(\\omega)$ is set by the parameter isl\\_rot\\_freq, normalised as other frequencies in the code BUT with opposite sign (positive is in the $\\nabla \\zeta$ direction, which is the electron grad-B drift direction when $s_{j}=1$ and $\\operatorname{rln} i 0$. By default the island is placed in the smallest non-zero poloidal wavevector (isl\\_mode=2), however this can be changed by setting isl\\_mode to another integer (e.g. isl\\_mode=3 will give 2 islands within the domain as the zero mode is always the first mode).\n\nWe recommend initialising the distribution function with finit='zero' as the island itself will seed the turbulence, and this gives faster convergence compared to non-zero distribution function initialisations. When plotting XY profile outputs, setting lisl\\_follow in the DIAGNOSTIC namelist will follow the magnetic island so that the O-point is always in the centre of the box. We do not recommend using the options to initialise the island after the turbulence, as growing the island too quickly drives a unphysical and large zonal flow, which initally supresses the turbulence and then takes a long time to decay.\n\n\\begin{verbatim}\n&SPCGENERAL\nbeta = 0.0001, ! not used\ntearingmode=.true., wstar = 5.0, finit = 'zero', adiabatic_electrons = .false.\nLs = 2.0, isl_mode = 2, isl_rot_freq = 0.1\n/\n\\end{verbatim}\n\n\\subsection*{5.2 Spectral implementation of islands in 2D sheared slab geometry}\nAn alternative way to deal with 2 D islands is also implemented, in which parallel dynamics are projected into the $y$ direction, as is usually done in slab analytics. This allows GKW islands to be compared directly with analytical results in the slab. Whilst this setup is intended for use with the slab geometry, it might also be applicable for a LFS toroidal case. The island amplitude is decoupled from geometric magnetic shear, and a new parameter, isl\\_shear is used in determing the island width. To use this option the geometric shear shat is set to 0 (which means reducing the coordinate system to purely Cartesian) and the code is run with a single s point and without parallel dynamics (a limit in which the geometrical magnetic shear plays no role). This also implies that the minimum $k_{x}$ and $k_{y}$ now can be set completely independently, but they are chosen to be the same (to give a square box).\n\nThe perturbed $A_{\\|}$in this case then also contains the part of the island that normally comes from the\\\\\nbackground magnetic field (in the 2D case the background B plays no role in the geometry and theoretically only enters via the Larmor radius). The slab geometry is defined in this case through a Cartesian set of coordinates, $x, y$ and $z$, where $z$, the direction of the guide magnetic field, is meant to be a symmetry coordinate for the whole system, i.e. $\\partial / \\partial z=0$, accordingly to the existing dedicated literature. The total magnetic field in this case reads\n\n\n\\begin{equation*}\n\\mathbf{B}=B_{z} \\nabla z-\\nabla \\psi \\times \\nabla z \\tag{5.13}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{equation*}\n\\psi=-\\frac{i_{s} x^{2}}{2} B_{z}+\\tilde{\\psi} \\cos \\left(k_{y} y\\right) \\tag{5.14}\n\\end{equation*}\n\n\nwhere $B_{z}$ is a constant and where $i_{s}$ corresponds to isl\\_shear, the (inverse of the) scale of variation of $B_{y}$, which plays a role analogous to the magnetic shear in toroidal geometry. The $y$-dependent term represents the island. The amplitude $\\tilde{\\psi}$, assumed to be constant as a consequence of the well-known \"constant- $\\psi$ approximation\", is linked to the island width $w$ through the relation\n\n\n\\begin{equation*}\nw^{2}=\\frac{4 \\tilde{\\psi}}{i_{s} B_{z}} \\tag{5.15}\n\\end{equation*}\n\n\nIn the 3D case, only the latter \"island\"-part of $\\psi$ is imposed as a perturbation, entering the gyrokinetic equation through $v_{\\chi}$ in the nonlinear term. In this 2 D case, in constrast, we consider a shearless slab, with equilibrium\n\n\n\\begin{equation*}\n\\mathbf{B}=B_{z} \\nabla z \\tag{5.16}\n\\end{equation*}\n\n\n(constant) and we include the whole $\\psi$ of Eq. 5.14 as a perturbation. In Fourier space this extra island component (additional to the usual part in the island $k_{y}$ mode) is applied in the $k_{y}=0$ mode, and has the form\n\n\n\\begin{equation*}\nA_{\\|}^{+}(p)=\\frac{4(-1)^{p} i_{s}}{\\bar{k}_{x}(p)^{2}} \\exp \\left(-(p / L s)^{2}\\right) \\tag{5.17}\n\\end{equation*}\n\n\nwhere $p$ is again the radial mode number, and an exponential damping has again be added to the exact Fourier transformed quantity. The overbar on $\\bar{k}_{x}$ represents the modes in the code, to distinguish them from the island wavenumbers $k_{x}$ and $k_{y}$ used above. While it is apparent that $\\psi$ is periodic on $y$, the quadratic dependence on $x$ cannot be exactly reproduced in Fourier space, as its derivative is not the same on the two boundaries. Thus, analogously to the toroidal case, we again employ the exponential damping for the high $k_{x}$ modes in order to remove boundary discontinuities. This approximation has the effect of creating a second magnetic island at the boundary which in full 3D geometry is obscured by parallel coupling, ballooning and curvature. The effect of this boundary island can be minimised by choosing an appropriate combination of the parameters box size, shear, island width, damping length (which differ in slab and torodial geometry) but it can never be completely eliminated.\\\\\nIn the 2D case, there is however an additional island option, to add two identical islands radially with perfect periodicity. This option is activated when shat $=0$ and isl\\_shear $>0$ by selecting a negative wstar. By choosing this option, $\\psi$ is approximated by\n\n\n\\begin{equation*}\n\\psi=\\hat{C} \\cos k_{x} x+\\tilde{\\psi} \\cos k_{y} y \\tag{5.18}\n\\end{equation*}\n\n\nwhere $\\hat{C}=\\pi B_{z} i_{s} / k_{x}^{2}$ is a constant chosen in order to have the same amplitude as the other case for $B_{y}=\\partial \\psi / \\partial$ at the edge of the box. In this case, the additional nonzero component only appears in the $k_{y}=0, p=-1,1$ modes with value $A_{\\|}^{+}=\\pi i_{s} / k_{x}^{2}$. The sinusoidal dependence can of course be implemented without any approximation, or artificial damping, leading therefore to no parasitic boundary island formation. However, the presence of both a maximum and a minimum in $x$ corresponds to the presence of two identical islands with $\\pi / 2$-shift in the $y$-direction. By carefully choosing the box width, one is able to reduce the mutual interaction of the two islands.\n\nSummarizing, for slab geometry GKW has three options for islands:\n\n\\begin{itemize}\n  \\item To run with shat $>0$ in 3 D , which is expensive (and where discontinuities at the boundary create numerical problems) and which does not reproduce the boundary condition $\\partial / \\partial z=0$ used in many analytic models.\n  \\item To run with shat $=0$ and wstar $>0$. These are 2 D runs, much faster, but which still employ the artificial damping on high- $\\bar{k}_{x}$ modes, and therefore require specific attention to the discontinuity at the boundary, as in the full 3D cases.\n  \\item To run with shat $=0$ and wstar $<0$. These are 2D runs, with no artificial damping, but which contain two identical out of phase magnetic islands at two radial locations.\n\\end{itemize}\n\nExample 2D setup:\n\n\\begin{verbatim}\n&GRIDSIZE\nNX = 167, N_mu_grid = 8, n_vpar_grid = 12, number_of_species = 2,\nN_s_grid = 1, NMOD = 20, nperiod = 1,\n/\n&MODE\nmode_box = .true., krhomax = 0.45, ikxspace = 1,\n/\n&GEOM\nGEOM_TYPE = 'slab_periodic', SHAT = 0.0, Q = 1.0, EPS = 1.0,\n/\n&SPCGENERAL\nfinit = 'zero', tearingmode=.true.,\nwstar = 10.0, isl_rot_freq = -0.02,\nadiabatic_electrons = .false.\nls=8.0, isl_shear = 0.1\n\\end{verbatim}\n\n\\subsection*{5.3 Nonspectral implementation of a magnetic island}\nIf the radial direction is not treated in Fourier space, the implementation is much more direct, since we need only to introduce at $t=0$ the term\n\n\n\\begin{equation*}\nA_{\\|}=A_{\\| 0} \\cos (2 \\pi \\mathrm{i}(m s-n \\gamma)) \\tag{5.19}\n\\end{equation*}\n\n\nwhich can be expressed by\n\n\n\\begin{equation*}\nA_{\\|}=\\frac{1}{2} A_{\\| 0}\\left[e^{i 2 \\pi n \\zeta}\\left(\\cos \\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi-i \\sin \\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi\\right)+e^{-i 2 \\pi n \\zeta}\\left(\\cos \\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi+i \\sin \\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi\\right)\\right] \\tag{5.20}\n\\end{equation*}\n\n\nIn the binormal direction we initialise only one mode, namely $e^{i 2 \\pi n \\zeta}$ and assume the existence of the other mode in other to get a real quantity once the inverse Fourier transform is performed. Therefore, we need to implement only the potential\n\n\n\\begin{equation*}\nA_{\\|,+}=\\frac{1}{2} A_{\\| 0}\\left(\\cos \\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi-i \\sin \\frac{\\partial q}{\\partial \\psi} n s \\Delta \\psi\\right) \\tag{5.21}\n\\end{equation*}\n\n\nIn order to decouple the island from the boundary of the simulation box, we multiply the previous potential by a radial envelope having the explicit expression\n\n\n\\begin{equation*}\nA_{r}(\\Delta \\psi)=\\frac{1}{4}\\left(1+\\tanh \\left(\\frac{\\Delta \\psi+\\Delta \\psi_{0}}{\\delta \\psi_{0}}\\right)\\right)\\left(1-\\tanh \\left(\\frac{\\Delta \\psi-\\Delta \\psi_{0}}{\\delta \\psi_{0}}\\right)\\right) \\tag{5.22}\n\\end{equation*}\n\n\nwhere $\\Delta \\psi_{0}$ and $\\delta \\psi_{0}$ are defined in the tearingmode namelist of the input file of GKW by the variables psi\\_0 and delta\\_psi\\_0, respectively.\n\nIn a 2D sheared slab geometry, the previous implementation reduces to\n\n\n\\begin{equation*}\nA_{\\|}=\\frac{1}{2} A_{\\| 0} A_{r}(\\Delta \\psi) \\tag{5.23}\n\\end{equation*}\n\n\nand the background magnetic shear is introduced together with this perturbation by means of the mode $\\kappa_{\\zeta}=0$. Therefore, the total parallel vector potential reads in 2D sheared slab geometry\n\n\n\\begin{equation*}\nA_{\\|}=\\frac{B_{z} i_{s}}{2}\\left[\\Delta \\psi^{2}-\\left(L_{x} / 2\\right)^{2}\\right]+\\frac{1}{2} A_{\\| 0} A_{r}(\\Delta \\psi) e^{i 2 \\pi n \\zeta} \\tag{5.24}\n\\end{equation*}\n\n\nwhere the additional term $\\frac{B_{z} i_{s}}{2}\\left(L_{x} / 2\\right)^{2}$ is introduced to impose a vanishing potential at the boundary in the nonspectral version. We therefore need to introduce the term $\\frac{B_{z} i_{s}}{2}\\left[\\Delta \\psi^{2}-\\left(L_{x} / 2\\right)^{2}\\right]$ in the $\\kappa_{\\zeta}=0$ component and the term $\\frac{1}{2} A_{\\| 0} A_{r}(\\Delta \\psi)$ in the $\\kappa_{\\zeta}=\\kappa_{\\text {isl }}$ component.\n\n\\subsection*{5.4 Reconstruction of flux tube radial profiles and profile flattening in GKW}\nThe benchmark of the magnetic islands implementation includes the flattening of the density and pressure profiles. The equilbrium profiles are linear with respect to the radial coordinate and are present in the source terms. Since we are solving the gyrokinetic equation for the perturbed part of the distribution function, the solution should respond to the source terms due to the background. In particular, the magnetic island should give a perturbation that cancels the background out inside the separatrix. Note that runs must be non-linear for the correct level of flattening to be obtained. To reconstruct the radial profiles the XY diagnostics must enabled in the diagnostics namelist.\n\n\\subsection*{5.4.1 Density profiles}\nThe files named den0\\#\\textit{000*}* hold the normalised XY perturbed density data ( $\\tilde{n}_{N, s}$ ) for each large time step. The background density profile can be reconstructed by using the local radial cordinate $x_{r}=\\psi / \\rho_{*}=$ $r / \\rho_{\\text {ref }}$ which is written in the file named xphi (with the same dimensions as the XY slices) and the input parameter $R L N_{-}=-\\left(1 / n_{R_{0}, s}\\right) \\frac{\\partial n_{R_{0}, s}}{\\partial \\psi}$. The total density of species $s$ is $n_{s}=n_{s, \\mathrm{eq}}+\\tilde{n}_{s}$, where $n_{s, \\mathrm{eq}}=$ $n_{R_{0}, s}\\left(1-\\frac{r-r_{0}}{L_{n}, s}\\right)$ is the global density of the Maxwellian equilibrium written in the local limit, i.e. $n_{R_{0}, s}$ at the resonant position $r_{0}$ plus the linear variation due to the gradient at that position. Note that in the expression of $n_{s, \\text { eq }}$, the quantity $n_{R_{0}, s}$ does not exhibit any radial dependence since it is considered in the local limit. The perturbed density of species $s$ is\n\n\n\\begin{equation*}\n\\tilde{n}_{s}=\\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v} \\delta f_{s}=\\rho_{*} n_{R_{0}, s} \\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v}_{N, s} \\delta f_{N, s}=\\rho_{*} n_{R_{0}, s} \\tilde{n}_{N, s} \\tag{5.25}\n\\end{equation*}\n\n\nTherefore, the total density for species $s$ reads\n\n\n\\begin{equation*}\nn_{s}=n_{R_{0}, s}\\left(1-\\frac{r-r_{0}}{L_{n, s}}\\right)+\\rho_{*} n_{R_{0}, s} \\tilde{n}_{N, s}=n_{R_{0}, s}\\left(1-\\frac{\\left(x_{r}-x_{r 0}\\right) \\rho_{\\mathrm{ref}}}{L_{n, s}}\\right)+\\rho_{*} n_{R_{0}, s} \\tilde{n}_{N, s} \\tag{5.26}\n\\end{equation*}\n\n\nWe can now normalise the density for species $s$ as $n_{N, s}=n_{s} / n_{R_{0}, s}$\n\n\n\\begin{equation*}\nn_{N, s}=\\left(1-\\frac{\\left(x_{r}-x_{r 0}\\right) \\rho_{\\mathrm{ref}}}{L_{n, s}}\\right)+\\rho_{*} \\tilde{n}_{N, s} \\tag{5.27}\n\\end{equation*}\n\n\nand define the change in the density for species $s$ as $\\Delta n_{N, s}=n_{N, s}-1$\n\n\n\\begin{equation*}\n\\Delta n_{N, s}=-\\left(x_{r}-x_{r 0}\\right) \\frac{\\rho_{\\mathrm{ref}} R_{\\mathrm{ref}}}{L_{n, s} R_{\\mathrm{ref}}}+\\rho_{*} \\tilde{n}_{N, s}=-\\rho_{*}\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{n, s}}+\\rho_{*} \\tilde{n}_{N, s} \\tag{5.28}\n\\end{equation*}\n\n\nor alternatively\n\n\n\\begin{equation*}\n\\frac{\\Delta n_{N, s}}{\\rho_{*}}=\\tilde{n}_{N, s}-\\frac{R_{\\mathrm{ref}}}{L_{n, s}}\\left(x_{r}-x_{r 0}\\right) \\tag{5.29}\n\\end{equation*}\n\n\nand the total density gradient (background plus perturbed density) can be computed as\n\n\n\\begin{equation*}\n\\frac{R_{\\mathrm{ref}}}{L_{n_{\\mathrm{eq}}+\\tilde{n}}}=-\\frac{1}{n_{R_{0}, s}} \\frac{\\partial\\left(n_{s, \\mathrm{eq}}+\\tilde{n}_{s}\\right)}{\\partial \\psi}=-\\frac{\\partial \\tilde{n}_{N, s}}{\\partial x_{r}}+\\frac{R_{\\mathrm{ref}}}{L_{n, s}} . \\tag{5.30}\n\\end{equation*}\n\n\n\\subsection*{5.4.2 Pressure profiles}\nTo obtain the pressure profiles we need to use the files ene0\\#\\textit{000*}*, which hold the normalised second moments of the distribution function, namely\n\n\n\\begin{equation*}\n\\tilde{E}_{N, s}=\\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v}_{N, s} \\delta f_{N, s} v_{N, s}^{2} \\tag{5.31}\n\\end{equation*}\n\n\nIt can be shown that the pressure perturbation is written in terms of this quantity as follows\n\n\n\\begin{equation*}\n\\tilde{p}_{s}=\\frac{1}{3} m_{\\mathrm{ref}} v_{t h, s}^{2} \\rho_{*} n_{R_{0}, s} m_{R, s} \\tilde{E}_{N, s} \\tag{5.32}\n\\end{equation*}\n\n\nTaking into account the definition of the reference temperature $T_{\\text {ref }}$, one can write\n\n\n\\begin{equation*}\n\\tilde{p}_{s}=\\frac{2}{3} \\rho_{*} n_{R_{0}, s} T_{\\mathrm{ref}} m_{R, s} v_{R, s}^{2} \\tilde{E}_{N, s} \\tag{5.33}\n\\end{equation*}\n\n\nIn addition, $m_{R, s} v_{R, s}^{2}=T_{R, s}$ and $T_{s}=T_{\\mathrm{ref}} T_{R, s}$, which leads to\n\n\n\\begin{equation*}\n\\tilde{p}_{s}=\\frac{2}{3} \\rho_{*} n_{R_{0}, s} T_{s} \\tilde{E}_{N, s} \\tag{5.34}\n\\end{equation*}\n\n\nIn the same way as has been done with the density, the total pressure is defined as $p_{s}=p_{s, \\text { eq }}+\\tilde{p}_{s}$, where $p_{s, \\mathrm{eq}}=n_{R_{0}, s} T_{s}\\left(1-\\frac{r-r_{0}}{L_{n, s}}\\right)\\left(1-\\frac{r-r_{0}}{L_{T, s}}\\right)$. In the local limit we can neglect terms of second order in $\\rho_{*}$ and therefore, the equilibrium pressure profile reads\n\n\n\\begin{equation*}\np_{s, \\mathrm{eq}} \\approx n_{R_{0}, s} T_{s}\\left(1-\\rho_{*}\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{n, s}}-\\rho_{*}\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{T, s}}\\right) \\tag{5.35}\n\\end{equation*}\n\n\nWe can now divide by $n_{R_{0}, s} T_{s}$ and define the change in the normalized pressure as\n\n\n\\begin{equation*}\n\\Delta p_{N, s}=\\frac{2}{3} \\rho_{*} \\tilde{E}_{N, s}-\\rho_{*}\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{n, s}}-\\rho_{*}\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{T, s}} \\tag{5.36}\n\\end{equation*}\n\n\nor equivalently\n\n\n\\begin{equation*}\n\\frac{\\Delta p_{N, s}}{\\rho_{*}}=\\frac{2}{3} \\tilde{E}_{N, s}-\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{n, s}}-\\left(x_{r}-x_{r 0}\\right) \\frac{R_{\\mathrm{ref}}}{L_{T, s}} \\tag{5.37}\n\\end{equation*}\n\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_11_06_cb0545ccfb9614bb7b3dg-069}\n\\end{center}\n\nFigure 5.2: Left: 2D colormap of the pressure profiles for ions and electrons in the presence of a magnetic island. The isocontours of the vector potential are shown only with the electron colormap. Right: radial profiles of the pressure through the O (black line) and X (blue line) points.\n\n", "This quantity is plotted in figure 5.2. Note that the flattening is observed in the moments of the distribution function, namely the density and the pressure. One can define a temperature for the unperturbed profiles, since these unperturbed quantities are obtained from a Maxwellian equilibrium. However, one cannot say that the total pressure is $p=n T$, where $n=n_{\\text {eq }}+\\tilde{n}$ and $T_{\\text {eq }}+\\tilde{T}$. For this reason, the flattening of the profiles can only be analysed for the density and the pressure. An example of unexpected results that one can obtain when defining a perturbed temperature is evidenced when introducing a magnetic island in a plasma with flat temperature profile but finite density gradient. One expects that the temperature is not modified, since it is already flat. However, by defining the temperature as $T=p / n$ one obtains a modification which actually corresponds to the modifications of both density and pressure.\n\nThe total pressure gradient (background plus perturbed pressure) reads\n\n\n\\begin{equation*}\n\\frac{R_{\\mathrm{ref}}}{L_{p_{\\mathrm{eq}}+\\tilde{p}}}=-\\frac{1}{n_{R_{0}, s} T_{s}} \\frac{\\partial\\left(p_{s, \\mathrm{eq}}+\\tilde{p}_{s}\\right)}{\\partial \\psi}=-\\frac{\\partial}{\\partial x_{r}} \\frac{\\Delta p_{N, s}}{\\rho_{*}}=-\\frac{2}{3} \\frac{\\partial \\tilde{E}_{N, s}}{\\partial x_{r}}+\\frac{R_{\\mathrm{ref}}}{L_{n, s}}+\\frac{R_{\\mathrm{ref}}}{L_{T, s}} \\tag{5.38}\n\\end{equation*}\n\n\n\\subsection*{5.5 Frozen electrons}\nDue to the small inertia of electrons, they are considered as frozen particles to the magnetic field lines. This means in particular that the rotation frequency of electrons must equal the rotation frequency of the island, namely\n\n\n\\begin{equation*}\n\\omega_{\\mathrm{isl}} \\equiv \\omega_{\\mathrm{TOT}, \\mathrm{e}}=\\omega_{*, e}+\\omega_{E \\times B} \\tag{5.39}\n\\end{equation*}\n\n\nwhich constitutes the second benchmark after implementation of a magnetic island.\\\\\nTherefore, the electric field must always compensate for the difference between the diamagnetic drift produced by any pressure gradient inside the island and the rotation of the island itself. In particular, if the island does not rotate, for a sufficiently large island resulting in a complete flattening, the electrostatic potential must vanish inside the island. To verify the previous identity, one must conveniently quantify from the GKW outputs the diamagnetic frequency resulting from the total pressure profile and the $E \\times B$ frequency. These two quantities are derived hereafter assuming a slab geometry and considering that the binormal (in the $y$ direction) structure is determined by the island. The diamagnetic frequency in the $y$ direction reads\n\n\n\\begin{equation*}\n\\omega_{*, s}=k_{y} \\frac{\\mathbf{b} \\times \\nabla p_{s}}{e_{s} n_{s} B} \\cdot \\mathbf{e}_{y} \\approx k_{y} \\frac{1}{e_{s} n_{s, \\mathrm{eq}} B} \\frac{\\partial p_{s}}{\\partial r} \\tag{5.40}\n\\end{equation*}\n\n\nUsing the normalizations of GKW, we can write\n\n\n\\begin{equation*}\n\\omega_{*, s} \\approx k_{y} \\frac{1}{e_{N, s} e n_{R_{0}, s} B_{N} B_{\\mathrm{ref}}} \\frac{n_{R_{0}, s} T_{s} \\rho_{*}}{\\rho_{\\mathrm{ref}}} \\frac{\\partial}{\\partial x_{r}} \\frac{\\Delta p_{N, s}}{\\rho_{*}} \\tag{5.41}\n\\end{equation*}\n\n\nThe temperature $T_{s}$ can now be expressed in terms of $T_{\\text {ref }}$ and $T_{R, s}$ and the reference Larmor radius used to write\n\n\n\\begin{equation*}\n\\omega_{*, s} \\approx k_{y} \\frac{1}{2} v_{\\mathrm{th}, \\mathrm{ref}} \\frac{T_{R, s}}{e_{N, s} B_{N}} \\rho_{*}\\left(\\frac{2}{3} \\frac{\\partial \\tilde{E}_{N, s}}{\\partial x_{r}}-\\frac{R_{\\mathrm{ref}}}{L_{n, s}}-\\frac{R_{\\mathrm{ref}}}{L_{T, s}}\\right) \\tag{5.42}\n\\end{equation*}\n\n\nUnder the assumption that the $y$ structure is determined by the island, one can write the wave number is that direction as $k_{y}=\\pi / y_{\\max }$, where $y_{\\max }$ is the maximum value of the $y$ coordinate. Expressing $\\rho_{*}$ as $\\rho_{*}=\\rho_{\\mathrm{ref}} / R_{\\text {ref }}$ and normalizing the diamagnetic frequency to the transit frequency $\\omega_{t}=v_{\\mathrm{th}, \\mathrm{ref}} / R_{\\text {ref }}$ one gets the normalized diamagnetic frequency in slab geometry\n\n\n\\begin{equation*}\n\\omega_{*, N, s} \\approx \\frac{\\pi}{y_{\\mathrm{max}, \\mathrm{~N}}} \\frac{1}{2} \\frac{T_{R, s}}{e_{N, s} B_{N}}\\left(\\frac{2}{3} \\frac{\\partial \\tilde{E}_{N, s}}{\\partial x_{r}}-\\frac{R_{\\mathrm{ref}}}{L_{n, s}}-\\frac{R_{\\mathrm{ref}}}{L_{T, s}}\\right) \\tag{5.43}\n\\end{equation*}\n\n\nIn a similar way, one can show that the $E \\times B$ frequency in GKW units reads\n\n\n\\begin{equation*}\n\\omega_{E, N, s} \\approx \\frac{\\pi}{y_{\\max , \\mathrm{N}}} \\frac{1}{2} \\frac{1}{B_{N}} \\frac{\\partial \\phi_{N}}{\\partial x_{r}} \\tag{5.44}\n\\end{equation*}\n\n\nFigure 5.3 represents the profiles of the frequency for each species in the presence of an island rotating in the ion diamagnetic direction with a frequency $\\omega_{\\text {isl }}=-0.006$. This frequency is represented by a solid black line, which must overlap the solid green line, corresponding to the total frequency of electrons. We observe this overlap everywhere inside the separatrix, but not around the X-point.\n\n\\subsection*{5.6 Dependence of the electrostatic potential on the island rotation frequency}\nThe third and last benchmark needed after the implementation of a magnetic island constitutes the dependence of the electrostatic potential on the island rotation frequency. This dependence is calculated assuming that electrons inside the island short out any variation of the parallel electric field, i.e. we need to verify that $\\nabla_{\\|} \\phi=-c^{-1} \\partial_{t} \\psi$ inside the island. For this we need to write an explicit expression for the parallel gradient, which is $\\nabla_{\\|}=\\mathbf{b} \\cdot \\nabla$, where $\\mathbf{b}=B^{-1} \\mathbf{B}$ is the unit vector in the direction of the magnetic field. Let us perform the calculation, for the sake of simplicity, in sheared 2D slab geometry, where the magnetic field reads\n\n\n\\begin{equation*}\n\\mathbf{B}=B_{z} \\nabla z-\\nabla \\psi \\times \\nabla z=B_{z} \\nabla z+\\frac{B_{z} x}{L_{s}} \\nabla y-\\tilde{\\psi} k_{y} \\sin \\left(k_{y} y-\\omega_{\\mathrm{isl}} t\\right) \\nabla x \\tag{5.45}\n\\end{equation*}\n\n\nUnder the assumption that the amplitude of the magnetic field is not significantly modified by the presence of the magnetic island and considering no derivatives in the $z$-direction (slab model), we can write\n\n\n\\begin{equation*}\n\\nabla_{\\|}=-\\frac{\\tilde{\\psi} k_{y}}{B_{z}} \\sin \\left(k_{y} y-\\omega_{\\mathrm{is} 1} t\\right) \\partial_{x}+\\frac{x}{L_{s}} \\partial_{y} \\tag{5.46}\n\\end{equation*}\n\n\nThe equation for the electrostatic potential is written as\n\n\n\\begin{equation*}\n\\frac{\\tilde{\\psi} k_{y}}{B_{z}} \\sin \\left(k_{y} y-\\omega_{\\text {isl }} t\\right) \\frac{\\partial \\phi}{\\partial x}-\\frac{x}{L_{s}} \\frac{\\partial \\phi}{\\partial y}=\\frac{1}{c} \\frac{\\partial \\psi}{\\partial t} \\tag{5.47}\n\\end{equation*}\n\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_11_06_cb0545ccfb9614bb7b3dg-071}\n\\end{center}\n\nFigure 5.3: Left: 2D colormap of the frequency profiles for ions (up) and electrons (down) in the presence of a magnetic island with $R / L_{n}=0.7$ and $R / L_{T}=0$. Right: radial profiles of the frequency through the O-point (up) and binormal profiles of the frequency through the O and X points (down). Electrons are represented by green curves and ions by blue curves. The dotted lines represent the diamagnetic frequency and the solid lines the total frequency. For the radial profiles, the black dashed line represents the $E \\times B$ frequency and the solid black line the rotation frequency of the island. For the binormal profiles, the dashed red line indicates the position of the X -point and the solid black line the rotation frequency of the island.\n\nNoticing that $x$ and $y$ coordinates must be related to each other on a flux surface for a given time $t$ by the flux label\n\n\n\\begin{equation*}\n\\Omega=\\frac{x^{2} B_{z}}{2 \\tilde{\\psi} L_{s}}-\\cos \\left(k_{y} y-\\omega_{\\mathrm{isl}} t\\right) \\tag{5.48}\n\\end{equation*}\n\n\nwe can rewrite the equation satisfied by the electrostatic potential as follows\n\n\n\\begin{equation*}\n-\\frac{x}{L_{s}} \\frac{\\partial \\phi}{\\partial y}=\\frac{1}{c} \\frac{\\partial \\psi}{\\partial t}, \\quad \\text { for } d \\Omega=0 \\tag{5.49}\n\\end{equation*}\n\n\nor equivalently\n\n\n\\begin{equation*}\n-\\left.\\frac{x}{L_{s}} \\frac{\\partial \\phi}{\\partial y}\\right|_{\\Omega}=\\frac{1}{c} \\frac{\\partial \\psi}{\\partial t} \\tag{5.50}\n\\end{equation*}\n\n\nThe derivative of $x$ with respect to $y$, for $x \\neq 0$, reads\n\n\n\\begin{equation*}\n\\frac{d x}{d y}=-\\frac{\\tilde{\\psi} L_{s}}{B_{z} x} \\sin \\left(k_{y} y-\\omega_{\\text {isl }} t\\right) \\tag{5.51}\n\\end{equation*}\n\n\nand therefore, the equation satisfied by the electrostatic potential becomes, for $k_{y} y \\not{ }_{\\pi} \\omega_{\\text {is } 1} t$\n\n\n\\begin{equation*}\n\\left.\\frac{k_{y}}{B_{z}} \\frac{\\partial \\phi}{\\partial x}\\right|_{\\Omega}=\\frac{\\omega_{\\mathrm{isl}}}{c} \\tag{5.52}\n\\end{equation*}\n\n\nwhich gives, after integration\n\n\n\\begin{equation*}\n\\phi=\\frac{\\omega_{\\mathrm{isl}} B_{z}}{k_{y} c}(x-h(\\Omega)) \\tag{5.53}\n\\end{equation*}\n\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_11_06_cb0545ccfb9614bb7b3dg-072}\n\\end{center}\n\nFigure 5.4: Expected values of the electrostatic potential at the separatrix (solid black line) and values obtained from simulations with GKW (red asterisks). Left: $w=10$. Right: $w=2$\\\\\nwhere $h(\\Omega)$ is a constant of integration for each flux surface. Note that the expression we have obtained for the electrostatic potential is only valid for $x \\neq 0$ and $k_{y} y \\not{ }_{\\pi} \\omega_{\\text {isl }} t$. The function $h(\\Omega)$ usually vanishes inside the island, corresponding to a complete flattening of radial profiles. Therefore, inside the separatrix and for $x \\neq 0$ we can write, in GKW units\n\n\n\\begin{equation*}\n\\phi_{N}=2 \\frac{\\omega_{\\mathrm{isl}, \\mathrm{~N}} y_{\\max , \\mathrm{N}}}{\\pi} \\Delta x_{r} \\tag{5.54}\n\\end{equation*}\n\n\nwhere $\\Delta x_{r}$ is the distance to the resonant surface. The extension to $x=0$ and $k_{y} y \\equiv_{\\pi} \\omega_{\\text {isl }} t$ can be done by assuming that the electrostatic potential is continuous. Therefore, $\\phi(x=0)=\\lim _{x \\rightarrow 0^{ \\pm}} \\phi=0$, $\\phi\\left(x=w, k_{y} y \\equiv_{\\pi} \\omega_{\\text {isl }} t\\right)=\\lim _{x \\rightarrow w^{+}} \\phi=2 \\frac{\\omega_{\\text {isl }, \\mathrm{N}} y_{\\max , \\mathrm{N}}}{\\pi} w$ and $\\phi\\left(x=-w, k_{y} y \\equiv_{\\pi} \\omega_{\\text {isl }} t\\right)=\\lim _{x \\rightarrow-w^{-}} \\phi=$ $-2 \\frac{\\omega_{\\text {isl } 1, \\mathrm{~N}} y_{\\max , \\mathrm{N}}}{\\pi} w$. The left panel of figure 5.6 shows a remarkable agreement between the expected values for the electrostatic potential at the separatrix $\\left(\\Delta x_{r}=w\\right)$ from the previous expression (solid black line) and the values obtained from five simulations with GKW (red asterisks). These simulations have been performed with $w=10, y_{\\max , \\mathrm{N}}=121.565$ and flat profiles.\n\nWhen the island width is comparable to or smaller than the ion Larmor radius, the ion pressure profile is little modified, whereas the electron pressure profile inside the island can still be modified. Of course, in the absence of background density and temperature profiles, this means that the ion pressure remains almost flat, whereas the electron pressure is only modified around the separatrix. However, this modification is of the order of the ion Larmor radius, meaning that for an island width of the order of the ion Larmor radius the electron pressure profile will be modified inside the island. In this case, the equation satisfied by the electrostatic potential should include the term related to the parallel gradient of the electrons pressure inside the island, namely\n\n\n\\begin{equation*}\n\\nabla_{\\|} \\phi=-c^{-1} \\partial_{t} \\psi+\\frac{1}{e n_{e}} \\nabla_{\\|} p_{e} \\tag{5.55}\n\\end{equation*}\n\n\nIntegrating this equation leads straightforwardly to the expression\n\n\n\\begin{equation*}\n\\phi=\\frac{\\omega_{\\text {isl }} B_{z}}{k_{y} c}(x-h(\\Omega))+\\frac{1}{e n_{e}} p_{e} \\tag{5.56}\n\\end{equation*}\n\n\nor equivalently, in GKW units\n\n\n\\begin{equation*}\n\\phi_{N, \\mathrm{sep}}=2 \\frac{\\omega_{\\mathrm{isl}, \\mathrm{~N}} y_{\\max , \\mathrm{N}}}{\\pi} w+\\left.\\frac{\\Delta p_{N, s}}{\\rho_{*}}\\right|_{\\mathrm{sep}} \\tag{5.57}\n\\end{equation*}\n\n\nThe right panel of figure 5.6 shows quite a good agreement, but some differences are observed. More analysis is needed for a complete understanding in the case of small islands.\n\n\\section*{Chapter 6 }\n\\section*{Eigenvalue solver}\n\\begin{abstract}\nHere we give some information on the usage of the eigenvalue solver, implemented in GKW, as well as\n\\end{abstract}\n\nsome technical details. Further information can be found in the presentation of R. Buchholz on the GKW webpages under Talks.\n\nAs the system size is to big for a direct (numerical) solution, projection methods are used. For a brief introduction, see the SLEPC manual [57] and references therein.\n\n\\subsection*{6.1 Usage}\nFirst, GKW must be compiled with SLEPC/PETSC, see 9.2.6 for details.\\\\\nThe easiest way to create an input file for the eigenvalue solver, is the following: First, set up an input file for use with the exponential time integration scheme. As second step then replace METHOD = 'EXP' with METHOD = 'EIV' in the control namelist, and set METH=1 and NAVERAGE=1 (also METH=2 and/or NAVERAGE $>1$ work, but these are at least not faster and usually slower).\\\\\nThe third and final step is to set the parameters for the eigenvalue solver itself. This is done using the optional namelist eiv\\_integration, an example of which is given below. One has to select which\\_eigenvalues should be searched for, for a full list of the options, see the sample input file. In addition, you can choose between two methods for extracting eigenvalues, type\\_extraction = 'harmonic', and type\\_extraction = 'ritz'. The target values for growthrate and freq) are always used if type\\_extraction = 'harmonic'. They are also used if you choose type\\_extraction = 'ritz' and which\\_eigenvalues = 11 and comparison\\_routine = 2 ('TARGET\\_COMPLEX'). Becuase the harmonic extraction makes a kind of shift-and-invert transformation, values near the target value have the largest magnitude, and so target values must always be provided.\n\nUnfortunately it is difficult to say in advance what settings are optimal, or will guarantee to find the physical eigenmodes of the system. Suggested starting points for the eigenvalue settings are given below. One rule seems to be valid in general: If you use harmonic extraction and search for the mode with largest eigenvalue, you should keep the target frequency freq=0.0. If you don't find an eigenvalue, increase the target growthrate, while if you just find stable high frequency eigenmodes, decrease it.\n\nTo share some more details of our experiences, fig. 6.1-6.6 show a scan for two set of parameters. Figures 6.16.3 show a scan for harmonic extraction, in which the eigenvalues with largest real part where searched. The first one has freq $=0$, while growthrate was varied, while it is the other way round for the second figure. The last one shows for two points from the previous scans, a scan over the size of the subspace (nr\\_column\\_vec).\n\nThe input parameters for fig. 6.4-6.6 are based on the STD\\_linear\\_ITG and simple\\_TEM input files found in doc/input, with $R / L_{T_{i}}=6$, which is near the ITG-TEM transition. Two unstable eigenmodes are therefore expected. The fixed parameters for the eigenvalue solver were\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-074(1)}\n\nFigure 6.1: Scan over growth rate with frequency set to zero. Dashed lines depict negative values of growthrate. Normalization is done with the maximum number of iterations for the first/second eigenvalue/total number of iterations, respectively.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-074}\n\nFigure 6.2: Scan over frequency with growth rate set to zero. Dashed lines depict negative values of freq. The point at $10^{-7}$ actually had zero frequency. Normalization is as for fig. 6.1. The dashed-dotted line depicts the minimum value for the total iterations of fig. 6.1 (only counting points where both unstable eigenmodes are found).\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-075}\n\nFigure 6.3: Scan over size of subspace, for one point of each of the other two scans. First case: growthrate $=0.0$, freq $=0.45$, searching for 5 eigenpairs (default value: 20). Second case: growthrate $=2.50 \\mathrm{E}-3$, freq $=0.0$, searching for 2 eigenpairs (default value: 17 ).\n\n\\begin{verbatim}\nmax_iterations = 30000\ntolerance = 1.0e-6\ntype_solver = 'krylovschur'\ntype_extraction = 'harmonic'\nnumber_eigenvalues = 3\nnr_column_vec = 20\nmat_vec_routine = 1\ncomparison_routine = 2\nwhich_eigenvalues = 1 ! largest magnitude\n\\end{verbatim}\n\nWe are searching for three eigenvalues for the case that there are more unstable ones than expected. Scans were made over the target growthrate and freq for the harmonic extraction. Some remarks on the speed: If you just want to find the fastest growing eigenmode, there is not much variation. About 900-1000 iterations were needed, if these mode was found. Only for the violet points is a large difference, here 6000-8000 iterations needed to be performed. If you are also interested in the second eigenpair, then the situation is quite samilar. This is found usually 100-150 iterations after the first one in the case of fig. 6.4 , while for fig. 6.5 the difference is quite often 0 or 1 . The third (stable) eigenvalue then takes about 16 - 18 times longer. This could be avoided by setting a suitable value for maxiterations.\\\\\nAn exception to this is the range growthrate $=0.75-0.9$ with freq $=0$, the third eigenvalue was already found after three times the iterations needed for the second eigenvalue.\n\nThe robustness and the speed of the solver are very dependant on the initial condition vector provided. We found finit=\"cosine4\" to be a good choice, but if one is doing a parameter scan, it can also be useful to restart with the output of the previous run. The batch launcher gkwnlin provides a facility (-restart\\_chain) for doing this.\n\nThe output, except for the screen output is only written if the solver finishes, which means either it finds the requested number of eigenpairs or it hits the maximum number of iterations. The output differs in some ways from the output obtained with METHOD $=$ 'EXP'. The main difference is that timestep is replaced\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-076}\n\nFigure 6.4: Scan for harmonic extraction and searching for eigenvalue with largest magnitude over the target values. Plus signs refer to actual found eigenvalues, crosses to 'conjugated' eigenvalues, stars to the projections on the growth rate axis. Color of the dots refers to the number of found eigenvalues. Please note, that a value of 1 (or more) requires that the fastest growing eigenmode was found and a value of 2 (or more) requires that both fastest growing eigenmodes where found.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-076(1)}\n\nFigure 6.5: Scan for harmonic extraction and searching for eigenvalue with largest magnitude over the target values. Here is scanned around the second eigenvalue. For the meaning of the symbols please refer to the caption of fig. 6.4.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-077}\n\nFigure 6.6: Scan for harmonic extraction and searching for eigenvalue with largest magnitude over the target values. Scan along freq $=0$, some of the other two scans can also be seen. For the meaning of the symbols please refer to the caption of fig. 6.4.\\\\\nby mode in files with time dependent output. For example, the first line in fluxes.dat will contain the fluxes determined for the first found eigenmode, the second line those for the second eigenmode, and so on. Second, there is an output file eigenvalues.dat that contains the growth rate and frequency determined by SLEPC (first column acts as an index). Also you will notice that not a single parallel.dat or restart file is produced, but one for each found eigenmode.\n\nIf some eigenvalues are found, you should check that these belong to a reasonable, physical mode. If the eigenvalues given by the diagnostics (found in time.dat) and the one determined by slepc (found in eigenvalues.dat) differ this is a sign (not a necessary one) that the result is unphysical, but the easiest possibility is to plot the mode eigenfunction. Note also that some of the eigenvalues found could be physical while others are not. Also a warning regarding parallelization: different parallel decompositions might result in different eigenmodes being found, in particular for stable eigenmodes.\n\n\\subsection*{6.2 Technical details}\nThe eigenvalue solver in GKW is mainly a interface for a library that does this job. So far the library SLEPC (which relies on PETSC) is used (and there are currently no plans to add support for/change support to other libraries).\n\nMost parameters of the eiv\\_integration namelist act as wrapper for the corresponding parameter in SLEPC. Via switches the call to the corresponding routine with the wanted argument is done.\n\nNote that no matrix is formed by SLEPC, as the so called matrix-free approach is used. This means instead of a matrix we just define the action of the matrix on a vector via a function, provided to SLEPC. Depending on the settings in the input file, either exp\\_integration (mat\\_vec\\_routine $=1$ ) is used to determine the result of the matrix vector multiplication or just the subroutine calculate\\_rhs (mat\\_vec\\_routine $=2$ ).\n\n\\subsection*{6.2.1 The actual eigenvalue problem}\nIn general an eigenvalue problem is formulated as\n\n\n\\begin{equation*}\nM x=\\lambda x \\tag{6.1}\n\\end{equation*}\n\n\nwhere $A$ is the operator of the problem and $\\lambda$ is the (complex) eigenvalue. The exp\\_integration part, solves\n\n\n\\begin{align*}\n& f_{t+1}=f_{t}+d t A f_{t}+d t B \\phi  \\tag{6.2}\\\\\n& 0=C f_{t}+D \\phi \\tag{6.3}\n\\end{align*}\n\n\nwith the state vector $f$, four matrices $A, B, C$ and $D$ and $\\phi$ represents all the fields that may be present in the simulation. Note that fdisi $=(\\mathrm{f}$, phi). It principle it is possible to solve the last equation for $\\phi$ and insert it into the former to get\n\n\n\\begin{equation*}\nf_{t+1}=f t+d t A f_{t}-d t B D^{-1} C f_{t} \\tag{6.4}\n\\end{equation*}\n\n\nThe disadvantage of this approach would be, that the inversion of the matrix $D$ and the matrix matrix multiplication most probably would destroy the sparsity structure of the complete operator. As is clear, this would make the determination of the eigenvalues much more expensive. For this reason the matrix is not explicitly formed. If the subroutine calculate\\_rhs is used instead, then the $f_{t}$ term vanishes, but otherwise the computation remains unchanged, thus also in this case a shell matrix is used.\n\n\\subsection*{6.2.2 Transformation between eigenvalue and growth rate/frequency}\nThe transformation between the eigenvalue computed by SLEPC and the growth rate and frequency from the code can be derived as follows. Recall again the general form of the eigenvalue problem (6.1), in comparison to this, the eigenvalue problem in GKW is\n\n\n\\begin{equation*}\nl f=(1+d t N)^{n} f \\tag{6.5}\n\\end{equation*}\n\n\nwhere $N$ sums up the parts from A and B and $n$ is naverage. Identifying $M$ and $(1+d t N)^{n}$ results in\n\n\n\\begin{align*}\n& \\lambda=(1+d t N)=l  \\tag{6.6}\\\\\n& \\ln \\lambda=n \\ln l  \\tag{6.7}\\\\\n& \\frac{\\ln \\lambda}{n d t}=\\frac{\\ln l}{n d t} \\tag{6.8}\n\\end{align*}\n\n\nThe right hand side of these equation is the same relation as between the change in the norm and the growth rate in the code. We take this as reason to propose this as general transformation between the eigenvalue determined by slepc and the growth rate/frequency got by gkw (another reason is it works).\n\nThe transformation for the tolerance $a$ is\n\n\n\\begin{align*}\na_{g k w} & =\\sqrt{\\left(\\frac{\\partial \\lambda_{\\text {gkw }}}{\\partial \\lambda_{\\text {slepc }}}\\left|\\lambda_{\\text {slepc }}\\right| a_{\\text {slepc }}\\right)^{2}}  \\tag{6.9}\\\\\n& =\\sqrt{\\left(\\frac{\\partial\\left(\\log \\left(\\lambda_{\\text {slepc }}\\right) /\\left(n_{\\text {average }} \\Delta t\\right)\\right)}{\\partial \\lambda_{\\text {slepc }}}\\left|\\lambda_{\\text {slepc }}\\right| a_{\\text {slepc }}\\right)^{2}}  \\tag{6.10}\\\\\n& =\\sqrt{\\left(\\frac{1}{n_{\\text {average }} \\Delta t} a_{\\text {slepc }}\\right)^{2}}  \\tag{6.11}\\\\\n& =\\frac{a_{\\text {slepc }}}{n_{\\text {average }} \\Delta t} \\tag{6.12}\n\\end{align*}\n\n\n\\subsection*{6.2.3 User defined routines}\nThere are two points at which SLEPC uses subroutines provided by GKW. Number one is - as should be clear - the matrix vector product. As the already existing capabilities of gkw should be used, these first copy the input vector into fdisi, the necessary operations are performed and then the resulting new state is copied to the output vector. \"Necessary operations\" is so far either using explicit\\_integration or calculate\\_rhs, both from the exp\\_integration module.\n\nOrdering the eigenvalues, is the second place where a (slepc-)user defined routine is used. These ordering functions determine which part of the spectrum is wanted. Besides of some predefined orderings, slepc also offers the possibility to let us decide, by telling which of two eigenvalues we like the most.\n\n\\subsection*{6.3 FAQ}\nWhat is a good starting point for the parameters? For the Ritz extraction (here for an electromagnetic case with kinetic electrons), to find the two most unstable modes you could try\n\n\\begin{verbatim}\n&CONTROL\n    fac_dtim_est=0.5, naverage= 1, method= 'EIV', meth= 1,\n    read_file = .true., irun = 2 ! to restart from previous dominant mode\n    ! using gkwnlin -restart_chain\n    /\n&eiv_integration ! using Ritz extraction method, the default\n    max_iterations = 90000 ! avoid looking for stable eigenmodes\n    tolerance=4.0e-4\n    number_eigenvalues=2\n    which_eigenvalues=3 ! LARGEST REAL (most unstable modes)\n    luse_initial_value = .true.\n    /\n&SPCGENERAL\n    finit=\"cosine4\" ! or restart from previous run in parameter scan\n    /\n\\end{verbatim}\n\nIt appears that the timestep cannot go above that required for explicit time integration but that setting a very small timestep makes the convergence take longer. Setting the tolerance too small can also cause convergence to take longer, and can even prevent the correct modes from being found.\n\nFor the harmonic extraction, you can try the following.\n\n\\begin{verbatim}\n&CONTROL\nfac_dtim_est=0.5; naverage= 1, method= 'EIV', meth= 1,\n/\n&eiv_integration\nmax_iterations = 50000\ntolerance = 1.0e-4\ntype_solver = 'krylovschur'\ntype_extraction = 'harmonic'\nnumber_eigenvalues = 2\nnr_column_vec = 20\nmat_vec_routine = 1\ncomparison_routine = 2\nwhich_eigenvalues = 11 ! look for eigenvalues near the target\ngrowthrate = 0.5000\nfreq = 0.0000\nluse_initial_value = .true.\n\\end{verbatim}\n\n\\begin{verbatim}\n/\n&SPCGENERAL\nfinit=\"cosine4\"\n/\n\\end{verbatim}\n\nIf you increase number\\_eigenvalues you may also have to increase nr\\_column\\_vec.\n\nDoes nr\\_column\\_vec = 0 (letting 'PETSC\\_DECIDE') work? From the scan done over the size of the subspace (see fig. 6.3 we would expect, that it should work well for at least number\\_eigenvalues = 1-2, while for bigger values it might be not optimal.\\\\\nExperience shows that even for number\\_eigenvalues = 15 eigenvalues have been found.\n\n\\section*{Chapter 7}\n\\section*{The non-spectral and global version of the code}\n\\section*{This chapter discusses the non-spectral and global version of the code. (Work in progress)}\nNon-spectral here refers to the treatment of the radial direction through the use of finite difference methods, and is switched on through the switch\\\\\nspectral\\_radius = .false.\\\\\nin the control namelist. The non-spectral representation can be used both in the local limit (which we will refer to as flux-tube) as well as in the global case. Global is used as synonym for profile effects, i.e. allowing plasma and geometry parameters to be a function of the radius. A global run is selected by setting\\\\\nflux\\_tube = .false.\\\\\nin the control namelist. Naturally, global simulations can only be preformed with a non-spectral representation. Global simulations can still be $\\delta f$ simulations, i.e. the perturbed distribution function can be assumed small compared to the background. In this case energy is not conserved since the parallel velocity nonlinearity is neglected. Energy conserving simulations will be referred to as full-f simulations below, and can be run setting\\\\\nlpar\\_vel\\_nl = .true.\\\\\nin the control namelist.\\\\\nTwo points should be noted: First, although you can run with the parallel velocity nonlinearity in a flux-tube run, there is no point since the expansion around a local flux surface means that energy cannot be conserved (It can easily be shown that the integrated kinetic energy in the perturbed distribution is always zero in the local limit, while the integrated energy in the field must be postive. The two can then not balance each other). Therefore, global full-f, global $\\delta f$, and local $\\delta f$ make sense, but local full-f does not, unless one wants to study some distinct property of the velocity nonlinearity. Second, care must also be taken using global $\\delta f$. The turbulence will lead to a rapid profile evolution that is represented by the perturbed distribution. The condition $\\delta f=\\mathcal{O}\\left[\\rho_{*} F_{M}\\right]$ is then easily violated. One way to keep $\\delta f$ small is through the Krook operator (see the section below), which damps the perturbed distribution on a specified timescale and acts through this damping as a source / sink of energy. But even with the use of the Krook operator the ordering is not necessarily satisfied.\n\n\\subsection*{7.1 Basic equation}\nWarning: not all is correct in this section\n\nThe equations in GKW are related to, but do not directly follow from a Lagrangian description. Further approximations to the Lagrange equations of motion are made in order to obtain a system that is easier to solve numerically. The approximations all involve neglecting higher order $\\rho_{*}$ terms, and since the Lagrangian from which the equations are derived itself is accurate up to terms linear in $\\rho_{*}$ the neglection of higher order terms is consistent with accuracy of the Lagrange description. Care has to be taken not to lose the properties that come with the Lagrange description, like conservation of energy and momentum. Below it will be shown that these properties still hold for the model equations used by GKW.\n\nStarting point of the derivation is the Lagrangian\n\n\n\\begin{equation*}\nL=\\sum_{s p} \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v} f L_{p}+\\sum_{s p} \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v} \\frac{Z_{s p}^{2} e^{2}}{2 T_{s p}}\\left[\\phi^{2}-\\langle\\phi\\rangle^{2}\\right] F_{M}+\\sigma_{a} \\int \\mathrm{~d}^{3} \\mathbf{X} L_{\\text {adiabatic }}+\\int \\mathrm{d}^{3} \\mathbf{X} \\frac{1}{2 \\mu_{0}}\\left|\\nabla A_{\\|}\\right|^{2} \\tag{7.1}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{equation*}\nL_{p}=\\gamma_{a} \\dot{z}^{a}-H=\\left(Z e \\mathbf{A}+m \\mathbf{u}_{0}+m v_{\\|} \\mathbf{b}+Z e\\left\\langle A_{\\|}\\right\\rangle \\mathbf{b}\\right) \\cdot \\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}-\\left(\\frac{1}{2} m v_{\\|}^{2}+\\mu B+Z e\\langle\\phi\\rangle+\\frac{1}{2} m u_{0}^{2}\\right) \\tag{7.2}\n\\end{equation*}\n\n\nwhere in the latter equation the species index is supressed. In the equations above the rapid gyro-motion has been removed from the Lagrangian and the indices in the Einstein summation convention are $a=1,2,3,4$ with $a=4$ refering to the parallel velocity (Note that $\\gamma_{4}$ is zero though). The brackets $\\rangle$ correspond to the gyro-average operator, and the sum with index sp is over all kinetic species. The vector potential $\\mathbf{A}$ describes the (constant) background magnetic field, while the perturbed magnetic field is described by $\\left\\langle A_{\\|}\\right\\rangle$.\\\\\nIn the case of adiabatic electrons, $\\sigma_{a}=1$ and the electron contribution is not included in the sum over sp (for kinetic electrons $\\sigma_{a}=0$. The Lagragian density associated with adiabatic electrons is\n\n", "\n\\begin{equation*}\nL_{\\text {adiabatic }}=-\\frac{e^{2} n_{e}}{2 T_{e}}[\\phi-\\{\\phi\\}]^{2}, \\tag{7.3}\n\\end{equation*}\n\n\nwhere $\\}$ indicate the flux surface average.\\\\\nVariation towards $\\phi$ yields the Poisson equation\n\n\n\\begin{equation*}\n\\sum_{s p} Z_{s p} e \\int \\mathrm{~d}^{3} \\mathbf{v}\\langle f\\rangle^{\\dagger}-\\sigma_{a} \\frac{n_{e} e^{2}}{T_{e}}(\\phi-\\{\\phi\\})=\\sum_{s p} \\frac{Z_{s p}^{2} e^{2}}{T_{s p}} \\int \\mathrm{~d}^{3} \\mathbf{v}\\left[\\phi-\\langle\\langle\\phi\\rangle\\rangle^{\\dagger}\\right] F_{M s p} \\tag{7.4}\n\\end{equation*}\n\n\nand variation towards $A_{\\|}$yields Ampere's law\n\n\n\\begin{equation*}\n-\\nabla^{2} A_{\\|}=\\sum_{s p} Z_{s p} \\mu_{0} e \\int \\mathrm{~d}^{3} \\mathbf{v} \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\mathbf{b}\\langle f\\rangle^{\\dagger} \\tag{7.5}\n\\end{equation*}\n\n\nGKW uses the Poisson equation and Ampere's law above, i.e. they follow directly from the Lagrange description. Approximations, however, are made in the equations of motion of the particles. The Lagrange description yields the equations of motion through the variation of the action\n\n\n\\begin{equation*}\n\\delta S=\\delta \\int_{t_{0}}^{t_{1}} L_{p} \\mathrm{~d} t=\\int_{t_{0}}^{t_{1}} \\frac{\\partial \\gamma_{a}}{\\partial z^{b}} \\delta z_{b} \\dot{z}^{a}+\\gamma_{a} \\delta \\dot{z}^{a}-\\frac{\\partial H}{\\partial z^{b}} \\delta z^{b} \\mathrm{~d} t \\tag{7.6}\n\\end{equation*}\n\n\nIntegrating the term with $\\delta \\dot{z}^{a}$ once partial towards the time yields the equations of motion in the form\n\n\n\\begin{equation*}\n\\left[\\gamma_{b, a}-\\gamma_{a, b}\\right] \\frac{\\mathrm{d} z^{b}}{\\mathrm{~d} t}=\\frac{\\partial H}{\\partial z^{a}}+\\frac{\\partial \\gamma_{a}}{\\partial t} \\tag{7.7}\n\\end{equation*}\n\n\nThe equation above can be spit in the components $(1,2,3)$ and the fourth component as follows\n\n\n\\begin{equation*}\n\\left(\\nabla \\times \\mathbf{A}^{*}\\right) \\times \\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}+\\frac{\\partial \\mathbf{A}^{*}}{\\partial v_{\\|}} \\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t}=-\\nabla H-\\frac{\\partial \\mathbf{A}^{*}}{\\partial t} \\tag{7.8}\n\\end{equation*}\n\n\n\n\\begin{equation*}\n\\frac{\\partial \\mathbf{A}^{*}}{\\partial v_{\\|}} \\cdot \\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}=\\frac{\\partial H}{\\partial v_{\\|}} \\tag{7.9}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{equation*}\nZ e \\mathbf{A}^{*}=Z e \\mathbf{A}+\\mathbf{u}_{0}+m v_{\\|} \\mathbf{b}+A_{\\|} \\mathbf{b} \\quad \\mathbf{B}^{*}=\\nabla \\times \\mathbf{A}^{*} \\tag{7.10}\n\\end{equation*}\n\n\nThe equation above determine both the evolution of the gyro-centre position as well as the parallel velocity. A set of reduced equations can be derived by taking the inner product of the first equation with $\\mathrm{d} \\mathbf{X} / \\mathrm{d} t$ to obtain\n\n\n\\begin{align*}\n& \\left(\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot Z e \\frac{\\partial \\mathbf{A}^{*}}{\\partial v_{\\|}}\\right) \\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t}=-\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\nabla H-Z e \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\frac{\\partial \\mathbf{A}^{*}}{\\partial t}  \\tag{7.11}\\\\\n& Z e \\frac{\\partial \\mathbf{A}^{*}}{\\partial v_{\\|}} \\cdot \\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}=\\frac{\\partial H}{\\partial v_{\\|}} \\tag{7.12}\n\\end{align*}\n\n\nThe essential observation here is that these equations will garantee energy conservation independent of the choice of $\\mathrm{d} \\mathbf{X} / \\mathrm{d} t$. We will use in the proof below that\n\n\n\\begin{equation*}\n\\frac{1}{J_{v}} \\frac{\\partial J_{v}}{\\partial t}+\\frac{1}{J_{v}} \\nabla \\cdot\\left[J_{v} \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t}\\right]+\\frac{1}{J_{v}} \\frac{\\partial}{\\partial v_{\\|}}\\left[J_{v} \\frac{\\mathrm{~d} v_{\\|}}{\\mathrm{d} t}\\right]=0 \\tag{7.13}\n\\end{equation*}\n\n\nwhere $J_{v}$ is the Jacobian of the velocity space integration. While this condition is perhaps not under all circumstances necessary to obtain exact energy conservation, it is in our derivation an additional constraint that must be satisfied for the gyrocentre velocity. This observation allows one to make approximations to $\\mathrm{d} \\mathbf{X} / \\mathrm{d} t$, removing higher order $\\rho_{*}$ corrections, without breaking energy conservation.\\\\\nCombining the equations above we have\n\n\n\\begin{equation*}\n\\frac{1}{J_{v}} \\frac{\\partial}{\\partial v_{\\|}}\\left[J_{v} H \\frac{\\mathrm{~d} v_{\\|}}{\\mathrm{d} t}\\right]+\\frac{1}{J_{v}} \\nabla \\cdot\\left[J_{v} H \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t}\\right]=-Z e \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\frac{\\partial \\mathbf{A}^{*}}{\\partial t} \\tag{7.14}\n\\end{equation*}\n\n\nThen we split the Hamilton in a field part $\\left(H_{1}=Z e\\langle\\phi\\rangle\\right)$ and the rest $H_{0}$ (which is time independent). To obtain\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} H_{0}}{\\mathrm{~d} t}=\\frac{1}{J_{v}} \\frac{\\partial}{\\partial v_{\\|}}\\left[J_{v} H_{0} \\frac{\\mathrm{~d} v_{\\|}}{\\mathrm{d} t}\\right]+\\frac{1}{J_{v}} \\nabla \\cdot\\left[J_{v} H_{0} \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t}\\right]=-\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot\\left[\\nabla H_{1}+Z e \\frac{\\partial \\mathbf{A}^{*}}{\\partial t}\\right] \\tag{7.15}\n\\end{equation*}\n\n\nUsing furthermore that $\\mathrm{d} f / \\mathrm{d} t=0$ we have\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d}}{\\mathrm{~d} t}\\left[H_{0} f\\right]=-\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot\\left[\\nabla H_{1}+Z e \\frac{\\partial \\mathbf{A}^{*}}{\\partial t}\\right] f \\tag{7.16}\n\\end{equation*}\n\n\nThe right hand side of this equation represents the inner product of current and electric field. It is the transfer term between kinetic and field energy.\n\nMultiplying the time derivative of the Poisson equation with $\\phi$ we obtain\n\n\n\\begin{equation*}\n\\int \\mathrm{d}^{3} \\mathbf{X} \\int \\mathrm{~d}^{3} \\mathbf{v} H_{1} \\frac{\\partial f}{\\partial t}=\\int \\mathrm{d}^{3} \\mathbf{X} \\phi \\frac{\\partial}{\\partial t}\\left[\\frac{\\delta H_{2 E}}{\\delta \\phi}\\right] \\tag{7.17}\n\\end{equation*}\n\n\nWhere\n\n\n\\begin{equation*}\nH_{2 E}=\\int \\mathrm{d}^{3} \\mathbf{v} \\frac{Z_{s p}^{2} e^{2}}{2 T_{s p}}\\left[\\phi^{2}-\\langle\\phi\\rangle^{2}\\right] F_{M}+\\sigma_{a} L_{\\text {adiabatic }} \\tag{7.18}\n\\end{equation*}\n\n\nAnd using $\\mathrm{d} f / \\mathrm{d} t=0$ the first term in the equation can be rewritten in the form\n\n\n\\begin{equation*}\n-\\int \\mathrm{d}^{3} \\mathbf{X} \\int \\mathrm{~d}^{3} \\mathbf{v} \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\nabla H_{1} f=\\int \\mathrm{d}^{3} \\mathbf{X} \\phi \\frac{\\partial}{\\partial t}\\left[\\frac{\\delta H_{2 E}}{\\delta \\phi}\\right] \\tag{7.19}\n\\end{equation*}\n\n\nThe right hand side can be rewritten as\n\n\n\\begin{equation*}\n\\int \\mathrm{d}^{3} \\mathbf{X} \\phi \\frac{\\partial}{\\partial t}\\left[\\frac{\\delta H_{2 E}}{\\delta \\phi}\\right]=\\sum_{s p} \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v} \\frac{Z_{s p}^{2} e^{2}}{2 T_{s p}}\\left[\\phi^{2}-\\langle\\phi\\rangle^{2}\\right] F_{M s p}+\\sigma_{a} \\int \\mathrm{~d}^{3} \\mathbf{X} \\frac{n_{e} e^{2}}{2 T_{e}}(\\phi-\\{\\phi\\})^{2} \\tag{7.20}\n\\end{equation*}\n\n\nFinally multiplying Ampere's law with $\\partial A_{\\|} / \\partial t$ and integrating over the whole of space we obtain\n\n\n\\begin{equation*}\n\\sum_{s p} Z_{s p} e \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v} \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot \\frac{\\partial \\mathbf{A}^{*}}{\\partial t} f=\\frac{1}{2 \\mu_{0}} \\int \\mathrm{~d}^{3} \\mathbf{X}\\left|A_{\\|}\\right|^{2} \\tag{7.21}\n\\end{equation*}\n\n\nConsequently the energy conservation theorem is\n\n\n\\begin{equation*}\nE=\\sum_{s p} \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v}\\left(\\frac{1}{2} m v_{\\|}^{2}+\\mu B+\\frac{1}{2} m u_{0}^{2}\\right) f+\\sum_{s p} \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v} \\frac{Z_{s p}^{2} e^{2}}{2 T_{s p}}\\left[\\phi^{2}-\\langle\\phi\\rangle^{2}\\right] F_{M s p}+\\sigma_{a} \\int \\mathrm{~d}^{3} \\mathbf{X} \\frac{n_{e} e^{2}}{2 T_{e}}(\\phi-\\{\\phi\\})^{2}+\\frac{1}{2 \\mu_{0}} \\tag{7.22}\n\\end{equation*}\n\n\nwhere the first part is the kinetic energy while the second part is the field energy. The Noehter theorem on the original Maxwellian gives exactly the same energy theorem. Note too that no assumption has been made on the form of $\\mathrm{d} \\mathbf{X} / \\mathrm{d} t$ other than that the equations and ?? must be satisfied.\n\nTaking the cross product of Eq. (7.8) with the unit vector along the magnetic field (b) one obtains the velocity of the gyro-centre\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}=\\frac{\\mathbf{B}^{*}}{B_{\\| *}} v_{\\|}+\\frac{\\mathbf{b}}{B_{\\|}^{\\prime \\prime}} \\times \\nabla H \\tag{7.23}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{equation*}\nB_{\\|}^{*}=\\mathbf{b} \\cdot \\mathbf{B}^{*}=\\mathbf{b} \\cdot \\nabla \\times \\mathbf{A}^{*} \\tag{7.24}\n\\end{equation*}\n\n\nand $J_{v}=B_{\\|}^{*}$. When used in this form $B_{\\|}^{*}$ is a function of the field $\\left\\langle A_{\\|}\\right\\rangle$, and therefore of time. Since $\\mathrm{d} \\mathbf{X} / \\mathrm{d} t$ depends nonlinearly on $B_{\\|}^{*}$ this complicates the numerical solution. At each time point the gyrocentre velocity would have to be constructed explicitly and the various terms in the equation can not be precalculated and stored in matrix format.\n\nThe approximation made in GKW is the approximation of $B_{\\|}^{*}$ by $B$. Working out $\\mathbf{B}^{*}$ we then obtain\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t}=v_{\\|} \\mathbf{b}+\\frac{m v_{\\|}^{2}}{Z e B} \\nabla \\times \\mathbf{b}+\\frac{m v_{\\|}}{Z e B} \\boldsymbol{\\Omega}+\\frac{1}{B} \\nabla \\times\\left[v_{\\|}\\left\\langle A_{\\|}\\right\\rangle \\mathbf{b}\\right]+\\frac{1}{B} \\mathbf{b} \\times \\nabla H \\tag{7.25}\n\\end{equation*}\n\n\nwith $J_{v}=B$ it can be shown that Eq. (7.13) is satisfied.\\\\\nA few remarks should be made here. First, the approximation\n\n\n\\begin{equation*}\n\\nabla \\times\\left\\langle A_{\\|}\\right\\rangle \\mathbf{b} \\approx-\\mathbf{b} \\times \\nabla\\left\\langle A_{\\|}\\right\\rangle \\tag{7.26}\n\\end{equation*}\n\n\nis problematic for exact energy conservation since in this case Eq. (7.13) is not satisfied.\n\n\\subsection*{7.1.1 Local limit}\nA brief look ahead for the local limit approximation may be in order. The local limit corresponds to a further approximation also in the gyro-centre velocity and must be separately discussed. Essentially, in the local limit all quantities are a function of the parallel coordinate $(s)$ only. The gyro-centre velocity does not depend on the coordinates perpendicular to the field and, therefore the divergence of this velocity is different from the expression derived above. If one assumes that the drift velocity $\\left(\\mathbf{v}_{D}\\right)$ and ExB velocity $\\left(\\mathbf{v}_{E}\\right)$ do not have a component in the direction of $\\nabla s$, (i.e. $\\mathbf{v}_{D} \\cdot \\nabla s=\\mathbf{v}_{\\mathbf{E}} \\cdot \\nabla s=0$, which is satisfied to lowest order in $\\rho_{*}$ and is strictly imposed in the code when the finite $\\rho_{*}$ parallel derivatives are turned of) then\n\n\n\\begin{equation*}\nB\\left(v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}+\\mathbf{v}_{E}\\right) \\cdot \\nabla f=\\nabla \\cdot\\left[B\\left(v_{\\|} \\mathbf{b}+\\mathbf{v}_{D}+\\mathbf{v}_{E}\\right) f\\right] \\tag{7.27}\n\\end{equation*}\n\n\ni.e. the gyro-centre velocity satisfies\n\n\n\\begin{equation*}\n\\frac{1}{B} \\nabla \\cdot\\left[B \\frac{\\mathrm{~d} \\mathbf{X}}{\\mathrm{~d} t}\\right]=0 \\tag{7.28}\n\\end{equation*}\n\n\nThen\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial v_{\\|}}\\left[\\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t}\\right] \\quad \\rightarrow \\quad \\frac{\\partial}{\\partial v_{\\|}}\\left[-\\frac{1}{m} \\mathbf{b} \\cdot \\mu \\nabla B\\right]=0 \\tag{7.29}\n\\end{equation*}\n\n\nmust be zero in order for phase space conservation to apply. The terms on the right (the trapping term) represent the only term of $\\mathrm{d} v_{\\|} / \\mathrm{d} t$ that is kept for the perturbed distribution $f$. Indeed for this term the parallel velocity derivative is zero and, consequently the phase space volume is conserved in the evolution of $f$.\n\nThe local limit is obtained through an expansion in $\\rho_{*}$, and the velocity nonlinearity is then neglected. This neglection means that energy is not strictly conserved. In fact, in the local limit with periodic boundary conditions energy conservation is problematic since the total field energy is always positive, whereas the total kinetic energy\n\n\n\\begin{equation*}\n\\int \\mathrm{d}^{3} \\mathbf{X} \\int \\mathrm{~d}^{3} \\mathbf{v}\\left[\\frac{1}{2} m v_{\\|}^{2}+\\mu B\\right] f \\tag{7.30}\n\\end{equation*}\n\n\nintegrates to zero for all Fourier modes except the mode that has a zero wave vector in both perpendicular directions (below this mode is refered to as 0,0 mode). The latter Fourier mode is usually not kept in the evolution equation, and it is then not possible to conserve the energy since the positive field energy can not be balanced with a negative total kinetic energy.\n\nEnergy conservation however can be obtained if the 0,0 mode is kept in the evolution equations, provided the velocity nonlinearity is implemented as\n\n\n\\begin{equation*}\n\\frac{\\partial f}{\\partial t} \\stackrel{ \\pm}{=}-\\frac{\\partial}{\\partial v_{\\|}}\\left[\\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t} f\\right] \\tag{7.31}\n\\end{equation*}\n\n\nThis form ensures phase space conservation in the local limit where the divergence of the gyro-centre velocity is zero. In the equation above the change in the parallel velocity is considered only through the electromagnetic field. It can easily be shown that when integrated over the whole computational domain the term only contributes to the 0,0 mode. The 0,0 mode has no spatial derivatives perpendicular to the field, and except through the velocity nonlinearity it does not couple to any other mode. The 0,0 mode therefore only acts as a reservoir for the kinetic energy essuring that the balance equation for the energy holds.\n\n\\subsection*{7.1.2 Toroidal momentum conservation}\nThe equations of motion (Eq. (7.7) can be written in the form\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\gamma_{a}}{\\mathrm{~d} t}=-\\frac{\\partial H}{\\partial z^{a}}-\\gamma_{b, a} \\frac{\\mathrm{~d} z^{b}}{\\mathrm{~d} t} \\tag{7.32}\n\\end{equation*}\n\n\nIn the case of a symmetry in coordinate $z^{a}$ we have\n\n\n\\begin{equation*}\n\\frac{\\partial H}{\\partial z^{a}}=0 \\quad \\gamma_{b, a}=0 \\tag{7.33}\n\\end{equation*}\n\n\nand therefore\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\gamma_{a}}{\\mathrm{~d} t}=0 \\tag{7.34}\n\\end{equation*}\n\n\nThis represents a conservation equation. The case of interest here is the toroidal symmetry of the tokamak, and the consequent conservation of toroidal angular momentum. The equations here are slightly different\\\\\nsince both $\\langle\\phi\\rangle$ and $\\left\\langle A_{\\|}\\right\\rangle$are a function of the toroidal angle. Choosing the toroidal angle $\\varphi$ as coordinate one obtains\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\gamma_{\\varphi}}{\\mathrm{d} t}=-\\frac{\\partial H_{1}}{\\partial \\varphi}-Z e \\frac{\\partial\\left\\langle A_{\\|}\\right\\rangle}{\\partial \\varphi} v_{\\|} \\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\tag{7.35}\n\\end{equation*}\n\n\nMultiplying this equation with $f$ and integrating over the whole phase space (using $\\mathrm{d} f / \\mathrm{d} t=0$ we obtain\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial t} \\int \\mathrm{~d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v} \\gamma_{\\varphi} f=-\\int \\mathrm{d}^{3} \\mathbf{X} \\mathrm{~d}^{3} \\mathbf{v}\\left[\\frac{\\partial H_{1}}{\\partial \\varphi}+Z e \\frac{\\partial\\left\\langle A_{\\|}\\right\\rangle}{\\partial \\varphi} v_{\\|}\\right] f \\tag{7.36}\n\\end{equation*}\n\n\nThe right hand side of this equation can be shown to vanish\n\n\\subsection*{7.2 Normalization}\nIn the local version of GKW the velocity coordinates are normalized to the thermal velocity of the considered species. This has the advantage that the Maxwell can be represented with the same accuracy for each of the species even if the temperatures of the species are very different. When the temperature is a function of the radial coordinate, however, the thermal velocity is no longer a constant. Using the local thermal velocity for normalization would have the advantage that the Maxwell is represented with the same relative resolution at each radial point, but would make the normalization constant a function of radius, and would lead to cross terms in all radial derivatives. A choice has therefore been made to use a fixed temperature, often the temperature at one particular radial location, for the normalization. This has the advantage that it does not change the structure of the equations, but also has disadvantages. In the global case the grid must be, both set up such that it is big enough to represent the maximum temperature ( $T_{\\max }$ ) in the domain, as well as have sufficient resolution to resolve the distribution function of the smallest temprature ( $T_{\\min }$ ). Because the velocity scales as the square root of the temperature this increases the computational cost by a factor $T_{\\text {max }} / T_{\\text {min }}$ over a local simulation.\n\nIn the text below all normalized quantities have an index $N$. A symbol like $T_{G}$ therefore has a physical unit. Naturally, the code uses only normalized quantities, and physical units can only be obtained through the reference quatities\n\n$$\nT_{\\mathrm{ref}}, \\quad n_{\\mathrm{ref}}, \\quad m_{\\mathrm{ref}}, \\quad R_{\\mathrm{ref}}, \\quad B_{\\mathrm{ref}}\n$$\n\nthe reference temperature, density, mass, major radius and magnetic field. These quantities are never explicitly specified. The numerical solution is valid for any choice of these quantities. Note though that the collision frequency leads to an additional constraint between the quantities mentioned above.\n\nThe temperature used for the normalization of the velocity coordinates is $T_{G}$. $T_{G}$ is not a function of the radius but, unlike $T_{\\text {ref }}$, is different for each species. The thermal velocity used for normalization then is\n\n$$\nw=\\sqrt{\\frac{2 T_{G}}{m}}\n$$\n\nWhere $m$ is the particle mass. Using this normalization the velocity space coordinates are\n\n$$\nv_{\\|}=w v_{\\| N} \\quad \\mu=\\frac{w^{2}}{B_{\\mathrm{ref}}} \\mu_{N}\n$$\n\n(Note that $\\mu$ in the code is defined without the mass). Besides the temperature a similar normalization is used for the density. Each of the species is normalized to the 'grid' density $n_{G}$, with\n\n$$\nn_{G N}=n_{G} / n_{\\mathrm{ref}} \\quad n_{N}=n / n_{\\mathrm{ref}}\n$$\n\nThe distribution functions are normalized as follows\n\n$$\nf=\\rho_{*} \\frac{n_{G}}{w^{3}} f_{N} \\quad F_{M}=\\frac{n_{G}}{w^{3}} F_{M N}\n$$\n\nTemperatures and masses are normalized with $T_{\\text {ref }}$ and $m_{\\text {ref }}$\n\n$$\nT_{N}=T / T_{\\mathrm{ref}} \\quad T_{G N}=T_{G} / T_{\\mathrm{ref}} \\quad m_{N}=m / m_{\\mathrm{ref}}\n$$\n\nand since $T_{\\text {ref }}$ and $m_{\\text {ref }}$ define the reference thermal velocity\n\n$$\nT_{\\mathrm{ref}}=\\frac{1}{2} m_{\\mathrm{ref}} v_{t h r e f}^{2}\n$$\n\nwe have\n\n$$\nw_{N}=\\frac{w}{v_{\\text {thref }}}=\\sqrt{\\frac{T_{G N}}{m_{N}}}\n$$\n\nNote that only the velocity space coordinates are normalized with $w$. Species independent quantities, like time, rotation velocity and normalized Larmor radius are normalized using $v_{\\text {thref }}$\n\n$$\n\\begin{aligned}\n& t=\\frac{R_{\\mathrm{reff}}}{v_{\\text {thref }}} t_{N} \\quad \\Omega=v_{\\text {thref }} \\Omega_{N} / R_{\\mathrm{reff}} \\\\\n& \\rho_{\\mathrm{ref}}=\\frac{m_{\\mathrm{ref}} v_{\\text {thref }}}{e B_{\\mathrm{ref}}} \\quad \\rho_{*}=\\rho_{\\mathrm{ref}} / R_{\\text {ref }}\n\\end{aligned}\n$$\n\nThe fields are also normalized with $T_{\\text {ref }}$\n\n$$\n\\phi=\\rho_{*} \\frac{T_{\\mathrm{ref}}}{e} \\phi_{N} \\quad A_{\\|}=B_{\\mathrm{ref}} R_{\\mathrm{ref}} \\rho_{*}^{2} A_{\\| N}\n$$\n\nFinally\n\n$$\n\\begin{aligned}\nR=R_{\\mathrm{ref}} R_{N}, & B=B_{\\mathrm{ref}} B_{N}, \\quad m=m_{\\mathrm{reff}} m_{N}, \\quad \\Phi=\\frac{T_{\\mathrm{ref}}}{e} \\Phi_{N} \\\\\n\\chi=\\frac{T_{\\mathrm{ref}}}{e} \\rho_{*} \\chi_{N}, & \\mathcal{E}_{\\Omega}=\\mathcal{E}_{\\Omega N} T_{G}\n\\end{aligned}\n$$\n\nWith this normalization the Maxwell can be written as\n\n$$\nF_{M N}=\\frac{n_{N} / n_{G N}}{\\pi^{3 / 2}\\left(T_{N} / T_{G N}\\right)^{3 / 2}} \\exp \\left[-\\frac{\\left(v_{\\| N}-\\sqrt{m_{N} / T_{G N}} R_{N} B_{t N} \\omega_{\\phi N} / B_{N}\\right)^{2}+2 \\mu_{N} B_{N}+\\mathcal{E}_{\\Omega N}}{T_{N} / T_{G N}}\\right]\n$$\n\nIn the above equation, only $n_{N}, T_{N}, R_{N}$ and $B_{N}$ are functions of radius. It is to be noted that the 'old' flux-tube normalization is included in the above normalization if one sets $T_{G}=T$. This choice is made by the code when choosing flux\\_tube $=$. true.. Furthermore, it should be noted that the frame rotation $(\\Omega)$ is not a function of the radius. This is more than just a choice. If the frame rotation is a function of the radius, two stationary points in the co-moving frame could shear apart in the laboratory frame. In short, the metric tensor would be a function of time, which is highly undesirable. The co-moving frame description of the rotation is, therefore, useful for the flux tube case, but less so for the global case. The use of $\\Omega$ in the global case is allowed, but the implementation is not entirely consistent (the $\\mathcal{E}_{\\Omega}$ quantity, for instance, is not a function of the radius). The user is therefore strongly discouraged from using the plasma rotation $\\Omega$ in the global case. Momentum fluxes due to the $u^{\\prime}$ however can be calculated. In the future a rotation profile will be implemented through a shift of the perturbed distribution, rather than a coordinate transformation.\n\nWith the new normalization the equations of motion are (below all quantities are normalized, i.e. $w$ in these equations refers to $w_{N}$, etc.)\n\n\n\\begin{equation*}\n\\frac{\\partial g}{\\partial t}=\\mathrm{I}+\\mathrm{II}+\\mathrm{III}+\\mathrm{IV}+\\mathrm{V}+\\mathrm{VI}+\\mathrm{VII}+\\mathrm{VIII} \\tag{7.37}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{align*}\n& \\mathrm{I} \\quad=\\quad-v_{\\|} \\mathbf{b} \\cdot \\nabla f \\rightarrow-w v_{\\|} \\mathcal{F} \\frac{\\partial f}{\\partial s},  \\tag{7.38}\\\\\n& \\mathrm{II} \\quad=\\quad-\\mathbf{v}_{D} \\cdot \\nabla f \\rightarrow \\\\\n& -\\frac{\\rho_{*}}{Z}\\left[T_{G} E_{D} \\mathcal{D}^{\\alpha}+T_{G} v_{\\|}^{2} \\beta^{\\prime} \\mathcal{E}^{\\psi \\alpha}+2 m w v_{\\|} \\Omega \\mathcal{H}^{\\alpha}+m \\Omega^{2} I^{\\alpha}+Z \\mathcal{E}^{\\beta \\alpha} \\frac{\\partial \\Phi}{\\partial x_{\\beta}}\\right] \\frac{\\partial f}{\\partial x_{\\alpha}}  \\tag{7.39}\\\\\n& \\text { III }=-\\mathbf{v}_{\\chi} \\cdot \\nabla g \\rightharpoonup-\\rho_{*}^{2} \\frac{\\partial \\chi}{\\partial x_{\\beta}} \\mathcal{E}^{\\beta \\alpha} \\frac{\\partial g}{\\partial x_{\\alpha}}  \\tag{7.40}\\\\\n& \\mathrm{IV}=\\quad+\\frac{\\mathbf{b}}{m} \\cdot\\left(\\mu \\nabla B+\\nabla \\mathcal{E}_{\\Omega}\\right) \\frac{\\partial f}{\\partial v_{\\|}} \\rightarrow w\\left(\\mu B \\mathcal{G}+\\frac{T}{2 T_{G}} \\mathcal{F} \\frac{\\partial \\mathcal{E}_{\\Omega}}{\\partial s}\\right) \\frac{\\partial f}{\\partial v_{\\|}},  \\tag{7.41}\\\\\n& \\mathrm{V} \\quad=\\quad-\\mathbf{v}_{\\chi} \\cdot \\nabla F_{M} \\rightarrow \\rho_{*} \\frac{\\partial \\chi}{\\partial x_{\\alpha}} \\mathcal{E}^{\\alpha \\psi}\\left[\\frac{1}{L_{n}}+E_{T} \\frac{1}{L_{T}}+\\left(\\frac{2 m w v_{\\|}}{T} \\frac{R B_{t}}{B}+\\frac{2 m \\Omega}{T} \\mathcal{J}\\right) u^{\\prime}+\\frac{m \\Omega^{2}}{T} \\mathcal{L}\\right] F_{\\Lambda}(7.42) \\\\\n& \\mathrm{VI} \\quad=\\quad-\\mathbf{v}_{D} \\cdot \\nabla F_{M} \\rightarrow \\frac{1}{Z}\\left[T_{G} E_{D} \\mathcal{D}^{\\psi}+2 m w v_{\\|} \\Omega \\mathcal{H}^{\\psi}+m \\Omega^{2} I^{\\psi}+Z \\mathcal{E}^{s \\psi} \\frac{\\partial \\Phi}{\\partial s}\\right]  \\tag{7.43}\\\\\n& \\times\\left[\\frac{1}{L_{n}}+E_{T} \\frac{1}{L_{T}}+\\left(\\frac{2 m w v_{\\|}}{T} \\frac{R B_{t}}{B}+\\frac{2 m \\Omega}{T} \\mathcal{J}\\right) u^{\\prime}+\\frac{m \\Omega^{2}}{T} \\mathcal{L}\\right] F_{M},  \\tag{7.44}\\\\\n& \\mathrm{VII} \\quad=\\quad-\\frac{Z e}{T} v_{\\|} \\mathbf{b} \\cdot \\nabla\\langle\\phi\\rangle F_{M} \\rightarrow-\\frac{Z}{T} w v_{\\|} \\mathcal{F} \\frac{\\partial\\langle\\phi\\rangle}{\\partial s} F_{M},  \\tag{7.45}\\\\\n& \\mathrm{VIII}=-\\frac{Z e}{T} \\mathbf{v}_{D} \\cdot \\nabla\\langle\\phi\\rangle F_{M} \\rightarrow \\\\\n& -\\frac{\\rho_{*}}{T}\\left[T_{G} E_{D} \\mathcal{D}^{\\alpha}+T_{G} \\beta^{\\prime} v_{\\|}^{2} \\mathcal{E}^{\\psi \\alpha}+2 m w v_{\\|} \\Omega \\mathcal{H}^{\\alpha}+m \\Omega^{2} \\mathcal{I}^{\\alpha}+Z \\mathcal{E}^{\\beta \\alpha} \\frac{\\partial \\Phi}{\\partial x_{\\beta}}\\right] \\frac{\\partial\\langle\\phi\\rangle}{\\partial x_{\\alpha}} F_{M} \\tag{7.46}\n\\end{align*}\n\n\nwhere\n\n\n\\begin{equation*}\n\\chi=\\langle\\phi\\rangle-2 w v_{\\|}\\left\\langle A_{\\|}\\right\\rangle \\tag{7.47}\n\\end{equation*}\n\n\nand\n\n\n\\begin{align*}\n& g=f+\\frac{2 Z}{T} w v_{\\|}\\left\\langle A_{\\|}\\right\\rangle F_{M},  \\tag{7.48}\\\\\n& E_{D}=v_{\\|}^{2}+\\mu B, \\quad E_{T}=\\frac{T}{T_{G}}\\left[v_{\\|}^{2}+2 \\mu B+\\mathcal{E}_{\\Omega}\\right]-\\frac{3}{2} .  \\tag{7.49}\\\\\n& \\frac{1}{L_{N}} \\equiv-\\frac{1}{n} \\frac{\\partial n}{\\partial \\psi} \\quad \\frac{1}{L_{T}} \\equiv-\\frac{1}{T} \\frac{\\partial T}{\\partial \\psi} \\quad u^{\\prime} \\equiv-\\frac{\\partial \\omega_{\\phi}}{\\partial \\psi} \\tag{7.50}\n\\end{align*}\n\n\nThe equations above apply to each of the species individually.\\\\\nIn the equations the spatial derivatives of the perturbed distribution function appear, and the Einstein summation convention has been used. For all directions that are represented by the spectral representation we have\n\n\n\\begin{equation*}\n\\rho_{*} \\frac{\\partial \\hat{f}}{\\partial x_{\\alpha}} \\rightarrow \\mathrm{i} k_{\\alpha} \\hat{f} \\tag{7.51}\n\\end{equation*}\n\n\nThe sum over $\\alpha$ also includes $\\alpha=s$. These terms are, however, $\\rho_{*}$ smaller than the derivatives perpendicular to the magnetic field and are usually neglected. They have been studied in connection with momentum transport in Ref. [80], and must be explicitly switched on through the input file.\n\n\\subsection*{7.3 The velocity nonlinearity}\nThe velocity nonlinearity is neglected in the $\\delta f$ formalism since it is one order smaller in the normalized Larmor radius $\\left(\\rho_{*}\\right)$ compared with the leading order terms. The correct equation for the velocity nonlinearity can be obtained by considering the equation for the evolution of the parallel velocity (Here without rotation and only electro-static)\n\n", "\n\\begin{equation*}\nm v_{\\|} \\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t}=-\\frac{\\mathrm{d} \\mathbf{X}}{\\mathrm{~d} t} \\cdot[Z e \\nabla\\langle\\phi\\rangle+\\mu \\nabla B] \\tag{7.52}\n\\end{equation*}\n\n\nIn the $\\delta f$ formalism the terms that are proportional to both the field $(\\phi)$ as well as the perturbed distribution are neglected. Note that these terms do include the term due to $\\mathbf{v}_{E} \\cdot \\mu \\nabla B$, which cancels $\\mathbf{v}_{\\nabla B} \\cdot Z e \\nabla\\langle\\phi\\rangle$. The remaining terms are\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} v_{\\|}}{\\mathrm{d} t}=-\\frac{Z e}{m v_{\\|}}\\left[v_{\\|} \\mathbf{b}+\\mathbf{v}_{D-}\\right] \\cdot \\nabla\\langle\\phi\\rangle \\tag{7.53}\n\\end{equation*}\n\n\nwhere $\\mathbf{v}_{D-}$ is the drift velocity minus the grad-B drift.\\\\\nThe parallel velocity nonlinearity therefore adds an additional term to the gyro-kinetic equation in the form\n\n\n\\begin{equation*}\n\\frac{\\partial f}{\\partial t} \\pm \\frac{Z e}{m v_{\\|}}\\left[v_{\\|} \\mathbf{b}+\\mathbf{v}_{D-}\\right] \\cdot \\nabla\\langle\\phi\\rangle \\frac{\\partial f}{\\partial v_{\\|}} \\tag{7.54}\n\\end{equation*}\n\n\nNormalizing this contribution gives for the parallel motion and the drift, respectively\n\n\n\\begin{align*}\n& \\frac{\\partial f_{N}}{\\partial t_{N}} \\pm \\frac{\\rho_{*}^{2}}{2}\\left[v_{\\| N} \\mathcal{D}^{\\alpha}+v_{\\| N} \\beta^{\\prime} \\mathcal{E}^{1 \\alpha}+2 H^{\\alpha} \\sqrt{\\frac{m_{N}}{T_{G N}}} \\Omega_{N}\\right] \\frac{\\partial\\left\\langle\\phi_{N}\\right\\rangle}{\\partial x^{\\alpha}} \\frac{\\partial f_{N}}{\\partial v_{\\| N}} \\tag{7.56}\n\\end{align*}\n\n\n(here the Coriolis drift is kept which is somewhat inconsistent with the fact that it has been neglected in the equation above, but it is work in progress). The drift terms involve derivatives in the perpendicular plane that scale as $1 / \\rho_{*}$. Therefore, both terms are of the order $\\rho_{*}$ and are usually neglected.\n\nAs discussed in section 7.1.1, in the case of the local limit the velocity nonlinearity must be implemented as\n\n\n\\begin{equation*}\n\\frac{\\partial f}{\\partial t} \\stackrel{\\partial}{=} \\frac{\\partial}{\\partial v_{\\|}}\\left[\\frac{Z e}{m v_{\\|}}\\left[v_{\\|} \\mathbf{b}+\\mathbf{v}_{D-}\\right] \\cdot \\nabla\\langle\\phi\\rangle f\\right] \\tag{7.57}\n\\end{equation*}\n\n\nin order to assure phase space convervation. In the latter casse an additional term appears in Eq. (7.56) which must be implemented as\n\n\n\\begin{align*}\n\\frac{\\partial f_{N}}{\\partial t_{N}} \\stackrel{ \\pm}{=} & \\frac{\\rho_{*}^{2}}{2}\\left[v_{\\| N} \\mathcal{D}^{\\alpha}+v_{\\| N} \\beta^{\\prime} \\mathcal{E}^{1 \\alpha}+2 H^{\\alpha} \\sqrt{\\frac{m_{N}}{T_{G N}}} \\Omega_{N}\\right] \\frac{\\partial\\left\\langle\\phi_{N}\\right\\rangle}{\\partial x^{\\alpha}} \\frac{\\partial f_{N}}{\\partial v_{\\| N}} \\\\\n& +\\frac{\\rho_{*}^{2}}{2}\\left[\\mathcal{D}^{\\alpha}+\\beta^{\\prime} \\mathcal{E}^{1 \\alpha}\\right] \\frac{\\partial\\langle\\phi\\rangle}{\\partial x^{\\alpha}} f \\tag{7.58}\n\\end{align*}\n\n\n\\subsection*{7.4 Krook operator}\nIn a global run the profiles relax. Without any sources or sinks this leads to a decay of the turbulence since it is no longer driven. One of the methods to obtain a 'stationary' turbulence run is to use the krook operator. The operator is implemented to conserve density and parallel velocity, but not energy. Below the krook option 1 is described.\n\nFirst the density moment is calculated and stored in the array sss\n\n$$\n\\mathrm{Sss}=\\tilde{n}=\\int f \\mathrm{~d}^{3} \\mathbf{x}\n$$\n\nThen this moment is used in the calculation of the damping term\n\n$$\n\\left.\\frac{\\partial f\\left(v_{\\|}, \\mu\\right)}{\\partial t}\\right|_{K}=-\\gamma_{K}\\left[\\frac{1}{2}\\left[f\\left(v_{\\|}, m u\\right)+f\\left(-v_{\\|}, \\mu\\right)\\right]-\\tilde{n} F_{M}\\left(v_{\\|}, \\mu\\right)\\right]\n$$\n\nwhere the Maxwell is here defined such that it satisfies\n\n$$\n\\int F_{M} \\mathrm{~d}^{3} \\mathbf{v}=1 \\quad \\int \\frac{1}{2} m v^{2} F_{M} \\mathrm{~d}^{3} \\mathbf{v}=\\frac{3}{2} T_{0}\n$$\n\nIntegrating the equation over velocity space yields for the zero moment\n\n$$\n\\left.\\frac{\\partial}{\\partial t}\\right|_{K} \\int f \\mathrm{~d}^{3} \\mathbf{v}=0\n$$\n\ni.e. density is locally conserved. Taking the first parallel velocity moment\n\n$$\n\\left.\\frac{\\partial}{\\partial t}\\right|_{K} \\int v_{\\|} f \\mathrm{~d}^{3} \\mathbf{v}=0\n$$\n\ni.e. also the parallel momentum is locally conserved. Of course, the energy is not\n\n$$\n\\left.\\frac{\\partial}{\\partial t}\\right|_{K} \\int \\frac{1}{2} m v^{2} f \\mathrm{~d}^{3} \\mathbf{v}=-\\gamma_{K} \\int\\left[\\frac{1}{2} m v^{2}-\\frac{3}{2} T_{0}\\right] f \\mathrm{~d}^{3} \\mathbf{v}\n$$\n\nSince density is conserved the perturbed distribution can not be uniformly (in velocity space) damped. The expression above makes clear that the distribution function is reduced for energies more than the thermal energy of the bulk, whereas it is growing for smaller energies.\n\n\\subsection*{7.5 Profile functions in GKW}\nIn the global version one can choose various analytic profiles through the switches 'dens\\_prof\\_type' and 'temp\\_prof\\_type' in the SPECIES namelist. Allowed are at present the switches 'const', 'cosh2', 'tanh', 'exp\\_tanh', 'orb', 'orb3', 'exp\\_poly3' and 'exp\\_poly6'. The parameters needed to calculate the profile are given in the arrays 'dens\\_prof\\_coef' and 'temp\\_prof\\_coef'. At present a maximum of five parameters is available.\n\nBelow the quantity $G$ stands for either density or temperature, while\n\n$$\nG^{\\prime}=\\frac{1}{G} \\frac{\\mathrm{~d} G}{\\mathrm{~d} \\psi}\n$$\n\nBesides the profiles of density and temperature one can also specify the $q$ profile. To select a specific profile one sets the prof\\_type option in the GEOM namelist. The magnetic shear is calculated consistently with the profile specified. Valid options are at present: 'parabolic', 'parabolic2', 'orb', 'wesson', 'rexp', 'mishchenko'. The parameters needed in the analytic profile are given to the code through the qprof\\_coef array (also in the namelist GEOM)\n\n\\subsection*{7.5.1 Density/Temperature profile option: $\\cosh 2$}\n$$\n\\begin{array}{rlr}\nG_{0} & =\\text { dens_prof_coef(1) } & \\text { the density / temperature at } x=X_{0} \\\\\nR / L_{G} & =\\text { dens_prof_coef }(2) & \\text { gradient length R/L_G at } x=X_{0} \\\\\nX_{0} & =\\text { dens_prof_coef }(3) & \\text { Radial location of the maximum gradient } \\\\\nw & =\\text { dens_prof_coef(4) } & \\text { the normalized width of the gradient profile } \\Delta x / R_{0}\n\\end{array}\n$$\n\n$\\Delta=$ dens\\_prof\\_coef(5) Width that determines the rise of the $R / L_{T}$ profile\n\n$$\n\\begin{gathered}\nX=\\min \\left(\\max \\left(X_{0}-w / 2, \\psi\\right), X_{0}+w / 2 .\\right) \\\\\nG=G_{0} \\exp \\left[-\\frac{R}{L_{G}}\\left(X-X_{0}\\right)+\\frac{R}{L_{G}} \\Delta \\tanh \\left(\\frac{X-X_{0}+w / 2}{\\Delta}\\right)+\\frac{R}{L_{G}} \\Delta \\tanh \\left(\\frac{X-X_{0}-w / 2}{\\Delta}\\right)\\right] \\\\\nG^{\\prime}=\\frac{R}{L_{G}}\\left(1-\\frac{1}{\\cosh ^{2}\\left(\\left(X-X_{0}+w / 2\\right) / \\Delta\\right)}-\\frac{1}{\\cosh ^{2}\\left(\\left(X-X_{0}-w / 2\\right) / \\Delta\\right)}\\right) \\\\\nG_{\\text {norm }}=G_{0}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.2 Density/Temperature profile option: 'const'}\n$G_{0}=$ dens\\_prof\\_coef(1) the density / temperature\n\n$$\n\\begin{gathered}\nG=G_{0} \\\\\nG^{\\prime}=0 \\\\\nG_{\\text {norm }}=G_{0}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.3 Density/Temperature profile option: 'exp\\_tanh'}\n$$\n\\begin{array}{rlc}\nG_{0} & =\\text { dens_prof_coef(1) } & \\text { the density / temperature at } x=X_{0} \\\\\nR / L_{G} & =\\text { dens_prof_coef(2) } & \\text { gradient length R/L_G at } x=X_{0} \\\\\nX_{0} & =\\text { dens_prof_coef(3) } & \\text { Radial location of the maximum gradient } \\\\\nw & =\\text { dens_prof_coef(4) } & \\text { the normalized width of the gradient profile } \\Delta x / R_{0}\n\\end{array}\n$$\n\n$$\n\\begin{gathered}\nG=G_{0} \\exp \\left(-\\frac{R}{L_{G}} w \\tanh \\left(\\frac{\\psi-X_{0}}{w}\\right)\\right) \\\\\nG^{\\prime}=\\frac{R}{L_{G}} \\frac{1}{\\cosh ^{2}\\left(\\left(\\psi-X_{0}\\right) / w\\right)} \\\\\nG_{\\text {norm }}=G_{0}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.4 Density/Temperature profile option: exp\\_poly3}\nResults in a quadratic profile of the gradient length. Limiting cases of linear (for a $=0$ ) and constant (for $\\mathrm{a}=0$ and $\\mathrm{b}=0$ ) are included. Some care has to be taken to get physical profiles. To get a gradient length that is positive over the whole range, the inequality $b^{2}<4 a$ has to be fullfilled.\n\n\\footnotetext{$G_{0}=$ dens\\_prof\\_coef(1) the density / temperature at $x=X_{0}$\\\\\n$R / L_{G}=$ dens\\_prof\\_coef(2) $\\quad$ gradient length R/L\\_G at $x=X_{0}$\\\\\n$X_{0}=$ dens\\_prof\\_coef(3)\\\\\nRadial location of the maximum gradient\\\\\n$a=$ dens\\_prof\\_coef(4)\\\\\nconstant for the quadratic term\\\\\n$b=$ dens\\_prof\\_coef(5)\\\\\nconstant for the linear term\n}\n\\$\\$\n\n\\[\n\\begin{gathered}\nG=G_{0} \\exp \\left[-\\frac{R}{L_{G}}\\left(\\frac{a}{3}\\left(\\psi-X_{0}\\right)^{3}+\\frac{b}{2}\\left(\\psi-X_{0}\\right)^{2}+\\left(\\psi-X_{0}\\right)\\right)\\right] \\\\\nG^{\\prime}=\\frac{R}{L_{G}}\\left[a\\left(\\psi-X_{0}\\right)^{2}+b\\left(\\psi-X_{0}\\right)+1\\right] \\\\\nG_{\\text {norm }}=G_{0}\n\\end{gathered}\n\\]\n\n\\$\\$\n\n\\subsection*{7.5.5 Density/Temperature profile option: exp\\_poly6}\nResults in a fifth and third order term as well as a constant for the gradient length.\n\n$$\n\\begin{array}{r}\n\\begin{array}{rc}\nG_{0}=\\text { dens_prof_coef(1) } & \\text { the density / temperature at } x=X_{0} \\\\\nR / L_{G}=\\text { dens_prof_coef(2) } & \\text { gradient length R/L_G at } x=X_{0} \\\\\nX_{0}=\\text { dens_prof_coef(3) } & \\text { Radial location of the maximum gradient } \\\\\na=\\text { dens_prof_coef(4) } & \\text { constant for the fifth order term } \\\\\nb=\\text { dens_prof_coef(5) } & \\text { constant for the third order term }\n\\end{array} \\\\\n\\qquad \\begin{aligned}\nG=G_{0} \\exp \\left[-\\frac{R}{L_{G}}\\left(\\frac{a}{6}\\left(\\left(\\psi-X_{0}\\right)^{6}+\\frac{b}{4}\\left(\\left(\\psi-X_{0}\\right)^{4}+\\left(\\psi-X_{0}\\right)\\right)\\right]\\right.\\right. \\\\\nG^{\\prime}=\\frac{R}{L_{G}}\\left[a\\left(\\left(\\psi-X_{0}\\right)^{5}+b\\left(\\psi-X_{0}\\right)^{3}+1\\right]\\right. \\\\\nG_{\\text {norm }}=G_{0}\n\\end{aligned}\n\\end{array}\n$$\n\n\\subsection*{7.5.6 Density/Temperature profile option : orb}\nThis produces profiles equivalent to one of the options used in ORB5 (NEMORB). The calculation is a little more involved because these orb profiles are defined as function of a different radial coordinate.\n\n$$\n\\begin{array}{rrr}\nG_{0} & =\\text { dens_prof_coef(1) } & \\text { the density / temperature at } x=X_{0} \\\\\nR / L_{G} & =\\text { dens_prof_coef(2) } & \\text { gradient length R/L_G at } x=X_{0} \\\\\nX_{0} & =\\text { dens_prof_coef(3) } & \\text { Radial location of the maximum gradier } \\\\\nw & =\\text { dens_prof_coef(4) } & \\text { Width of the profile } \\\\\nX_{e} & =\\text { dens_prof_coef(5) } & \\text { minor radius of the plasma edge } X_{e}=a /\n\\end{array}\n$$\n\ngradient length R/L\\_G at $x=X_{0}$\\\\\nRadial location of the maximum gradient\\\\\nWidth of the profile\\\\\nminor radius of the plasma edge $X_{e}=a / R_{0}$\n\nThe values of $\\bar{q}$ as used in ORB at the edge and in the centre\n\n$$\n\\begin{gathered}\nq_{a}=q(a) \\sqrt{1-X_{e}^{2}} \\\\\nq_{0}=q(0)\n\\end{gathered}\n$$\n\nRescale the gradient length to have exactly the input value at the $s_{0}$ coordinate used in ORB\n\n$$\n\\frac{R}{L_{G *}}=\\frac{R / L_{G}}{1-1 / \\cosh ^{2}\\left(X_{0} / w\\right)}\n$$\n\nCalculate the $s$ coordinate used in ORB\n\n$$\n\\begin{gathered}\ns=\\sqrt{\\left(\\frac{\\log \\left(1+\\left(q_{a}-q_{0}\\right) \\psi^{2} /\\left(q_{0} X_{e}^{2}\\right)\\right)}{\\log \\left(1+\\left(q_{a}-q_{0}\\right) / q_{0}\\right)}\\right)} \\\\\nD(X)=\\exp \\left(\\frac{R}{L_{G *}} \\frac{s^{2}}{\\cosh \\left(x_{0} / w\\right)^{2}}-2 \\frac{R}{L_{G *}} s w \\tanh \\left(\\frac{s-X_{0}}{w}\\right)\\right) \\\\\nG(\\psi)=G_{0} D(\\psi) / D\\left(X_{0}\\right) \\\\\nG^{\\prime}=\\frac{R}{L_{G *}}\\left(\\frac{1}{\\cosh ^{2}\\left(\\left(s-X_{0}\\right) / w\\right)}-\\frac{1}{\\cosh ^{2}\\left(x_{0} / w\\right)}\\right) \\\\\nG_{\\text {norm }}=G_{0}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.7 Density/Temperature profile option: 'orb3'}\nOne of the profiles used in ORB (NEMORB)\\\\\n$G_{0}=$ dens\\_prof\\_coef(1) the density $/$ temperature at $x=X_{0}$\\\\\n$R / L_{G}=$ dens\\_prof\\_coef(2) $\\quad$ gradient length R/L\\_G at $x=X_{0}$\\\\\n$X_{0}=$ dens\\_prof\\_coef(3) Radial location of the maximum gradient\\\\\n$w=$ dens\\_prof\\_coef(4)\\\\\nWidth of the profile\\\\\n$\\Delta=$ dens\\_prof\\_coef(5) width that determines the rise of the profile\n\n$$\n\\begin{gathered}\nX=\\min \\left(\\max \\left(\\psi, X_{0}-w / 2\\right), x_{0}+w / 2\\right) \\\\\nG=G_{0} \\exp \\left(-\\frac{1}{2} \\frac{R}{L_{G}} \\Delta \\log \\left(\\frac{\\cosh \\left(\\left(X-X_{0}+w\\right) / \\Delta\\right)}{\\cosh \\left(\\left(X-X_{0}-w\\right) / \\Delta\\right)}\\right)\\right) \\\\\nG^{\\prime}=\\frac{1}{2} \\frac{R}{L_{G}}\\left(\\tanh \\left(\\frac{X-X_{0}+w}{\\Delta}\\right)-\\tanh \\left(\\frac{X-X_{0}-w}{\\Delta}\\right)\\right) \\\\\nG_{\\text {norm }}=G_{0}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.8 Density/Temperature profile option: 'tanh'}\nThe tanh profile\\\\\n$G_{0}=$ dens\\_prof\\_coef(1) the density $/$ temperature at $x=X_{0}$\\\\\n$R / L_{G}=$ dens\\_prof\\_coef(2) $\\quad$ gradient length R/L\\_G at $x=X_{0}$\\\\\n$X_{0}=$ dens\\_prof\\_coef(3) Radial location of the maximum gradient\\\\\n$w=$ dens\\_prof\\_coef(4) Width of the profile\\\\\n$\\Delta=$ dens\\_prof\\_coef(5) width that determines the rise of the profile\n\n$$\n\\begin{gathered}\nG=G_{0}\\left[1 .-\\frac{\\Delta}{2} \\frac{R}{L_{G}}\\left(\\log \\left(\\cosh \\left(\\frac{\\psi-X_{0}+w / 2}{\\Delta}\\right)\\right)-\\log \\left(\\cosh \\left(\\frac{\\psi-X_{0}-w / 2}{\\Delta}\\right)\\right)\\right)\\right] \\\\\nG^{\\prime}=\\frac{1}{2} \\frac{R}{L_{G}}\\left(\\tanh \\left(\\frac{\\left.\\psi-X_{0}+w / 2\\right)}{\\Delta}\\right)-\\tanh \\left(\\frac{\\psi-X_{0}-w / 2}{\\Delta}\\right)\\right)\n\\end{gathered}\n$$\n\nThe norm is the value of the profile at $X_{0}$, not the $G_{0}$ value\n\n$$\nG_{\\text {norm }}=G\\left(X_{0}\\right)\n$$\n\n\\subsection*{7.5.9 q-profile option: parabolic}\nParabolic q-profile\\\\\n$q_{0}=$ qprof\\_coef(1) $\\quad q$ value at the axis\\\\\n$a=$ qprof\\_coef(2) coefficient for the quadratic term\n\n$$\nq=q_{0}+a \\psi^{2}\n$$\n\nwith $\\psi=r / R_{0}$ in circular geometry.\n\n$$\n\\hat{s}=\\frac{2 a \\psi^{2}}{q_{0}+a \\psi^{2}}\n$$\n\n\\subsection*{7.5.10 q-profile option: parabolic2}\nSecond degree polynomial\n\n\\begin{center}\n\\begin{tabular}{|c|c|}\n\\hline\n$q_{0}=$ qprof\\_coef(1) & $q$ value at the axis \\\\\n\\hline\n$a=$ qprof\\_coef(2) & coefficient for the linear term \\\\\n\\hline\n$b=$ qprof\\_coef (3) & coefficient for the quadratic term \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\n$$\n\\begin{gathered}\nq=q_{0}+a \\psi+b \\psi^{2} \\\\\n\\hat{s}=\\frac{a \\psi+2 b \\psi^{2}}{/ q}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.11 q-profile option: orb}\nFor circular geometry one of the options in ORB is\\\\\n$q_{0}=$ qprof\\_coef(1) $\\quad q$ value at the axis\\\\\n$a=$ qprof\\_coef(2) coefficient for the quadratic term\n\n$$\n\\begin{gathered}\nq=\\frac{q_{0}+a \\psi^{2}}{\\sqrt{1-\\psi^{2}}} \\\\\n\\hat{s}=\\frac{2 a \\psi^{2}}{q_{0}+a \\psi^{2}}-\\frac{\\psi^{2}}{1-\\psi^{2}}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.12 q-profile option: wesson}\nThe q-profile used in Wesson. For this profile $\\operatorname{qprof}_{c} o e f(1) \\psi^{2}<1$ has to hold over the entire profile, otherwise the term in the logarithm gets negative. If this happens, the simulation will abort.\n\n$$\n\\begin{aligned}\n& D_{w}=\\text { qprof_coef(1) The aspect ratio squared }(R / a)^{2} \\\\\n& \\nu=\\text { qprof_coef(2) Exponent of the q-profile. } \\\\\n& q_{0}=\\text { qprof_coef(2) } \\quad q \\text { value on the axis }\n\\end{aligned}\n$$\n\n$$\n\\begin{gathered}\nq=\\frac{q_{0} \\psi^{2} D_{w}}{1-\\exp \\left((\\nu+1) \\log \\left(1-D_{w} \\psi^{2}\\right)\\right)} \\\\\n\\hat{s}=2\\left(1-\\frac{q(\\nu+1)}{q_{0}} \\exp \\left(\\nu \\log \\left(1-D_{w} \\psi^{2}\\right)\\right)\\right)\n\\end{gathered}\n$$\n\n\\subsection*{7.5.13 q-profile option: rexp}\nExponential q-profile, with a cut off $q_{c}$. Values of the exponent lower than $q_{c}$ are set to $q_{c}$ with the shear then set to zero.\n\n$$\n\\begin{aligned}\n& a=\\text { qprof_coef(1) } 1 / \\text { length for exponential increase } \\\\\n& q_{v}=\\text { qprof } \\_ \\text {coef(2) Multiplication factor } \\\\\n& q_{c}=\\text { qprof_coef(2) Cut off value }\n\\end{aligned}\n$$\n\n$$\n\\begin{gathered}\nq=\\max \\left(q_{v} \\psi \\exp (a \\psi), q_{c}\\right) \\\\\n\\hat{s}=1+\\psi a \\quad \\text { for } q>q_{c}\n\\end{gathered}\n$$\n\n\\subsection*{7.5.14 q-profile option: mishchenko}\nThis has for example been used in Mishchenko and Zocco, Phys. Plasmas 19.\n\n\\begin{verbatim}\nq}0=\\mathrm{ qprof_coef(1) The q-value on the axis\na = qprof_coef(2) Norm factor for }\n\\nu=qprof_coef(2) Exponent\n\\end{verbatim}\n\n$$\n\\begin{gathered}\nq=q_{0}+\\left(1-q_{0}\\right)(\\psi / a)^{\\nu} \\\\\n\\hat{s}=\\frac{\\nu\\left(1-q_{0}\\right)(\\psi / a)^{\\nu}}{q}\n\\end{gathered}\n$$\n\n\\section*{Chapter 8}\n\\section*{Numerical implementation}\nIn this section we outline the details of the numerical solution of the equations. GKW uses a combination of finite difference and spectral methods. The turbulence in the plane perpendicular to the magnetic field is homogeneous and the solution in the $\\zeta, \\psi$ plane is represented by Fourier modes, as mentioned previously. All other directions are treated using finite difference techniques. In what follows $N_{\\text {mod }}$ and $N_{x}$ are the number of bi-normal ( $\\zeta$ direction) and radial ( $\\psi$ direction) modes respectively, $N_{s p}$ is the number of kinetic species, $N_{s}$ the number of grid points along the field line. $N_{v \\|}$ is the number of grid points in the parallel velocity direction and $N_{\\mu}$ the number of magnetic moment grid points.\n\n\\subsection*{8.1 Derivatives along the magnetic field line and in the parallel velocity direction}\nTerms I, IV and VII on the right hand side of Eq. (7.37), involving a derivative along the magnetic field line or in the parallel velocity direction are considered here. These terms correspond to an advection with a spatially dependent advective velocity and can be written in the form $-v(s) \\frac{\\partial g}{\\partial s}$. The second and fourth-order centred-differences used for these terms can then be written\n\n\n\\begin{align*}\n& v \\frac{\\partial g}{\\partial s} \\rightarrow v_{i} \\frac{-g_{i-1}+g_{i+1}}{2 \\Delta s}-D\\left|v_{i}\\right| \\frac{g_{i-1}-2 g_{i}+g_{i+1}}{2 \\Delta s}  \\tag{8.1}\\\\\n& v \\frac{\\partial g}{\\partial s} \\rightarrow v_{i} \\frac{g_{i-2}-8 g_{i-1}+8 g_{i+1}-g_{i+2}}{12 \\Delta s}-D\\left|v_{i}\\right| \\frac{-g_{i-2}+4 g_{i-1}-6 g_{i}+4 g_{i+1}-g_{i+2}}{12 \\Delta s} \\tag{8.2}\n\\end{align*}\n\n\nwhere the terms involving a dissipation coefficient $D$ correspond to (hyper)diffusive upwind dissipation. This dissipation is not included in the case of term VII (containing derivatives of $\\phi$ ) for numerical stability reasons.\n\nMerely to keep the code simple, the finite difference expression for the 4th derivative in Eq. 8.2 has only second order accuracy, as a higher order would involve more than just 5 gridpoints.\\\\\nThe fact that in Fourier representation the $\\partial_{s}^{4}$ becomes $i k_{s}^{4}$ illustrates that the dissipation term affects in particular the small scales.\\\\\nNote that only a small dissipative contribution is desired, the smaller the higher the grid resolution is. Hence it makes sense to prepend the dissipation term with a factor $\\Delta s^{n}$, where $n$ is an arbitrary power. This should make an appropriate choice of the coefficient $D$ (parameters disp\\_par and disp\\_vp) more obvious.\n\n$$\n-D \\Delta s^{n}\\left|v_{i}\\right| \\frac{-g_{i-2}+4 g_{i-1}-6 g_{i}+4 g_{i+1}-g_{i+2}}{12 \\Delta s^{4}}\n$$\n\nOne may consider a grid-scale oscillation, i.e. $g_{i}=1$ for even indices $i$ and -1 for odd $i$. This is just the kind of oscillation that the artifical dissipation term is supposed to suppress. In this example, the finite\\\\\ndifference in the dissipation term yields $1 / \\Delta s^{4}$ while that of the advection yields $1 / \\Delta s$. If one prepends the dissipation with $\\Delta s^{3}$ then for coefficients $D \\sim 1$ the dissipation term is comparable to the advection term and will indeed damp the grid-scale oscillation effectively. This is why in Eq. 8.2 only $\\Delta s$ appears, not $\\Delta s^{4}$.\n\nRather than apply this central differencing scheme separately to terms I and IV, the code user can choose an alternative scheme, which combines the derivative along the field line with the trapping term. Defining $H\\left(s, v_{\\|}\\right)=\\frac{1}{2} v_{\\|}^{2}+\\mu B+\\frac{1}{2} \\mathcal{E}_{R}$, and noting that $B \\mathcal{G}=\\mathcal{F} \\frac{\\partial B}{\\partial s}$ in IV, we can combine terms I and IV to give\n\n\n\\begin{equation*}\nv_{R} \\mathcal{F}\\left(\\mu \\frac{\\partial B}{\\partial s} \\frac{\\partial \\hat{f}}{\\partial v_{\\|}}-v_{\\|} \\frac{\\partial \\hat{f}}{\\partial s}\\right)=v_{R} \\mathcal{F}\\{H, \\hat{f}\\} \\tag{8.3}\n\\end{equation*}\n\n\nwhere $\\{H, \\hat{f}\\}$ is a Poisson bracket (note that we have neglected the redundant dependence of $\\mu$ in the definition of $H$ for simplicity). Following the second and fourth-order schemes of Arakawa [76], we allow the Poisson bracket to be differenced directly. The terms containing $D$ in Eqs (8.1) and (8.2) are also added to allow some dissipation. The advantage of this scheme over the separate differencing scheme is that usually zero (or relatively small) dissipation is needed to obtain a stable solution. Presently this is implemented only as a fourth-order scheme.\n\n\\subsection*{8.2 Boundary conditions along a field line}\nWe here discuss the implementation of the boundary conditions in the parallel direction $s$, that are presented in Sec. 2.3. After one poloidal turn the Fourier mode connects to a mode with a different radial wave vector. The grid in the $s$ direction is therefore constructed such that at the end of the field line it connects smoothly to the start of the field line (i.e. the grid spacing remains constant). Of course, the radial wave vector to which the mode has to connect might not be represented on the grid. At the end (or beginning) of the field line a boundary condition is then employed. GKW allows for a choice in this boundary condition, setting the perturbed distribution either to zero (NO LONGER AVAILABLE) or to have a zero derivative (default, parallel\\_boundary\\_conditions='open') in the direction upwind with respect to the convection. ${ }^{1}$ The down wind direction is always treated with a zero derivative boundary condition, allowing the distribution to 'flow off the grid', without reflections. Close to the end point boundaries a staggered change in differencing order accuracy is used to remove ghost cells and to allow the flow of the distribution function out of the domain. Reflection or the allowed build up at the upper velocity boundaries is seen as unphysical and therefore undesirable. Because of the use of up-winding the boundary condition is dependent on the sign of the advective velocity.\n\nWhen the advective velocity $v(s)$ is positive the distribution function will move toward the left boundary, and the following scheme is used\n\n$$\n\\begin{array}{cl}\n\\text { Boundary cell : } & \\text { Second order scheme }-\\frac{\\partial g}{\\partial s} \\rightarrow \\frac{-\\frac{3}{2} g_{n}+2 g_{n+1}-\\frac{1}{2} g_{n+2}}{\\Delta s}, \\\\\n\\text { Adjacent cell : } & \\text { Third order }-\\frac{\\partial g}{\\partial s} \\rightarrow \\frac{-\\frac{1}{3} g_{n-1}-\\frac{1}{2} g_{n}+g_{n+1}-\\frac{1}{6} g_{n+2}}{\\Delta s}\n\\end{array}\n$$\n\nwith the right hand boundary using the centrally differenced schemes. When the advective velocity is negative the opposite is true and the right hand boundary is differenced in an identical way. To obtain the scheme for the opposing boundary simply reverse the signs of the equation above. When using the second order scheme, special consideration is needed only for the boundary cell. Depending on the direction of the advective velocity, a first order back-winded scheme is used at the boundary. The effect of these open boundary conditions is to remove the need for ghost cells in the differencing scheme while maintaining a high order scheme. Compared to other alternatives we have found that the chosen scheme removes rapid fluctuations near the end points, and therefore allows for a minimum dissipation. In the Poisson bracket formulation Eq. 8.3, the above convention is integrated into the scheme at the boundaries to have similar properties. Less (or no) dissipation (Diffusion/super-diffusion) is needed for this scheme, but the dissaption\n\n\\footnotetext{${ }^{1}$ The option parallel\\_boundary\\_conditions='Dirichlet' may be different to both of these and is experimental - not documented further here.\n}\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-098}\n\nFigure 8.1: Schematic showing the cells of intest in the differencing scheme when considering the boundary cell (Hollow circles) and the adjacent cell (Filled circles). The figure shows the left hand boundary, for right hand simply reflect in the y direction\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-098(1)}\n\nFigure 8.2: Figure showing the effect of the new open boundary conditions at the boundary. The new boundary has reduced cell to cell fluctuations giving a smoother solution.\\\\\nis implemented as seperate routine using the normal differencing above, allowing identical dissipation to be applied to both schemes.\n\nThe effect of the open boundary conditions is to remove the need for ghost cells in the differencing scheme while maintaining a high order scheme. It has reduced the amplitude of cell to cell fluctuations refelecting off the boundary (See figure 8.2), which in turn, has reduced the need for adding artificial dissipation to the system to damp away these modes. The dissipation, however, can not be wholly turned off in non-linear runs. Note also that the dealiasing in nonlinear runs also has some dissipative effect in the perpendicular spatial directions.\n\n\\subsection*{8.3 Parallel velocity grid - Trapping condition}\n(STILL EXPERIMENTAL AND UNDER DEVELOPMENT) By contorting the velocity grid to conform to the electron trapping condition we are able to remove terms that involve derivatives in the parallel velocity direction. This greatly speeds up linear run computation times but more significantly removes the need for numerical diffusion in the parallel velocity direction and lastly, provides resolution in the required areas.\n\nThis option is turned on by setting vp\\_trap $=1$ in the CONTROL namelist of the input deck. A further parameter is needed in the GRIDSIZE namelist which is named $n_{-}$trapped which is the number of grid points within the trapped region of the velocity grid.\n\nIn the current implementation of the trapping condition, the number of cells in the s direction and the number of points in the parallel velocity direction add certain restrictions to the number of points that can be placed within the trapped region.\n\nFirstly, for ease of differencing the bounce points of a specific $v_{\\| 0}$ (The velocity on the low-field side) must occur exactly half way between two grid-cells, thus the number of grid cells in the s direction restrict both the number and initial values of $v_{\\|}$. The maximum number of bounce points available is given by n\\_s\\_grid/2-1. The value of n\\_trapped must be less than or equal to this. If less is chosen then the code will select which points to use determined by the spacing between points (The closer to the boundary, the closer the bounce points become), the algorithm will iterate over the points, sequentially removing points until n\\_trapped are left. n\\_trapped must also be less than n\\_vpar\\_grid. Outside the trapping region the points are uniformly placed, the spacing is determined by the number n\\_vpar\\_grid $-2 \\times$ n\\_trapped.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-099}\n\n", "Figure 8.3: Figure of parallel velocity grid points as given by the trapping condition, the line corresponds to the trapped/untrapped boundary $v_{| | 0}=\\sqrt{2 \\mu\\left(B_{\\max }-B_{\\min }\\right)+\\mathcal{E}_{\\Omega}^{H}-\\mathcal{E}_{\\Omega}^{L}}$. In the above data, N\\_vpar\\_grid $=16$ (only one half of the grid is shown as it is symmetric), n\\_trapped $=4$ and $\\mu=6$. It must be noted that the total number of points within the trapped region (full grid) is $2 \\times$ n\\_trapped.\n\nThis algorithm gives the grid at the low field side (For an example see figure 8.3), this is then propagated around the torus by the equation\n\n\n\\begin{equation*}\nv_{\\| N}=\\sqrt{v_{\\| 0 N}^{2}+2 \\mu_{N}\\left(B-B_{0}\\right)+\\mathcal{E}_{\\Omega}-\\mathcal{E}_{\\Omega}^{\\mathrm{L}}} \\tag{8.4}\n\\end{equation*}\n\n\nwhere $B_{0}$ is the magnetic field at the low field side, and $\\mathcal{E}_{\\Omega}^{L}$ is the centrifugal energy at the low field side. When a bounce point is reached, the velocity becomes zero, and all velocity grid points after this along $s$ are set to zero and are ignored in the differencing. The grid is also symmetric around $v_{\\|}=0$.\n\nRules that must be followed, otherwise the code will throw you out,\n\n\\begin{itemize}\n  \\item The value of $n_{-} t r a p p e d$ must be less than $n_{-} v p a r \\_g r i d / 2$\n  \\item n\\_trapped must also be less than or equal to n\\_s\\_grid/2-1\n  \\item For optimal convergence $2 \\times n$ \\_trapped must be roughly half of n\\_vpar\\_grid. (This may no longer be true: See issue 8 for latest updates on Gaussian integration (and the separate document Gaussian\\_integration.tex which should be merged here)\n\\end{itemize}\n\n\\subsection*{8.4 The collision operator}\nThe collision operator can be thought of as a convection/diffusion equation in velocity space and thus is differenced accordingly. The velocity space boundary conditions are taken to be zero flux, which occurs\\\\\nnaturally at the $\\mu=0$ boundary and is artificially imposed on the other three boundaries. These boundary conditions guarantee the conservation of mass. Considering that the diffusion coefficient is velocity space dependent, and the grid can be non-uniform in the $\\mu$-direction, the differencing scheme of the equations is chosen as follows for the parallel velocity direction\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial v_{\\|}}\\left(D \\frac{\\partial \\hat{f}}{\\partial v_{\\|}}\\right) \\rightarrow \\frac{1}{v_{i+1 / 2 \\|}^{j}-v_{i-1 / 2 \\|}^{j}}\\left(D_{i+1 / 2}^{j}\\left(\\frac{f_{i+1}^{j}-f_{i}^{j}}{v_{i+1 \\|}^{j}-v_{i \\|}^{j}}\\right)-D_{i-1 / 2}^{j}\\left(\\frac{f_{i}^{j}-f_{i-1}^{j}}{v_{i \\|}^{j}-v_{i-1 \\|}^{j}}\\right)\\right), \\tag{8.5}\n\\end{equation*}\n\n\nwhere i denotes the point in the parallel velocity direction and j the $\\mu$ direction. When considering the cross-terms a four point interpolation method is used to calculate the half point values. Four points are needed on a two-dimensional grid. The friction term is differenced in the same way, but with a two point interpolation.\n\nTo bypass the complications caused by non-uniform distribution of $\\mu$ points (which in uniform in the $v_{\\perp}$ coordinate), the code chooses the suitable version of the collision operator that is uniform, and as such, can conserve mass (and parallel momentum) to machine accuracy.\n\nA further switch selfcollcon in the collisions input deck changes the momentum conservation from just the self-collisions for each species (selfcollcon = .true.) to absolute conservation (selfcollcon=.false, default=.true.). Note that the absolute conservation option is unphysical and only implemented for tests and benchmarks purposes.\n\n\\subsection*{8.5 The Fourier representation}\nIn a nonlinear run a rectangular grid of wave vectors $\\left(k_{\\zeta}, k_{\\psi}\\right)$ is used. The nonlinearity is treated using fast Fourier transforms (FFT). Different choices of FFT libraries are possible, but at present we use mostly the FFTW library [56]. For the nonlinear term a de-aliasing method is applied, i.e. the transformation to real space is constructed on a grid finer (number of grid points at least $3 / 2$ larger in real space) than the Fourier modes represent. The de-aliasing method is non-conservative and has a dissipative effect on the finer grid scales, with the consequence that a numerical dissipation term in the spectral directions is generally not required.\n\nSince the distribution function is a real quantity the number of complex Fourier modes can be reduced by a factor two and a half plane of wavevectors with $k_{\\zeta} \\geq 0$ is used. Grid sizes in real space are chosen so that they have only small prime factors. Such sizes lead to particularly efficient computations with the standard FFT libraries. There are no significantly more efficient grid sizes any more, as it used to be in the past.\n\n\\subsection*{8.6 Time integration}\nGKW has several options for the explicit time integration: modified midpoint, fourth order Runga Kutta (recommended), and a second order scheme that is stable for hyperbolic equations. An implicit scheme is also implemented, but is still under development and not yet recommended for general use (For latest updates see issue 10).\n\n\\subsection*{8.7 Poisson equation}\nThe Poisson equation 2.277 is split into three linear terms which are stored in the main solution matrix, but evaluated separately from the other linear terms. The calculation of the fields takes place in fields.F90 subroutine calculate\\_fields.\n\nThe Poisson equation given in 2.277 can be rewritten.\n\n\n\\begin{align*}\n& \\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p}\\left[2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}+\\frac{Z_{s p}}{T_{R s p}}\\left[\\Gamma\\left(b_{s p}\\right)-1\\right] \\exp \\left(-\\mathcal{E}_{R \\mathrm{sp}}\\right) \\hat{\\phi}\\right]=\\frac{n_{R_{0}, e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\left(\\hat{\\phi}-\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}\\right) \\\\\n& \\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p}\\left[2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}\\right]+\\frac{n_{R_{0}, e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}= \\\\\n& \\quad=-\\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p}\\left[\\frac{Z_{s p}}{T_{R s p}}\\left[\\Gamma\\left(b_{s p}\\right)-1\\right] \\exp \\left(-\\mathcal{E}_{R \\mathrm{sp}}\\right) \\hat{\\phi}\\right]+\\frac{n_{R_{0}, e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}} \\hat{\\phi} \\tag{8.6}\n\\end{align*}\n\n\nSolving for $\\hat{\\phi}$\n\n\n\\begin{align*}\n& \\sum_{s p, \\text { ions }} Z_{s p} n_{R_{0}, s p}\\left[2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}\\right]+\\frac{n_{R_{0}, e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}= \\\\\n& \\quad=\\left[-\\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p}\\left[\\frac{Z_{s p}}{T_{R s p}}\\left[\\Gamma\\left(b_{s p}\\right)-1\\right] \\exp \\left(-\\mathcal{E}_{R \\mathrm{sp}}\\right)\\right]+\\frac{n_{R_{0}, e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\right] \\hat{\\phi} \\tag{8.7}\n\\end{align*}\n\n\nyields\n\n\n\\begin{equation*}\n\\hat{\\phi}=-\\frac{1}{A}[\\sum_{s p, i o n s} \\underbrace{Z_{s p} n_{R_{0}, s p} 2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right)}_{\\text {poisson_int }()_{-M^{3}}} \\hat{g}_{s p}+\\underbrace{\\frac{n_{R e} \\exp \\left(-\\mathcal{E}_{R e}\\right)}{T_{R e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}}_{\\text {poisson_Zf }() \\rightarrow \\text { eq. 8.15 }}] \\tag{8.8}\n\\end{equation*}\n\n\nwhere the factor\n\n\n\\begin{equation*}\nA=\\sum_{\\mathrm{sp,ions}} n_{s p} Z_{s p}\\left[\\frac{Z_{s p}}{T_{R s p}}\\left(\\Gamma\\left(b_{s p}\\right)-1\\right) \\exp \\left(-\\mathcal{E}_{R \\mathrm{sp}}\\right)-\\frac{\\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\right]=M^{4} \\tag{8.9}\n\\end{equation*}\n\n\nis evaluated in subroutine poisson\\_dia. The symbols $M^{3}$ and $M^{4}$ number the matrices presented in this paragraph (and are not \"powers of $M$ \" or so) and refer to sections of mat. In this sense also $M^{1}$ and $M^{2}$ which contain the linear terms of the GKE and are mentioned elsewhere denote sections 1 and 2 of the matrix mat. The quantity $\\{\\hat{\\phi}\\}_{\\text {FSA }}$ can be eliminated from 8.8 by taking the flux surface average of equation 8.8.\n\n\n\\begin{align*}\n\\{\\hat{\\phi}\\}_{\\mathrm{FSA}} & =\\left\\{-\\frac{1}{A}\\left[\\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p} 2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}+\\frac{n_{R e} \\exp \\left(-\\mathcal{E}_{R e}\\right)}{T_{e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}\\right]\\right\\}_{\\mathrm{FSA}} \\\\\n& =\\left\\{-\\frac{1}{A} \\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p} 2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}\\right\\}_{\\mathrm{FSA}}+\\left\\{-\\frac{1}{A} \\frac{n_{R e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}\\right\\}_{\\mathrm{FSA}} \\tag{8.10}\n\\end{align*}\n\n\nThe expressions containing $\\{\\hat{\\phi}\\}_{\\text {FSA }}$ are drawn together:\n\n\n\\begin{gather*}\n\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}-\\frac{n_{R e}}{T_{R e}}\\left\\{\\frac{-\\exp \\left(-\\mathcal{E}_{R e}\\right)}{A}\\right\\}_{\\mathrm{FSA}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}=\\left\\{-\\frac{1}{A} \\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p} 2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}\\right\\}_{\\mathrm{FSA}} \\\\\n\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}\\left(1-\\frac{n_{R e}}{T_{R e}}\\left\\{\\frac{-\\exp \\left(-\\mathcal{E}_{R e}\\right)}{A}\\right\\}_{\\mathrm{FSA}}\\right)= \\\\\n\\frac{n_{R e}}{T_{R e}} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}\\left(\\frac{T_{R e}}{n_{R e}} \\frac{1}{\\exp \\left(-\\mathcal{E}_{R e}\\right)}-\\left\\{\\frac{-1}{A}\\right\\}_{\\mathrm{FSA}}\\right)= \\tag{8.11}\n\\end{gather*}\n\n\nThe zonal correction term can then be written as a function of the distribution function, parameters and background quantities.\n\n\n\\begin{equation*}\n\\frac{n_{R e} \\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{T_{R e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}=\\frac{\\left\\{-\\frac{1}{A} \\sum_{s p, i o n s} Z_{s p} n_{R_{0}, s p} 2 \\pi B \\int \\mathrm{~d} v_{\\|} \\mathrm{d} \\mu J_{0}\\left(k_{\\perp} \\rho_{s p}\\right) \\hat{g}_{s p}\\right\\}_{\\mathrm{FSA}}}{\\frac{1}{\\exp \\left(-\\mathcal{E}_{R e}\\right)}\\left(\\frac{T_{R} e}{n_{R} e}+\\left\\{\\frac{\\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{A}\\right\\}_{\\mathrm{FSA}}\\right)} \\tag{8.12}\n\\end{equation*}\n\n\nThe subroutine poisson\\_zf prepares matrices according to the definitions\n\n\n\\begin{align*}\nZ & =-\\frac{\\mathrm{d} s}{A}  \\tag{8.13}\\\\\nY & =\\frac{1}{\\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}\\left(\\frac{T_{R} e}{n_{R} e}+\\left\\{\\frac{\\exp \\left(-\\mathcal{E}_{R \\mathrm{e}}\\right)}{A}\\right\\}_{\\mathrm{FSA}}\\right) \\tag{8.14}\n\\end{align*}\n\n\nwhich are used to express the right hand side of 8.12 in the form\n\n\n\\begin{equation*}\n\\frac{n_{R e} \\exp \\left(-\\mathcal{E}_{R e}\\right)}{T_{R e}}\\{\\hat{\\phi}\\}_{\\mathrm{FSA}}=\\frac{\\sum_{s} Z M^{3} \\hat{g}}{Y} \\tag{8.15}\n\\end{equation*}\n\n\nThanks to $8.12,8.8$ allows the subroutine calculate\\_fields to calculate $\\hat{\\phi}$ explicitely.\\\\\nTo calculate $\\hat{\\phi}$ from the distribution function, first the integral part poisson\\_int is evaluated using section $M^{3}$ of the matrix.\n\n\n\\begin{equation*}\na_{i}\\left(k_{y}, k_{x}, s\\right)=M_{i j}^{3} \\hat{g}_{j} \\tag{8.16}\n\\end{equation*}\n\n\nNext, the zonal flow correction term, equation 8.12, is evaluated separately, using the special \"matrices\" $Z$ and $Y$. First, the flux surface average in the numerator is evaluated.\n\n\n\\begin{equation*}\nb_{i}\\left(k_{x}\\right)=\\sum_{s} Z_{i j} a_{j} \\tag{8.17}\n\\end{equation*}\n\n\nThen each element is divided by the denominator from equation 8.12.\n\n\n\\begin{equation*}\n\\left.c_{i}\\left(0, k_{x}, s\\right)\\right)=b_{i} / Y_{i}(s) \\tag{8.18}\n\\end{equation*}\n\n\nThe zonal correction term is then subtracted from the minuend in equation 8.8.\n\n\n\\begin{equation*}\nd_{i}\\left(k_{y}, k_{x}, s\\right)=a_{i}-c_{i} \\tag{8.19}\n\\end{equation*}\n\n\nFinally, all elements are divided by the factor $A$ ( $A$ being identical to $M^{4}$, the section 4 of \"the matrix of the linear terms\").\n\n\n\\begin{equation*}\n\\hat{\\phi}_{i}\\left(k_{y}, k_{x}, s\\right)=d_{i} / M_{i}^{4} \\tag{8.20}\n\\end{equation*}\n\n\nThe other linear terms are stored in sections 1 and 2 of the matrix and evaluated as $\\hat{f}_{i}^{\\prime}=\\hat{f}_{i}+\\delta t \\cdot \\hat{f}_{j} M_{i j}^{1,2}$ in calculate\\_rhs after the evaluation of the fields.\n\n\\subsection*{8.8 Notes on individual routines}\nThis section discusses the individual routines and gives some details on the physics processes implemented. Here, not all the input and output or all the variables are discussed. It merely gives some details that should allow the reader to understand the code better.\n\n\\subsection*{8.8.1 linear\\_terms.f90}\nNOT INCLUDED here: centrifugal effects\n\nIn the treatment so far, the terms as implemented in the code were described in 7.37 as terms I-VIII. Here we link these terms to the routines in the code, as well as to 1.31 , the Vlasov equation for the modified perturbation distribution function $g$.\n\n\n\\begin{equation*}\n\\frac{\\partial g}{\\partial t}+(\\underbrace{v_{\\|} \\mathbf{b}}_{I}+\\underbrace{\\mathbf{v}_{D}}_{I I}) \\cdot \\nabla f+\\underbrace{\\mathbf{v}_{\\chi}}_{I I I} \\cdot \\nabla g-\\underbrace{\\frac{\\mu B}{m} \\frac{\\mathbf{B} \\cdot \\nabla B}{B^{2}} \\frac{\\partial f}{\\partial v_{\\|}}}_{I V}=S \\tag{8.21}\n\\end{equation*}\n\n\nWhere the source from the Maxwellian background is given by eqn 1.32\n\n\n\\begin{equation*}\nS=-\\underbrace{\\left(\\mathbf{v}_{\\chi}\\right.}_{V}+\\underbrace{\\left.\\mathbf{v}_{D}\\right)}_{V I} \\cdot \\nabla_{p} F_{M}-\\frac{Z e}{T} \\underbrace{\\left[v_{\\|} \\mathbf{b}\\right.}_{V I I}+\\underbrace{\\left.\\mathbf{v}_{D}\\right]}_{V I I I} \\cdot \\nabla \\chi F_{M} \\tag{8.22}\n\\end{equation*}\n\n\nWe also need the expansion of the drift velocity 1.21\n\n\n\\begin{align*}\n& \\mathbf{v}_{D}=\\underbrace{\\frac{1}{Z e}[\\underbrace{\\frac{m v_{\\|}^{2}}{B}}_{1}+\\underbrace{\\mu}_{2}] \\frac{\\mathbf{B} \\times \\nabla B}{B^{2}}}_{A}+\\underbrace{\\frac{m v_{\\|}^{2}}{2 Z e B} \\beta^{\\prime} \\mathbf{b} \\times \\nabla \\psi}_{3}+\\underbrace{\\frac{2 m v_{\\|}}{Z e B} \\boldsymbol{\\Omega}_{\\perp}}_{4} \\\\\n& -\\underbrace{\\frac{m \\Omega^{2} R}{Z e B} \\mathbf{b} \\times \\nabla R}_{5}, \\tag{8.23}\n\\end{align*}\n\n\nIn linear\\_terms.f90 the various terms from these equations are input into the matrix in individual routines which will be described below. Most of the computation in the code is done in the wave vector domain. All derivatives in the perpendicular direction are in Fourier space; but derivatives along the field line are done in real space (terms I and VII)\n\nSome routines in linear\\_terms.f90 have two versions (identified by a postfix to the routine name), one for each of the second order and fourth order methods. We concentrate here on the fourth order method since the other is out of order. The routines do the same thing with regards to which terms are implemented; the implementation is different for each method. The linear terms all operate on the the distribution $g$ (often called $f$ in the code comments!), because the linear terms matrix is applied to the array called fdisi which always contains $g$.\\\\\ncalc\\_linear\\_terms is the master routine that calls the subroutines which put the terms I-XI (excluding term III) into the matrix. Broadly, the first section puts the terms on the LHS of 8.21 . The second section calculates the source terms due to the maxwell background.8.22. The third section of calc\\_linear\\_terms calls the routines that input the field equations into the matrix. These are the equations that force the solution the be self consistent with the potentials calculated from the distribution function. After each section is completed there is a call to finish\\_matrix\\_section in module matdat which stores the k index labels of the matrix for each section..\n\nHence calc\\_linear\\_terms covers all the terms I-VII in 7.37 ( also labelled as the underbraced numbers in 8.21, 8.22, and 8.23), with the exception of term III, which is implemented in non\\_linear\\_terms.f90.\n\n\\section*{vpar\\_grad\\_df, term I}\nvpar\\_grad\\_df calculates the convection parallel to the field. This routine also adds parallel velocity dissipation, which can be required for a numerically stable solution in nonlinear runs. The dissipation is controlled by the input parameter disp\\_par. This term is the free streaming motion along the field line, with derivative calculated in real space.\\\\\nvdgradf, term II\\\\\nvdgradf calculates the drift in the gradient of the eikonal term.\n\n\\section*{trapdf, terms IV}\ntrapdf calcuates the mirror trapping terms dependent on the switch variable trapping. This routine also adds perpendicular velocity dissipation, which can be required for a numerically stable solution in nonlinear runs. The dissipation is controlled by the input parameter disp\\_vp.\n\n\\section*{ve\\_grad\\_fm, term V}\nve\\_grad\\_fm calculates the $\\mathbf{E} \\times \\mathbf{B}$ drift due to the background distribution, as well as (optionally according to logical nlapar) the electromagnetic correction $\\mathbf{v}_{\\delta B_{\\perp}}$.\n\n\\section*{neoclassical, term VI}\nneoclassical optionally includes the neoclassical terms according to the switch neoclassics. Note many gyrokinetics codes disregard this term.\n\n\\section*{vpgrphi, term VII}\nvpgrphi calculates the landau damping term, dependent on the switch variable landau. This is an acceleration along the field line with parallel derivative in real space.\n\n\\section*{vd\\_grad\\_phi\\_fm, term VIII}\nvd\\_grad\\_phi\\_fm calculates the drift in the gradient of phi times the velocity derivative of the Maxwell background. Note that Equation terms 8.23.1 and 8.23.2 are combined as 8.23.A in the $E_{D}$.multiplier as defined in 7.37.\n\n\\subsection*{8.8.2 non\\_linear\\_terms.F90}\n\\section*{CHECK CONSISTENCY OF THIS SECTION}\nThe Fourier amplitudes of the potential (and perturbed distribution function) are defined as\n\n\n\\begin{equation*}\n\\phi_{N}(x)=\\sum_{k} \\phi_{N k} \\exp [\\mathrm{i} k x]+c . c . \\tag{8.24}\n\\end{equation*}\n\n\nNote that because the inverse discrete Fourier transform $\\left(H_{l}\\right)$ is defined such that the values in real space $\\left(h_{n}\\right)$ are given by\n\n\n\\begin{equation*}\nh_{n}=\\frac{1}{N} \\sum_{l=0}^{N-1} H_{l} \\exp [\\mathrm{i} 2 \\pi \\ln / N] \\tag{8.25}\n\\end{equation*}\n\n\nwhere $N$ is the total number of grid points of the discrete transform. The relation between the amplitudes and the discrete Fourier transform, therefore, is\n\n\n\\begin{equation*}\nH_{l}=N \\phi_{N k} \\tag{8.26}\n\\end{equation*}\n\n\nThe wave vector $k$ is given by the standard relation\n\n\n\\begin{equation*}\nk=\\frac{2 \\pi l}{N \\Delta} \\tag{8.27}\n\\end{equation*}\n\n\nwhere $\\Delta$ is the grid distance. This relation is used to determine the size of the box in real space. It follows that the lowest non-zero wave vector $k_{1}$ determines $\\Delta$ and the size of the box $L=N \\Delta$\n\n\n\\begin{equation*}\nL=\\frac{2 \\pi}{k_{1}} \\tag{8.28}\n\\end{equation*}\n\n\n\\section*{add\\_non\\_linear\\_terms, term III}\nThis routine implements the full term III with electromagnetic corrections. Hence the routine finds the $\\mathbf{E} \\times \\mathbf{B}$ drift of the perturbed distribution function, and adds the term:\n\n\n\\begin{equation*}\n\\mathbf{v}_{\\chi} \\cdot \\nabla g=\\frac{\\mathbf{b} \\times \\nabla\\langle\\hat{\\chi}\\rangle}{B} \\cdot \\nabla g \\tag{8.29}\n\\end{equation*}\n\n\nWithout the elctromagnetic corrections, Term III of 7.37 becomes\n\n\n\\begin{equation*}\n\\mathrm{III}=-\\mathbf{v}_{\\phi} \\cdot \\nabla g \\mathcal{T}\\left(\\mathcal{E}^{\\psi \\zeta}\\left[\\mathcal{T}^{-1}\\left(i k_{\\zeta} \\hat{\\phi}\\right) \\mathcal{T}^{-1}\\left(i k_{\\psi} \\hat{g}\\right)-\\mathcal{T}^{-1}\\left(i k_{\\zeta} \\hat{g}\\right) \\mathcal{T}^{-1}\\left(i k_{\\psi} \\hat{\\phi}\\right)\\right]\\right) \\tag{8.30}\n\\end{equation*}\n\n\nwhere the expansion of the tensor sum uses the anti-symmetry of $\\mathcal{E}^{\\beta \\alpha}$. Note also that the diagonal elements of $\\mathcal{E}^{\\beta \\alpha}$ are zero, and derivatives along $s$ are neglected.\n\nThe gyroaveraged potential $\\left\\langle\\phi_{N}\\right\\rangle$ is first calculated in the wavevector domain by multiplying the potential by the Bessel function $J_{0}$ (2.259). In k space the derivative of the potential is obtained by multiplying by $i k_{\\alpha}$.\\\\\nHence the implementation in the code is\n\n\n\\begin{align*}\n& a=i J_{0}\\left(k_{\\perp} \\rho\\right) k_{N, \\zeta} \\phi_{N, k}=i k_{\\zeta} \\rho_{\\mathrm{ref}}\\left\\langle\\phi_{N, k}\\right\\rangle  \\tag{8.31}\\\\\n& b=i J_{0}\\left(k_{\\perp} \\rho\\right) k_{N, \\psi} \\phi_{N, k}=i k_{\\psi} \\rho_{\\mathrm{ref}}\\left\\langle\\phi_{N, k}\\right\\rangle\n\\end{align*}\n\n\nNote the $\\rho$ in the Bessel function is species dependent. Also the normalization of the k vector $k=k_{N} / \\rho_{\\mathrm{ref}}$ introduces a multiplier of $\\rho_{\\text {ref }}$ Hence the inverse Fourier transformation gives\n\n\n\\begin{align*}\n& a r=\\mathcal{F}^{-1}(a)=\\rho_{\\mathrm{ref}} \\frac{\\partial\\left\\langle\\phi_{N}\\right\\rangle}{\\partial \\zeta_{N}}=\\frac{\\rho_{\\mathrm{ref}}}{R_{\\mathrm{ref}}} \\frac{\\partial\\left\\langle\\phi_{N}\\right\\rangle}{\\partial \\zeta}=\\rho_{*} \\frac{\\partial\\left\\langle\\phi_{N}\\right\\rangle}{\\partial \\zeta}  \\tag{8.33}\\\\\n& b r=\\mathcal{F}^{-1}(b)=\\rho_{*} \\frac{\\partial\\left\\langle\\phi_{N}\\right\\rangle}{\\partial \\psi} \\tag{8.34}\n\\end{align*}\n\n\nSince the coordinates are normalised by $x_{\\alpha, N}=x_{\\alpha} / R_{\\text {ref }}$. Here we have explicitly linked the normalizations of the k vector and coordinates to show that under the Fourier transform; $\\rho_{*} \\frac{\\partial}{\\partial x_{\\alpha}} \\rightarrow \\mathrm{i} k_{\\alpha}$, as was intended in its definition. Put simply, a factor of $\\rho_{*}$ appears after the inverse Fourier transform.\n\nSimilarly, the gradient of the distribution function in k space is found $a=i k_{\\psi} g_{N, k}, b=i k_{\\zeta} g_{N, k}$ and applying the inverse Fourier transform gives\n\n\n\\begin{align*}\nc r & =\\mathcal{F}^{-1}(a)=\\rho_{*} \\frac{\\partial g_{N}}{\\partial \\psi}  \\tag{8.35}\\\\\nd r & =\\mathcal{F}^{-1}(b)=\\rho_{*} \\frac{\\partial g_{N}}{\\partial \\zeta} \\tag{8.36}\n\\end{align*}\n\n\nThe tensor $\\mathcal{E}^{\\alpha \\beta}$ (see 2.23) is defined in geom.f90 with name efun. Note that although the tensor has two indices, each component varies along the field line due to the gradient in $B$. The array therfore has 3\\\\\nindices with efun $(i, 2,1)$ being the $\\mathcal{E}(s)^{\\zeta \\psi}$ component. Calling this element of the array we now have all the components needed to calculate 2.263. The factor of $\\rho_{*}^{2}$ comes from the 2 inverse Fourier transforms. Term III then appears in the code as\n\n\n\\begin{equation*}\n\\operatorname{efun}(i, 2,1) *(a r * c r-b r * d r) \\tag{8.37}\n\\end{equation*}\n\n\nFinally this is Fourier transformed back to the wavevector domain and $\\mathcal{F}\\left(\\mathbf{v}_{E} \\cdot \\nabla g\\right)$ is added to the RHS of the equations - which were passed to the subroutine as an argument along with the distribution function when it was called from exp\\_integration.F90.\n\nThe routine also calculates maximum velocities to be used in the timestep estimator. The first time this routine is called it does some initialisations which are not repeated in later calls: The sizes of the boxes in real space are calculated, the max k-vectors are calculated and the location of the $k_{x}=0$ mode is determined. Index arrays are also set up to relate the storage regime on the fast Fourier transform (fft) routine to the GKW storage regime. The remainder of the routine as described above is executed every time.\n\n\\subsection*{8.9 The code}\nThe package GKW consists of a README file (where a description of the full contents can be found), Fortran 95 source files, various makefiles and related scripts, some documentation, some sample code input files, some scripts associated with running and testing the code and tools to pre/post process data and perform visualisation. This section describes what the code can do in terms of parallelisation and how it is structured with respect to the solution of the equations presented in the previous sections. In order to do this, we follow the various tasks the code performs as it runs and discuss the relevant modules to that task. Instructions for building, installing and running the code can be found in section 9.\n\nEach source code file contains a module, except the main program file linart.f90. Each source file has either the extension .f90 or .F90, the latter denoting the need to be pre-processed. For the modules, each module name corresponds directly to the file name (which is always lower case), minus the suffix. Therefore, in the following subsections, when referring to the module GRID, the corresponding source code can be found in the file grid.F90.\n\nThe code does not come with any routines to perform FFTs, which are required for the computation of the non-linear term in Eq. 2.263, and to transform some of the diagnostics into real space. No FFT's are required for a linear run and the code can be compiled without FFT functionality. The FFT's are presently performed via the external FFTW3 library [56], for which the FFT module provides an interface. Although more interfaces for various other portable Fortran FFT libraries could be provided, the performance of the FFTW3 library has been found to exceed that of other alternatives significantly. In addition, the FFTW3 library is fairly portable, so to date there has been no good reason to consider alternatives.\n\nGKW is parallelised primarily using the Message Passing Interface (MPI) ${ }^{2}$. Each parallel process is responsible for solving the equations over a sub domain of the space and a subset of the species. A process usually only has knowledge of the part of the solution it is responsible for, unless explicitly communicated between processes using the MPI library. The parallelisation is discussed in more detail in a later section.\n\n\\subsection*{8.9.1 Initialisation}\nAt the start of a run, the code will first call various basic MPI routines. These give each process an individual rank (processor\\_number) and inform each process of the total number of processors available for the computation (number\\_of\\_processors). Checks are then performed to see if various output or restart files are present.\n\nAfter this, the main input file is read. A single processor is responsible for doing this. The input file contains several Fortran namelists, which are described later. The first namelist is called control and is read in the\n\n\\footnotetext{${ }^{2}$ Shared memory parallelisation, implemented via OpenMP directives, is now possible with the code and is documented in a later subsection\n}\nmodule CONTROL, and is responsible for controlling the basic switches for the physics, numerics and some of the code output. Each module requiring input is responsible for reading its input from this file. After each namelist is read, the processor that read the file broadcasts the information to all the other processors via MPI. All processors can then individually check that the input is allowed or satisfactory, and if necessary, abort the run.\n\n\\subsection*{8.9.2 Parallelisation: local grid}\nThe sizes of the local and global grids and associated quantities are dealt with in the module GRID. The namelist gridsize contains the input variables for the grid sizes. The code can decompose the calculation over the $s, v_{\\|}$and $\\mu$ coordinates and the species. Given the number of processors as input, the routines of GRID decide how the global solution will be subdivided between the processors. Alternatively, a user can specify explicitly the number of processors over which to subdivide the problem in each divisible direction. If a user explicitly sets an invalid combination, the code will abort at this point or earlier. For the decomposition over the species or the $\\mu$ grid, 1 point per processor is the minimum. The minimum number of grid points per processor in the $s$ and $v_{\\|}$directions is limited to either 1 (when using the second-order finite differences) or 2 (when using the fourth-order scheme). These minimum grid sizes dictate the maximum number of processors that can be used in a given direction; the maximum is either the number of grid points in that direction (for the second-order scheme) or half that value (for the fourth-order scheme). The parallelisation is discussed in more detail in Sect. 8.10.\n\nA processor is provided with various logical variables denoting if it is at a particular boundary in the global domain together with the ranks of the processors that it will need to communicate with (which are usually the ones responsible for adjacent parts of the computational domain).\n\nOnce the local grid sizes have been confirmed, some MPI communicators are set up to facilitate communication between processes responsible various subsets of the whole domain. These are found in the MPICOMMS module. They are particularly useful when performing a sum over a subset of the coordinates when all the relevant points are not present on the local processor.\n\n\\subsection*{8.9.3 Memory layout and allocation}\nIn GKW, the solution pertubation distribution $g\\left(k_{\\zeta}, k_{\\psi}, s, \\mu, v_{\\|}\\right)$for each species, together with the various fields, are stored in the one-dimensional array fdisi, found in the module DIST. These quantities are defined at discrete grid points, so can most conveniently be thought of as multidimensional arrays of dimension 6 for the distribution function (three dimensions of space, two of velocity, and one for the species) or 3 for the fields (three dimensions of space). In the code we want to address them as multidimension arrays, via the various grid indices, in order to perform initialisation and output calculations. However, these arrays are embedded into the array fdisi in order to facilitate the implementation of different types of numerical schemes and optimisations.\n\n", "The modules DIST and INDEX\\_FUNCTION are responsible for the tasks of mapping the multidimensional arrays into fdisi and providing a means to reference them. The DIST module is primarily responsible for deciding where within fdisi those arrays should be stored (as a contiguous block), and also making sure that each array is in a distinct part of fdisi. The INDEX\\_FUNCTION module determines how the indices of the multidimensional array are mapped to a single unique index for the one dimensional array. This mapping can be adjusted in order to improve parallel efficiency and (possibly) improve cache efficiency. The default ordering is at present quite optimal, but manual adjustments within the INDEX\\_FUNCTION module may yield further improvement in some cases. These two modules are quite complicated and one should look into those modules in the code or at Sect. ?? for a detailed explanation.\n\nThe function which provides the array location within fdisi is indx(). This is used in many modules throughout the code, but specifically not the time integration modules, which are designed not to require it. As an example of how it is used, the value phi of the potential at a radial grid point ix, a binormal grid point imod and an $s$ grid point $i$ is obtained in the code as\n\n\\begin{verbatim}\nphi = fdisi(indx(iphi,imod,ix,i))\n\\end{verbatim}\n\nwhere iphi is an identifier for the potential.\\\\\nIn addition to the local solution $g$ and the various fields, the fdisi\\_tmp array contains parts of the solution from other processors which have been communicated via MPI datatypes. In the case of parallelising over the $s$-grid, the fields are also decomposed, so parts of the potential from other processors must also be present in order to calculate the derivative of $\\langle\\phi\\rangle$. The indx () function deals with referencing the right part of fdisi so that other parts of the code do not need to make special arrangements for processor boundary points.\n\nThe distribution function $f$ only ever exists temporarily in the array fdis\\_tmp, and in diagnostics and elsewhere a conversion from $g$ to $f$ must be made (usually using the routine get\\_f\\_from\\_g, except in optimised routines) when it is necessary to work with $f$.\n\nIn general, each module is responsible for allocating any arrays they require. The code attempts to do as much memory allocation as necessary early on, so that if it will exceed the memory limits of a given machine, not much time will have been wasted before the code aborts. When diagnostics are performed at the end of a run, memory allocated for time integration is freed.\n\n\\subsection*{8.9.4 Linear terms}\nThe linear terms are calculated in the LINEAR\\_TERMS and COLLISIONOP module and put into a matrix which is in MATDAT. The LINEAR\\_TERMS module is designed so that more new terms can be added by only adding one new routine and calling it from within that module.\n\nThe linear terms all operate on the the distribution $g$ (often called $f$ in the code comments!), because the linear terms matrix is applied to the array called fdisi which always contains $g$.\n\n\\subsection*{8.10 Code parallelisation}\nAt present, the parallelisation of the code is done primarily via decomposition of the distribution function grid and the various species in a given run, using MPI. There are now shared memory OpenMP directives implemented into the code which enable more efficient parallelisation in some cases with a large number of parallel processes. This is because performing parallel reduction operations between a large number of processes becomes expensive; at some point, when doubling the number of available processor cores, work sharing the local data between 2 cores can become more efficient than doubling the number of MPI processes. The implementation and testing of the OpenMP parallelisation can be found in Sec. 9.3.10. Here we describes the various MPI parallelisation options and their potential consequences for code performance. In the next section, a scaling test is shown for a Cray XT4.\n\n\\section*{Simple parallelisation via the fields}\nThe equation for the distribution function (without collisions) contains no derivatives in the magnetic moment $\\mu$, which means that the distribution function for any point in the $\\mu$ grid can be updated independently of the other points in the $\\mu$ grid. Similarly, the distribution function for each species can be updated independently. Therefore, one can run up to number of grid points in mu $\\times$ number of species parallel processes (typically 32-64 processes) to update the distribution function if parallelising over these two 'directions'. However, these points are coupled via the fields, which must be updated before the distribution function can be calculated in an explicit time step. The field equations involve a summation over the whole of the velocity space and the species, for which the code requires an inter-process reduction sum. In parallelising over these 'trivial' directions, a process can first perform a partial sum over local species and $\\mu$-grid points, before participating in a sum involving all the parallel processes. For each field, this sum must be performed at every point in the 3-dimensional space, and the result must be then known to every process. As the number of utilised processor cores increases, the amount of data per core that is involved in the sum remains constant. How\\\\\nmuch the parallel efficiency of the code decreases as the number of utilised processors is increased will depend on the algorithm used by MPI\\_ALLREDUCE and underlying system. In this simple parallelisation case (and potentially in other cases) this ALLREDUCE operation is the bottleneck in parallel performance.\n\n\\section*{Parallelisation over the $v_{\\|}$grid}\nThe equations have derivatives in parallel velocity, which in their numerical implementation involve points of the distribution function along lines in the parallel velocity grid. The derivative at the local point requires at most the value of the distribution function at 1 or 2 adjacent points (second or fourth-order scheme) in each direction along the parallel velocity grid (see Sect 8.1). When decomposing the $v_{\\|}$grid, the calculation of a $v_{\\|}$derivative at the end of a local grid will require 1 or 2 more points managed by another process. These points need to be communicated from the adjacent processor before the derivatives are performed. Typically, the 2 points at either end of the local parallel velocity grid must be communicated to the corresponding adjacent process, and 2 points must be received from it. Therefore, if we parallelise over the $v_{\\|}$grid we have this communication to perform in addition to that required to calculate the fields as discussed in the previous subsection. On systems which support performing computation at the same time as communication (such as a Cray XT4), this communication can be overlapped with the relatively expensive nonlinear terms computation. However, in such a case we would still be left with the same field calculation bottleneck as the number of processors responsible for the parallel velocity grid is increased.\n\n\\section*{Parallelisation over the $s$ grid}\nIn terms of the communication required for the derivatives along the $s$ direction, parallelisation over the $s$ grid is much the same as for the $v_{\\|}$grid. However, splitting up the $s$ direction decomposes the space over which the fields are calculated. This means that the ALLREDUCE operation for a given processor only needs to be performed between processors responsible for the same part of the $s$ grid. If the number of processors over which the $s$ grid is decomposed is doubled, then the data involved in the reduction sum is halved, and the number of processors that partake in the sum remains the same. A consequence of this is that when parallelising only in the $s$ direction, no communication is needed to calculate the fields. This is typically very favourable for parallel performance; one potential bottleneck would be effectively removed (and the other can usually be overlapped with computation).\n\n\\section*{Parallelisation over the $\\mu$ (and $v_{\\|}$) grid with collisions}\nIf the collision operator is used, the parallelisation over the $\\mu$ grid is not simply via the fields as derivatives are present. The second-order local derivative for the collision operator uses all the adjacent points in the velocity space (see Sect. 8.4). Although only 1 point must be exchanged between adjacent processors, any 1 processor may need to perform this exchange between 8 processors. If parallelising over the $v_{\\|}$and $\\mu$ grids at the same time, this would mean communication between 6 additional processors (when the grid is decomposed over more than 2 processors in each direction) when compared to a run without collisions. Ideally we would like to avoid parallelising over both the $v_{\\|}$and $\\mu$ grids till other options have been exhausted. Parallelising over the $v_{\\|}$grid, but not the $\\mu$ grid should be equally expensive with or without collisions, since there is no difference in the grid points communicated. Parallelising instead over just the $\\mu$ grid, but not the $v_{\\|}$grid would be more expensive with collisions than without, although typically cheaper (when using the default fourth-order finite-differences) than the previous case using only $v_{\\|}$.\n\n\\subsection*{8.11 Parallel performance (pure MPI), Cray XT4}\nHere we make a simple assessment of the parallel performance of the code on a Cray XT4 (HECTOR). We define the performance as the amount of main time loop computation done by the code per unit time. In the ideal case, a doubling in the number of processor cores used will double the amount of computation done per unit time (or halve the time required to do a fixed number of time steps). We consider a non\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-110}\n\nFigure 8.4: Parallel performance for a typical sized problem on HECToR (Cray XT4), both without and with the collision operator turned on. Due to machine memory constraints, this problem can run with a minimum of 64 cores without collisions and 128 cores with. The performance/speedup is based on the time taken to perform the main time integration loop of the code and is scaled such that it is equal to the number of cores when the smallest possible number of cores is used. The parallel efficiency, based on $100 \\%$ for the smallest number of cores, is noted at several points on the plot.\\\\\nlinear problem of fairly typical size that we believe to be reasonably well converged with respect to grid resolution. As mentioned in Sect. 8.9.3, we can change the data memory layout to potentially tweak the parallelisation and cache efficiency of the code. We have experienced some variation in performance due to these adjustments. However, we do not yet have enough experience of how to optimally prescribe the layout depending on grid size and parallelisation options, so for the purpose of this test, we keep the layout fixed to the default. We perform a test with a resolution of 83 radial wave vectors, 21 bi-normal modes, 4 species, 16 $s$ grid points, $16 \\mu$ grid points and $64 v_{\\|}$grid points, using fourth-order finite-differences in double precision. Two cases are considered, one using the collision operator and one without. Due to the memory available per processor core, a minimum of 64 processors are required for the former case and 128 for the latter. Using a second-order finite-difference scheme and/or a single precision calculation can reduce this minimum. From the parallel algorithm perspective, the upper limit on the number of parallel processes used for this case is 16384. Using second-order finite differences would increase this maximum to 65536 cores. However, only up to 8192 cores were available on the hardware at the time of testing.\n\nBefore deciding how to producing a scaling plot for this testcase (such as in Fig. 8.4), some preliminary investigations on the effects of parallelising in each direction were made. Using the 'trivial' directions alone, the test case parallelises over the minimum 64 processors for the default case. The difference in performance between this parallelisation and parallelising primarily over the parallel velocity grid is fairly small, the 'trivial' directions giving less than $10 \\%$ better performance than with the $v_{\\|}$direction. Parallelising primarily over the $s$ grid at 64 cores (using the maximum number of cores in the $s$ direction before using the simple direction) yields a performance which is almost identical to that using only the 'trivial' directions. It seems that for 64 processors, the communication needed for the derivatives has little (if any) effect on the parallel performance. To get an idea of the relative expense of parallelising over $s$ and $v_{\\|}$, two tests were made by starting with 64 cores (using only the trivial parallelisations), then varying either the number of processors in the $v_{\\|}$direction or the $s$ direction until a total of 512 cores were used. The reduction in efficiency with increasing processors was greater with $v_{\\|}$, with the $s$ parallelisation performing around $6 \\%$ better at 512 cores (at $>95 \\%$ of the efficiency at 64 processors).\n\nA scaling test was performed for the collisionless case up to 8192 cores. Fig. 8.4 shows how the performance\\\\\nincreases with the number of cores. For the first point at 64 cores, only the 'trivial' directions are used for the parallelisation, since that combination provides the best performance (but only by around $1 \\%$ ). Since the $s$ direction is the preferred parallelisation direction (least expensive in terms of performance), the number of processors in $s$ doubled between each point on the graph up to 512 cores, where the maximum of 8 processors in $s$ is used. Beyond that point, the more expensive $v_{\\|}$grid is decomposed until 8192 cores are used. At 8192 cores, the code runs at $63 \\%$ of the efficiency at 64 cores.\n\nFollowing the discussion in the previous subsections, we should expect that with collisions, parallelisation over the $\\mu$ direction is more expensive than over the $s$ direction. Therefore, the scaling test for collisions (as shown in Fig. 8.4) starts at 128 processors fully parallelised over the $s$ direction and over the species, using only 4 processors in $\\mu$. Then, the number of processors in $\\mu$ is doubled, until 512 cores are used. At 1024 cores, it is cheaper to use 32 processors in $v_{\\|}$and only 1 in $\\mu$, since this avoids using parallelisation in both those directions together. For the final 2 points on the graph, the number of processors in the $v_{\\|}$and $\\mu$ are either identical, or there are twice as many in $v_{\\|}$. Since these parallelisation combinations give the best performance (considerably better than using the same ones as without collisions), careful consideration should be given to the number of processors used in each direction when using collisions. At 4096 cores the efficiency is $63 \\%$ of that at 64 cores.\n\nIn both cases considered we see decreasing performance gains when we begin to parallelise in less favourable directions. Running the tests in single precision would mean less data communicated, so may improve scaling (but at the same time would likely reduce the time between communication, or the time available for overlapping communication with computation). Running with the second order finite difference scheme would allow double the number of cores in the $s$ direction and may improve the efficiency at a large number of cores. If different test cases are considered, it may well be that more resolution in a particular direction is needed, which would then lend itself to further scaling.\n\nFor hardware in which not all processor interconnects are equal in speed, the ordering of the MPI communicators within the cartesian topology can have a significant effect on parallel performance. Current high performance machines appear with multiple shared memory cores on interconnected nodes are one example. Given the above discussion of the bottleneck in global reduction operations, it is preferable that the $s$ direction decomposition should be over the slowest communication direction. The GKW default setup assumes that MPI rank ordering is done with adjacent physical processors adjacent in the rank ordering. Testing of a collisionless case on a Cray XT6 (HECTOR phase-2b with 24 cores per node) with 1344 cores indicated that the default dimension ordering (Species, $\\mu, v_{\\|}, s$ ) was optimal. The configuration $\\left(v_{\\|}, \\operatorname{Species,} \\mu, s\\right)$, was $30 \\%$ slower, even with exact multiples of the $v_{\\|}$grid (presumably) on a single node. This is counter-intuitive, since one would expect putting the $v_{\\|}$direction first to be optimal. Configurations with $s$ first were up to $80 \\%$ slower. The ordering can be simply reconfigured near the top of grid.F90. The optimal configuration will depend on hardware and problem size, and conducting tests prior to expensive runs is recommended.\n\n\\subsection*{8.12 Parallel performance (hybrid, MPI+OpenMP), BlueGene/P}\nThe performance of pure MPI parallelisation has also been compared to hybrid parallelisation MPI+OpenMP (see Sec. 9.3.10 for details on the hybrid scheme) for a typical non-linear electromagnetic case with kinetic electrons. The problem size is almost the same as in the previous section: 83 radial wave vectors, 20 binormal modes, 4 species, $32 s$ grid points, $8 \\mu$ grid points and $64 v_{\\|}$grid. A case without collisions and a case with collisions ( $R_{\\mathrm{ref}}=3, T_{2}$ and $n_{\\text {ref }}=6$, was investigated. In contrast to the previous section, the full collision operator with mass and momentum conservation was used ${ }^{3}$.\n\n\\footnotetext{${ }^{3}$ How much the scaling is affected by the communication required for the momentum conservation has not yet been fully investigated by comparisons on the same machine. Limited tests on BABEL indicated that momentum conservation caused a consistent $4 \\%$ slowdown up to 4096 cores, but it could become more (or less) important at higher number of cores (note that it is overlapped with derivatives communications when the MPI implementation supports this). The version of GKW tested on BABEL did not yet have OpenMP implemented in the calculation of the momentum conserving field. Comparison of timings for the regular fields indicate that implementing this would give a $4 \\%(2 \\%)$ speedup at 4 (2) threads without MPI, but with MPI it will likely make no difference if the scaling bottleneck is in the overlapped derivatives communication.\n}\\begin{center}\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\ncores & 512 & 1024 & 2048 & 4096 & 8192 & 16384 \\\\\n\\hline\n1 thread - no OMP & 203.5 h & 212.8 h & 227.9 h & 255.3 h & 304.3 h & 408.4 h \\\\\n(time, efficiency) & $100 \\%$ & $95.6 \\%$ & $89.3 \\%$ & $79.7 \\%$ & $66.9 \\%$ & $49.8 \\%$ \\\\\n\\hline\n1 thread & 214.4 h & 222.1 h & 237.0 h & 263.6 h & 316.6 h & 551.0 h \\\\\n(time, efficiency) & $100 \\%$ & $96.5 \\%$ & $90.5 \\%$ & $81.3 \\%$ & $67.7 \\%$ & $38.9 \\%$ \\\\\n\\hline\n2 threads & 221.1 h & 225.5 h & 233.3 h & 255.1 h & 313.2 h & 493.1 h \\\\\n(time, efficiency) & $100 \\%$ & $98.0 \\%$ & $94.8 \\%$ & $86.7 \\%$ & $70.6 \\%$ & $44.8 \\%$ \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\nTable 8.1: Case without collisions. Total main loop time (in hours) for 600 time steps and strong scaling efficiency based on the case with 512 cores.\n\n\\begin{center}\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\ncores & 512 & 1024 & 2048 & 4096 & 8192 & 16384 \\\\\n\\hline\n1 thread & - & 290.0 h & 317.9 h & 373.1 h & 519.2 h & - \\\\\n(time, efficiency) & $(100 \\%)$ & $(92.6 \\%)$ & $(84.4 \\%)$ & $(71.9 \\%)$ & $(51.7 \\%)$ & - \\\\\n\\hline\n2 threads & 268.4 h & 283.0 h & 300.4 h & 323.4 h & 480.6 h & 713.6 h \\\\\n(time, efficiency) & $100 \\%$ & $94.8 \\%$ & $89.4 \\%$ & $83.0 \\%$ & $55.9 \\%$ & $37.6 \\%$ \\\\\n\\hline\n4 threads & 281.7 h & 283.5 h & 294.9 h & 314.6 h & 380.5 h & 506.1 h \\\\\n(time, efficiency) & $100 \\%$ & $99.4 \\%$ & $95.5 \\%$ & $89.5 \\%$ & $74.0 \\%$ & $55.7 \\%$ \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\nTable 8.2: Case with collisions (including momentum conservation). Total main loop time (in hours) for 600 time steps and strong scaling efficiency based on the case with 512 cores. On 1 thread, the run at 512 cores was out of memory and the strong scaling efficiency was calculated using the results on 2 threads.\n\nThe tests were conducted on the BlueGene/P BABEL ( 4 cores at 850 MHz and 2 GB of memory per node \\href{http://www.idris.fr/eng/User_Support/bg_support.html}{http://www.idris.fr/eng/User\\_Support/bg\\_support.html}) for which the number of OpenMP threads per node can be 1, 2 or 4 . The executable was compiled from revision 2076 of GKW source with O4 optimisation level (typically 10\\% faster that O2/O3 optimisation for a compilation without OpenMP and $5 \\%$ faster for a compilation with OpenMP) and double precision. Due to the small amount of memory per node available on BABEL at least 512 cores were required to run the problem under consideration (to be accurate, the run fits on 256 cores but the execution is then very slow). For all the runs in this section, the number of MPI processes in the species and $s$ direction was n\\_procs\\_sp $=4$ and n\\_procs\\_s $=16$, respectively. The number of processes in the $\\mu$ direction was $n_{-}$procs\\_mu $=8$ for the collisionless case and $n_{-}$procs\\_mu $=4$ for the case with collisions (except when 4 threads were used at 512 cores where n\\_procs\\_mu was reduced to 4 and 2, respectively). This means that the MPI parallelisation over the three most favorable directions was maximised to start with and the scaling of the least favorable direction, $v_{\\|}$, was then compared to the OpenMP scaling by increasing either n\\_procs\\_vpar or the number of threads per node. For instance, a collisonless run on 2048 cores was performed on 1 thread with n\\_procs\\_vpar $=4$ or on 2 threads with n\\_procs\\_vpar $=2$. The tests were conducted with a typical set of diagnostics with NAVERAGE=100, and with the nonlinear timestep estimator on, both were found to have little effect on the scaling performance (for the single threaded case at least).\n\nThe results of the tests are summarised in Table 8.1 (no collisions) and Table 8.2 (with collisions). The corresponding speed-up and total main loop time is displayed in Fig. 8.5 and 8.6, respectively. Hybrid parallelism with 4 threads is especially useful with collisions and allows to recover the scaling obtained without collisions near the MPI limits. Compilation without OpenMP is slightly faster (due to different cache efficiencies in the matrix ordering). This was also observed on HECTOR. (This has since been changed, both now use the same sort ordering so there is no longer any cache penalty for openmp)\n\nA test has also been performed with the number of modes increased to NX=183 and NMOD=32 with the results summarised in Table 8.3.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-113}\n\nFigure 8.5: Parallel performance for a typical sized problem on BABEL (BlueGene/P), both without (left plot) and with (right plot) the collision operator (with momentum conservation) turned on. The performance/speedup is based on the time taken to perform the main time integration loop of the code and is scaled such that it is equal to the number of cores when the smallest possible number of cores is used.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-113(1)}\n\nFigure 8.6: Total main loop time in hours for the cases studied in this section.\n\n\\begin{center}\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\ncores & 2048 & 4096 & 8192 & 16384 \\\\\n\\hline\n1 thread & 1166.4 h & 1369.1 h & 1731.7 h & - \\\\\n(time, efficiency) & $100 \\%$ & $85.2 \\%$ & $67.4 \\%$ & - \\\\\n\\hline\n2 threads & 1094.9 h & 1164.4 h & 1412.5 h & 2317.3 h \\\\\n(time, efficiency) & $100 \\%$ & $94.0 \\%$ & $77.5 \\%$ & $47.3 \\%$ \\\\\n\\hline\n4 threads & 1081.7 h & 1136.5 h & 1305.4 h & 1692.5 h \\\\\n(time, efficiency) & $100 \\%$ & $95.2 \\%$ & $82.9 \\%$ & $63.9 \\%$ \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\nTable 8.3: Case with collisions (with momentum conservation), $\\mathrm{NX}=167$ and NMOD $=32$. Total main loop time (in hours) for 600 time steps and strong scaling efficiency based on the case with 2048 cores.\n\n\\subsection*{8.13 Parallel nonspectral performance (pure MPI), Helios}\nThe nonspectral version of the code additionally parallelizes over the radial ( x ) direction (with the exception an implicit solve for the polarization term). The nonspectral version of the code spends proportionally more time in the fields calculations than the spectral version, since the multi-point averages use for the gyroaverages are much slower than the Bessel functions of the spectral version. (The nonlinear terms, by contrast, are much faster since they only require 1D FFTs.)\n\nSince the \"diagonal part\" of the fields solve is only 3 dimensional, it cannot parallelise over the velocity space or species. This is true in both the spectral and nonspectral versions, but in the spectral version, the diagonal part of the fields solve takes a neglible of CPU time. To allow efficient scaling for the nonspectral version, the fields solve work is additionally parallelised over the toroidal modes using the same communicators that are elsewhere used to distribute work over the velocity space and species. This feature also reduces the fraction of time spent in the implicit polarization solve, which is radially global. Two allgather communications are therefore required in the fields solve: The first in x before the polarization solve, and the second in nmod after the polarization solve so that every processor obtains the result for every toroidal mode. Since these are both gather operations of 3d quantities, they are relatively fast compared to the reductions and communications of ghost cells.\n\nParallelization over the x direction brings the same benefits for reducing the reduction operations in the field solve as the parallelism over the s direction. The additional penalties of extra ghost cell and allgather communications in the fields solve are outweighed by the benefit that this brings. The result is that parallelism over x is always more efficient than parallelism over parallel velocity (which in the nonspectral case performs much worse than in the spectral case due to the larger fraction of time in the field solve). For more details see doc/GKW\\_MPI\\_nonspectral.pdf.\n\nScaling tests of the radially nonspectral version of the code (Fig. 8.7) were performed on the Bull IFERC Helios machine (Intel Sandy Bridge with fat tree topology Infiniband communication network). As with the scaling test described in Sec. 8.11, the 'trivial' parallel directions were used first, followed by s, then x (although not to maximum), then finally vpar. Two cases were chosen to represent a medium and a large physics case simulation, with gridsizes\n\nNX = 256, N\\_s\\_grid = 32, N\\_mu\\_grid = 16, N\\_vpar\\_grid = 32, NMOD = 16, number\\_of\\_species = 2\\\\\nfor the medium case, and\n\nNX = 512, N\\_s\\_grid = 64, N\\_mu\\_grid = 16, N\\_vpar\\_grid = 64, NMOD = 43, number\\_of\\_species = 2\\\\\nfor the large case.\\\\\nThe radial box size was $1 \\mathrm{x}=128$ or $\\mathrm{lx}=256$ respectively, which resulted in 6 x ghost points required for the gyroaverages (only two are communicated for the derivatives). Since the number of ghost points must be less than the number of local points, this sets the maximum limit of n\\_procs\\_x = 32 or 64 repsectively.\n\nFor the medium problem size, the maximum possible n\\_procs\\_x=32, n\\_procs\\_vpar=16 would allow a theoretical maximum of 131,072 cores ( 65,536 with collisions). For the large problem size, the maximum possible n\\_procs\\_x=64, n\\_procs\\_vpar=32 allows a theortical maximum of 1,048,576 cores ( 524,288 with collisions). These results compare favorably with the spectral scaling tests: The parallelism over x removes any scaling performance penalty associated with the use of the collision operator (which adds $20 \\%$ to all runtimes).\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-115}\n\nFigure 8.7: Strong scaling performance for the medium and large sized nonspectral problems on Helios. The speedup is based on the time taken to perform the main time integration loop of the code and is scaled such that it is equal to the number of cores when the smallest possible number of cores is used. BullX MPI seems to perform better at ghost cell communications of derived datatypes while Intel MPI seems to perform better at the large collective operations. Which is better therefore depends on which MPI communication is dominant for a given problem.\n\n\\section*{Chapter 9}\n\\section*{Obtaining, building and running the code}\n\\subsection*{9.1 Getting the code}\nTo obtain the latest version of the code (which should approximately correspond to the latest version of this documentation), you should use the git revision control system (\\href{http://git-scm.com/.)}{http://git-scm.com/.)}. The git program is installed on many systems as the git command. Assuming you are using git, you can check out the code with the command\\\\\ngit clone \\href{mailto:git@bitbucket.org}{git@bitbucket.org}:gkw/gkw.git gkw\\\\\nTo push changes, you will need a bitbucket account to be given write permissions.\n\n\\subsection*{9.2 Building the source code}\nThere are two methods provided to build the code, involving various makefiles. The use of the 'simple' makefile, src/makefile, is intended only as a fallback if the standard makefiles, requiring GNU make, cannot be used. The standard GNU makefiles allow one to create build settings on a per user/machine/compiler basis, without having to make any modifications to the original makefiles ${ }^{1}$. Both methods are outlined below.\n\nWith the latest version of the source code, it will often be possible to build the code by doing very little other than running make in the top-level directory containing the GNUmakefile file. Although this may appear successful, one should be aware that the resulting executable may not contain all the desired functionality.\n\n\\subsection*{9.2.1 Prerequisites and suggestions}\nA Fortran 95 compiler is essential for building the code. Most Fortran compilers are able to pre-process the source files containing C pre-processor directives ${ }^{2}$.\n\nA minimum of a Unix-like system, together with the POSIX shell and standard make utility is suggested. ${ }^{3}$\n\n\\footnotetext{1 The standard makefiles also result in executables which can provide information about themselves and how they were produced. For example, the executable will be able to report its revision number in various ways, which can be quite useful to know.\\\\\n${ }^{2}$ In the unlikely event that this is not the case, and an appropriate pre-processor is not available, some editing of the source files may be necessary before compilation.\\\\\n${ }^{3}$ Without these basics, the various source files will have to be compiled in the correct order (or concatenated into a single file in the the correct compilation order beforehand).\n}For building the latest version of the code from the git repository, GNU make is recommended. This should be the default make program installed on GNU operating systems, such as GNU/Linux. On some systems, the command may be gmake, in order to distinguish it from the system default make.\n\nTo enable parallelisation, you will require an MPI implementation and/or a Fortran compiler which supports OpenMP directives. To allow nonlinear runs, the FFTW3 library is required (more details in Sect. 8.9).\n\nA C compiler is not required to compile the code, but will be required to compile the optional libraries includes with GKW.\n\nMore information on linking optional libraries is given in section 9.2.6.\n\n\\subsection*{9.2.2 Using the GNU makefile}\nInstructions within the top-level makefile, GNUmakefile, should be the first point of reference for this method. Ultimately, you should just need to run make (GNU make) in this directory and you will end up with an executable in the run/ directory. However, when building for the first time on a given machine, it is suggested to create at least one new makefile which contains settings specific to the local machine and user (and perhaps compiler if there are multiple possibilities). Whenever the code is then built again on this machine, those specific makefiles will be used automatically when running make.\n\nAll host-specific makefiles are located in the config/ directory and subdirectories. The variables contained in global\\_defaults.mk will always be used, unless host-specific variables override them. You can use \\href{http://template.mk}{template.mk}, which documents almost all the variables one may wish to change. If you are creating a new file for machine hostname, it should usually be saved to \\href{http://defaults.mk}{defaults.mk} within the hostname/ subdirectory of config/. You will likely want to set at least the Fortran compiler, external libraries, and the required precision. One may wish to look at existing files for examples; template files for Intel, GNU and IBM compilers are also provided in config/templates.\n\nThe code object files are built in different subdirectories of /obj, depending on hostname, compiler and precision, among other things. The resulting executable name will represent which SVN version of the code was used, which compiler was used, and if the executable is single (SP) or double precision (DP) ${ }^{4}$. If you run make clean, ALL object files will removed. make cleanloc will remove only object files for the compiler and precision subfolder ${ }^{5}$. If your make program supports it, there should be no problem in building the code in parallel (GNU make does this via the '-j' flag).\n\nIf everything completes correctly, the compiled executable will appear in the /run directory.\n\n\\subsection*{9.2.3 Using the 'simple' makefile}\nIf using the GNU makefiles is problematic, one may wish to build the code using the simple makefile, src/makefile. You will need to run make from within the src/ directory, but there is a good chance you will have to edit the makefile beforehand - instructions for doing this can be found in the file itself. Any files created during compilation will be in this directory, together with the source files, apart from the resulting executable, which by default, will be found in the top-level directory.\n\n\\footnotetext{${ }^{4}$ Beyond these distinctions, it is possible to clobber an existing executable with one of the same name that does something different.\\\\\n${ }^{5}$ Note that if you pass variables to the make program by specifying them after the command (rather than changing them in the appropriate file), you should be aware that existing objects might be re-used to complete the build, such that the desired properties of the program are only partly present. For example, say you compile the code without OpenMP, then edit some files, then type make SMP=OPENMP, then it might be the case that only some of the code has OpenMP enabled in it. To avoid such problems, use the configuration files, or type make clean, before (re)building to make sure you get what you expect.\n}\\subsection*{9.2.4 Some important makefiles}\nThere are two files common to both methods which are found in the src/ directory. The \\href{http://objfiles.mk}{objfiles.mk} file contains the list of object files to be created before linking to produce the executable. It should only be necessary to modify this file when adding new source files to the code. The file deps .mk lists the dependencies for the objects found in \\href{http://objfiles.mk}{objfiles.mk}, so that the objects/modules may be built in the correct order. This should be updated automatically with the standard makefiles, but may need to be modified manually when using the 'simple' makefile. It may be possible to update it via\n\n\\begin{verbatim}\n./scripts/mkdeps > deps.mk\n\\end{verbatim}\n\nfrom within the source directory.\\\\\nThe file src/gkw.mk is the main GNU makefile which should not need to be modified in general, unless new variables are being introduced to the code. Otherwise, all settings should be made via the files in config/.\n\n\\subsection*{9.2.5 Potential compilation issues}\nMost compilers tested to date have no problems compiling the code. Occasionally, some non-standard features or bugs get into the trunk version, creating problems. However, these tend to get removed rapidly after they are discovered. The Intel and GNU compilers are in most frequent use and are least likely to find unexpected new issues when compiling and running. On Hector, the PGI compiler has historically caused less problems than the Cray compiler.\n\nSome compilers, such as those found on Fujitsu machines, may not like very large source files; if such a compiler is used, it may be necessary to edit the problematic source file and remove code which is not needed for the particular run.\n\nSome compilers (e.g. Intel) do not by default include the present working directory in the include path. If make gives an error that gkw\\_info.h cannot be found, when it already exists in the /obj directory, you should first try adding I./ to FFLAGS\\_INC to your config file.\n\n\\subsection*{9.2.6 Additional libraries}\nHere we list some third party libraries that can be used to extend the functionality of the code.\n\n\\section*{MPI-2}\nAn MPI-2 implementation is required for any distributed memory parallel run. ${ }^{6}$ MPI is enabled through preprocessing by setting MPI=mpi2 in the config file. For most MPI implementations, the include files and linking are automatically handled by a compiler wrapper script such as mpif90 or mpiifort.\n\n\\section*{FFTW3}\nFor nonlinear runs a Fourier transform library is needed. At the moment only the FFTW3 library is supported. If this library is installed it can be linked against by setting FFTLIB = FFT\\_FFTW3 in the corresponding config file of gkw. Depending on the system you may also need to set FFLAGS\\_INC and LDFLAGS to link to -lfftw3 (-lfftw3f) for double (single) precision.\n\n\\footnotetext{${ }^{6}$ The code might compile and run (with limited MPI-I/O and nonspectral functionality) with MPI-1 but this has not been attempted for a long time, and it is likely that some MPI-2 function calls would need to be commented to make this possible.\n}\\section*{AMD and UMFPACK}\nThe two libraries amd and umfpack are needed for the (experimental) implicit time integration scheme and the nonspectral and global cases. They are provided with the GKW trunk and must be compiled before GKW.\n\nAt present these libraries can only be compiled in double precision. If GKW is compiled in single precision, then type conversions are made wherever these libraries are used in the code. To compile and link these libraries to GKW one must add to the GKW config file\n\n\\begin{verbatim}\nIMPLICIT = umfpack # Compile GKW with umfpack (64 bit) or umfpack32 (32 bit)\n\\end{verbatim}\n\nIn most cases this should be sufficient; the libraries should then be built and linked automatically. One can also explicitly require compilation and linking of umfpack by setting\n\nUMFPACK = compile \\# Compile the UMFpack provided with GKW\\\\\nLD\\_UMFPACK = -lumfpack \\# link GKW with UMFpack\n\n\\section*{SLEPc and PETSc}\nFor the eigenvalue solver the two libraries SLEPc and PETSc are required (where the former depends on the latter). Note that these two libraries have to be compiled for using complex numbers to work. This can be achieved with the option --with-scalar-type=complex for the configure script of PETSc. SLEPc inherits these settings automatically from PETSc (if configured afterwards). To link these libraries, one must add the paths for the libraries to the LDFLAGS together with some subset of these (-lslepc -lpetsc -llapack -lblas -lX11 -lmkl) and you must set SLEPC = HAVE\\_SLEPC in your config file for GKW. If the headers are not installed in a standard location for Fortran you may also have to add the library include paths to FFLAGS\\_INC. It might also be necessary to add the path to petscconf.h to FFLAGS\\_INC (probably under an include subdirectory for each architecture).\n\n", "\\section*{HDF5}\nThe HDF5 library is needed to write output in the HDF5 data format. Note that at the moment GKW expects the HDF5 library to be compiled in its serial version.\\\\\nTo link this library, one must add the paths of the LDFLAGS and FFLAGS\\_INC variables. It is a good idea to make use of the h5fc wrapper which is provided by the HDF5 library to make compilation easier (e.g. see the helios config). Furthermore, set IO\\_LIB = HAVE\\_HDF5 in your config file for GKW, this will then enable GKW's HDF5 support.\n\nNote that the default output format of GKW depends on the availability of HDF5. If GKW was compiled without HDF5 it then io\\_format='mixed' is the default, but if compiled with HDF5 the default becomes io\\_format = 'hdf5+ascii', see also section 10.7.\n\nNote also that some datasets, in particular higher-dimensional (3D+) diagnostic data (using MPI-IO) is not output in HDF5 format at the moment, because parallel HDF5 is not yet supported by GKW. If such data is requested, it will be output in fortran binary output instead of HDF5.\n\n\\subsection*{9.3 Running GKW}\nBefore you do any run it is important to realize that it is not all that hard to produce nonsense. The code is not under all conditions stable, and it is not always immediately obvious if a result is wrong. It is therefore important to diagnose your runs to make sure they are O.K.. It is your responsibility as a user to produce physically meaningful results.\n\nHere it is assumed you have the necessary MPI environment set up and running on the machine (consult your MPI library documentation) and that any run time dependencies can be satisfied.\n\nIn order to run GKW, the code requires a single input file input.dat to be present in the run directory. Optionally, a file containing equilibrium geometry information from the CHEASE code can be provided as input. To get started, there are a few example input files found in the input directory, together with corresponding README files. The file input.dat.sample lists every input switch together with a description of its purpose. input.dat.minimum is a bare minimum input file containing the essential inputs required for the code to run.\n\nTo run the code in parallel, you will probably need to use the program provided by the MPI implementation; this is usually called mpirun or mpiexec.\n\nGKW will try to select an appropriate parallelisation given the gridsize input but this can be overridden (by setting $N_{-}$procs\\_[sp-mu-vpar-s] in the gridsize namelist). Nevertheless it is sensible to have in mind a parallelisation setup when you set the gridsize, as the user controls the number of processors the code will be run on and should choose a number that fits with the gridsize. For the largest parallel runs, the user is recommended to manually choose the parallel setup.\n\nThe rest of this section describes a basic input file. Many of the input switches are optional and default values will be used if they are not provided. The input variables are provided in Fortran namelists, for example the namelist 'control' contains the main switches for the code. The namelist examples presented here provide you with a basic set needed to run the code. The namelists are sensitive to bad formatting, in which case the code should inform you which namelist has the problem.\n\nGKW tries to catch as many invalid input combinations as possible. Most of the time if you input a set of incompatible switches the code will tell you and abort if necessary. For more minor errors the code will generate a warning that it is ignoring an input parameter and continue. The actual input parameters the code runs with are written to input.out. By renaming input.out to input.dat the code should re-run without the warnings (if the compiler correctly formats namelist outputs).\n\n\\subsection*{9.3.1 Modes}\nThe spacing and location of the wavevectors is determined by the 'mode' namelist. For mode\\_box=.false. there is only one radial wavevector considered, but the field line can be extended to take more than one poloidal turn by setting nperiod. The total number of full poloidal turns is then 2 nperiod - 1 . The bi-normal modes are determined by the input kthrho which specifies the value(s) of $k_{\\theta} \\rho_{\\text {ref }}$, see Eq. (2.256). For mode\\_box $=$.false. the bi-normal modes are given as a list i.e. kthrho $=0.1,0.2,0.3$ (the variable krhomax is ignored). The radial mode is determined by the input krrho which specifies the value of $k_{r} \\rho_{\\mathrm{ref}}=\\sqrt{g^{\\psi \\psi}(s=0)} k_{\\psi}$. Alternatively, a poloidal shift of the balooning angle can be specified using the input CHIN. A finite value of $k_{\\psi}$ will then be calculated to minimise $k_{\\perp} \\rho_{\\text {ref }}$ at the poloidal angle $\\theta=C H I N$. The value of $k_{\\psi}$ is given by\n\n$$\nk_{\\psi}=-k_{\\zeta} g^{\\psi \\zeta} / g^{\\psi \\psi}\n$$\n\nwhere the metric elements are evaluated at the poloidal location specified by CHIN (poloidal angle, from the magnetic axis, positive counterclockwise, in radian and zero at the low field side midplane) and $k_{\\zeta}=$ $k_{\\theta} \\rho_{\\text {ref }} / \\sqrt{g^{\\zeta \\zeta}(s=0)}$, as usual.\n\nFor mode\\_box=.true., the field line must have one poloidal turn, i.e. one must set nperiod=1. In this case the radial modes are coupled at the end of the field line according to the ballooning shift connected with the magnetic shear. The bi-normal modes will be equally spaced from $k_{\\theta} \\rho_{\\mathrm{ref}}=0$ to krhomax (the kthrho input is ignored). The integer $i_{k}$ in Eq. (2.255) is input into the code as ikxspace and determines the balance between radial resolution and radial box size. ikspace should be adjusted to give an approximately square box (the code will output LX and LY).\n\n\\begin{center}\n\\begin{tabular}{c|c|c|c|c}\nNS & ikxspace & NX & NPERIOD & mode\\_box \\\\\n\\hline\n80 & N/A & 1 & 3 & false \\\\\n16 & 1 & 5 & 1 & true \\\\\n\\hline\n$n_{s} .\\left(2 n_{p}-1\\right)$ & N/A & 1 & $n_{p}$ & false \\\\\n$n_{s}$ & 1 & $2 n_{p}-1$ & 1 & true \\\\\n\\end{tabular}\n\\end{center}\n\nTable 9.1: Equivalent formulations example with mode\\_box true and false\n\n\\subsection*{9.3.2 Dissipation}\nThe parameter disp\\_vp sets the dissipation on the trapping term. It acts a bit like a collisionality but the normalization is different: The dissipation decreases at fixed disp\\_vp when $N_{-}$vpar\\_grid is increased, so that convergence should always be reached. For all collisionless problems that depend critically on the trapping (TEM modes, particle fluxes) one should not set the dissipation in velocity space too high. For these cases a lower disp\\_vp (say 0.01 ) will allow a lower resolution convergence of the particle fluxes. When collisions are included, disp\\_vp can and should be small (0.2).\n\nThe parameter disp\\_par sets the dissipation on the streaming term, and 0.2 is a reasonable value for most linear runs. For nonlinear runs, values in the range $0.5-2.0$ are typically required for numerical stability, although stable results can be achieved with lower dissipation by using the Arakawa scheme. If parallel dynamics must be finely resolved, higher N\\_s\\_grid bay also allow lower disp\\_par. The default form of the parallel dissipation uses idisp $=2$, which does not vary over the velocity grid and is usually more stable for electromagnetic runs . However, in some physical cases with a sharp parallel structure (usually at low $k_{y}$ ), excessive dissipation appears to drive a linear numerical instability; in these cases the stability may be improved by using idisp $=1$. (See issue 201).\n\nThe circular geometry tends to be more stable than the $s-\\alpha$ geometry if numerical problems arise in the zonal mode [26]. For runs with strong $E \\times B$ shear, disp\\_par should be minimised, and some radial dissipation (disp\\_x $=1.0$ ) should be used (see Ref. [51] or [52]). disp\\_x $<0.0$ is also required for the finite differences of the nonspectral version. disp $p_{-}$\\& 0.0 can be useful in some nonlinear runs to cut out high k physical instabilities (e.g ETG modes) and supress high-k spectral pileup.\n\n\\subsection*{9.3.3 Gridsizes}\nA detailed GKW linear convergence study including many figures is available in Ref. [47], of which the numbers below are a summary. The gridsizes required for a converged result will vary for each problem, but here we give some guidance assuming disp\\_vp $=0.01$ and circular geometry. For adiabatic runs, $\\left[N_{s}, N_{\\mu}, N_{v_{\\|}}\\right]=[16,8,16]$ is often sufficient (Here, $N_{s}$ is points per poloidal turn, but $N_{-S}$ grid in the input file is the total number.). Collisionless ITG modes with kinetic electrons will give growth rate and frequency converged to within $5 \\%$ for $\\left[N_{s}, N_{\\mu}, N_{v_{\\|}}\\right]=[16,8,32]$, but if the particle fluxes are to be examined, gridsizes of $\\left[N_{s}, N_{\\mu}, N_{v_{\\|}}\\right]=[40+, 8,48]$ may be required (this is because the trapped passing boundary must be accurately resolved).\n\nIn general, trapped electron modes require more resolution to get accurate growth rate and frequencies, but once these are resolved, the particle fluxes should be also. A TEM mode is converged to with $5 \\%$ for $\\left[N_{s}, N_{\\mu}, N_{v_{\\|}}\\right]=[30,8,64]$ Including collisions can reduce the values of $N_{v_{\\|}}$required substantially ( $N_{v_{\\|}}=$ $16-32$ ), with the lower figures for greater collisionality.\n\nFor a linear run, Nperiod will depend on the type of mode you are looking at. For some ITG cases with high magnetic shear, 3 would be sufficient, but for some TEM cases or cases with lower magnetic shear, as many as 10 may be required. Remember to adjust N\\_s\\_grid accordingly.\\\\\nFor a nonlinear run, $N \\bmod$ should be at least 16. In the past a value of $\\operatorname{nmod}=21$ (or $43,86, \\ldots$ ) was used for particularly efficient FFT computations, but this is no longer significant. For kinetic runs $N X=167$ is a sensible size. For adiabatic runs $N X=83$ may be sufficient. For cases with very low magnetic shear or high $\\mathrm{E} \\times \\mathrm{B}$ shear, $N X=339$ is sometimes used for convergence tests.\n\nFor $N_{s}$, more points are required if using complex general geometry. The boundaries of the velocity space do not usually need to be increased from the defaults.\n\n\\subsection*{9.3.4 Species}\nThere is no default species data, hence the user must provide some. The species input must satisfy quasineutrality. This requires the user to set ratios of densities and charge to satisfy\n\n\n\\begin{equation*}\n\\sum_{s} Z_{s} n_{s}=0, \\quad \\sum_{s} Z_{s} n_{s} \\frac{1}{L_{n_{s}}}=0 \\tag{9.1}\n\\end{equation*}\n\n\nMultiple ion species can be input but only one negatively charged species is allowed. The number of species read in is controlled by the number of species parameter in the 'gridsize' namelist and hence it is possible that later species data you specify will not be read in if this is set incorrectly. The number\\_of\\_species input variable does not include adiabatic electrons (the species data for the negative charge species will still be read).\n\nNote that for a trace species, $n_{s}=0$ is acceptable. The density only appears in the field equations and for scattering species in collisions. A trace particle does not contribute to the fields and does not act as a scattering species, so setting $n_{s}=0$ will give the desired result.\n\n\\subsection*{9.3.5 Stability}\nThe timestep required for numerical stability can vary greatly depending on input parameters, and for kinetic electrons will need to be much smaller. For a linear run, there is a time step estimate made at the start of the run and the code will post a warning if the chosen timestep is larger than this. For a non linear run, the minimum time step is estimated based on the non linear terms, then the time step is adapted as necessary. A minimum time step size can be set in the code (dt\\_min) so that the run stops when the time step becomes too small. The parallel structure of the solution is a good indicator of a the stability of a solution.\n\nFor linear runs a stable solution will converge to a constant growth rate. A tolerance for the growth rate can be specified in the code input (parameter gamatol), so that the run ends when the standard deviation of the growth rate computed over the last six big time steps is less than gamatol. When the tolerance on the growth rate is used to end the run, it is advised to keep the big time steps long enough to have a meaningful standard deviation. Typically, if the big time step length is such that DTIM $\\times$ NAVERAGE $>0.2$, setting gamatol $=10^{-6}$ will usually ensure convergence.\n\nGKW outputs the global growth rate in time. dat so a growth rate spectrum can be generated from a batch of linear runs with $N M O D=1$ and mode\\_box=.false.. Typical grid sizes can be seen in the example input files.\n\n\\subsection*{9.3.6 $\\beta$ and $\\beta^{\\prime}$}\nThe plasma $\\beta$ enters the field equations (parallel and perpendicular components of the Ampere's law, Eq. 1.43 and 1.45) through the parameter $\\beta_{N}$ defined in Eq. 2.12 and recalled here:\n\n\n\\begin{equation*}\n\\beta_{N}=\\frac{n_{\\mathrm{ref}} T_{\\mathrm{ref}}}{B_{\\mathrm{ref}}^{2} / 2 \\mu_{0}} \\tag{9.2}\n\\end{equation*}\n\n\nThe parameter $\\beta_{N}$ is linked to the total plasma $\\beta$ at the reference magnetic field as follows:\n\n\n\\begin{equation*}\n\\beta_{0}=\\sum_{\\text {species }} 2 \\mu_{0} \\frac{n_{s} T_{s}}{B_{\\text {ref }}^{2}}=\\beta_{N} \\sum_{\\text {species }} \\frac{n_{s}}{n_{\\text {ref }}} \\frac{T_{s}}{T_{\\text {ref }}}=\\beta_{N} \\sum_{\\text {species }} n_{N_{s}} T_{N_{s}} \\tag{9.3}\n\\end{equation*}\n\n\nThe user can specify the value of $\\beta_{N}$ used by GKW within the namelist SPCGENERAL. Two options are implemented and controled by the switch BETA\\_TYPE:\n\n\\begin{itemize}\n  \\item BETA\\_TYPE='ref'\n\\end{itemize}\n\nThe value of $\\beta_{N}$ is given as an input in BETA\\_REF.\n\n\\begin{itemize}\n  \\item BETA\\_TYPE='eq'.\n\\end{itemize}\n\nThe total plasma $\\beta$ at the reference magnetic field is read from the MHD equilibrium file and $\\beta_{N}$ is calculated using Eq. 9.3 and the species parameters. The value given as an input in BETA\\_REF is not used and replaced by the calculated value. Note that this option is only available if GEOM\\_TYPE='chease' in namelist GEOM. If it is not the case a warning is displayed and $\\beta_{N}=0$ is used instead.\n\nIn addition, the radial derivative of the plasma $\\beta$ modifies the curvature drift, as seen in Eq. 1.21. Here again, the value at the reference magnetic field is needed (the dependence on the magnetic field is introduced directly in linear\\_terms.F90):\n\n\n\\begin{equation*}\n\\beta_{0}^{\\prime}=\\frac{2 \\mu_{0}}{B_{\\text {ref }}^{2}} \\sum_{\\text {species }} \\frac{\\partial p_{s}}{\\partial \\psi}=-\\beta_{N} \\sum_{\\text {species }} n_{N_{s}} T_{N_{s}}\\left[R / L_{n_{s}}+R / L_{T_{s}}\\right] \\tag{9.4}\n\\end{equation*}\n\n\nThree ways of inputing $\\beta_{0}^{\\prime}$ are implemented:\n\n\\section*{- BETAPRIME\\_TYPE='ref'}\nThe value of $\\beta_{0}^{\\prime}$ is given as an input in BETAPRIME\\_REF.\n\n\\begin{itemize}\n  \\item BETAPRIME\\_TYPE='sp'\n\\end{itemize}\n\nThe value of $\\beta_{0}^{\\prime}$ is made consistent with the species parameters and the value of $\\beta_{N}$ defined above using Eq. 9.4. The value given as an input in BETAPRIME\\_REF is not used and replaced by the calculated value\n\n\\begin{itemize}\n  \\item BETAPRIME\\_TYPE='eq'.\n\\end{itemize}\n\nThe value of $\\beta_{0}^{\\prime}$ is read from the MHD equilibrium file. The value given as an input in BETAPRIME\\_REF is not used and replaced by the calculated value.\n\nNote that when the species parameters are used, ALL species are considered including the adiabatic one.\\\\\nReminder: if GEOM\\_TYPE = 'chease', the values of $R_{\\mathrm{ref}}$ and $B_{\\mathrm{ref}}$ used in GKW are the values R0EXP and B0EXP given as an input to CHEASE. It is advised that R0EXP and B0EXP are chosen to be the radius of the magnetic axis and the value of the magnetic field at this position respectively for better convergence in CHEASE.\n\n\\subsection*{9.3.7 Generating a linear growth rate spectrum}\nGKW currently outputs the global growth rate (and frequency) in time.dat so the easiest way to generate a growth rate spectrum is do a batch of linear runs with $N M O D=1$, mode\\_box =.false., and $N X=1$, and scan over kthrho and take the growth rate from each. The matlab scripts create\\_gkwscan.m and growth\\_rate\\_spec.m help with creating the input and plotting the output; script gkwnlin runs the batch jobs.\n\nAlternatively, a growth rate (frequency) spectrum can be generated by running with mode\\_box=.true. and setting lgrowth\\_rates=.true. (lfrequencies=.true.)in the DIAGNOSTIC namelist. For each toroidal mode, the growth rate and of the mode with $k_{\\psi}=0$ will be output. To get this spectrum to exactly match a spectrum generated by the first method at higher $k_{\\zeta}$ will require large $N X$ (and low ikxspace) to fully resolve the mode along the field line. The excercise of matching the spectra generated by these two methods will require the user to understand the mode coupling over the parallel boundary condition and will indicate the $n x$ resolution required for mode\\_box=true and nonlinear runs.\n\n\\subsection*{9.3.8 Restarts and checkpoints}\nOn a successful exit, GKW writes a binary file FDS which contains the distribution function needed for a restart. Along with the input file, this is the only file required to restart the code. For seamless continuation, some other quantities such as file counters and normalized time are also written to the ASCII file FDS.dat which contains Fortran namelist which the code reads. The binary restart file is written using MPI-IO and is independent of processor layout. This means that runs can be restarted with different parallelizations from the original run.\n\nGKW will only attempt to restart from the above files if read\\_file $=T$ in the CONTROL namelist. If it does not find any files, it will initialize a new run. Under the default behaviour, when this subsequent run completes, a restart files FDS and FDS. dat will be overwritten. This behavior can be altered by setting the integer irun in the CONTROL namelist which allows incremental numbering of restart files. If irun=1, FDS is read if present and FD1 is written. If irun=2, FD1 is read and FD2 is written, and so on.\n\nFor systems on which MPI-IO is not available or problematic ${ }^{7}$, GKW can also be made to write a legacy restart file format, in which each processor writes its own file FDSXXXXXX numbered by processor (option restart\\_file\\_version $=1$ in CONTROL). In this case, restarts may not alter the parallelization.\n\nIntermediate checkpoints can also be written by setting the integer n\\_dump\\_ts=50 in the CONTROL namelist, to write, for instance a checkpoint every 50 large timesteps. This is strongly advised for any expensive nonlinear simulation. Two restart files DM1/2 are alternately overwritten by a newer one each time. These files have exactly the same format as the final restart file FDS and can be used for a restart by simple renaming. One should note that if restarting an interrupted run from a checkpoint, some the time trace files may have duplicated lines, which can be easily verified by checking or plotting column 1 of time.dat.\n\nA clean exit can be requested at anytime while the code is running by creating a file named gkw.stop in the run directory. An additional checkpoint file can be created by instead creating a file named gkw.dump, after which the code will continue to run.\n\nSome batch systems will automatically resubmit a job which is terminated by a hardware problem; to allow GKW to automatically restart from the DM1/2 files (and take precedence over FDS files) if present, set auto\\_restart $=T$ in the CONTROL namelist. GKW could also be made to interface with batch systems which are provide accounting flexibility for codes able to halt on request, by means of the gkw.stop file creation mechanism.\n\n\\footnotetext{${ }^{7}$ For large problems with more than about 64 processes, there can be problems/errors when reading/writing the restart files in parallel, depending the filesystem and the MPI implementation. This has been observed on some Cray XT4 machines, where in some cases it was necessary to modify environment variables to successfully write restart files. There is also a workaround in the code which must be set at compile time via adjustments to two variables in switches.F90: Rather than writing to file with all processes simultaneously, this allows writes with subsets of processes at a time, where the file is closed then re-opened between subsets. Increasing the number of subsets reduces overheads and can allow files to be written successfully. This might also improve the I/O performance on machines, where such operations already work. However, if the number of subsets is too large, the I/O performance will suffer. The variable min\\_fdisi\\_io\\_subsets selects the minimum number of process subsets to use. When problems are encountered, it is suggested to first try setting this value to the value of $n_{-} p r o c s_{-} s p$, then to n\\_procs\\_sp*n\\_procs\\_s if problems persist. Using larger values will likely give very poor performance, but may be necessary. The other variable, min\\_procs\\_io\\_split, sets the minimum number of processes for which the read/write split should be used.\n}\\subsection*{9.3.9 Tips and tricks}\nThis section aims to document other useful things to know when running the code. Please add here anything else useful to the user that we have yet to document properly. Received wisdom, etc.\n\n\\begin{itemize}\n  \\item The linear timestep estimator is based on the Courant condition for the Vlasov equation, and the frequency of shear-Alfv\u00e8n wave [70], so it is not foolproof for some high frequency waves (e.g. ETG). If GKW gives unphysicaly large growth rates, the first thing one should try is to reduce the timestep (no more than a factor of two at a time). If your problem requires a very small timestep (less than $1 \\mathrm{e}-6)$, something else is likely to be wrong, but if a very small timestep is really required it may be best to run with normalized=.false. Equally, for most efficient resource usage, one should try to find the upper limit of the stable timestep.\n  \\item For nonlinear kinetic runs, adding a small electromagnetic component e.g. $\\beta=0.03 \\%$ can stabilise some long wavelength instabilities (electrostatic shear-Alfv\u00e8n waves), allowing a much larger stable timestep, as suggested in [71].\n  \\item The nonlinear timestep estimator rarely manages to prevent blowup in the event of numerical instability, but can be useful for strongly nonlinear physics. For very large numbers of processors it may cause an overhead which reduces the scaling efficiency. It can therefore be disabled by setting. nl\\_dtim\\_est=F in the CONTROL namelist, which will cause the code will abort rather than continue if the timestep estimate is violated. The code could then be restarted from the previous dumpfile with the nonlinear timestep estimator enabled, or with a smaller timestep.\n  \\item The nonlinear timestep estimator is often too conservative. If your problem is limited by the nonlinear timestep, it may be possible to save CPU resources by increasing it (no more than $90 \\%$ ) by setting e.g. fac\\_nl\\_est $=1.6$ in CONTROL.\n  \\item Don't be tempted to use more cores than you need. Pushing the parallelisation to its limit (particularly less than 4 points per processor in parallel velocity) will result in inefficient scaling.\n  \\item Be aware of the effects of the boundary condition at the end of the field line. If not running a box of modes, you should check that nperiod is large enough so that the results are insensitive to the free boundary. If running with mode\\_box, care should be taken with the radial mode resolution so that most toroidal modes have several periods and do not feel the effect of the boundary. This is particularly important when kinetic electrons are used.\n\\end{itemize}\n\n\\subsection*{9.3.10 Hybrid scheme}\nHybrid parallelism combining distributed memory MPI parallelism with shared memory OpenMP parallelism has been implemented to allow the code to scale further, and more efficiently. Many modern high performance machines now have an architecture with a number of shared memory CPU cores on each node (2-24), and a large number of these nodes connected by a fast network interconnect. The communication between nodes is much slower than between cores, and a well optimised and well utilised MPI implementation will take advantage of this by putting the most intensive communication on the local node. In cases where this is not done, or cases where a subset of the problem grid does not fit nicely on a single node, the efficiency of the inter-node communication may be increased by reducing the number of MPI processes involved in the intra-node communication. For example, on a machine with 8 cores per node (e.g. HPC-FF), 1024 processors can be utilised with the combinations (number of MPI processes, number of OpenMP threads per node) $=$ $(1024,1),(512,2),(256,4)$, or $(128,8)$, where the lower number of MPI processes in the latter case may result in a more efficient reduction sum (though in theory the amount of inter-node data communicated by the ideal MPI implementation would remain the same).\n\nIn GKW, hybrid parallelism (for the spectral scheme only) is achieved by subdividing the most CPU intensive loops amongst OpenMP threads. The slowest of these is the loop in nonlinear terms, where for each local grid point, $5-7$ FFTS in 2 D must be performed. At the maximum limit on the number of MPI processes, there will always be at least 2 ( 4 with collisions) points in this loop (it contains $N M U^{*} N S P^{*} N S$ local grid\\\\\npoints) which can be divided between threads. (The code could be rewritten here to increase the number of threads that can be used in this section, if the hybrid scheme is demonstrated to bring a clear benefit at these numbers of threads). The second largest loop which must be parallelised is the sparse matrix-vector multiply involved in the linear terms. Due to the sparse matrix storage format, this loop cannot be vectorised, but cache efficiency can be maximised by an appropriate sorting of the matrix. After this sort, the matrix elements are subdivided between threads at carefully chosen boundaries, to ensure there is no data race in the update of the right hand side. The same technique is used for the fields calculation. All possible smaller loops ( $<5 \\%$ runtime) are also parallelised with OpenMP, but here there are diminishing returns here due to the overhead involved in thread branching. This inherently serial element of the code will set the limit of the number of threads that can efficiently be used (likely four at present).\n\nThe hybrid scheme with OpenMP parallelism can allow GKW to scale better in certain situations for large runs. Tests on HPC-FF and Babel Bluegene machines (combined with some reasoning), suggest that the cases in which it is most likely to be useful are those in which the MPI communications are the bottleneck. When this occurs depends on the problem and the hardware. These situations are likely to include one or more of the following:\n\n\\begin{itemize}\n  \\item Problems with large numbers of modes\n  \\item Problems with collisions (4 threads has been demonstrated to bring a benefit here)\n  \\item Runs on very large numbers of processsors, near the limit of GKW MPI capability\n  \\item Hardware with slow communication (HPC-FF or BlueGene as opposed to Hector)\n\\end{itemize}\n\nPreliminary tests with the hybrid scheme on up to 1536 processors (on HPC-FF: IBM-Intel-Xeon-Infiniband) demonstrated up to a $5 \\%$ performance increase using two OpenMP threads per node. More extensive scaling tests on Bluegene/P BABEL have demonstrated a scaling efficiency increase of up to $20 \\%$ with 4 threads when running a collisional case on 8192 cores and above (for more details see Sec. 8.12).\n\nYou are advised to do some brief checks for your problem and hardware to determine if the hybrid scheme is an advantage. Best results will probably be obtained using the hybrid scheme with no more than four OpenMP threads per MPI process. For acceptable results, the number of threads must be a factor of the local processor gridsize $N M U^{*} N S P^{*} N S$ (which is also the maximum number of threads), as a loop of this size is parallelised in the nonlinear terms.\n\nTo use the hybrid scheme, you need a compiler that supports OpenMP. You will need to compile with SMP =OPENMP preprocessor flag, openmp compiler flag, and link with the correct libraries (by using the same compiler flag). In the standard makefile build process, this is usually achived by setting\n\n\\begin{verbatim}\nSMP=OPENMP\nFFLAGS_OMP=-openmp (for intel, or -fopenmp for gnu)\n\\end{verbatim}\n\nUsing the compile optimisations specific to the processor is also recommended.\n\n\\subsection*{9.4 Example GKW input file}\nFurther example input files are provided with the code, including a comprehensive input file input.dat.sample, a minimal input input.dat.minimum, and input files for some common benchmark cases in input/.\n\n\\begin{verbatim}\n&CONTROL !Namelist read in module CONTROL\n    non_linear = .false. !Include the non linear terms, computationally expensive fft\n    zonal_adiabatic = .false.,!If zonal flows correction included for adiabatic electrons\n    order_of_the_scheme = 'fourth_order' !or 'second_order' in space\n    dtim = 0.02 !Time step size (normalised time)\n    ntime = 25, !Number of iterations of NAVERAGE.\n    naverage = 100, !Number of timesteps between re-normalisation, data output\n    nlapar = .false., !true = keep parallel electro-magnetic potential.(electrostatic=false)\n    nlbpar = .false., !true = keep compressional magnetic field (electrostatic=false)\n    collisions = .false. !Turn on the collision operator\n    disp_par = 1.0 !Dissipation coefficient for parallel derivatives.\n    disp_vp = 0.0 !Dissipation coefficient for parallel velocity space\n    max_seconds = 1000. !Internal program kill time.\n    gamatol = 0. !tolerance in the linear growth rate for which the code should stop\n    io_format = 'ascii' !chose output format to be ascii\n/\n&GRIDSIZE !Namelist read in module GRID\n    nx = 83, !Number of radial wave vectors - needs to be an odd number for fft\n    n_s_grid = 50, !Number of grid points along the field line\n    nperiod = 1, !Integer - the field line makes 2*nperiod - 1 poloidal turns.\n    n_mu_grid = 8, !Number of magnetic moment grid points\n    n_vpar_grid = 32, !Number of grid points for parallel velocity\n    nmod = 21, !Number of bi-normal modes (k_zeta)\n    number_of_species = 1 !Number of kinetic species.\n/\n&MODE !Namelist read in module MODE\n    kthrho = 0.5,1.0, !'Poloidal' wavevector(s) if mode_box=.false.\n    mode_box = .true., !Determines if there is a 2D grid of modes. If true use nperiod = 1\n    !Also determines if radial modes are coupled at end of field line.\n    krhomax = 1.0, !For mode_box, the maximum 'poloidal' wavevector (k_perp rho_i) used\n    krhomax = 1.0, !For mode_box, the maximum 'poloidal' wavevector (k_perp rho_i) us,\n    !rho_i evaluated on the flux surface at the major radius of magnetic axis\n    ikxspace = 7, !Spacing between radial modes (resolution against box size)\n/\n&SPCGENERAL !Namelist read in module COMPONENTS\n    beta_ref = 0.000, !Plasma beta (not used if both nlapar, nlbpar are .false.)\n    adiabatic_electrons = .true. !Kinetic electrons require a smaller timestep\n/\n&SPECIES !Namelist read in module COMPONENTS\n    mass = 1.0, !Species mass in terms of reference mass\n    z = 1.0, !Species charge. If negative, assumed to be the electrons.\n    temp = 1., !Temperature of species scaled by reference temperature\n    dens = 1., !Density of species scaled by reference density\n    rlt = 8, !Temperature gradient R/LT\n    rln = 3.5, !Density gradient R/Ln\n    uprim = 0.0, !Gradient of the toroidal rotation Rref^2 grad Omega / v_thref\n/\n&SPECIES\n    mass = 2.72e-4, !Electrons\n    z = -1.0, !Only one negatively charged species is allowed.\n    temp = 1.0,\n    dens = 1.0,\n    rlt = 7.9,\n    rln = 3.5,\n    uprim = 0.0,\n/\n&GEOM !Namelist read in module GEOM, s-alpha is default geometry\n    shat = 1.0, !Magnetic shear\n    q = 2.0, !Safety factor\n    eps = 0.1 !Radial Coordinate\n/\n&ROTATION\n    vcor = 0.0\n    shear_rate = 0.0\n    shear_profile = 'none'\n    cf_trap = .true.\n    cf_drift = .true.\n/\n&COLLISIONS !Namelist read in module COLLISONOP if collisions = .true.\n    rref = 1 !reference major radius used in collision operator\n    tref = 1 !reference temperature in units of kev used for the collision operator\n    nref = 1 !reference density in units 10^19 m^-3 used for the collision operator\n    mom_conservation = .false. !Use the correction to conserve momentum\n    mass_conserve = .true., !Forces zero flux boundary on velocity space so no out flow of mass\n    freq_override=.false. !Manually specify ii collision frequency to override ref values\n    coll_freq=6.515E-5 !Ion-ion collision frequency used if freq_override=.true.\n/\n    !Namelist read in module ROTATION\n    !Rotation of the plasma vcor = Rref Omega / vthref = \\Omega_N\n    !Normalised shearing rate for the E x B perpendicular shear\n    !To include a shear flow, use 'wavevector_remap'\n    !Include the centrifugal trapping effects\n    !Include the centrifugal drift\n\\end{verbatim}\n\n\\section*{Chapter 10}\n\\section*{Diagnostics}\nIn GKW, each diagnostic constitutes a separate module diagnos\\_foobar. The distinction between modules is mainly made by the physical quantities they compute - and usually not their dimensionality.\n\nA template with some typical code snippets and comments on writing new diagnostics can be found in diagnos\\_template.F90.\n\n\\subsection*{10.1 Fluxes (module diagnos\\_fluxes)}\nThe fluxes are calculated as guiding centre fluxes (flux surface averaged) and are given by the equations\n\n\n\\begin{equation*}\n\\left\\{\\boldsymbol{\\Gamma}_{i} \\cdot \\nabla \\psi\\right\\}=\\Gamma_{i}^{\\psi}=\\left\\{\\int \\mathrm{d}^{3} \\mathbf{v} \\tilde{\\mathbf{v}}_{E} \\cdot \\nabla \\psi \\alpha_{i} f\\right\\}+\\left\\{\\int \\mathrm{d}^{3} \\mathbf{v} \\tilde{\\mathbf{v}}_{\\delta B} \\cdot \\nabla \\psi \\alpha_{i} f\\right\\}+\\left\\{\\int \\mathrm{d}^{3} \\mathbf{v} \\tilde{\\mathbf{v}}_{\\nabla B_{1 \\|}} \\cdot \\nabla \\psi \\alpha_{i} f\\right\\} \\tag{10.1}\n\\end{equation*}\n\n\nfor the electro-static and electro-magnetic (due to magnetic flutter and compression) fluxes, respectively. In the above equation all quantities are dimensional and unnormalised (with the exception of the dimensionless coordinate $\\psi=\\epsilon$ ), and $i=(1,2,3)$ with $\\alpha_{i}=\\left(1, v^{2} / 2, \\frac{s_{\\mathrm{B}} R B_{t}}{B} m v_{\\|}\\right)$, i.e. $i=1$ is the normalised particle flux, $i=2$ is the heat flux, $i=3$ is the toroidal angular momentum flux (with the toroidal flow counted positive in the toroidal direction, clockwise from above). The toroidal angular momentum is the quantity that is conserved in tokamaks, and toroidal angular momentum flux is what enters the 1D transport equation. This flux is positive for outward flux of plasma rotating in the toroidal direction (clockwise from above), which differs from the parallel direction when $s_{B}=-1$.\n\nBoth the potential and the distribution function are represented as a sum over Fourier modes. Since the flux contains an average over space it will be zero unless the wave vectors of the potential and distribution function add up to be zero. In the representation of modes used in this manuscript this means that a particular wave vector of the representation of $f$ must be combined with the complex conjugate of the same wave vector in the representation of $\\phi$ or $A_{\\|}$(sec. 10.4), i.e.\n\n", "\n\\begin{equation*}\n\\left\\langle\\hat{v}_{E} f\\right\\rangle=2 \\sum_{m} \\operatorname{Re}\\left[\\left\\langle\\hat{\\mathbf{v}}_{E m}^{\\dagger} \\cdot \\nabla \\psi \\hat{f}_{m}\\right\\rangle\\right] \\tag{10.2}\n\\end{equation*}\n\n\nwhere $\\sum_{m}=\\sum_{k_{\\zeta, \\min }}^{k_{\\zeta, \\max }} \\sum_{-k_{\\psi, \\max }}^{k_{\\psi, \\max }}$ is the sum over the modes as kept in the code (noting that zero-mode does not contribute to the fluxes), $\\hat{v}_{E m}$ and $\\hat{f}_{m}$ are the Fourier amplitudes of the $E \\times B$ velocity and distribution function of the mode $m$ respectively, and the dagger denotes the complex conjugate. Substituting the various\\\\\ndefinitions one can derive the expression for the normalised fluxes (electro-static and electro-magnetic)\n\n\n\\begin{align*}\n& \\mathcal{I}_{i}=\\sum_{m}\\left\\{2 \\mathcal{E}^{\\psi \\beta} k_{\\beta m} \\int 2 \\pi B \\mathrm{~d} \\mu \\mathrm{~d} v_{\\|} \\hat{\\alpha}_{i} \\operatorname{Im}\\left[\\left\\langle\\hat{\\phi}_{m}\\right\\rangle^{\\dagger} \\hat{f}_{m}\\right]\\right\\}=\\sum_{m}\\left\\{\\overline{\\mathcal{I}}_{i}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right\\},  \\tag{10.3}\\\\\n& \\mathcal{J}_{i}=-2 \\sum_{m}\\left\\{2 \\mathcal{E}^{\\psi \\beta} k_{\\beta m} \\int 2 \\pi B \\mathrm{~d} \\mu \\mathrm{~d} v_{\\|} \\hat{\\alpha}_{i} v_{R} v_{\\|} \\operatorname{Im}\\left[\\left\\langle\\hat{A}_{\\| m}\\right\\rangle^{\\dagger} \\hat{f}_{m}\\right]\\right\\}=\\sum_{m}\\left\\{\\overline{\\mathcal{J}}_{i}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right\\},  \\tag{10.4}\\\\\n& \\mathcal{K}_{i}=2 \\sum_{m}\\left\\{2 \\mathcal{E}^{\\psi \\beta} k_{\\beta m} \\int 2 \\pi B \\mathrm{~d} \\mu \\mathrm{~d} v_{\\|} \\hat{\\alpha}_{i} \\frac{\\mu T_{R}}{Z_{s p}} \\operatorname{Im}\\left[\\left\\langle\\hat{B}_{\\| m}\\right\\rangle^{\\dagger} \\hat{f}_{m}\\right]\\right\\}=\\sum_{m}\\left\\{\\overline{\\mathcal{K}}_{i}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right\\} \\tag{10.5}\n\\end{align*}\n\n\nwhere here all quantities are normalised and $\\sum_{m}\\{ \\}=\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{s} \\mathrm{~d} s$ is a sum over all modes and a flux surface average over $s$, and where $\\hat{\\alpha}_{i}=\\left(1, v^{2}, \\frac{s_{\\mathrm{B}} R B_{t}}{B} v_{\\|}\\right)$. (In the code, the factor $2 \\pi$ from the velocity space Jacobian is included in the array intmu $=2 \\pi \\Delta \\mu$ ).\n\nThe fluxes in physical units can be obtained from\n\n\n\\begin{align*}\n& R_{\\mathrm{ref}} \\Gamma_{s}^{\\psi}=n_{R_{0}, s} \\rho_{*}^{2} v_{\\text {thref }}\\left(\\mathcal{I}_{1}+\\mathcal{J}_{1}+\\mathcal{K}_{1}\\right)  \\tag{10.6}\\\\\n& R_{\\mathrm{ref}} Q_{s}^{\\psi}=n_{R_{0}, s} T_{s} \\rho_{*}^{2} v_{\\text {thref }}\\left(\\mathcal{I}_{2}+\\mathcal{J}_{2}+\\mathcal{K}_{2}\\right)  \\tag{10.7}\\\\\n& R_{\\mathrm{ref}} \\Pi_{\\phi s}^{\\psi}=m_{s} n_{R_{0}, s} v_{\\text {ths }} R_{\\mathrm{ref}} \\rho_{*}^{2} v_{\\text {thref }}\\left(\\mathcal{I}_{3}+\\mathcal{J}_{3}+\\mathcal{K}_{3}\\right) \\tag{10.8}\n\\end{align*}\n\n\nfor particle, heat, and angular momentum fluxes respectively $\\left(\\Gamma_{s}^{\\psi}, Q_{s}^{\\psi}, \\Pi_{\\phi s}^{\\psi}\\right.$ are the contravariant components of the flux and therefore have units of particle, heat, angular momentum flux per unit length respectively). Note: In some GKW publications the flux of parallel momentum $\\Gamma_{\\|}$has been used. This is meaningful only for the $s-\\alpha$ geometry in which the finite $\\epsilon$ terms are neglected, in which case $\\Pi=R_{\\text {ref }} \\Gamma_{\\|}$.\n\nNote that when calculating momentum diffusivity, the definition of $u^{\\prime}$ relative to $v_{\\text {thref }}$ means that the factor $v_{R}=v_{t h i} / v_{\\text {thref }}$ must be inserted if $T_{\\text {ref }} \\neq T_{i}$. The Prandtl number (for example) is therefore calculated as\n\n\n\\begin{equation*}\n\\operatorname{Pr}=\\frac{\\mathcal{I}_{3}}{\\mathcal{I}_{2}} \\frac{R / L_{T}}{u^{\\prime}} v_{R} \\tag{10.9}\n\\end{equation*}\n\n\nThe suprema of the fluxes (for which we use the notation $\\hat{\\mathcal{I}}_{i}, \\hat{\\mathcal{J}}_{i}, \\hat{\\mathcal{K}}_{i}$ ), are defined the same way as the fluxes in equation 10.3 etc, but replacing $\\hat{f}_{m} \\rightarrow-i\\left|\\hat{f}_{m}\\right|$ and $\\hat{\\phi} \\rightarrow|\\hat{\\phi}|$. The fluxes suprema represent the largest possible fluxes for the fluctuation amplitudes, which would occur if the fluctuations were out of phase by $\\pi / 2$. The ratio between the fluxes and the flux suprema\n\n\n\\begin{equation*}\n\\frac{\\mathcal{I}_{i}}{\\hat{\\mathcal{I}}_{i}}=\\sin \\{\\hat{\\theta}\\} \\tag{10.10}\n\\end{equation*}\n\n\nthen contains the cross phase information, where $\\{\\hat{\\theta}\\}$ is the average phase angle between the fluctuating quantites in the flux (note, that from this ratio one cannot distiguish phase angles outside the principal value).\n\n\\subsection*{10.2 Fluxes in more detail (module diagnos\\_fluxes\\_vspace)}\nThere is the possibilibty to output the unintegrated fluxes by setting the switch lfluxes\\_detail, with contributions of all field fluctuations which are considered by the run.\n\n\n\\begin{align*}\n\\overline{\\mathcal{I}}_{i}\\left(k_{\\psi}, k_{\\zeta}, s, \\mu, v_{\\|}\\right) & =2 \\mathcal{E}^{\\psi \\beta} k_{\\beta m} 2 \\pi B \\mathrm{~d} \\mu \\mathrm{~d} v_{\\|} \\hat{\\alpha}_{i} \\operatorname{Im}\\left[\\left\\langle\\hat{\\phi}_{m}\\right\\rangle^{\\dagger} \\hat{f}_{m}\\right] \\mathrm{d}^{3} X  \\tag{10.11}\\\\\n\\overline{\\mathcal{J}}_{i}\\left(k_{\\psi}, k_{\\zeta}, s, \\mu, v_{\\|}\\right) & =-2 \\cdot 2 \\mathcal{E}^{\\psi \\beta} k_{\\beta m} 2 \\pi B \\mathrm{~d} \\mu \\mathrm{~d} v_{\\|} \\hat{\\alpha}_{i} v_{R} v_{\\|} \\operatorname{Im}\\left[\\left\\langle\\hat{A}_{\\| m}\\right\\rangle^{\\dagger} \\hat{f}_{m}\\right] \\mathrm{d}^{3} X  \\tag{10.12}\\\\\n\\overline{\\mathcal{K}}_{i}\\left(k_{\\psi}, k_{\\zeta}, s, \\mu, v_{\\|}\\right) & =2 \\cdot 2 \\mathcal{E}^{\\psi \\beta} k_{\\beta m} 2 \\pi B \\mathrm{~d} \\mu \\mathrm{~d} v_{\\|} \\hat{\\alpha}_{i} \\frac{\\mu T_{R}}{Z_{s p}} \\operatorname{Im}\\left[\\left\\langle\\hat{B}_{\\| m}\\right\\rangle^{\\dagger} \\hat{f}_{m}\\right] \\mathrm{d}^{3} X \\tag{10.13}\n\\end{align*}\n\n\n\\subsection*{10.3 Growth rates, Frequencies (module diagnos\\_growth\\_freq) and Quasi-linear fluxes}\nFor a linear run, the dominant (overall) mode growth rate is calculated as\n\n\n\\begin{equation*}\n\\gamma^{\\max }(t)=\\ln \\left[\\frac{\\sqrt{\\sum_{m} \\int|\\hat{\\phi}(t)|^{2}+\\left|\\hat{A}_{\\|}(t)\\right|^{2}+\\left|\\hat{B}_{\\|}(t)\\right|^{2} \\mathrm{~d} s}}{\\sqrt{\\sum_{m} \\int|\\hat{\\phi}(t-\\Delta t)|^{2}+\\left|\\hat{A}_{\\|}(t-\\Delta t)\\right|^{2}+\\left|\\hat{B}_{\\|}(t-\\Delta t)\\right|^{2} \\mathrm{~d} s}}\\right] / \\Delta t . \\tag{10.14}\n\\end{equation*}\n\n\nThe corresponding total mode frequency is calculated as\n\n\n\\begin{equation*}\n\\omega(t)=\\left[\\operatorname{Arg}\\left(\\sum_{m} \\int \\hat{\\phi}(t)+\\hat{A}_{\\|}(t)+\\hat{B}_{\\|}(t) \\mathrm{d} s\\right)-\\operatorname{Arg}\\left(\\sum_{m} \\int \\hat{\\phi}(t-\\Delta t)+\\hat{A}_{\\|}(t-\\Delta t)+\\hat{B}_{\\|}(t-\\Delta t) \\mathrm{d} s\\right)\\right] / \\Delta t \\tag{10.15}\n\\end{equation*}\n\n\nThese values are output in columns 2 and 3 of time.dat respectively. Positive values of $\\omega(t)$ indicate propagation in the direction of $B \\times \\nabla B$ (opposite to $\\nabla \\zeta$ ), which for $s_{\\mathrm{j}}=1$ and $R / L_{n}>0$ is in the ion diamagnetic drift direction. In a run with mode\\_box $=F$ (including nonlinear runs), per mode growth rates and frequencies are also produced in a similar way in the files growth. dat and frequencies.dat. For these diagnostics, however, only the $k_{\\psi}$ modes connected to the $k_{\\psi}=0$ by the condition Eq. 2.254 mode are included in the sum, which makes these mode properties directly comparable to a run with mode\\_box $=F$ and $\\theta_{0}=C H I N=0$.\n\nIn the case of runs with mode\\_box $=T$, the values above (always written to time. dat) correspond to a global growth rate and frequency summed over all modes, which usually corresponds closely to the fastest growing mode. In addition, the growth rate and frequencies for each individual mode connected to $k_{\\psi}=0$ are also calculated and written to the files growth.dat and frequencies.dat.\n\nFor a normalised linear run, the solution is normalised by\n\n\n\\begin{equation*}\n\\sqrt{\\sum_{m} \\int|\\hat{\\phi}(t)|^{2}+\\left|\\hat{A}_{\\|}(t)\\right|^{2}+\\left|\\hat{B}_{\\|}(t)\\right|^{2} \\mathrm{~d} s} \\tag{10.16}\n\\end{equation*}\n\n\nwhich means that the outputs in fluxes. dat correspond to\n\n\n\\begin{equation*}\n\\left(\\mathcal{I}_{i}, \\mathcal{J}_{i}, \\mathcal{K}_{i}\\right) /\\left(\\sum_{m} \\int|\\hat{\\phi}(t)|^{2}+\\left|\\hat{A}_{\\|}(t)\\right|^{2}+\\left|\\hat{B}_{\\|}(t)\\right|^{2} \\mathrm{~d} s\\right) \\tag{10.17}\n\\end{equation*}\n\n\nand can therefore be used directly in Quasi-linear models. When comparing with nonlinear or unnormalised runs (at least in the linear phase), these Quasi-linear normalised values in fluxes.dat should be directly comparable to the values in the fluxes spectra divided by the sum of the per mode values in the files kyspec and kyspec\\_em.\n\n\\subsection*{10.4 Hermitian symmetry of binormal spectra}\nMany diagnostics calculate quantities which are quadratic in the perturbations and output them either as $k_{\\zeta}$ spectra or integrated over $k_{\\zeta}$. According to what is often called Parseval's Theorem one can integrate the Fourier-space field.\n\n\n\\begin{align*}\n\\int \\mathrm{d} \\zeta|f(\\zeta)|^{2} & =\\int \\mathrm{d} k_{\\zeta}\\left|\\hat{f}\\left(k_{\\zeta}\\right)\\right|^{2} \\\\\n\\int \\mathrm{~d} \\zeta f(\\zeta) \\phi(\\zeta) & =\\int \\mathrm{d} k_{\\zeta} \\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right) \\tag{10.18}\n\\end{align*}\n\n\nThe Fourier representation of a real-valued field possesses Hermitian symmetry, as\n\n\n\\begin{equation*}\n\\hat{f}\\left(k_{\\zeta}\\right)=\\frac{1}{2 \\pi} \\int \\mathrm{~d} \\zeta f(\\zeta) e^{i k_{\\zeta} \\zeta} \\tag{10.19}\n\\end{equation*}\n\n\none finds\n\n\n\\begin{equation*}\n\\hat{f}\\left(-k_{\\zeta}\\right)=\\frac{1}{2 \\pi} \\int \\mathrm{~d} \\zeta f(\\zeta) e^{i\\left(-k_{\\zeta}\\right) \\zeta}=\\hat{f}^{*}\\left(k_{\\zeta}\\right) \\quad \\text { and also } \\quad \\hat{f}\\left(-k_{\\zeta},-k_{\\psi}\\right)=\\hat{f}^{*}\\left(k_{\\zeta}, k_{\\psi}\\right) \\tag{10.20}\n\\end{equation*}\n\n\nThis symmetry allows the FFT libraries and GKW to save unnecessary memory for $k_{\\zeta}$-space quantities. For a position space grid having $n_{-} y \\_$grid elements, the Fourier space representation has in principle also $n_{-} y \\_g r i d$ coefficients, but due to the symmetry, only floor $\\left(\\frac{n_{-}-\\text {grid }}{2}\\right)+1=$ nmod of them are stored in memory (Note that in contrast to this, radially spectral quantities have n\\_x\\_grid elements). When it comes to integration, the sum $\\int \\mathrm{d} k_{\\zeta}$ is to be taken over all $n_{-} y_{\\_} g r i d$ coefficients, however.\n\n\n\\begin{align*}\n& \\int \\mathrm{d} k_{\\zeta} \\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right) \\hat{=} \\hat{f}^{*}(0) \\hat{\\phi}(0)+\\sum_{-k_{\\zeta, \\text { max }}}^{-\\Delta k_{\\zeta}} \\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right)+\\sum_{\\Delta k_{\\zeta}}^{k_{\\zeta, \\text { max }}} \\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right) \\\\\n& \\hat{=} \\hat{f}^{*}(0) \\hat{\\phi}(0)+\\sum_{k_{\\zeta, \\text { max }}}^{\\Delta k_{\\zeta}} \\hat{f}^{*}\\left(-k_{\\zeta}\\right) \\hat{\\phi}\\left(-k_{\\zeta}\\right)+\\sum_{\\Delta k_{\\zeta}}^{k_{\\zeta, \\text { max }}} \\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right) \\\\\n& \\hat{=} \\hat{f}^{*}(0) \\hat{\\phi}(0)+\\sum_{k_{\\zeta, \\text { max }}}^{\\Delta k_{\\zeta}}\\left(\\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right)\\right)^{*}+\\sum_{\\Delta k_{\\zeta}}^{k_{\\zeta, \\text { max }}} \\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right) \\\\\n& \\hat{=} \\hat{f}^{*}(0) \\hat{\\phi}(0)+\\sum_{k_{\\zeta, \\text { max }}}^{\\Delta k_{\\zeta}} 2 \\Re\\left\\{\\hat{f}^{*}\\left(k_{\\zeta}\\right) \\hat{\\phi}\\left(k_{\\zeta}\\right)\\right\\} \\tag{10.21}\n\\end{align*}\n\n\nHence an integral over a modulus square has to be computed as\n\n\n\\begin{equation*}\n\\int \\mathrm{d} k_{\\zeta}\\left|f\\left(k_{\\zeta}\\right)\\right|^{2} \\hat{=} \\hat{f}^{*}(0) \\hat{f}(0)+\\sum_{k_{\\zeta, \\max }}^{\\Delta k_{\\zeta}} 2\\left|\\hat{f}\\left(k_{\\zeta}\\right)\\right|^{2} \\tag{10.22}\n\\end{equation*}\n\n\nTo simplify the code and to make the factor 2 explicit, the array parseval\\_correction was introduced. Here is an example of how it is used:\n\n\\begin{verbatim}\nreal :: integral = 0.0\ninteger :: ix = 1, i = 2, j = 3, k = 4, is = 1\n! integrate |f|**2 over zeta, with all other coordinates fixed to some value\ndo imod = 1, nmod\n    integral = integral + parseval_correction(imod) *\n        abs(get_f_from_g(imod,ix,i,j,k,is,fdisi))**2\nend do\n\\end{verbatim}\n\nSeveral diagnostics output binormal spectra. Note that some of these contain the factor 2 (e.g. the entropy entr from diagnos\\_energetics), while others do not (e.g. the intensity spectrum kyspec from diagnos\\_fields). While for some considerations the factor 2 in front of the non-zonal-mode contributions may not matter much for the qualitative picture, it is usually important to consider it if the quantity has to fulfill certain consistency conditions.\n\n\\subsection*{10.5 Tips for unit conversions}\nAlthough GKW uses the thermal velocity $(\\sqrt{2 T / m})$ for normalisation, it is common in the literature to use the gyro-Bohm $(\\mathrm{GB})$ units of sound speed $c_{s}=\\sqrt{T_{e} / m_{i}}$ and the corresponding Larmor radius $\\rho_{s}=$\\\\\n$c_{s} / \\omega_{c i}$, where $\\omega_{c i}=e B_{\\mathrm{ref}} / m_{i}$ is the ion cyclotron frequency, and the index i (e) corresponds to the ions (electrons). The user should note that the definition of $B$ used to define $c_{s}$ and $\\rho_{s}$ may vary between codes and publications.\n\nIn the usual case where $m_{i}=m_{\\text {ref }}$, the sound speed is $c_{s}=v_{\\text {thref }} \\sqrt{T_{R e} / 2}$, the Larmor radius is $\\rho_{s}=$ $\\rho_{\\mathrm{ref}} \\sqrt{T_{R e} / 2}$, and the GKW wavevectors have $k_{\\perp} \\rho_{\\mathrm{ref}}=k_{\\perp} \\rho_{s} \\sqrt{T_{R e} / 2} .{ }^{1}$\n\nThe time normalisation converts to GB units as\n\n\n\\begin{equation*}\nt_{N}=\\frac{v_{\\text {thref }}}{R_{\\mathrm{ref}}} t=\\sqrt{\\frac{2}{T_{R e}}} \\frac{c_{s}}{R_{\\mathrm{ref}}}=\\frac{\\sqrt{\\frac{2}{T_{R e}}} a}{R_{\\mathrm{ref}}}\\left(\\frac{c_{s}}{a}\\right) t, \\tag{10.23}\n\\end{equation*}\n\n\nand the heat fluxes convert to a gyro-Bohm diffusivity as\n\n\n\\begin{equation*}\n\\chi^{N}=\\frac{\\mathcal{I}_{2}}{R_{\\text {ref }} / L_{T}\\left\\{g^{\\psi \\psi N}\\right\\}}=\\frac{R_{\\text {ref }}}{\\rho_{\\text {ref }}^{2} v_{\\text {thref }}} \\chi=\\left(\\frac{T_{R e}}{2}\\right)^{3 / 2} \\frac{R_{\\text {ref }}}{a}\\left(\\frac{a}{\\rho_{s}^{2} c_{s}}\\right) \\chi . \\tag{10.24}\n\\end{equation*}\n\n\nNote that $N$ in the two previous expressions is used to denote a normalised quantity, as used in most of this manual, and the equivalent quantity without the $N$ is a dimensional one. The dimensional diffusivity in $m^{2} / s$ is given by\n\n\n\\begin{equation*}\n\\chi=\\frac{\\mathcal{I}_{2} \\rho_{*}^{2} v_{\\text {thref }} R_{\\text {ref }}}{\\left\\{g^{\\psi \\psi \\psi N}\\right\\} R_{\\text {ref }} / L_{T}} \\tag{10.25}\n\\end{equation*}\n\n\nand a dimensional power flux in $J / s$ is obtained (see A.7) by\n\n\n\\begin{equation*}\nQ=\\left\\{\\boldsymbol{\\Gamma}_{2} \\cdot \\nabla \\psi\\right\\} V^{\\prime} \\tag{10.26}\n\\end{equation*}\n\n\nwhere $V$ is the dimensional volume of the plasma with the local flux surface (see A.6) and\n\n\n\\begin{equation*}\nV^{\\prime}=\\frac{\\partial V}{\\partial \\epsilon}=R_{\\mathrm{ref}}^{3} J_{\\psi \\zeta s}^{N} \\tag{10.27}\n\\end{equation*}\n\n\nIn the flux tube, one should realize that the local radial coordinate $x_{r}$ appearing as the scale for the XY diagnostics (in file xphi) differs by a factor of $\\rho_{*}$ from the global radial coordinate $\\psi=\\epsilon$. Thus $\\Delta x_{r}=$ $\\Delta \\psi / \\rho_{*}=\\Delta r / \\rho_{\\text {ref }}$. This is required when combining background and perturbed quantities in the flux tube to create a profile as in Sec. 5.4.\n\n\\subsection*{10.6 Output grids (module diagnos\\_grid)}\nThe $\\zeta$ grid output is re-scaled to the input scale of $k_{\\theta} \\rho_{\\mathrm{ref}}$, so the two perpendicular coordinate scales are equal (Eq. 2.256).\n\n\\subsection*{10.7 Summary: diagnostic outputs and their data format}\nIn GKW, most diagnostics are calculated inside the code at runtime (as opposed to in post-processing). The advantage of this approach is that one does not need to store the full 5 dimensional distribution functions at every timestep (which occupy a lot of disk space and are difficult to transfer). The disadvantage is that if a time dependant diagnostic is not enabled or implemented before the run, that information cannot later be retrieved without re-running the entire simulation (final state diagnostics can always be retrieved by restarting the code if the restart file is available). One should therefore think carefully about which diagnostics are required before launching any expensive simulation. One could argue that this approach is suited to a world in which computation is cheap, but storage and transfer are expensive.\n\n\\footnotetext{${ }^{1}$ Care should also be taken when comparing the GKW input wavenumber \" $k_{\\theta}$ \" with other codes. It is defined by Eq. 2.256, and the relationship to the toroidal mode number is described by Eq. 2.257.\n}The default set of time dependent diagnostics contains scalar time traces (fluxes, growth rates) and 1D spectra, but no 2 D or 3 D quantities.\n\nGKW does contain a wrapper which allows to write output data in various formats, according to the setting of io\\_format in the input file.\\\\\nio\\_format='ascii' (also called 'formatted' output) All data is written to a collection of text files. Those can be read and analysed easily, and they are very portable. The ASCII format becomes impractical for higher dimensional and large amounts of data.\\\\\nFor ascii and binary formats, diagnostic meta-data is output by the code to a simple text file gkwdata.meta.\\\\\nio\\_format='binary' (also called 'raw' output) All data is written to binary files. Binary data consumes typically by a factor of about 6-10 less disk space than ascii data. Binary or hdf5 (see below) format is therefore recommended if large amounts of data are produced.\\\\\nio\\_format='hdf5' (also called 'structured' output), if io\\_format='hdf5' is set. This structured binary format is available if the code was compiled with the HDF5 library. If the HDF5 library was compiled with szip encoding support, then the GKW output data can be compressed (for now, there is only a hardcoded switch, see the comments).\\\\\nThe HDF5 format allows to output diagnostic meta-data by associating attributes to datasets. These can be read by analysis scripts. More and more metadata will be added in the near future, for discussions see issue 69. Note that\n\n\\begin{itemize}\n  \\item If one tries to access HDF5 files during run, they may turn out to be invalid (not always though).\n  \\item Aborted runs may leave a corrupted HDF5 file. Usually then there are just no parameters in the file, sometimes datasets are missing and in rarer cases even the file as a whole is invalid.\n  \\item To produce the 3d fields and moments data and the 4 d mode structure data, a MPI gather operation is performed and the output is written serially by just one process. For large runs with many processes this is likely not very performant. Instead, it is recommended to use MPI-IO binary output format then.\n  \\item At the time moment GKW supports only serial HDF5.\n\\end{itemize}\n\nIn order to take advantage of the benefits of certain formats, GKW knows also about mixed output:\\\\\nio\\_format='mixed' Most of the data (mainly scalar time traces and 1D spectra, parallel.dat final state eigenfunctions) is output to text files, whereas higher dimensional data is output to binary files.\\\\\nio\\_format='hdf5+ascii' All data is output as with the 'hdf5' setting. In addition, lowerdimensional data is output also to text files.\n\nAs long as there is not enough descriptive metadata attached to the GKW diagnostic output data, we here summarize most of the GKW diagnostic outputs in tables 10.1 and 10.2 for 1 D time traces, final state outputs, and 2D time trace outputs. A full listing of available diagnostics and switches is documented in input.dat.sample. In the case of less standard diagnostics it may be necessary to examine the source and comments in the respective diagnostic module diagnos\\_foo.F90 to determine the exact order and meaning of the output quantities.\n\nGenerally, 2D diagnostics can be output by GKW at every timestep, or at the end (\"R or E\" in tables 10.1 and 10.2 , switched by xy\\_estep).\\\\\nWhen successive binary records for each timestep are stacked into one file, this happens with ( 32 bit / 4 byte, usually) integers before and after each record for the size of the binary record (which will have Endianness of the hardware it was written on). The data records can be read into matlab with the script read\\_file2d.m.\n\nSome slices are output at the point nearest the LFS, for these a different location can be set with switch xy\\_slice\\_ipar.\n\nReorganisation of diagnostics and the io\\_legacy switch: Note that there currently efforts to clean up GKW's diagnostics. This includes renaming of some files, split up of datasets and change of the order of the data, where necessary. The goal is to output data in a more natural way which is easy to understand and to analyse.\n\nIn order to provide users for some time the possibility to keep using their old analysis tools without larger changes, the switch io\\_legacy was introduced.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-135}\n\nFigure 10.1: Coordinate directions on the outboard plane $(s=0)$ for $s_{\\mathrm{B}}=1$, as output by the potential slices diagnostic phi\\# with the coordinate labels for each point as output by xphi and yphi (the yphi coordinate label inverts the plot). For $s_{\\mathrm{B}}=1$, the poloidal field is 'upwards' $\\operatorname{sign}\\left(B_{p} \\nabla \\theta \\cdot \\nabla \\zeta\\right)=s_{\\mathrm{B}}$. If in doubt, see Sec. 2.2.6. Note that the 'centre' of the flux tube is in the bottom left corner when output from the FFTs.\n\n", "\\begin{center}\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\nFilename / dataset name & Description & Quantity (norm.=normalised) & Size & when & \\begin{tabular}{l}\nGrid \\\\\nFiles \\\\\n\\end{tabular} & \\begin{tabular}{l}\nNamelist \\\\\nSwitch \\\\\n\\end{tabular} \\\\\n\\hline\n\\begin{tabular}{l}\ndominant\\_growth\\_rate \\\\\ndominant\\_real\\_freq \\\\\ngrowth\\_rates.dat \\\\\nfrequencies.dat \\\\\namplitudes.dat \\\\\n\\end{tabular} & Dominant linear mode growth rate Dominant linear mode frequency Growth rates of all linear modes Frequencies of all linear modes Amplitudes of all linear modes & \\( \\begin{aligned} \\hline & \\hline \\text { Module diagnos_growth_freq: } \\\\ & \\gamma_{N}^{\\max } \\\\ & \\omega_{N} \\text { belonging to } \\gamma_{N}^{\\max } \\\\ & \\gamma_{N} \\\\ & \\omega_{N} \\end{aligned} \\) & \\( \\begin{aligned} & N_{t} \\\\ & N_{t} \\end{aligned} \\) & \\( \\begin{aligned} & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\end{aligned} \\) &  &  \\\\\n\\hline\n\\begin{tabular}{l}\ntime.dat \\\\\nsgrid \\\\\nkrho \\\\\nkxrh \\\\\nyphi \\\\\nxphi \\\\\nkx\\_connect \\\\\n\\end{tabular} & \\begin{tabular}{l}\ntimestamp (large time steps) \\\\\ns grid (parallel coordinate) \\\\\nBi-normal wavevector grid \\\\\nRadial wavevector grid \\\\\nReal space bi-normal grid \\\\\nReal space radial grid \\\\\nParallel boundary connections \\\\\n\\end{tabular} & \\begin{tabular}{l}\n\\( \\) \\\\\nLabelled in file \\\\\n\\end{tabular} & \\( \\begin{aligned} & N_{-t} \\\\ & N_{s} \\\\ & N_{x}, N_{\\bmod } \\\\ & N_{x}, N_{\\bmod } \\\\ & M_{x}, M_{\\bmod } \\\\ & M_{x}, M_{\\bmod } \\\\ & \\text { N/A } \\\\ \\hline & \\end{aligned} \\) & \\( \\begin{aligned} & \\mathrm{R} \\\\ & \\mathrm{~B} \\\\ & \\mathrm{~B} \\\\ & \\mathrm{~B} \\\\ & \\mathrm{~B} \\\\ & \\mathrm{~B} \\\\ & \\mathrm{~B} \\end{aligned} \\) &  &  \\\\\n\\hline\n\\begin{tabular}{l}\nphi \\\\\nApar \\\\\nBpar \\\\\ndens \\\\\nTpar \\\\\nTperp \\\\\nvpar \\\\\n\\end{tabular} & \\begin{tabular}{l}\nes. potential \\\\\ndensity fluctuations parall. temperature fluct. perp. temp. fluctuations parallel flow fluctuations \\\\\n\\end{tabular} & \\begin{tabular}{l}\nModule diagnos\\_mode\\_struct: \\\\\nSee Sec. 10.7.1. \\\\\nSee Sec. 10.7.1. \\\\\nSee Sec. 10.7.1. \\\\\nSee Sec. 10.7.1. \\\\\nSee Sec. 10.7.1. \\\\\nSee Sec. 10.7.1. \\\\\nSee Sec. 10.7.1. \\\\\n\\end{tabular} & \\begin{tabular}{l}\n$N_{\\text {MOD }}, N_{s}, N_{x}$ \\\\\n$N_{\\text {MOD }}, N_{s}, N_{x}$ \\\\\n$N_{\\text {MOD }}, N_{s}, N_{x}$ \\\\\n$N_{\\mathrm{sp}}, N_{\\mathrm{MOD}}, N_{s}, N_{x}$ \\\\\n$N_{\\mathrm{sp}}, N_{\\mathrm{MOD}}, N_{s}, N_{x}$ \\\\\n$N_{\\mathrm{sp}}, N_{\\mathrm{MOD}}, N_{s}, N_{x}$ \\\\\n$N_{\\mathrm{sp}}, N_{\\mathrm{MOD}}, N_{s}, N_{x}$ \\\\\n\\end{tabular} & \\begin{tabular}{l}\nE and O \\\\\nE and $O$ \\\\\nE and $O$ \\\\\nE and $O$ \\\\\n$E$ and $O$ \\\\\nE and O \\\\\nE and O \\\\\n\\end{tabular} &  &  \\\\\n\\hline\n\\begin{tabular}{l}\nkyspec \\\\\nkyspec\\_em \\\\\nkxspec(\\_em) \\\\\nkyvort \\\\\nkxvort \\\\\nparallel\\_phi \\\\\nparallel\\_apar \\\\\nparallel\\_bpar \\\\\n\\end{tabular} & Bi-normal mode potential spectrum (Equivalent for $A_{\\|}$field) Radial mode potential spectrum Bi-normal vorticity spectra Radial vorticity spectra ES potential parallel structure (no ZF) EM potential parallel structure (no ZF ) EM field parallel structure (no ZF) & \\( \\begin{aligned} & \\quad \\text { Module diagnos_fields: } \\\\ & \\sum_{k_{\\psi}} \\int_{s}\\left|\\hat{\\phi}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right|^{2} \\mathrm{~d} s \\\\ & \\sum_{k_{\\psi}} \\int_{s}\\left|\\hat{A}_{\\|}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right|^{2} \\mathrm{~d} s \\\\ & \\sum_{k_{\\zeta}} \\int_{s}\\left|\\hat{\\phi}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right|^{2} \\mathrm{~d} s \\\\ & \\sum_{k_{\\psi}, s p} \\int Z_{s p}\\left|\\hat{f}_{s p}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right|^{2} \\mathrm{~d}^{3} v \\mathrm{~d} s \\\\ & \\sum_{k_{\\zeta}, s p} \\int Z_{s p}\\left|\\hat{f}_{s p}\\left(k_{\\psi}, k_{\\zeta}, s\\right)\\right|^{2} \\mathrm{~d}^{3} v \\mathrm{~d} s \\\\ & \\sum_{k_{\\zeta} \\neq 0} \\sum_{k_{\\psi}} \\hat{\\phi}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\\\ & \\sum_{k_{\\zeta} \\neq 0} \\sum_{k_{\\psi}} \\hat{A}_{\\|}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\\\ & \\sum_{k_{\\zeta} \\neq 0} \\sum_{k_{\\psi}} \\hat{B}_{\\|}\\left(k_{\\psi}, k_{\\zeta}, s\\right) \\\\ \\hline & \\end{aligned} \\) & \\( \\begin{aligned} & N_{t}, N_{\\text {mod }} \\\\ & N_{t}, N_{\\text {mod }} \\\\ & N_{t}, N_{x} \\\\ & N_{t}, N_{\\text {mod }} \\\\ & N_{t}, N_{x} \\\\ & N_{t}, N_{s} \\\\ & N_{t}, N_{s} \\\\ & N_{t}, N_{s} \\end{aligned} \\) & \\begin{tabular}{l}\nR \\\\\nR \\\\\nR \\\\\nR \\\\\nR \\\\\nR \\\\\nR \\\\\nR \\\\\n\\end{tabular} & \\begin{tabular}{l}\ntime,sgrid \\\\\ntime,sgrid \\\\\ntime,sgrid \\\\\n\\end{tabular} & \\begin{tabular}{l}\nlparallel\\_phi \\\\\nlparallel\\_apar \\\\\nlparallel\\_bpar \\\\\n\\end{tabular} \\\\\n\\hline\n\\begin{tabular}{l}\nspc\\# \\\\\nphi\\# \\\\\napc\\# \\\\\napa\\# \\\\\nbpc\\# \\\\\nbpa\\# \\\\\nvok\\# \\\\\n\\end{tabular} & \\begin{tabular}{l}\nES potential spectrum (LFS) \\\\\nES potential slice (LFS) \\\\\nEM potential spectrum (LFS) \\\\\nEM potential slice (LFS) \\\\\nEM field spectrum (LFS) \\\\\nEM field slice (LFS) \\\\\nVorticity spectrum (FSA) \\\\\n\\end{tabular} & \\( \\begin{aligned} & \\left|\\hat{\\phi}\\left(k_{\\psi}, k_{\\zeta}, s \\approx 0\\right)\\right| \\quad \\text { (norm.) } \\\\ & \\phi(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & \\left|\\hat{A}_{\\|}\\left(k_{\\psi}, k_{\\zeta}, s \\approx 0\\right)\\right| \\text { (norm.) } \\\\ & A_{\\|}(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & \\left|\\hat{B}_{\\|}\\left(k_{\\psi}, k_{\\zeta}, s \\approx 0\\right)\\right| \\text { (norm.) } \\\\ & B_{\\|}(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & \\sum_{s} \\int\\left|\\hat{f}_{s}\\left(k_{\\psi}, k_{\\zeta}\\right)\\right| d^{3} v d s \\quad \\text { (norm.) } \\end{aligned} \\) &  & \\begin{tabular}{l}\nR or E \\\\\nR or E \\\\\nR or E \\\\\n$R$ or $E$ \\\\\nR or E \\\\\nR or E \\\\\n$R$ or $E$ \\\\\n\\end{tabular} & \\begin{tabular}{l}\nkxrh, krho \\\\\nxphi, yphi \\\\\nkxrh, krho \\\\\nxphi, yphi \\\\\nkxrh, krho \\\\\nxphi, yphi \\\\\nkxrh, krho \\\\\n\\end{tabular} & \\begin{tabular}{l}\nxy\\_phi \\\\\nxy\\_phi \\\\\nxy\\_apar \\\\\nxy\\_apar \\\\\nxy\\_bpar \\\\\nxy\\_bpar \\\\\nxy\\_vort \\\\\n\\end{tabular} \\\\\n\\hline\n\\( \\begin{aligned} & \\text { ene[sp\\#]_\\# } \\\\ & \\text { den[sp\\#]_\\# } \\\\ & \\text { pac[sp\\#]_\\# } \\\\ & \\text { pac[sp\\#]_\\# } \\\\ & \\text { den/ene_spectra } \\end{aligned} \\) & \\begin{tabular}{l}\nTemp. pert. moment (LFS) \\\\\nDensity pert. moment (LFS) \\\\\nCurrent pert. moment (LFS) \\\\\nCurrent ${ }^{2}$ pert. moment (LFS) \\\\\nBi-normal spectral perturbation moments for each species \\\\\n\\end{tabular} & \\( \\begin{aligned} & \\text { Module diagnos_moments: } \\\\ & \\sum_{s p} \\int\\left|\\hat{f}_{s} v^{2}\\right| d^{3} v \\quad \\text { (norm.) } \\\\ & \\int\\left|\\hat{f}_{S}\\right| d^{3} v \\text { (norm.) } \\\\ & \\int\\left|\\hat{f}_{s}\\right| v_{\\|} d^{3} v \\quad \\text { (norm.) } \\\\ & \\int\\left|\\hat{f}_{s}\\right| v_{\\|}^{2} d^{3} v \\text { (norm.) } \\\\ & \\int_{s} \\int \\hat{\\alpha}_{1,2}\\left|\\hat{f}_{s p}\\right| \\mathrm{d}^{3} v \\mathrm{~d} s \\end{aligned} \\) & $N_{\\text {mod }}, N_{s p}$ & \\begin{tabular}{l}\nR or E \\\\\nR or E \\\\\nR or E \\\\\nR or E \\\\\n\\end{tabular} & \\begin{tabular}{l}\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\n\\end{tabular} & \\begin{tabular}{l}\nxy\\_temp \\\\\nxy\\_dens \\\\\nxy\\_current \\\\\nxy\\_current2 \\\\\n\\end{tabular} \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\nTable 10.1: Diagnostics output by GKW (Part 1), with io\\_legacy=false. The abbreviations denote output at the beginning (B), repeatedly (R), at the end (E) or other (O). FSA denotes Flux Surface Averaged quantities. LFS denotes quantities evaluated at the low field side, i.e. in the center of the $s$-grid.\n\n\\begin{center}\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\nFilename / dataset name & Description & Quantity (norm.=normalised) & Size & beginning (B), repeatedly (R), at the end ( E ) & \\begin{tabular}{l}\nGrid \\\\\nFiles \\\\\n\\end{tabular} & \\begin{tabular}{l}\nNamelist \\\\\nSwitch \\\\\n\\end{tabular} \\\\\n\\hline\n\\( \\begin{aligned} & \\text { p/e/vflux_es } \\\\ & \\text { p/e/vflux_apar } \\\\ & \\text { p/e/vflux_bpar } \\\\ & \\text { p/e/vflux_spectra } \\\\ & \\text { p/e/vflux_xspec } \\\\ & \\text { p/eflux_(em_) sup } \\end{aligned} \\) & \\begin{tabular}{l}\nTotal $v_{E}$ particle flux by species \\\\\nTotal $A_{\\|}$particle flux by species \\\\\nTotal $\\nabla B_{\\|}$particle flux by species \\\\\nBi-normal spectral $v_{E}$ flux for each species Radial spectral $v_{E}$ fluxes for each species \\\\\nBi-normal spectral flux suprema for each species \\\\\n\\end{tabular} & Module diagnos\\_fluxes: \\( \\begin{aligned} & \\mathcal{I}_{i}=\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{s} \\overline{\\mathcal{I}}_{i} \\mathrm{~d} s \\\\ & \\mathcal{J}_{i}=\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{s} \\overline{\\mathcal{J}}_{i} \\mathrm{~d} s \\\\ & \\mathcal{K}_{i}=\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{\\mathcal{S}} \\overline{\\mathcal{K}}_{i} \\mathrm{~d} s \\\\ & \\sum_{k_{\\psi}} \\int_{s} \\overline{\\mathcal{I}}_{i}\\left(k_{\\psi}, k_{\\zeta}\\right) \\mathrm{d} s \\\\ & \\sum_{k_{\\zeta}} \\int_{s} \\overline{\\mathcal{I}}_{i}\\left(k_{\\psi}, k_{\\zeta}\\right) \\mathrm{d} s \\\\ & \\hat{\\mathcal{I}}_{i}\\left(k_{\\zeta}\\right), \\hat{\\mathcal{J}}_{i}\\left(k_{\\zeta}\\right) \\end{aligned} \\) & \\( \\begin{aligned} & N_{t}, N_{s p} \\\\ & N_{t}, N_{s p} \\\\ & N_{t}, N_{s p} \\\\ & N_{t}, N_{\\mathrm{mod}}, N_{s p} \\\\ & N_{t}, N_{\\mathrm{mod}}, N_{s p} \\\\ & N_{t}, N_{\\mathrm{mod}}, N_{s p} \\end{aligned} \\) & \\( \\begin{aligned} & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\\\ & \\mathrm{R} \\end{aligned} \\) & \\begin{tabular}{l}\ntime \\\\\ntime \\\\\ntime \\\\\n\\end{tabular} &  \\\\\n\\hline\n\\texttt{PFlesr[sp\\#]\\_\\# EFlesr[sp\\#]\\_\\# VFlesr[sp\\#]\\_\\# [P/E/V]Flemr[sp\\#]\\_\\# [P/E/V]Flbpr[sp\\#]\\_\\# [P/E/V]F\\textbackslash underline\\{S\\}[es/em/bp]r[sp\\#]\\_\\# [P/E/V]F[l/S][es/em/bp]p[sp\\#]\\_\\# [P/E/V]Fl[es/em/bp] k[sp\\#]\\_\\#} & \\begin{tabular}{l}\nES radial particle flux (LFS) \\\\\nES radial energy flux (LFS) \\\\\nES radial momentum flux (LFS) \\\\\nEM flutter fluxes as above (LFS) \\\\\nEM comp. fluxes as above (LFS) \\\\\nAll fluxes as abv., but (FSA) \\\\\nBinormal fluxes as abv. (LFS/FSA) \\\\\nRadial fluxes spectra (FSA) \\\\\n\\end{tabular} & \\( \\begin{aligned} \\hline & \\mathcal{I}_{1}(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & \\mathcal{I}_{2}(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & \\mathcal{I}_{3}(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & J_{i}(\\psi, \\zeta, s \\approx 0) \\text { (norm.) } \\\\ & K_{i}(\\psi, \\zeta, s \\approx 0) \\quad \\text { (norm.) } \\\\ & \\int I_{i} / J_{i} / K_{i}(\\psi, \\zeta) d s \\quad \\text { (norm.) } \\\\ & \\mathrm{N} / \\mathrm{A} \\\\ & \\int I_{i} / J_{i} / K_{i}\\left(k_{\\psi}, k_{\\zeta}\\right) d s \\quad \\text { (norm.) } \\end{aligned} \\) &  & \\begin{tabular}{l}\nR or E \\\\\nR or E \\\\\nR or E \\\\\nR or E \\\\\nR or E \\\\\nR or E \\\\\nR or E \\\\\n$R$ or E \\\\\n\\end{tabular} & \\begin{tabular}{l}\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\nxphi, yphi \\\\\nkxrh, krho \\\\\n\\end{tabular} & xy\\_fluxes\\_P xy\\_fluxes xy\\_fluxes\\_V + xy\\_fluxes\\_em + xy\\_fluxes\\_bpar + xy\\_fluxes\\_fsa + xy\\_fluxes\\_bi + xy\\_fluxes\\_k \\\\\n\\hline\nfluxes\\_det.dat & 5D fluxes for each species, including $\\mathrm{d}^{3} X$ and $\\mathrm{d}^{3} v$ & dule diagnos\\_fluxes\\_vspace: \\( \\left(\\overline{\\mathcal{I}}_{i}+\\overline{\\mathcal{J}}_{i}+\\overline{\\mathcal{K}}_{i}\\right)\\left(k_{\\psi}, k_{\\zeta}, s, \\mu, v_{\\|}\\right) \\) & \\( \\begin{aligned} & \\text { binary, } \\\\ & N_{v_{\\|}} N_{\\mu} N_{s} \\\\ & N_{\\psi} N_{m o d} N_{s p} i, \\\\ & i=1,2,3 \\end{aligned} \\) & E &  & lfluxes\\_detail \\\\\n\\hline\n[p/e/v]fluxes\\_vspace[sp\\#]\\_\\# & Fluxes in velocity space (FSA) & $\\int I_{i} / J_{i} / K_{i}\\left(v_{\\|}, \\mu\\right) d s$ (norm.) &  & R or E & distr[1/2] & lfuxes\\_vspace \\\\\n\\hline\ndistr*.dat & 2D velocity space output of 1 mode. & \\begin{tabular}{l}\nModule diagnos\\_f: \\\\\n1,2 grids, $3 \\operatorname{Re}(\\hat{g}(s=0)), 4 \\operatorname{Im}(\\hat{g}(s=0))$ \\\\\n\\end{tabular} & \\( N_{\\mu}, N_{v_{\\|}} \\) & E &  &  \\\\\n\\hline\n\\texttt{parfun.dat par.dat geom.dat FDS FDS.dat Coll\\_params.dat cfdens.dat} & Perpendicular wavevector Curvature and Coriolis functions Geometry tensors Restart distribution function Additional restart information Collision frequencies Centrifugal poloidal density variations & \\begin{tabular}{l}\nut by other parts of the code: $k_{\\perp} \\rho_{\\text {ref }}$ \\\\\n$k_{\\perp} \\rho_{\\mathrm{ref}}, \\mathcal{D}^{\\psi} k_{\\psi}+\\mathcal{D}^{\\zeta} k_{\\zeta}, \\mathcal{H}^{\\psi} k_{\\psi}+\\mathcal{H}^{\\zeta} k_{\\zeta}$, \\\\\nLabelled in file \\\\\nbinary (see Sec. 9.3.8) \\\\\nAscii namelists (see Sec. 9.3.8) \\\\\nLabelled in file \\\\\n$s, R / L_{\\mathrm{n}, \\mathrm{sp}}^{E}(s), \\exp \\left(-\\mathcal{E}_{R}\\right)_{\\mathrm{sp}}(s), \\theta$ \\\\\n\\end{tabular} & \\( \\begin{aligned} & 2, N_{s} N_{\\bmod } N_{x} \\\\ & 3, N_{s} N_{\\bmod } N_{x} \\\\ & \\mathrm{~N} / \\mathrm{A} \\\\ & \\mathrm{E} \\\\ & \\mathrm{E} \\\\ & \\mathrm{~N} / \\mathrm{A} \\\\ & 2 N_{\\mathrm{sp}}+2 \\end{aligned} \\) & \\( \\begin{aligned} & \\text { B } \\\\ & \\text { B } \\\\ & \\text { B } \\\\ & \\\\ & \\text { B } \\\\ & \\text { B } \\end{aligned} \\) &  &  \\\\\n\\hline\n\\end{tabular}\n\\end{center}\\\\\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\nFilename & Description & Quantity (norm.=normalised) & Cols,(Rows) & beginning (B), repeatedly (R), at the end (E) & \\begin{tabular}{l}\nGrid \\\\\nFiles \\\\\n\\end{tabular} & \\begin{tabular}{l}\nNamelist \\\\\nSwitch \\\\\n\\end{tabular} \\\\\n\\hline\n\\begin{tabular}{l}\ntime.dat \\\\\ngrowth.dat \\\\\n\\end{tabular} & Dominant linear mode growth rate Growth rates of all linear modes & Module diagnos\\_growth\\_freq: \\( \\begin{aligned} & t_{N}, \\gamma_{N}^{\\max }, \\omega_{N} \\\\ & \\gamma_{N} \\end{aligned} \\) & 3 & \\( \\begin{aligned} & \\mathrm{R} \\\\ & \\mathrm{R} \\end{aligned} \\) &  &  \\\\\n\\hline\nparallel.dat & \\multicolumn{5}{|l|}{Module diagnos\\_mode\\_struct:} &  \\\\\n\\hline\nden/ene\\_spectra & Bi-normal spectral perturbation moments for each species & Module diagnos\\_moments: $\\int_{s} \\int \\hat{\\alpha}_{1,2}\\left|\\hat{f}_{s p}\\right| \\mathrm{d}^{3} v \\mathrm{~d} s$ & $N_{\\text {mod }} N_{s p}$ &  &  &  \\\\\n\\hline\n\\begin{tabular}{l}\nfluxes.dat \\\\\nfluxes\\_em.dat \\\\\nfluxes\\_bpar.dat \\\\\n\\end{tabular} & Total $v_{E}$ fluxes $(i=1,2,3)$ by species Total $\\delta B$ fluxes $(i=1,2,3)$ by species Total $\\nabla B_{1 \\|}$ fluxes $(i=1,2,3)$ by species & Module diagnos\\_fluxes: \\( \\begin{aligned} \\mathcal{I}_{i} & =\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{s} \\overline{\\mathcal{I}}_{i} \\mathrm{~d} s \\\\ \\mathcal{J}_{i} & =\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{s} \\overline{\\mathcal{J}}_{i} \\mathrm{~d} s \\\\ \\mathcal{K}_{i} & =\\sum_{k_{\\zeta}} \\sum_{k_{\\psi}} \\int_{s} \\overline{\\mathcal{K}}_{i} \\mathrm{~d} s \\end{aligned} \\) & \\( \\begin{aligned} & 3 N_{s p} \\\\ & 3 N_{s p} \\\\ & 3 N_{s p} \\end{aligned} \\) & R R R &  &  \\\\\n\\hline\n\\end{tabular}\n\nTable 10.3: Legacy diagnostics output by GKW, with io\\_legacy=true. This table shows output datasets which differ from the ones described in tables 10.1 and 10.2 which are associated with io\\_legacy=false.\n\n\\subsection*{10.7.1 Mode structure (module diagnos\\_mode\\_struct)}\nThe file parallel.dat contains some diagnostics connected with the parallel mode structure. For every mode then species the following quantities are (sequentially) written to file, in this column order:\n\n\\begin{center}\n\\begin{tabular}{lll}\n1 & sgr & the length along the field line \\\\\n$2-3$ & phi & the perturbed potential \\\\\n$4-5$ & apar & the parallel component of the vector potential \\\\\n$6-7$ & dens & the perturbed density \\\\\n$8-9$ & tpar & the perturbed parallel temperature \\\\\n$10-11$ & tperp & the perturbed perpendicular temperature \\\\\n$12-13$ & wflow & the perturbed parallel flow velocity \\\\\n$14-15$ bpar & the perturbed parallel (compressional) magnetic field &  \\\\\n\\end{tabular}\n\\end{center}\n\nNote only sgr is real. The other quantities are complex and fill 2 columns in the output file. For a normalised run, all quantities are normalised and rotated in the complex plane so that the maximum of the potential for each mode is $1+0 i$. Therefore the output quantity is $\\hat{l}_{E}(s)$ where\n\n\n\\begin{equation*}\n\\hat{l}(s, t)=\\exp (\\gamma t+i \\omega t) \\hat{l}_{E}(s) \\tag{10.28}\n\\end{equation*}\n\n\nThe file will have $N_{\\text {MOD }} N_{x} N_{s} N_{\\text {sp }}$ rows (with data ordered by $\\zeta$ mode, then $\\psi$ mode, then species). For a run with multiple modes, extracting data of interest can be a little involved, matlab script paralleldat.m, helps with this.\n\n\\subsection*{10.8 Island torque and stabilization by the parallel current}\nA diagnostic especially useful for tearing mode dynamics is the one giving the torque and the stabilization by the parallel current, namely $T_{\\varphi}$ and $\\Delta_{\\text {pol }}$, respectively. These quantities are defined as follows, under the assumption of a non rotating island\n\n\n\\begin{align*}\nT_{\\varphi} & \\propto \\int_{-L_{x} / 2}^{L_{x} / 2} d x \\int_{-\\pi}^{\\pi} d \\zeta_{0} J_{\\|} \\sin \\left(\\kappa_{\\zeta, \\mathrm{isl}} \\zeta_{0}\\right)  \\tag{10.29}\\\\\n\\Delta_{\\mathrm{pol}} & \\propto \\int_{-L_{x} / 2}^{L_{x} / 2} d x \\int_{-\\pi}^{\\pi} d \\zeta_{0} J_{\\|} \\cos \\left(\\kappa_{\\zeta, \\mathrm{isl}} \\zeta_{0}\\right) \\tag{10.30}\n\\end{align*}\n\n\nwhere $L_{x}$ is the width of the simulation box in the radial direction, the variable $\\zeta_{0}$ is the helical co-ordinate in the absence of rotation and $J_{\\|}$is the gyro-centre parallel current, given by\n\n\n\\begin{equation*}\nJ_{\\|}=\\sum_{s} e Z_{s} \\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v} v_{\\|} \\delta f_{s} \\tag{10.31}\n\\end{equation*}\n\n\nwith $\\delta f_{s}$ the perturbed distribution function of the gyro-centres of species $s$. Note that multiplying equation 10.29 by $-i$ and adding the resulting expression to equation 10.30 yields\n\n\n\\begin{equation*}\n\\Delta_{\\mathrm{pol}}-i T_{\\varphi} \\propto \\sum_{s} e Z_{s} \\int_{-L_{x} / 2}^{L_{x} / 2} d x \\int_{-\\pi}^{\\pi} d \\zeta_{0} \\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v} v_{\\|} \\delta f_{s} \\exp \\left(-i \\kappa_{\\zeta, \\text { isl } 1} \\zeta_{0}\\right) \\tag{10.32}\n\\end{equation*}\n\n\nwhere we can distinguish the Fourier mode $\\delta \\hat{f}_{\\text {sisl }} \\equiv \\delta \\hat{f}_{s}\\left(\\kappa_{\\zeta}=\\kappa_{\\zeta, \\text { isl }}\\right) \\propto \\int_{-\\pi}^{\\pi} d \\zeta_{0} \\delta f_{s} \\exp \\left(-i \\kappa_{\\zeta, \\text { isl }} \\zeta_{0}\\right)$, with $\\kappa_{\\zeta \\text {,isl }}$ being the mode of the island in the binormal direction. Therefore, we can write\n\n\n\\begin{equation*}\n\\Delta_{\\mathrm{pol}}-i T_{\\varphi} \\propto \\sum_{s} e Z_{s} \\int_{-L_{x} / 2}^{L_{x} / 2} d x \\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v} v_{\\|} \\delta \\hat{f}_{s \\text { isl }} \\tag{10.33}\n\\end{equation*}\n\n\nA rotating island is usually imposed or obtained self-consistently in GKW. This means that the island is not always in the middle of the simulation box in the binormal direction. However, the above expressions are obtained assuming that the island is centered and therefore need to be corrected by multiplying by the phase $\\exp \\left(i \\int_{0}^{t} d t^{\\prime} \\omega_{\\text {isl }}\\right)$, where $\\omega_{\\text {isl }}$ is the rotation of the island, which results in the definition of the co-ordinate $\\zeta=\\zeta_{0}-\\int_{0}^{t} d t^{\\prime} \\omega_{\\text {isl }}$. Note that in the absence of rotation, the amplitude of the vector potential $A_{\\|}$is real, due to the fact that a pure $\\cos \\left(\\kappa_{\\zeta} \\zeta\\right)$ is represented in GKW by a real amplitude of $A_{\\|}$. Therefore, any departure from a real amplitude in $A_{\\|}$implies a rotation $\\omega_{\\text {isl }}$, which can be calculated as\n\n\n\\begin{equation*}\n\\int_{0}^{t} d t^{\\prime} \\omega_{\\mathrm{isl}}=\\arctan \\left(\\frac{\\Im\\left(A_{\\|}\\right)}{\\Re\\left(A_{\\|}\\right)}\\right) \\tag{10.34}\n\\end{equation*}\n\n\nleading to the expression\n\n\n\\begin{equation*}\n\\mathcal{T} \\equiv \\Delta_{\\mathrm{pol}}-i T_{\\varphi} \\propto \\sum_{s} e Z_{s} \\int_{-L_{x} / 2}^{L_{x} / 2} d x \\int_{\\mathbb{R}^{3}} d^{3} \\mathbf{v} v_{\\|} \\delta \\hat{f}_{s_{\\text {isl }}} \\exp \\left(i \\int_{0}^{t} d t^{\\prime} \\omega_{\\text {isl }}\\right) \\tag{10.35}\n\\end{equation*}\n\n\nFinally, the torque and instability parameter are calculated as\n\n\n\\begin{gather*}\nT_{\\varphi}=-\\Im(\\mathcal{T})  \\tag{10.36}\\\\\n\\Delta_{\\mathrm{pol}}=\\Re(\\mathcal{T}) \\tag{10.37}\n\\end{gather*}\n\n\nThese two quantities are output in the files torque. dat and deltaprime.dat, respectively. The first column corresponds to the values for the ions and the second column to the values for the electrons.\n\n\\subsection*{10.9 Entropy (module diagnos\\_energetics and diagnos\\_eng)}\n\\subsection*{10.9.1 Definition of the Total Entropy of the Simulated Box}\nLet $p\\left(\\mathbf{X}, v_{\\|}, \\mu\\right) \\in[0,1]$ be a probability density function.\\\\\nOne can define the functional\n\n\n\\begin{equation*}\nS=-\\int \\mathrm{d}^{3} x \\mathrm{~d}^{3} v p \\ln \\left(p \\cdot c_{d}\\right), \\quad c_{d}=\\text { const. } \\tag{10.38}\n\\end{equation*}\n\n\nand show that this expression has properties of the thermodynamical entropy (see e.g. the book of Jelitto 1989). It is therefore called \"statistical entropy\" or Shannon-Jaynes-entropy or Pauli-entropy or Boltzmann-Shannon-Gibbs (BGS) entropy. A constant $c_{d}$ is formally needed in 10.38 to make the logarithm dimensionless [77] but it can be set equal to 1 . Note that the integral in 10.38 is over the whole system, i.e. derived integrals below, on quantities of the simulated model, are taken over the whole simulation box.\n\nA \"relative entropy\" functional can be defined in the form\n\n\n\\begin{equation*}\nS=-\\int \\mathrm{d}^{3} x \\mathrm{~d}^{3} v p \\ln \\frac{p}{q} \\tag{10.39}\n\\end{equation*}\n\n\nThis functional characterizes the distribution $p$ with respect to a certain reference probability density function $q \\in[0,1]$.\n\nMaximization of the relative entropy $S$ under the constraint\n\n\n\\begin{equation*}\n1=\\int \\mathrm{d} \\mathbf{x} \\mathrm{~d} \\mathbf{v} p(\\mathbf{x}, \\mathbf{v}) \\tag{10.40}\n\\end{equation*}\n\n\nleads to the condition\n\n\n\\begin{equation*}\n0=1+\\ln \\frac{p}{q}+\\alpha \\tag{10.41}\n\\end{equation*}\n\n\nand thus\n\n\n\\begin{equation*}\np=q \\cdot \\exp [-(1+\\alpha)] \\tag{10.42}\n\\end{equation*}\n\n\nthe distribution which corresponds to the extremum of the functional depends on the reference. With the assumption that the reference PDF $q$ fulfills 10.40, one applies this constraint 10.40 to 10.42 and finds then $\\alpha=-1$ and so\n\n\n\\begin{equation*}\np=q, \\tag{10.43}\n\\end{equation*}\n\n\nthat means the entropy has its extremum for $p=q$. Variation of the relative entropy under other constraints, using a reference which fulfills those, leads to the condition $p=q$ by the same argument.\n\nFor a PDF describing an ensemble of classical particles, the distribution which maximizes the entropy under two contraints (normalisation of the distribution and given kinetic energy average) is the Maxwellian. For our purposes, we put therefore $f_{t o t}$ in place of $p$ and the reference distribution is chosen to be the Maxwell distribution in velocity space and to describe particle trapping (and possibly centrifugal trapping) in position space. This Maxwellian distribution function is denoted with $F_{M}$ and is given in equation 1.29.\n\n\n\\begin{equation*}\nS=-\\int \\mathrm{d}^{3} X \\mathrm{~d}^{3} v f_{t o t} \\ln \\frac{f_{t o t}}{F_{M}} \\tag{10.44}\n\\end{equation*}\n\n\nA state of maximum entropy then corresponds to $f_{t o t}=F_{M}$. In the $\\delta f$ model, where the distribution is split into $f_{t o t}=F_{M}+f$, this means that the distribution perturbation vanishes in the thermodynamic equilibrium: $f=0$.\n\nFurthermore, it can be shown [77] that in contrast to the BGS entropy 10.38 given first, maximizing the relative entropy 10.39 leads to the same distribution function, independently of the coordinate system. This\\\\\nis an important property if we want to investigate systems relaxing towards equilibrium in the field aligned coordinate system in which the gyrokinetic model is formulated. The invariance under coordinate transformations of the maximum-entropy principle associated with the relative entropy notion 10.39 guarantees that the distribution $f_{t o t}=F_{M}$ really corresponds to the maximum value of the entropy, and not another distribution, e.g. by multiplication with a factor.\\\\\nReduction of the perturbation $|f|$ means growth of the entropy $S$, i.e. the system moves towards thermodynamic equilibrium. On the contrary, processes that grow fluctuations $|f|$ effectively diminish the entropy of the system and keep it away from equilibrium, which is by definition the macrostate of maximum entropy.\\\\\nWe set $f_{t o t}=F_{M}+f$ and expand around $f=0$ :\n\n", "\n\\begin{align*}\n\\left(F_{M}+f\\right) \\ln \\frac{F_{M}+f}{F_{M}} & =\\left(F_{M}+f\\right)\\left[0+\\left.\\frac{1}{F_{M}+f}\\right|_{f=0} f^{1}+\\left.\\frac{1}{2} \\frac{-1}{\\left(F_{M}+f\\right)^{2}}\\right|_{f=0} f^{2}+\\ldots\\right] \\\\\n& =0+f+\\frac{f^{2}}{F_{M}}-\\frac{1}{2} \\frac{f^{2}}{F_{M}}+\\ldots \\\\\n& =0+f+\\frac{1}{2} \\frac{f^{2}}{F_{M}}+\\ldots \\tag{10.45}\n\\end{align*}\n\n\nThen 10.44 becomes\n\n\n\\begin{equation*}\nS \\approx-\\int \\mathrm{d}^{3} X \\mathrm{~d}^{3} v\\left(f+\\frac{1}{2} \\frac{f^{2}}{F_{M}}\\right)=-\\frac{1}{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f^{2}}{F_{M}} \\tag{10.46}\n\\end{equation*}\n\n\nwhere the integral of the fluctuation $f$ vanishes. $S$ in 10.46 is a small-amplitude approximation to the plasma entropy. Again, one can see that reduction of $|f|$ means increase of the entropy $S$.\n\nIn its normalized form 10.46 is\n\n\n\\begin{equation*}\nS \\approx-\\frac{1}{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f^{2}}{F_{M}}=\\rho_{*}^{2} \\frac{v_{\\text {thref }}}{R_{r e f}} n_{R_{0}} \\underbrace{\\left(-\\frac{1}{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v_{N} \\frac{f_{N}^{2}}{F_{M N}}\\right)}_{S_{N}} \\tag{10.47}\n\\end{equation*}\n\n\nIn the normalized balance equation 10.49 the reference quantities are dropped, but the smallness parameter $\\rho_{*}$ is kept for illustration.\\\\\nThe quantity $H=-S$ is a measure of the intensity of the fluctuations in the distribution.\n\n\n\\begin{equation*}\nH \\approx \\frac{1}{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f^{2}}{F_{M}}=\\rho_{*}^{2} \\frac{v_{\\text {thref }}}{R_{r e f}} n_{R_{0}} \\underbrace{\\left(\\frac{1}{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v_{N} \\frac{f_{N}^{2}}{F_{M N}}\\right)}_{H_{N}} \\tag{10.48}\n\\end{equation*}\n\n\nTo emphasise, the fluctuation intensity $H$ is found to be increasing in the simulations of a system driven out of equilibrium by applied thermodynamic forces (temperature and density gradient). Accordingly the entropy $S=-H$ is found to decrease.\n\n\\subsection*{10.9.2 Entropy Balance}\n\\section*{General procedure}\nOne starts from the normalized gyrokinetic equation given in section 2.4, multiplies every term with $\\frac{f}{F_{M}}$ and integrates over the box volume and velocity space.\n\nIn this section, all quantities are normalized, but we omit the index $N$ here. Moreover, only the electrostatic case is considered, so that $g=f$ for the purposes of this section.\n\n\n\\begin{equation*}\n\\rho_{*}^{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f}{F_{M}}\\left[\\frac{\\partial g}{\\partial t}+\\mathrm{I}+\\mathrm{II}+\\mathrm{III}+\\mathrm{IV}+\\mathrm{V}+\\mathrm{VI}+\\mathrm{VII}+\\mathrm{VIII}\\right]=0 \\tag{10.49}\n\\end{equation*}\n\n\n\\section*{Regard the terms separately}\nOne can recover $\\frac{\\partial}{\\partial t} H$ in the very first integral.\n\n\n\\begin{align*}\n\\rho_{*}^{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f}{F_{M}} \\frac{\\partial g}{\\partial t} & =\\rho_{*}^{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{1}{F_{M}} \\frac{1}{2} \\frac{\\partial f^{2}}{\\partial t} \\\\\n& =\\frac{\\partial H}{\\partial t}=-\\frac{\\partial S}{\\partial t} \\tag{10.50}\n\\end{align*}\n\n\nThe linear $\\mathbf{E} \\times \\mathbf{B}$-drift term V yields\n\n\n\\begin{align*}\n\\rho_{*}^{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f}{F_{M}} \\mathrm{~V}= & \\rho_{*}^{3} \\int \\mathrm{~d}^{3} X\\left[-\\frac{1}{L_{n}} \\Gamma_{N}^{\\psi}-Q_{N}^{\\psi} \\frac{1}{L_{T}}\\right. \\\\\n& +\\frac{3}{2} \\frac{1}{L_{T}} \\Gamma^{\\psi}-\\frac{\\mathcal{E}_{R}}{T_{R}} \\frac{1}{L_{T}} \\Gamma^{\\psi}+ \\\\\n& \\left.-\\frac{2}{T_{R}} \\Pi_{\\varphi}^{\\psi} u^{\\prime}-2 \\frac{m_{R}}{T_{R}} \\Omega_{N}^{2} \\mathcal{L} \\Gamma^{\\psi}\\right] \\tag{10.51}\n\\end{align*}\n\n\nAt the moment these six terms are output seperately by the code, but very likely they will be combined in the near future to fewer, more symmetric quantities.\n\nThe Landau-Damping terms VI and VII give non-vanishing contributions, too. In combination with the Poisson equation, they can be rewritten as\n\n\n\\begin{align*}\n\\rho_{*}^{2} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v \\frac{f}{F_{M}}[\\mathrm{VII}+\\mathrm{VIII}] & =\\int \\mathrm{d}^{3} X \\frac{\\partial}{\\partial t} \\sum_{s} \\int \\mathrm{~d}^{3} v \\frac{Z_{s}^{2}}{2 T_{s}^{2}} F_{M}\\left(\\phi^{2}(\\mathbf{x})-(\\mathbf{G} \\phi)^{2}\\right)  \\tag{10.52}\\\\\n\\text { and } W_{s} \\text { is defined such that } & =\\frac{\\partial}{\\partial t} \\sum_{s} W_{s}  \\tag{10.53}\\\\\nW_{N, s} & =\\int \\mathrm{d}^{3} X_{N} \\int \\mathrm{~d}^{3} v_{N} \\frac{Z_{s}^{2}}{2 T_{R, s}^{2}} F_{M N}\\left(\\phi_{N}^{2}-\\left(\\mathbf{G} \\phi_{N}\\right)^{2}\\right) \\tag{10.54}\n\\end{align*}\n\n\nIf only ion dynamics is simulated and electrons are treated adiabatically, the index $s$ above only runs over ion species and the term $W_{N, e}$ for the electrons is different.\n\n\n\\begin{align*}\n\\frac{\\partial}{\\partial t} W_{N, e, a d i a} & =\\frac{\\partial}{\\partial t} \\int \\mathrm{~d}^{3} X_{N} \\phi_{N} \\int \\mathrm{~d}^{3} v_{N} \\frac{Z_{e}}{T_{R, e}}\\left(\\mathbf{G}^{\\dagger} f_{e N}\\right) \\\\\n& =\\frac{\\partial}{\\partial t} \\int \\mathrm{~d}^{3} X_{N} \\phi_{N} \\frac{Z_{e}}{T_{R, e}} n_{R} \\frac{Z_{e}}{T_{R, e}}\\left(\\phi_{N}-\\left\\{\\phi_{N}\\right\\}_{\\text {FSA }}\\right) \\\\\n& =\\int \\mathrm{d}^{3} X_{N} n_{R} \\frac{Z_{e}^{2}}{2 T_{R, e}^{2}}\\left(\\frac{\\partial \\phi_{N}^{2}}{\\partial t}-2 \\phi_{N} \\frac{\\partial}{\\partial t}\\left\\{\\phi_{N}\\right\\}_{\\text {FSA }}\\right) \\tag{10.55}\n\\end{align*}\n\n\nAnd with $\\{\\cdot\\}_{\\text {FSA }}=\\{\\cdot\\}_{\\text {FSA }}(\\psi, \\zeta)$ and $T_{R, e}^{2}$ being constant with respect to the parallel direction, one can write\n\n\n\\begin{align*}\n& =\\int \\mathrm{d} \\psi \\mathrm{~d} \\zeta J_{X} n_{R} \\frac{Z_{e}^{2}}{2 T_{R, e}^{2}}\\left(\\frac{\\partial\\left\\{\\phi_{N}^{2}\\right\\}_{\\text {FSA }}}{\\partial t}-2\\left\\{\\phi_{N}\\right\\}_{\\text {FSA }} \\frac{\\partial}{\\partial t}\\left\\{\\phi_{N}\\right\\}_{\\text {FSA }}\\right)  \\tag{10.56}\\\\\n& =\\int \\mathrm{d} \\psi \\mathrm{~d} \\zeta J_{X} n_{R} \\frac{Z_{e}^{2}}{2 T_{R, e}^{2}}\\left(\\frac{\\partial\\left\\{\\phi_{N}^{2}\\right\\}_{\\text {FSA }}}{\\partial t}-\\frac{\\partial\\left\\{\\phi_{N}\\right\\}_{\\text {FSA }}^{2}}{\\partial t}\\right)  \\tag{10.57}\\\\\n& =\\frac{\\partial}{\\partial t} \\int \\mathrm{~d} \\psi \\mathrm{~d} \\zeta J_{X} n_{R} \\frac{Z_{e}^{2}}{2 T_{R, e}^{2}}\\left(\\left\\{\\phi_{N}^{2}\\right\\}_{\\mathrm{FSA}}-\\left\\{\\phi_{N}\\right\\}_{\\}_{\\mathrm{FSA}}}^{2}\\right) \\tag{10.58}\n\\end{align*}\n\n\n\\subsection*{10.9.3 Resulting entropy balance equation}\nThe terms of the entropy balance equation which were very briefly presented in section 10.9 .2 , and the numerical diffusion terms, summed over all species make up the following balance equation.\n\n\n\\begin{align*}\n0= & \\sum_{s} \\frac{\\partial}{\\partial t}(H_{s}+\\overbrace{W_{s}}^{\\text {from VII and VIII }})+\\sum_{s}(\\overbrace{\\text { contrib. from turb. fluxes }}^{\\text {from linear }}+\\overbrace{\\text { contrib. from neoclass. fluxes }}^{\\text {ExB drift V; }}+ \\\\\n& \\left.-\\mathcal{D}_{f \\|}-\\mathcal{D}_{v_{\\|}}-\\mathcal{D}_{\\perp}\\right)-\\sum_{s} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v_{N} \\frac{f_{N}}{F_{M N}} \\mathcal{C}_{N} \\tag{10.59}\n\\end{align*}\n\n\nTo be more explicit, in terms of entropy this equation reads\n\n\n\\begin{align*}\n\\sum_{s} \\frac{\\partial}{\\partial t}\\left(S_{s}-W_{s}\\right)=\\sum_{s} & \\left(\\int \\mathrm{~d}^{3} X\\left[-\\frac{1}{L_{n}} \\Gamma_{N}^{\\psi}-Q_{N}^{\\psi} \\frac{1}{L_{T}}+\\frac{3}{2} \\frac{1}{L_{T}} \\Gamma^{\\psi}-\\frac{\\mathcal{E}_{R}}{T_{R}} \\frac{1}{L_{T}} \\Gamma^{\\psi}-\\frac{2}{T_{R}} \\Pi_{\\varphi}^{\\psi} u^{\\prime}-2 \\frac{m_{R}}{T_{R}} \\Omega_{N}^{2} \\mathcal{L} \\Gamma^{\\psi}\\right]\\right. \\\\\n& \\left.-\\mathcal{D}_{f \\|}-\\mathcal{D}_{v_{\\|}}-\\mathcal{D}_{\\perp}\\right)-\\sum_{s} \\int \\mathrm{~d}^{3} X \\mathrm{~d}^{3} v_{N} \\frac{f_{N}}{F_{M N}} \\mathcal{C}_{N} \\tag{10.60}\n\\end{align*}\n\n\nand in terms of free energy\n\n\n\\begin{align*}\n& \\frac{\\partial}{\\partial t} \\sum_{s}\\left(-T_{R, s} S_{N, s}+E_{\\chi, N, s}\\right)= \\\\\n& \\quad \\sum_{s} T_{R, s}\\left(\\int \\mathrm{~d}^{3} X\\left[\\frac{1}{L_{n}} \\Gamma_{N}^{\\psi}+Q_{N}^{\\psi} \\frac{1}{L_{T}}-\\frac{3}{2} \\frac{1}{L_{T}} \\Gamma^{\\psi}+\\frac{\\mathcal{E}_{R}}{T_{R}} \\frac{1}{L_{T}} \\Gamma^{\\psi}+\\frac{2}{T_{R}} \\Pi_{\\varphi}^{\\psi} u^{\\prime}+\\frac{m_{R}}{T_{R}} \\Omega_{N}^{2} \\mathcal{L} \\Gamma^{\\psi}\\right]\\right. \\\\\n& \\left.\\quad+\\mathcal{D}_{f \\|}+\\mathcal{D}_{v_{\\|}}+\\mathcal{D}_{\\perp}\\right)+\\sum_{s} \\mathcal{D}_{C, s} \\tag{10.61}\n\\end{align*}\n\n\nwhere $E_{\\chi, S}=W_{s} T_{R, s}$.\\\\\nIn a system driven out of equilibrium the fluctuations grow, that is, the entropy gets smaller (i.e. more negative). The time derivative on the left side is therefore negative. This corresponds to the fluxes and the gradient lengths defined here being positive and the numerical dissipation terms $\\mathcal{D}_{i}$ being negative.\n\nIn a statistically steady state, the left side of this equation vanishes. The entropy sinks from the fluxes are then balanced by the numerical dissipation terms.\n\n\\subsection*{10.9.4 Output quantities of the diagnostic}\nIf lcalc\\_energetics in the diagnostics namelist is switched on, the code will produce a number of files related to the entropy balance equation:\n\nThe quantities in the entropy balance equation 10.60 correspond directly to the output of the energetics() diagnostic.\n\n\n\\begin{align*}\n& d t \\_e n t r+d t \\_e n t r \\_f i e l d=-\\left(e n t r \\_s r c 01+e n t r \\_s r c 02+e n t r \\_s r c 03\\right. \\\\\n& \\text { + entr_src04 + entr_src05 + entr_src06 } \\\\\n& + \\text { entr_num_dis + entr_num_vp + entr_num_perp } \\\\\n& + \\text { entr_coll) } \\tag{10.62}\n\\end{align*}\n\n\nTo clarify the signs, note the definition\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial t} \\sum_{s}\\left(-W_{N, s}\\right)=d t \\_e n t r \\_f i e l d \\tag{10.63}\n\\end{equation*}\n\n\nIn order to check the balance one can sum both sides and see how well they eliminate each other.\n\n\n\\begin{align*}\n& \\text { dt_entr + dt_entr_field }+(\\text { entr_src01 + entr_src02 + entr_src03 } \\\\\n& \\quad+\\text { entr_src04 + entr_src05 + entr_src06 } \\\\\n& \\quad+\\text { entr_num_dis + entr_num_vp }+ \\text { entr_num_perp }+ \\text { entr_coll }) \\stackrel{?!}{=} 0 \\tag{10.64}\n\\end{align*}\n\n\n\\section*{Chapter 11}\n\\section*{Benchmarks}\nIn this section we describe a set of benchmarks. The benchmark cases have been chosen to maximise the effect of each of the different implemented terms as much as possible. Together they give evidence for the correct implementation of the entire model. Linear benchmarks have been made against the GS2 code which is well established. Indeed the model equations are equivalent, with the exception that GKW includes the effect of a rigid body toroidal rotation, while GS2 does not. The implementation is to some extent similar; both use a spectral approach for the plane perpendicular to the magnetic field, and finite differences for the other directions. The main difference lies in the velocity space discretisation where GKW uses $\\left(v_{\\|}, \\mu\\right)$ coordinates, whereas GS2 uses pitch angle and energy. The GS2 velocity grid allows an efficient implicit time integrator, while the default grid of GKW is suitable for an explicit time integrator which facilitates parallelisation. Also the finite difference scheme used for GKW in the benchmarks is fourth order while GS2 has a second order scheme. In this section all quantities have been converted to use gyro-Bohm units.\n\n\\subsection*{11.1 Linear Benchmarks}\nThe standard benchmark for linear problems is the growth rate of the Ion Temperature Gradient mode (ITG) as a function of the poloidal wave vector $k_{\\theta} \\rho_{s}$ for the so-called Cyclone base case [48] ( $q=1.4, \\hat{s}=0.78$, $\\epsilon=0.19, R / L_{T}=6.9, R / L_{n}=2.2, T_{e} / T_{i}=1$, electro-static (zero $A_{\\|}$), and adiabatic electrons). The growth rate for this case is shown in the right panel of Fig. 11.1 as a function of $k_{\\theta} \\rho_{s}$ for various values of the normalised ion temperature gradient $\\left(R / L_{T}=6.9,8.2810 .35,12.44\\right.$, and 15.18$)$ calculated with both GKW and GS2. As can be seen from the figure, good agreement is obtained. The left panel, furthermore, shows the comparison of the potential as a function of the coordinate along the field line $(s)$ for both codes.\\\\\nFor nonlinear runs the proper response of the zonal flows is of utmost importance. The standard benchmark $[15,69,9]$ that addresses the physics of the zonal flow / geo-acoustic mode is the Rosenbluth-Hinton test which was described analytically in Ref. [72]. In this benchmark the initial condition is an ion density perturbation with a finite (small) radial wave vector, and no dependence on either $s$ or $\\zeta$. The adiabatic electron response is used, keeping the correction due to the flux surface average of the potential. The density perturbation generates a potential perturbation and excites the so called geo-acoustic mode. This mode is damped and a small residual poloidal flow remains. Fig. 11.2 gives the potential perturbation as a function of time. The relevant parameters used for this benchmark are $q=1.3, \\epsilon=0.05, k_{\\psi} \\rho_{s}=0.02$, electrostatic, collisionless. Rather large grid sizes $\\left(N_{s}=128\\right.$ and $\\left.N_{v_{\\|}}=128\\right)$ are used to avoid the recurrence problem [15]. The residual potential is given by the equation\n\n\n\\begin{equation*}\n\\frac{\\phi(t=\\infty)}{\\phi(t=0)}=\\frac{1}{1+q^{2} \\Theta / \\epsilon^{2}} \\quad \\text { with } \\quad \\Theta=1.6 \\epsilon^{3 / 2}+0.5 \\epsilon^{2}+0.36 \\epsilon^{5 / 2} \\tag{11.1}\n\\end{equation*}\n\n\nThe original derivation of Ref. [72] is accurate to lowest order in $\\epsilon$ only, i.e. it retained only the first term $\\left(1.6 \\epsilon^{3 / 2}\\right)$ in $\\Theta$. The higher order terms have been calculated in Ref. [73]. For the parameters of the simulation shown in the left panel the residue is $\\phi(t=\\infty) / \\phi(t=0)=0.0713$ smaller than the result of Ref.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-147(1)}\n\nFigure 11.1: Left: mode structure of the Cyclone base case. The full line is the real part and the dotted line is the imaginary part of the potential calculated with GS2. The corresponding results of GKW are given by the diamonds. Right: growth rate as a function of $k_{\\theta} \\rho_{s}$ for various values of $R / L_{T i}$ (numbers given in the figure). The full lines give the results of GS2 while the diamonds are the corresponding results of GKW.\\\\[0pt]\n[72] (0.0764) but in very good agreement with the results of Ref. [73] (0.0710). The right panel shows the residue as a function of $\\epsilon$. Good agreement with the analytic theory is obtained provided the finite $\\epsilon$ effects are kept.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-147}\n\nFigure 11.2: Zonal flow benchmark. Left: The potential perturbation (normalised to the potential at $t=0$ ) as a function of normalised time, for $q=1.3, \\epsilon=0.05$. The horizontal line gives the residual ( 0.0711 ) as predicted in Ref. [73]. For this value of $\\epsilon$ a numerical residual of 0.0713 is obtained, i.e. in agreement with the analytic result to within $0.3 \\%$ Right: Residual $\\phi(t=\\infty) / \\phi(0)$ as a function of $\\epsilon$ for $q=1.3$. The circles are the result of GKW, the dotted line is the Rosenbluth-Hinton result [72] and the full line gives the analytic result of Xiao-Catto [73].\n\nThe Cyclone base case with adiabatic electrons does not check the correct implementation of the kinetic electron response, and in general is not very sensitive to the effects associated with trapped particles. The physics effects associated with kinetic electrons can be well benchmarked by considering a Trapped Electron Mode. A benchmark with GS2 is shown on the left of Fig. 11.3. The parameters are taken from a discharge in the ASDEX Upgrade tokamak [17]: $\\hat{s}=1.07, q=1.57, \\epsilon=0.177, T_{e} / T_{i}=3, R / L_{T i}=0$, electro-static, collisionless, and with an ion to electron mass ratio of a Deuterium plasma. The values of the density gradient as well as the temperature gradient are scanned. The agreement for the growth rates is good.\n\nFinite beta effects are tested for an ITG case increasing the plasma beta. The middle panel of Fig. 11.3 shows the normalised growth rate as a function of the electron beta $\\beta=n_{e} T_{e} /\\left(B^{2} / 2 \\mu_{0}\\right)$ for the Waltz standard case $R / L_{T i}=R / L_{T e}=9, R / L_{n}=3, q=2 \\hat{s}=1, \\epsilon=0.166 T_{e} / T_{i}=1$, and with a mass ratio of a\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-148(1)}\n\nFigure 11.3: Left: Benchmark of a trapped electron mode case. Shown is the normalised growth rate $R \\gamma / c_{s}$ as a function of $R / L_{T e}$ for various values of $R / L_{n}$ indicated in the figure. Blue lines are the results of GS2 while red diamonds give the results of GKW. Middle: A benchmark of the growth rates of the ITG / Kinetic ballooning mode versus the plasma beta. Blue lines and circles are results from GS2 while red diamonds give the results of GKW. Right: The fluxes, normalised to the ion heat flux as a function of beta. Lines give the results of GS2, while the diamonds give the results of GKW.\n\nDeuterium plasma. The ITG is stabilised by the finite beta effects and, at sufficient high values of beta, a kinetic ballooning mode is destabilised. The agreement for the growth rate between GKW and GS2 is again good. The electro-magnetic case also provides for a good benchmark of the calculation of the fluxes, since all fluxes (also the ones due to the magnetic flutter) are nonzero in this case. The right panel of Fig. 11.3 shows the comparison of the fluxes calculated by GS2 and GKW. Since for a linear problem the amplitude of the mode and, therefore, the magnitude of the fluxes is arbitrary, all fluxes have been normalised to the ion heat flux. This allows for a straightforward comparison between the codes. All calculated fluxes are again in good agreement.\n\nEffects of magnetic field compression are also tested with the linear Waltz standard test case $R / L_{T i}=$ $R / L_{T e}=9, R / L_{n}=3, q=2, \\hat{s}=1, \\epsilon=0.166, T_{e} / T_{i}=1$, the mode with the fastest electrostatic growth rate has been used: $k_{\\perp} \\rho_{s}=0.3$. Fig. 11.4 shows that the ITG mode is hardly affected by the perturbation $B_{1 \\|}$ but the kinetic ballooning mode is further destabilised with increasing $\\beta$. Both with the growth rates and the parallel structure a good agreement with GS2 has been obtained.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-148}\n\nFigure 11.4: Waltz linear test case. Left: Benchmark of growth rates of ITG and kinetic ballooning modes with magnetic field compression on and off. Right: Parallel structure of $B_{1| |}$ in ITG and KBM regimes.\n\nA collisionality benchmark of the pitch angle scattering against GS2 for a TEM is presented in Fig. 11.5. To isolate the effect of e-e collisions and e-i collisions, the collisions input variable $Z_{\\text {eff }}$ (a multiplier for the\\\\\ne-i collision rate) was varied. Scattering of ions (off either species) made no difference for this benchmark (turning them on / off did not change the result of either code). This result was obtained with the Arakawa scheme and zero dissipation in $v_{\\|}$. At low collisionalities, GKW convergence for a TEM requires many $v_{\\|}$ points (the 64 used for this benchmark are not quite sufficient).\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-149(1)}\n\nFigure 11.5: Collisions benchmark (pitch angle scattering) for a TEM with varying $Z_{\\text {eff }}$\n\nThe pitch angle collisions have also been benchmarked against GS2 in Ref. [22], with good agreement obtained for the particle flux as a function of collisionality. The treatment of arbitrary toroidal geometry has been benchmarked against GS2 by performing an elongation scan. The parameters considered are $R / L_{T i}=R / L_{T e}=8.9, R / L_{n}=2.85, q=1.42 \\hat{s}=1.25, \\epsilon=0.182, T_{e} / T_{i}=1$ for deuterium ions and adiabatic electrons. The elongation of the last closed flux surface is varied from $\\kappa=1.2$ to $\\kappa=1.6$ and the corresponding MHD equilibrium is calculated using the CHEASE code [42]. This equilibrium is then used for the calculation of the metric tensors both in GKW and GS2. The results for the linear growth rate as a function of $k_{\\theta} \\rho_{s}$ are shown in Fig. 11.6 showing a good agreement between the two codes. The wavevector normalisation (projection) in the two codes in general differs (GKW uses $g^{\\zeta \\zeta}(L F S)$ while GS2 uses $\\mathcal{E}^{\\psi \\zeta}$ [45] which are only equivalent in ' $s-\\alpha$ ' geometry) and must be corrected for (in this case the GKW $k_{\\theta}$ inputs were rescaled). Note that the results are significantly different from the ones obtained with the simplified ' $s-\\alpha$ ' equilibrium shown by the dashed line (obtained with GKW).\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-149}\n\nFigure 11.6: Benchmark of the geometry treatment. The normalised growth rate $R \\gamma / c_{s}$ is shown as a function of GS2 $k_{\\theta} \\rho_{s}$ for various values of the last closed flux surface elongation $\\kappa$ indicated in the figure. Blue lines are the results of GS2 while red diamonds give the results of GKW. The results obtained for the simplified ' $s-\\alpha$ ' equilibrium with GKW are indicated by the red dashed line.\n\nThe effects of impurities have been benchmarked against GS2 using again the Waltz standard test case with ' $s-\\alpha$ ' geometry $R / L_{T i}=R / L_{T e}=9, R / L_{n}=3, q=2, \\hat{s}=1, \\epsilon=0.166, T_{e} / T_{i}=1$. Collisions were not included in this test. The left panel of Fig. 11.7 shows the ITG-TEM part of the linear electro-static growth rate spectra for 4 different lithium impurity concentration. The increasing impurity density was balanced by lowering the amount of deuterium in order the preserve quasi-neutrality. This means that the increasing $n_{L i}$ leads to larger values of $Z_{\\text {eff }}$ which is accountable for the stabilisation of the TEM modes.\n\nOn the middle panel of Fig. 11.7 the effect of varying the type of the impurity species can be seen. The impurity density is kept at a constant $1 \\%$ in this test. Fully ionized lithium, carbon and neon and partially ionized (charge number $\\mathrm{Z}=10$ for both cases) iron and tungsten ions have been used. Quasi-neutrality was maintained by adjusting the deuterium density. Here, as well, the increasing $Z_{\\text {eff }}$ has a stabilizing effect on the TEM modes.\n\nAnd finally, the right panel of Fig. 11.7 shows the effect of the two electro-magnetic perturbations, the magnetic flutter $A_{\\|}$and the magnetic compression $B_{\\|}$, obtained with a lithium impurity density of $10 \\%$. The growth rates are significantly increased compared to the electro-static cases. Apart from the longest wavelength modes a good agreement is found between the two codes.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-150}\n\nFigure 11.7: Benchmark of impurity treatment, growth rates of the Waltz standard test case with ' $s-\\alpha$ ' equilibrium without collisions. Line: GS2, diamonds: GKW. Left panel: effect of varying the Li impurity concentration, electro-static. Middle panel: effect of changing the impurity species, electro-static. Right panel: effect of the electro-magnetic perturations. Green line: fully electro-magnetic, both $A_{\\|}$(magnetic flutter) and $B_{\\|}$(magnetic compression) are retained. Blue line: only $A_{\\|}$is included.\n\nThe Miller geometry has been benchmarked against GS2, also for the adiabatic Waltz Standard case, with $\\epsilon$ changed to 0.266 . As for the general geometry benchmark, the different wavevector normalisations must be corrected (in this case the GS2 $k_{\\theta}$ inputs were rescaled), after which very good agreement is found (Fig. 11.8.). The squareness and elevation have not been benchmarked since GS2 does not have these parameters. Some of the Miller parameters are defined differently in the two codes and require a simple conversion.\n\n\\subsection*{11.2 Nonlinear benchmarks}\nFor the nonlinear solution there are two well established benchmark cases for which several codes have been compared: the cyclone base case, and the Nevins ETG benchmark. GKW has been benchmarked against the European gyrokinetic codes for the Cyclone case in Ref. [49].\n\nHere we describe the alternative ETG benchmark of Nevins [75]. The parameters for this case are the same as those of the Cyclone base case $\\left(R / L_{T}=6.9, R / L_{n}=2.2, q=1.4, T_{e} / T_{i}=1, \\epsilon=0.18\\right)$ with only the magnetic shear changed to $\\hat{s}=0.1$. For this case the electron dynamics is simulated while the ions are assumed adiabatic. The latter response does not include the flux surface average of the electrostatic potential, i.e. the response is proportional to $n_{i} \\phi / T_{i}$. To obtain the same results as published in Ref. [75] we have used (and must use) the same number of bi-normal modes $N_{\\text {mod }}=8$, and mode spacing $\\left(k_{\\perp} \\rho_{s}\\right)_{\\max }=0.69$. The radial grid spacing is $\\Delta\\left(k_{r} \\rho_{s}\\right)=0.0619$ with $N_{x}=41$ (both positive and negative\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-151}\n\nFigure 11.8: Benchmark of the Miller geometry for the growth rates of the adiabatic Waltz standard case with $\\epsilon=0.266$ and GKW $k_{\\theta} \\rho_{i}=0.43$. Line: GS2, Circles: GKW. The Miller parameters shown on the horizontal axes refer to the GKW definitions.\\\\\nwave vectors counted). Finally, $N_{\\mu}=8, N_{v_{\\|}}=16$, and $N_{s}=16$.\\\\\nFigure 11.9 shows the normalised electron heat flux as a function of the normalised time. Averaging over the time interval ( $1000<t c_{e} / L_{T}<19500$ ), GKW predicts a heat diffusion coefficient $\\chi_{e}=3.08 \\pm 0.19$ in good agreement with the value $\\chi_{e}=2.95 \\pm 0.15$ reported in Ref. [75]. The ETG case is sensitive to the magnetic shear. For values $\\hat{s}>0.3$ no convergence is found in the simulations reported in Ref. [75]. GKW reproduces this result as shown in Fig. 11.10.\n\nThe background ExB shear stabilisation has been successfully benchmarked against GYRO results as reported in Ref. [24]. This result for the Waltz standard case is included again here for convenience in Fig. 11.11. GKW has also been checked against the GS2 results reported in Ref. [50] for the Cyclone case, also shown in Fig. 11.11. Both of these comparisions were against existing results, i.e. no further attempt to examine the convergence of the GYRO and GS2 results has been made. Detailed convergence testing for the GKW results is described in Refs. [51] and [52]. This study revealed that it is preferable to use some radial hyperdissipation and minimal parallel dissipation at high shear rates (see also Sec. 9.3.2.) (not the case for these figures) which can improve the agreement at high shear rates to better than that shown in Fig. 11.11.\n\nTowards the edge, nonlinear and electromagnetic physics can be significantly more complex than the ITG dominated Cyclone and GA-STD cases, and benchmarking in this area is an active area of research. For L-mode ASDEX-Upgrade plasmas, GKW has been sucessfully benchmarked with GENE for four nonlinear electromagnetic cases using full geometry, and full collisions. The results are reported in in Refs. [54] and [55]. Benchmarking for the the DIII-D 'shortfall' case is in progress and is reported in ITPA presentations of C. Holland and Y. Camenen.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-152(1)}\n\nFigure 11.9: GKW results of the electron heat flux expressed as a heat conduction coefficient (normalised to $\\rho_{e}^{2} c_{e} / L_{T}$ with $\\left.c_{e}=\\sqrt{T_{e} / m_{e}}\\right)$ as a function of normalised time $\\left(t_{N N}=t c_{e} / L_{T}\\right)$ for the Nevins ETG benchmark\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-152}\n\nFigure 11.10: GKW results of the electron heat conduction coefficient for different values of the magnetic shear\n\n\\subsection*{11.2.1 Global Benchmarks}\nCan be found in the Ringberg 2012 presentation of A.G Peeters on the GKW webpages under Talks..\\\\\nAcknowledgements The authors want to thank W. Dorland and M. Kotschenreuther for making the GS2 code available, as well as A. Marinoni for his contribution to the geometry benchmark. One of the authors (AGP) would also like to thank Bruce D. Scott for his tutorials and insights into the subject which he has been able to follow over many years.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_cb0545ccfb9614bb7b3dg-153}\n\nFigure 11.11: Left: GKW benchmark of background ExB shearing with GYRO for Waltz standard case parameters. GKW results (diamonds) for adiabatic electrons, kinetic electrons, and adiabatic with $\\hat{s}=-0.5$, are compared to the equivalent GYRO results (circles) from Tables II, III, IV and V of Ref. [53]. The dashed lines include coupled parallel velocity shear for purely toroidal rotation with $u^{\\prime}=12 \\gamma_{E}$. Right: GKW benchmark of background ExB shearing with GS2 results reported in Ref. [50] for Cyclone case parameters. Both codes were run including coupled parallel velocity shear for purely toroidal rotation. $\\gamma_{\\max }$ is the maximum linear growth rate at $\\gamma_{E}=0$.\n\n", "\\section*{Appendix A}\n\\section*{Geometry - generalised}\n\\section*{A. 1 Field aligned Hamada coordinates}\nIn this Appendix the straight field line coordinates as well as the shifted metric are described in detail. The development of the material in this section has benefited from, and closely follows the publications of B.D. Scott [40, 41], and the references cited therein. This material is in addition to Section 2.2 of this document (which describes the specific geometry models implemented); here we add a generalised formulation for deriving the geometry tensors, and describe the shifted metric procedure for the nonspectral version of the code. At some point in the future the two sections should be consolidated.\n\nWe start with an arbitrarily shaped, but toroidally symmetric geometry, for which the magnetic field can be written in the form\n\n\n\\begin{equation*}\n\\mathbf{B}=s_{B} F \\nabla \\varphi+s_{j} \\nabla \\varphi \\times \\nabla \\Psi, \\tag{A.1}\n\\end{equation*}\n\n\nwhere $F=R B_{t}$ with $B_{t}>0$ being the toroidal magnetic field strength. The quantities $s_{B}$ and $s_{j}$ represent the sign of the magnetic field and plasma current (both positive when in the direction of $\\nabla \\varphi$. Finally, $\\Psi$ is the poloidal flux, not to be confused with the radial coordinate $(\\psi)$. Of course, $\\psi=\\psi(\\Psi)$, and the choice $\\psi=\\Psi$ will sometimes be made below.\n\nAn orthogonal coordinate system $(\\psi, \\theta, \\varphi)$ is assumed, where $\\psi$ is the 'radial' coordinate (i.e. $\\mathbf{B} \\cdot \\nabla \\psi=0$ ), $\\theta$ is the poloidal angle (upward on the outboard midplane), and $\\varphi$ is the toroidal angle (clockwise when viewed from above). Furthermore, it is assumed that the magnetic field and quantities like the major radius are known in this coordinate system. Below two coordinate transformations are introduced. The first will make the field lines straight in the new coordinates, and the second will align one of the coordinates with the magnetic field.\n\nIn the first step we transform the poloidal and toroidal angle\n\n\n\\begin{equation*}\ns=s(\\psi, \\theta), \\quad \\gamma=\\gamma(\\psi, \\theta, \\varphi) \\tag{A.2}\n\\end{equation*}\n\n\nin such a way that the contra-variant components of the magnetic field are flux functions in the new coordinate system $\\left(B^{s}=B^{s}(\\psi), B^{\\gamma}=B^{\\gamma}(\\psi)\\right)$. These coordinates are known as Hamada coordinates [36]. Note that the new coordinate $\\gamma$ is still an ignorable coordinate, since any function that is independent of $\\varphi$ will be independent of $\\gamma(f(\\theta, \\psi) \\rightarrow f(s, \\psi))$ after the coordinate transformation. The transformation of the poloidal angle is chosen such that $B^{s}$ becomes a flux function\n\n\n\\begin{equation*}\nB^{s}=\\mathbf{B} \\cdot \\nabla s=\\mathbf{B} \\cdot \\nabla \\theta \\frac{\\partial s}{\\partial \\theta}+\\mathbf{B} \\cdot \\nabla \\psi \\frac{\\partial s}{\\partial \\psi}=\\mathbf{B} \\cdot \\nabla \\theta \\frac{\\partial s}{\\partial \\theta} \\tag{A.3}\n\\end{equation*}\n\n\nFrom which the relation between $s$ and $\\theta$ can be derived\n\n\n\\begin{equation*}\n\\frac{\\partial s}{\\partial \\theta}=\\frac{B^{s}}{\\mathbf{B} \\cdot \\nabla \\theta} \\Leftrightarrow \\int_{0}^{\\theta} \\frac{\\partial s}{\\partial \\theta} d \\theta=s=B^{s} \\int_{0}^{\\theta} \\frac{d \\theta}{\\mathbf{B} \\cdot \\nabla \\theta} \\tag{A.4}\n\\end{equation*}\n\n\nWe now go through the second coordinate transformation where one of the coordinates is aligned with the magnetic field, i.e. we demand\n\n\n\\begin{equation*}\n\\mathbf{B} \\cdot \\nabla=B^{s} \\frac{\\partial}{\\partial s} \\tag{A.15}\n\\end{equation*}\n\n\nNote that this does not mean that $\\nabla s$ is in the direction of the magnetic field. In general it is not. The transformation is\n\n\n\\begin{equation*}\n\\zeta=\\zeta(s, \\gamma, \\psi) \\tag{A.16}\n\\end{equation*}\n\n\nIn the new coordinates\n\n\n\\begin{equation*}\n\\mathbf{B} \\cdot \\nabla=B^{\\psi} \\frac{\\partial}{\\partial \\psi}+B^{s} \\frac{\\partial}{\\partial s}+B^{\\zeta} \\frac{\\partial}{\\partial \\zeta} \\tag{A.17}\n\\end{equation*}\n\n\nwhere $B^{\\psi}$ is zero. The transformation to field aligned coordinates is the transformation for which $B^{\\zeta}=0$. The latter condition can be formulated as\n\n\n\\begin{equation*}\nB^{\\gamma} \\frac{\\partial \\zeta}{\\partial \\gamma}+B^{s} \\frac{\\partial \\zeta}{\\partial s}=0 \\tag{A.18}\n\\end{equation*}\n\n\nwhich is satisfied for the simple linear transformation\n\n\n\\begin{equation*}\n\\zeta=q s-\\gamma \\quad \\text { where } \\quad q=\\frac{B^{\\gamma}}{B^{s}} \\tag{A.19}\n\\end{equation*}\n\n\nFrom the field line equation it follows that\n\n\n\\begin{equation*}\n\\frac{\\mathrm{d} \\gamma}{\\mathrm{~d} s}=\\frac{B^{\\gamma}}{B^{s}} \\quad \\rightarrow \\quad \\oint \\frac{\\mathrm{~d} \\gamma}{\\mathrm{~d} s} \\mathrm{~d} s=\\oint \\frac{B^{\\gamma}}{B^{s}} \\mathrm{~d} s=q \\tag{A.20}\n\\end{equation*}\n\n\ni.e. $q=q(\\psi)$ is indeed the safety factor.\n\nNote that the coordinate transformation above flips the sign of the toroidal angle. The right handed coordinate system can therefore be defined as $(\\psi, \\zeta, s)$. The Jacobian of the new coordinate system can be expressed in terms of the original Jacobian through\n\n\n\\begin{equation*}\n(\\nabla \\psi \\times \\nabla \\zeta) \\cdot \\nabla s=\\frac{1}{J_{\\psi \\zeta s}}=\\frac{1}{2 \\pi} \\frac{\\partial s}{\\partial \\theta} \\frac{1}{J_{\\psi \\theta \\varphi}} \\tag{A.21}\n\\end{equation*}\n\n\nFrom which it follows\n\n\n\\begin{equation*}\nJ_{\\psi \\zeta s}=2 \\pi \\mathbf{B} \\cdot \\nabla \\theta \\oint \\frac{\\mathrm{~d} \\theta^{\\prime}}{\\mathbf{B} \\cdot \\nabla \\theta^{\\prime}} J_{\\psi \\theta \\varphi}=2 \\pi \\frac{\\mathbf{B} \\cdot \\nabla \\theta}{B^{s}} J_{\\psi \\theta \\varphi} \\tag{A.22}\n\\end{equation*}\n\n\nWe note here that the coordinates $s$ and $\\zeta$ are dimensionless, but that the dimension of $\\psi$ is not yet defined. We will always use a normalized $\\psi$ that is dimensionless.\n\n\\section*{A. 2 Caculating the Geometry tensors from the metric tensor and derivatives of coordinates and magnetic field}\nThe various tensors that are used for the implementation of the geometry are not independent. $\\mathcal{E}, \\mathcal{D}, \\mathcal{F}, \\mathcal{G}$, $\\mathcal{H}, \\mathcal{I}, \\mathcal{J}, \\mathcal{K}$ can be expressed in the metric tensor and derivatives of the coordinates as well as the magnetic field. We will assume here that the metric tensor $g^{\\alpha \\beta}$, the magnetic field strength $(B)$ and its derivatives towards the coordinates $(\\partial B / \\partial s, \\partial B / \\partial \\psi)$, the major radius $R$ and its derivatives $(\\partial R / \\partial s, \\partial R / \\partial \\psi)$, the zcoordinate $Z$ and its derivatives $(\\partial Z / \\partial s, \\partial Z / \\partial \\psi)$ and finally the derivative of the poloidal flux towards the radial coordinate $\\partial \\Psi / \\partial \\psi$ are given. Of course, even these quatities are not independent, since the derivatives of $R, Z$ towards the coordinates can be used to calculate the metric tensor. The tensors can then be calculated as discussed below\n\nSince we can write any vector $\\mathbf{A}$ as\n\n\n\\begin{equation*}\n\\mathbf{A}=\\frac{1}{2} \\epsilon_{i j k} A^{i} J_{x^{i} x^{j} x^{k}} \\nabla x^{j} \\times \\nabla x^{k} \\tag{A.23}\n\\end{equation*}\n\n\none finds for the magnetic field, using $\\psi=\\Psi$,\n\n\n\\begin{equation*}\n\\mathbf{B}=B^{s} J_{\\Psi \\zeta s} \\nabla \\Psi \\times \\nabla \\zeta . \\tag{A.24}\n\\end{equation*}\n\n\nUsing\n\n\n\\begin{equation*}\nB^{s}=\\mathbf{B} \\cdot \\nabla s=s_{b} F \\nabla \\varphi \\cdot \\nabla s+s_{j} \\nabla \\varphi \\times \\nabla \\Psi \\cdot \\nabla s \\tag{A.25}\n\\end{equation*}\n\n\nand remembering that by definition of $\\zeta$\n\n\n\\begin{equation*}\n\\nabla \\varphi \\times \\nabla \\Psi \\cdot \\nabla s=-2 \\pi \\nabla \\zeta \\times \\nabla \\Psi \\cdot \\nabla s \\tag{A.26}\n\\end{equation*}\n\n\none gets\n\n\n\\begin{equation*}\nB^{s}=2 \\pi s_{j} \\frac{1}{J_{\\Psi \\zeta s}} \\tag{A.27}\n\\end{equation*}\n\n\nFinally, one obtains\n\n\n\\begin{equation*}\n\\mathbf{B}=2 \\pi s_{j} \\nabla \\Psi \\times \\nabla \\zeta \\tag{A.28}\n\\end{equation*}\n\n\nThe Clebsch representation of the magnetic field can directly be used to calculate the tensor $\\mathcal{E}$\n\n\n\\begin{equation*}\n\\mathcal{E}^{\\alpha \\beta}=\\frac{1}{2 B^{2}} \\mathbf{B} \\cdot\\left(\\nabla x^{\\alpha} \\times \\nabla x^{\\beta}\\right)=\\frac{\\pi s_{j}}{B^{2}} \\frac{\\partial \\Psi}{\\partial \\psi}\\left[g^{\\psi \\alpha} g^{\\zeta \\beta}-g^{\\zeta \\alpha} g^{\\psi \\beta}\\right] \\tag{A.29}\n\\end{equation*}\n\n\nWith the $\\mathcal{E}$ tensor and the derivatives of the magnetic field strength given, the $\\mathcal{D}$ vector directly follows from\n\n\n\\begin{equation*}\n\\mathcal{D}^{\\alpha}=-2 \\mathcal{E}^{\\alpha \\beta} \\frac{1}{B} \\frac{\\partial B}{\\partial x_{\\beta}} \\tag{A.30}\n\\end{equation*}\n\n\nThe scalars that have been given earlier in this document are\n\n\n\\begin{equation*}\n\\mathcal{F}=\\frac{B^{s}}{B} \\quad \\mathcal{G}=\\frac{\\mathcal{F}}{B} \\frac{\\partial B}{\\partial s} \\tag{A.31}\n\\end{equation*}\n\n\nThe angular rotation vector points in the $\\nabla Z$ direction, and\n\n\n\\begin{equation*}\n\\boldsymbol{\\Omega}_{\\perp}=\\Omega \\mathbf{b} \\times(\\nabla z \\times \\mathbf{b}) \\tag{A.32}\n\\end{equation*}\n\n\nThis allows the $\\mathcal{H}$ vector to be written in the form\n\n\n\\begin{equation*}\n\\mathcal{H}^{\\alpha}=-\\frac{s_{B}}{B_{N}}\\left[\\frac{\\partial Z}{\\partial x_{\\beta}} g^{\\alpha \\beta}-\\left(\\frac{B^{s}}{B}\\right)^{2} \\frac{\\partial Z}{\\partial s} \\delta_{\\alpha s}\\right] \\tag{\u0410.33}\n\\end{equation*}\n\n\nThe $\\mathcal{I}$ tensor is straightforwardly\n\n\n\\begin{equation*}\n\\mathcal{I}^{\\alpha}=\\frac{1}{2 B}\\left(\\nabla x_{\\alpha} \\times \\nabla R^{2}\\right) \\cdot \\mathbf{b}=2 R \\mathcal{E}^{\\alpha \\beta} \\frac{\\partial R}{\\partial x_{\\beta}} \\tag{A.34}\n\\end{equation*}\n\n\nThe $\\mathcal{J}$ and $\\mathcal{K}$ tensor can be directly calculated from the known quantities.\n\n\\section*{A. 3 Periodicity}\nThe torus is periodic in both the toroidal as well as the poloidal angle. In the new coordinates this means that for any function $f(\\psi, \\zeta, s)$\n\n\n\\begin{equation*}\nf(\\psi, \\zeta+1, s)=f(\\psi, \\zeta, s) \\tag{A.35}\n\\end{equation*}\n\n\n\n\\begin{equation*}\nf(\\psi, \\zeta+q, s+1)=f(\\psi, \\zeta, s) \\tag{A.36}\n\\end{equation*}\n\n\nIn a flux tube one, furthermore, demands that the solution is periodic in the radial direction\n\n\n\\begin{equation*}\nf\\left(\\psi+L_{\\psi}, \\zeta, s\\right)=f(\\psi, \\zeta, s) \\tag{A.37}\n\\end{equation*}\n\n\nNone of the equilibrium quantities is a function of $\\zeta$. For these quantities Eq. (A.35) is trivially satisfied, and the Eq. (A.36) reduces to\n\n\n\\begin{equation*}\nB(\\psi, s+1)=B(\\psi, s) \\tag{A.38}\n\\end{equation*}\n\n\nwhere we have use the background magnetic field strength as example. The perturbed quantities (distribution function as well as fields) for the $\\zeta$ - direction are always represented by Fourier modes\n\n\n\\begin{equation*}\nf(\\psi, \\zeta, s)=\\sum_{k_{\\zeta}} \\hat{f}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta} \\zeta / \\rho_{*}\\right] \\tag{A.39}\n\\end{equation*}\n\n\nThe periodicity constraint of Eq. (A.36) then reduces to\n\n\n\\begin{equation*}\n\\hat{f}\\left(\\psi, k_{\\zeta}, s+1\\right)=\\hat{f}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[-\\mathrm{i} k_{\\zeta} q / \\rho_{*}\\right] \\tag{A.40}\n\\end{equation*}\n\n\nThe flux tube treats the limit of $\\rho_{*} \\rightarrow 0$ to the lowest relevant order only. Even though the phase factor can in principle take any value, we can assume that a very small change in the safety factor can always be choosen such that\n\n\n\\begin{equation*}\n\\exp \\left[-\\mathrm{i} k_{\\zeta} q / \\rho_{*}\\right]=1 \\tag{A.41}\n\\end{equation*}\n\n\nwithout changing the results. This choice can, however, only be made for one location since the safety factor is a function of the radial coordinate $\\psi$. We choose the phase factor above to be zero for the centre of the box (presented by $\\psi=0$ to obtain a periodicity constraint\n\n\n\\begin{equation*}\n\\hat{f}\\left(\\psi k_{\\zeta}, s+1\\right)=\\hat{f}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[-\\mathrm{i} k_{\\zeta} \\frac{1}{\\rho_{*}} \\frac{\\mathrm{~d} q}{\\mathrm{~d} \\psi} \\psi\\right] \\tag{A.42}\n\\end{equation*}\n\n\n\\section*{A. 4 Shifted metric}\nIn general the metric tensor has no zero elements. Especially the magnetic shear leads to a finite $g^{\\zeta \\psi}$ element that is a function of the coordinate along the field line. This means that an originally rectangular grid cell, deforms when moving along the magnetic field. This can potentially lead to problems [41]. A remedy, that does not cost anything computationally when using Fourier modes in $\\zeta$ is the shifted metric procedure. In this procedure we change the coordinate $\\zeta$ at every location in $s$.\n\n\n\\begin{equation*}\n\\zeta_{k}=q s-\\gamma-\\alpha_{k}(\\psi) \\tag{A.43}\n\\end{equation*}\n\n\nIt is important that $\\alpha$ is not a function of $\\zeta$. With this transformation one has a different set of coordinates at every grid point in $s$, with the different grid points denoted by the index k . The metric tensor in the new coordinates can be expressed as\n\n\n\\begin{align*}\n& g_{k}^{\\zeta \\zeta}=g^{\\zeta \\zeta}-2 \\alpha_{k}^{\\prime} g^{\\zeta \\psi}+\\left(\\alpha_{k}^{\\prime}\\right)^{2} g^{\\psi \\psi}  \\tag{A.44}\\\\\n& g_{k}^{\\zeta \\psi}=g^{\\zeta \\psi}-\\alpha_{k}^{\\prime} g^{\\psi \\psi}  \\tag{A.45}\\\\\n& g_{k}^{\\zeta s}=g^{\\zeta s}-\\alpha_{k}^{\\prime} g^{\\psi s} \\tag{A.46}\n\\end{align*}\n\n\nwhere $\\alpha_{k}^{\\prime}=\\partial \\alpha_{k} / \\partial \\psi$. With this transformation one can set the $g^{\\zeta \\psi}$ element at the grid point $s=s_{k}$ locally to zero\n\n\n\\begin{equation*}\n\\alpha_{k}^{\\prime}=\\frac{g^{\\zeta \\psi}\\left(s_{k}\\right)}{g^{\\psi \\psi}\\left(s_{k}\\right)} \\tag{A.47}\n\\end{equation*}\n\n\nIn the flux tube the metric elements are evaluated at one surface only, and are not a function of the radial coordinate. The equation above can then be trivially integrated to obtain\n\n\n\\begin{equation*}\n\\alpha_{k}=\\frac{g^{\\zeta \\psi}\\left(s_{k}\\right)}{g^{\\psi \\psi}\\left(s_{k}\\right)} \\psi \\tag{A.48}\n\\end{equation*}\n\n\nIn the new coordinates\n\n\n\\begin{align*}\n& g_{k}^{\\zeta \\zeta}=g^{\\zeta \\zeta}-\\left(g^{\\zeta \\psi}\\right)^{2} / g^{\\psi \\psi}  \\tag{A.49}\\\\\n& g_{k}^{\\zeta \\psi}=0  \\tag{A.50}\\\\\n& g_{k}^{\\zeta s}=g^{\\zeta s}-g^{\\zeta \\psi} g^{\\psi s} / g^{\\psi \\psi} \\tag{A.51}\n\\end{align*}\n\n\nThe perturbed solution in the new coordinates has the form\n\n\n\\begin{equation*}\n\\hat{f}_{k}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta} \\zeta_{k} / \\rho_{*}\\right] \\tag{A.52}\n\\end{equation*}\n\n\nWe must demand that the solution is single valued, and therefore\n\n\n\\begin{equation*}\n\\hat{f}_{k}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta} \\zeta_{k} / \\rho_{*}\\right]=\\hat{f}_{p}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta} \\zeta_{p} / \\rho_{*}\\right] \\tag{A.53}\n\\end{equation*}\n\n\nUsing\n\n\n\\begin{equation*}\n\\zeta_{p}=\\zeta_{k}+\\alpha_{k}-\\alpha_{p} \\tag{A.54}\n\\end{equation*}\n\n\nWe obtain\n\n\n\\begin{equation*}\n\\hat{f}_{k}\\left(\\psi, k_{\\zeta}, s\\right)=\\hat{f}_{p}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[\\mathrm{i} k_{\\zeta}\\left(\\alpha_{k}-\\alpha_{p}\\right) / \\rho_{*}\\right] \\tag{A.55}\n\\end{equation*}\n\n\nThe perturbed distribution function as well as the fields are calculated at the discrete points $s_{k}$ as $f_{k}$. When taking a parallel derivative one must use the transformation given above to transform $\\hat{f}_{p}$ to $\\hat{f}_{k}$.\n\nFinally we must consider the possible radial periodicity of the domain. In the new coordinates Eq. (A.37) becomes\n\n\n\\begin{equation*}\nf_{k}\\left(\\psi+L_{\\psi}, \\zeta_{k}+\\alpha_{k}^{\\prime} \\psi+\\alpha_{k}^{\\prime} L_{\\psi}, s\\right)=f_{k}\\left(\\psi, \\zeta_{k}+\\alpha_{k}^{\\prime} \\psi, s\\right) \\tag{A.56}\n\\end{equation*}\n\n\nOr\n\n\n\\begin{equation*}\n\\hat{f}_{k}\\left(\\psi+L_{\\psi}, k_{\\zeta}, s\\right)=\\hat{f}_{k}\\left(\\psi, k_{\\zeta}, s\\right) \\exp \\left[-\\mathrm{i} k_{\\zeta} \\alpha_{k}^{\\prime} L_{x}\\right] \\tag{A.57}\n\\end{equation*}\n\n\n\\section*{A. 5 Summary of the sign conventions in GKW}\nIn GKW, the cylindrical coordinate system $(R, Z, \\varphi)$ is right handed, which means that $\\varphi$ is increasing clockwise when the torus is viewed from above.\\\\\nThe toroidal rotation is defined positive for a plasma flowing in the direction of $\\mathbf{B}$.\\\\\nThe mode frequency is defined positive for a perturbation evolving in the direction opposite to $\\nabla \\zeta$. This corresponds to the ion $\\nabla B$ drift direction if $s_{\\mathrm{j}}=1$ and to the electron $\\nabla B$ drift direction if $s_{\\mathrm{j}}=-1$. See also Fig. 10.1\\\\\nCoordinate system:\n\n\\begin{itemize}\n  \\item $\\psi=\\varepsilon=\\left(R_{\\max }-R_{\\min }\\right) /\\left(2 R_{\\text {ref }}\\right)$ is always increasing from the plasma center to the plasma edge.\n  \\item $s$ is always increasing upwards from the low field side midplane. It is zero at the height of the magnetic axis, on the low field side midplane.\n  \\item $\\zeta$ is always increasing in the direction opposite to $\\varphi$ (i.e. anticlockwise when viewed from above) at constant $\\psi$ and $s$. The direction of $\\nabla \\zeta$ in the poloidal plane is given by $\\operatorname{sign}(\\nabla s \\cdot \\nabla \\zeta)=\\operatorname{sign}(\\nabla \\zeta \\cdot \\nabla \\theta)=$ $s_{\\mathrm{B}} s_{\\mathrm{j}}$\n\\end{itemize}\n\n\n\\begin{align*}\n\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla \\varphi) & \\equiv s_{B}  \\tag{A.58}\\\\\n\\operatorname{sign}(\\mathbf{j} \\cdot \\nabla \\varphi) & \\equiv s_{j}  \\tag{A.59}\\\\\n\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla \\theta) & =s_{j}  \\tag{A.60}\\\\\n\\operatorname{sign}(\\mathbf{B} \\cdot \\nabla s) & =s_{j}  \\tag{A.61}\\\\\n\\operatorname{sign}(\\nabla \\varphi \\cdot \\nabla \\zeta) & =-1  \\tag{A.62}\\\\\n\\operatorname{sign}(\\nabla s \\cdot \\nabla \\theta) & =1  \\tag{A.63}\\\\\n\\operatorname{sign}(\\nabla \\theta \\cdot \\nabla \\zeta) & =s_{B} s_{j}  \\tag{A.64}\\\\\n\\operatorname{sign}\\left(B_{\\theta} \\nabla \\theta \\cdot \\nabla \\zeta\\right) & =s_{B}  \\tag{A.65}\\\\\n\\operatorname{sign}(\\nabla s \\cdot \\nabla \\zeta) & =s_{B} s_{j}  \\tag{A.66}\\\\\n\\mathbf{B} \\cdot \\nabla \\zeta & =0  \\tag{A.67}\\\\\n\\boldsymbol{\\Omega} & =-s_{B} \\Omega \\nabla z  \\tag{A.68}\\\\\nu & =R \\Omega \\tag{A.69}\n\\end{align*}\n\n\n\\section*{A. 6 Flux surface average}\n\\section*{A.6.1 General}\nThe general definition of the flux surface average is\n\n\n\\begin{equation*}\n<A>=\\frac{\\int A(\\mathbf{x}) \\delta\\left(r-r_{0}\\right) d^{3} x}{\\int \\delta\\left(r-r_{0}\\right) d^{3} x} \\tag{A.70}\n\\end{equation*}\n\n\nwhere $A$ is the quantity being averaged, $r_{0}$ is the flux surface label of flux surface on which the average is being performed, $r$ is the value of the flux surface label at position $\\mathbf{x}, \\delta$ is the Dirac function and the integral is being performed over the whole plasma (or entire world, it does not matter) volume.\n\n\\section*{A.6.2 GKW coordinates}\nIn GKW coordinates $(r, \\zeta, s)$, the elementary plasma volume is\n\n\n\\begin{equation*}\nd^{3} x=d r d \\zeta d s \\mathcal{J} \\tag{A.71}\n\\end{equation*}\n\n\nwith $\\mathcal{J}^{-1}=\\nabla r \\cdot \\nabla \\zeta \\times \\nabla s$. Actually the expression above is true for any coordinates, but one of the specificity of GKW coordinate system is that $\\mathcal{J}$ is a flux surface label:\n\n\n\\begin{equation*}\n\\mathcal{J}=\\frac{\\partial \\Psi}{\\partial r} \\frac{s_{j}}{B^{s}} \\tag{A.72}\n\\end{equation*}\n\n\nand $B^{s}$ is a flux surface label by construction. This implies that the flux surface average can be written as\n\n\n\\begin{equation*}\n<A>=\\frac{\\oint_{r=r_{0}} A(r, \\zeta, s) d \\zeta d s}{\\oint_{r=r_{0}} d \\zeta d s} \\tag{A.73}\n\\end{equation*}\n\n\nIf $A$ is independent of the toroidal angle, one arrives at\n\n\n\\begin{equation*}\n<A>=\\oint A\\left(r_{0}, s\\right) d s \\tag{A.74}\n\\end{equation*}\n\n\n\\section*{A.6.3 Alternative expression}\nNoting that the surface element $\\mathrm{d} S$ on a flux surface is related to the volume element $\\mathrm{d}^{3} x$ by\n\n\n\\begin{equation*}\n\\mathrm{d}^{3} x=\\mathrm{d} S \\frac{\\mathrm{~d} r}{|\\nabla r|} \\tag{A.75}\n\\end{equation*}\n\n\nwith $r$ an arbitrary flux surface label, an alternative expression for the flux surface average is obtained:\n\n\n\\begin{equation*}\n<A>=\\frac{1}{V^{\\prime}} \\oint A \\frac{\\mathrm{~d} S}{|\\nabla r|} \\tag{A.76}\n\\end{equation*}\n\n\nwith\n\n\n\\begin{equation*}\nV^{\\prime}=\\frac{\\partial V}{\\partial r}=\\oint \\mathcal{J} \\mathrm{d} \\zeta \\mathrm{~d} s \\tag{\u0410.77}\n\\end{equation*}\n\n\nand $V$ being the volume enclosed by the flux surface labelled by $r$.\n\n\\section*{A. 7 Use of fluxes in transport equations}\nIn the following the density conservation equation is taken as an example, but the same can be applied to heat, momentum or any conserved quantity. The local density conservation equation is\n\n\n\\begin{equation*}\n\\frac{\\partial n}{\\partial t}+\\nabla \\cdot \\boldsymbol{\\Gamma}=S_{n} \\tag{A.78}\n\\end{equation*}\n\n\nwith $n$ the density in $\\mathrm{m}^{-3}, \\boldsymbol{\\Gamma}$ the particle flux in $\\mathrm{m}^{-2} \\mathrm{~s}^{-1}$ and $S_{n}$ the particle source density in $\\mathrm{m}^{-3} \\mathrm{~s}^{-1}$ Integrating this equation over the volume enclosed by a flux surface labelled by $r_{0}$ leads to:\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial t} \\int n \\mathrm{~d} V+\\oint \\boldsymbol{\\Gamma} \\cdot \\frac{\\nabla r}{|\\nabla r|} \\mathrm{d} S=\\int S_{n} \\mathrm{~d} V \\tag{\u0410.79}\n\\end{equation*}\n\n\nwhere the flux surface shape and position has been assumed to be constant in time. Using Eq. (A.76), the continuity equation can then be written as\n\n\n\\begin{equation*}\n\\frac{\\partial}{\\partial t} \\int n \\mathrm{~d} V+V^{\\prime}\\langle\\boldsymbol{\\Gamma} \\cdot \\nabla \\mathbf{r}\\rangle=\\int S_{n} \\mathrm{~d} V \\tag{A.80}\n\\end{equation*}\n\n\nIn steady-state we have:\n\n\n\\begin{equation*}\n<\\Gamma^{r}>=<\\boldsymbol{\\Gamma} \\cdot \\nabla \\mathbf{r}>=\\frac{1}{V^{\\prime}} \\int S_{n} \\mathrm{~d} V=\\frac{1}{V^{\\prime}} S_{n}^{\\mathrm{int}} \\tag{A.81}\n\\end{equation*}\n\n\nThis means that $\\Gamma^{r}$ which is the quantity we calculate in GKW needs to be compared to the particle source inside the flux surface $S_{n}^{\\mathrm{int}}$ divided by $V^{\\prime}$. This is the obvious choice for comparisons with the experiments or transport codes.\n\nConcerning the flux decomposition, the best choice is a direct decomposition of $<\\Gamma^{r}>$ :\n\n\n\\begin{equation*}\n<\\Gamma^{r}>=-D \\frac{\\partial n}{\\partial r}+V n \\tag{A.82}\n\\end{equation*}\n\n\nwith possibly a normalising length if $r$ is a dimensionless flux label (e.g. GKW $\\psi$ ). For a benchmark or a comparison with experiment one needs to make sure that everybody uses the same definition.\n\n\\section*{Appendix B }\n\\section*{Transformation of transport coefficients in presence of poloidal asymmetries}\n\\section*{Memo on the transformation of the transport coefficients \\\\\n from LFS density to flux-surface averaged density}\nPlease report comments and corrections to C. Angioni\n\nNote: The notation used in this Appendix does not attempt to be consistent with the rest of the GKW manual.\n\nIn the presence of a poloidally asymmetric density $n(r, \\theta)$ of a particle species like W , the flux surface averaged particle flux $\\Gamma$ can be expressed as a function of the flux surface averaged density $n(r)=\\langle n(r, \\theta)\\rangle$ or as a function of densities evaluated at specific locations or poloidal angles. A natural choice, for instance, is $n_{0}(r)=n(r, \\theta=0)$, evaluated at the LFS $\\theta=0$ location, which is adopted by codes like GKW and NEO.\n\nIn the present memo we provide the equations to transform the corresponding transport coefficients from one description to the other. This is practical for many applications, in particular when the output of codes which can include 2D poloidal asymmetries has to be used inside usual 1D transport codes, which consider only 1D (or in any case flux surface averaged) quantities.\n\nThe flux surface averaged particle flux is expressed in the two forms\n\n$$\n\\Gamma=-D \\frac{d n}{d r}+V n\n$$\n\nand\n\n$$\n\\Gamma=-D_{0} \\frac{d n_{0}}{d r}+V_{0} n_{0}\n$$\n\nand we state that these two forms are equivalent. In the present memo, we shall made this equivalence explicit.\n\nWe note that the first expression for $\\Gamma$ involves the flux surface averaged density $n(r)=\\langle n(r, \\theta)\\rangle$, and the corresponding transport coefficients $D$ and $V$. In contrast, the second expression involves the LFS density $n_{0}=n(r, \\theta=0)$ and the corresponding transport coefficients $D_{0}$ and $V_{0}$.\n\nWe remind that in general\n\n$$\nn(r, \\theta)=n_{0}(r) \\exp \\left\\{-\\frac{Z e \\Phi(r, \\theta)}{T(r)}+\\frac{m \\Omega^{2}(r)}{2 T(r)}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\}\n$$\n\nwhere $\\Phi$ is the background electrostatic potential, defined in such a way that $\\Phi(r, \\theta=0)=0$, and $R_{0}(r)$ is the major radius of the location where $n_{0}$ is evaluated (usually LFS $\\theta=0$ ).\n\nWe introduce also the auxiliary (species dependent) normalized energy\n\n$$\nE(r, \\theta)=\\frac{Z e \\Phi(r, \\theta)}{T(r)}-\\frac{m \\Omega^{2}(r)}{2 T(r)}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\n$$\n\nFor clarity, with circular concentric flux surfaces, $R(r, \\theta)=R_{\\text {geo }}+r \\cos \\theta$ and $R_{0}(r)=R_{\\text {geo }}+r$.\\\\\nIn general flux tube geometry, $\\theta$ is a generalized poloidal angle, which describes the distance along the field line. Considering the right handed system of coordinates $(r, \\theta, \\phi)$, the flux surface average of the quantity $n(r, \\theta)$ is given by\n\n$$\n\\langle f\\rangle=\\frac{1}{V^{\\prime}} \\oint d \\theta d \\phi \\sqrt{g} n(r, \\theta)\n$$\n\nwhere $g=(\\nabla r \\times \\nabla \\theta \\cdot \\nabla \\phi)^{-2}$ is the determinant of the metric tensor, and $V^{\\prime}=d V / d r$, where $V(r)$ is the plasma volume up to the flux surface $r$.\n\nThen, the following relationship holds,\n\n$$\n\\frac{d\\langle n(r, \\theta)\\rangle}{d r}=\\left\\langle\\frac{\\partial n(r, \\theta)}{\\partial r}\\right\\rangle+n_{0}(r) \\mathcal{G}_{r}\n$$\n\nwhere we have defined\n\n$$\n\\mathcal{G}_{r}=\\left[-\\frac{1}{V^{\\prime}} \\frac{d^{2} V}{d r^{2}}\\langle n(r, \\theta)\\rangle+\\frac{1}{V^{\\prime}} \\oint d \\theta d \\phi n(r, \\theta) \\frac{\\partial \\sqrt{g}}{\\partial r}\\right] n_{0}(r)^{-1}\n$$\n\nthat is\n\n$$\n\\mathcal{G}_{r}=-\\frac{1}{V^{\\prime}} \\frac{d^{2} V}{d r^{2}}\\langle\\exp \\{-E(r, \\theta)\\}\\rangle+\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial \\log (\\sqrt{g})}{\\partial r}\\right\\rangle\n$$\n\nPartial derivatives versus the minor radius $r$ are intended to be performed at constant $\\theta$. We note that $\\mathcal{G}_{r}=0$ with a Hamada coordinate system (as used in GKW).\n\nIn order to derive the relationship between the two pairs $(D, V)$ and $\\left(D_{0}, V_{0}\\right)$, we proceed by expressing the flux surface averaged density $n(r)$ and its radial derivative $d n(r) / d(r)$ in terms of $n_{0}(r)$ and $d n_{0}(r) / d(r)$. The relationship between $n(r)$ and $n_{0}(r)$ is straightforward\n\n", "$$\nn(r)=n_{0}(r)\\left\\langle\\exp \\left\\{-\\frac{Z e \\Phi(r, \\theta)}{T(r)}+\\frac{m \\Omega^{2}(r)}{2 T(r)}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\}\\right\\rangle\n$$\n\nIn order to express $d n(r) / d(r)$ in terms of $n_{0}(r)$ and $d n_{0}(r) / d(r)$, we proceed with the computation of $\\partial n(r, \\theta) / \\partial r$.\n\n\n\\begin{align*}\n\\frac{\\partial n(r, \\theta)}{\\partial r} & =\\exp \\left\\{-\\frac{Z e \\Phi(r, \\theta)}{T(r)}+\\frac{m \\Omega^{2}(r)}{2 T(r)}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\}\\left\\{\\frac{d n_{0}(r)}{d r}+n_{0}(r) \\cdot\\right. \\\\\n& \\cdot\\left[-\\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}+\\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)+\\frac{m \\Omega^{2}}{2 T(r)} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right] \\\\\n& \\left.+n_{0}(r) \\frac{1}{T(r)} \\frac{d T(r)}{d r}\\left[\\frac{Z e}{T(r)} \\Phi(r, \\theta)-\\frac{m \\Omega^{2}}{2 T(r)}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right]\\right\\} \\tag{B.1}\n\\end{align*}\n\n\nWe take now the flux surface average, and recalling that\n\n$$\n\\frac{d n(r)}{d r}=\\left\\langle\\frac{\\partial n(r, \\theta)}{\\partial r}\\right\\rangle+n_{0}(r) \\mathcal{G}_{r}\n$$\n\nwe find,\n\n$$\n\\begin{aligned}\n\\frac{d n(r)}{d r} & =\\langle\\exp \\{-E(r, \\theta)\\}\\rangle \\frac{d n_{0}(r)}{d r}+ \\\\\n& +n_{0}(r)\\left\\{-\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}\\right\\rangle\\right. \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\Phi(r, \\theta)\\right\\rangle \\frac{1}{T(r)} \\frac{d T(r)}{d r} \\\\\n& \\left.-\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}\\right\\}+n_{0}(r) \\mathcal{G}_{r}\n\\end{aligned}\n$$\n\nAt this point, we replace the expressions of $d n(r) / d r$ and $n(r)$ in the expression for $\\Gamma$ and we obtain\n\n$$\n\\begin{aligned}\n\\Gamma= & -D\\langle\\exp \\{-E(r, \\theta)\\}\\rangle \\frac{d n_{0}(r)}{d r}+ \\\\\n& -D n_{0}(r)\\left\\{-\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}\\right\\rangle\\right. \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\Phi(r, \\theta)\\right\\rangle \\frac{1}{T(r)} \\frac{d T(r)}{d r} \\\\\n& \\left.-\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}+\\mathcal{G}_{r}\\right\\} \\\\\n& +V n_{0}(r)\\langle\\exp \\{-E(r, \\theta)\\}\\rangle\n\\end{aligned}\n$$\n\nFinally, we compare with equation\n\n$$\n\\Gamma=-D_{0} \\frac{d n_{0}}{d r}+V_{0} n_{0}\n$$\n\nand we identify the following relationships:\n\n$$\nD_{0}=D\\langle\\exp \\{-E(r, \\theta)\\}\\rangle,\n$$\n\nand\n\n$$\n\\begin{aligned}\nV_{0} & =-D\\left\\{-\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}\\right\\rangle\\right. \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\Phi(r, \\theta)\\right\\rangle \\frac{1}{T(r)} \\frac{d T(r)}{d r} \\\\\n& \\left.-\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}+\\mathcal{G}_{r}\\right\\} \\\\\n& +V\\langle\\exp \\{-E(r, \\theta)\\}\\rangle.\n\\end{aligned}\n$$\n\nThe final relationships follow directly\n\n$$\nD=D_{0}\\langle\\exp \\{-E(r, \\theta)\\}\\rangle^{-1}=D_{0} \\frac{n_{0}}{n}\n$$\n\n$$\n\\begin{aligned}\nV & =V_{0}\\langle\\exp \\{-E(r, \\theta)\\}\\rangle^{-1}+D_{0}\\left\\{-\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}\\right\\rangle\\right. \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\Phi(r, \\theta)\\right\\rangle \\frac{1}{T(r)} \\frac{d T(r)}{d r} \\\\\n& \\left.-\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}+\\mathcal{G}_{r}\\right\\}\\langle\\exp \\{-E(r, \\theta)\\}\\rangle^{-2}\n\\end{aligned}\n$$\n\nWe define the following conversion factor for the convection,\n\n$$\n\\begin{aligned}\n\\mathcal{V} & =a\\left\\{-\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}\\right\\rangle\\right. \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\\\\n& +\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\Phi(r, \\theta)\\right\\rangle \\frac{1}{T(r)} \\frac{d T(r)}{d r} \\\\\n& \\left.-\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}+\\mathcal{G}_{r}\\right\\}\\langle\\exp \\{-E(r, \\theta)\\}\\rangle^{-1},\n\\end{aligned}\n$$\n\nby which the transformation from the pair $\\left(D_{0}, V_{0}\\right)$ into the pair $(D, V)$ simply reads\n\n\n\\begin{align*}\nD & =\\langle\\exp \\{-E(r, \\theta)\\}\\rangle^{-1} D_{0}=\\frac{n_{0}}{n} D_{0}  \\tag{B.2}\\\\\na V & =\\langle\\exp \\{-E(r, \\theta)\\}\\rangle^{-1}\\left(a V_{0}+D_{0} \\mathcal{V}\\right) \\tag{B.3}\n\\end{align*}\n\n\nHere we have introduced an arbitrary normalizing length $a$ (usually the geometrical major radius $R_{g e o}$ in GKW and the minor radius $a$ in NEO).\n\nThe quantity $\\mathcal{V}$ can be directly computed inside codes which treat poloidal aysmmetries (like GKW and NEO). It is suggested that the quantity $\\mathcal{V}$ is computed for each species independently.\n\nThereby, for each kinetic species, codes like GKW and NEO can provide directly in output the two flux surface averaged quantities $n_{0} / n$ (already present in output actually) and the convection conversion factor $\\mathcal{V}$. In this way the equation to be applied in 1 D transport codes to pass from $\\left(D_{0}, V_{0}\\right)$ to $(D, V)$ is very simple.\\\\\nOptionally, codes like GKW and NEO can also provide in output the entire set of flux surface averaged quantities which are required to perform the transformation from the pair $\\left(D_{0}, V_{0}\\right)$ into the pair $(D, V)$,\n\n$$\n\\begin{aligned}\ne_{0} & =\\langle\\exp \\{-E(r, \\theta)\\}\\rangle \\\\\ne_{1} & =\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\Phi(r, \\theta)\\right\\rangle \\\\\ne_{2} & =a\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{Z e}{T(r)} \\frac{\\partial \\Phi(r, \\theta)}{\\partial r}\\right\\rangle \\\\\ne_{3} & =a^{-2}\\left\\langle\\exp \\{-E(r, \\theta)\\}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\\\\ne_{4} & =a^{-1}\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial}{\\partial r}\\left(R(r, \\theta)^{2}-R_{0}(r)^{2}\\right)\\right\\rangle \\\\\ne_{5} & =a \\mathcal{G}_{r}=a\\left[-\\frac{1}{V^{\\prime}} \\frac{d^{2} V}{d r^{2}} e_{0}+\\left\\langle\\exp \\{-E(r, \\theta)\\} \\frac{\\partial \\log (\\sqrt{g})}{\\partial r}\\right\\rangle\\right]\n\\end{aligned}\n$$\n\nwhere we included normalizations to an arbitrary length $a$, which can be chosen in order to be consistent with the other normalizations used in the codes (that is, e.g., major radius in GKW, and minor radius in NEO). We remind that $e_{5}=0$ with Hamada coordinates, as used in GKW. Then, the convection conversion factor reads\n\n$$\n\\mathcal{V}=\\frac{1}{e_{0}}\\left\\{-e_{2}+e_{3} a^{3} \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r}+e_{4} a^{2} \\frac{m \\Omega^{2}}{2 T(r)}+e_{1} a \\frac{1}{T(r)} \\frac{d T(r)}{d r}-e_{3} a^{3} \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}+e_{5}\\right\\}\n$$\n\nand the transformation equations read\n\n$$\n\\begin{aligned}\n& D=\\frac{D_{0}}{e_{0}}=\\frac{n_{0}}{n} D_{0} \\\\\n& a V=\\left(a V_{0}+D_{0} \\mathcal{V}\\right) e_{0}^{-1}\n\\end{aligned}\n$$\n\nWe notice that the convection conversion factor $\\mathcal{V}$ has been defined in such a way that\n\n$$\n\\frac{a V}{D}=\\frac{a V_{0}}{D_{0}}+\\mathcal{V}\n$$\n\nwhich can also be regarded as a direct consequence of the following relationship\n\n$$\n\\frac{a}{n} \\frac{d n}{d r}=\\frac{a}{n_{0}} \\frac{d n_{0}}{d r}+\\mathcal{V}\n$$\n\n\\section*{B.0.1 Anisotropic minorities (Reinke model)}\nIn the Reinke model (see Sec. 4.4.1), the poloidal density variation for the anisotropic minority is\n\n\n\\begin{equation*}\nn(r, \\theta)=n_{0}\\left(\\frac{B}{B_{0}}\\right)^{-\\eta} \\exp \\left(-\\mathcal{E}_{\\Omega} / T_{\\|}\\right)=n_{0} \\exp \\left(-\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}\\right) \\tag{B.4}\n\\end{equation*}\n\n\nThe radial deriviative then has additional terms\n\n\n\\begin{equation*}\n\\frac{\\partial n(r, \\theta)}{\\partial r}=n_{0}\\left[-\\ln \\left(B / B_{0}\\right) \\frac{\\partial \\eta}{\\partial r}-\\frac{\\eta}{B} \\frac{\\partial B}{\\partial r}+\\frac{\\eta}{B_{0}} \\frac{\\partial B_{0}}{\\partial r}\\right] \\exp \\left(-\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}\\right)+\\cdots \\tag{B.5}\n\\end{equation*}\n\n\nwhere $\\cdots$ represents all the terms on the RHS of equation B. 1 with the generalised normalised energy $E=\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}$in place of the former $E=\\mathcal{E}_{\\Omega} / T$ (as defined in Eq. 4.36). The coefficients $e_{0}, e_{1}, e_{2}, e_{3}, e_{4}, e_{5}$ are also generalised using this generalised energy in their definition. Then, the transformation identities above all still hold if $\\mathcal{V}$ is extended to\n\n\n\\begin{equation*}\n\\mathcal{V}=\\frac{1}{e_{0}}\\left\\{-e_{2}+e_{3} a^{3} \\frac{m \\Omega}{T(r)} \\frac{d \\Omega(r)}{d r}+e_{4} a^{2} \\frac{m \\Omega^{2}}{2 T(r)}+e_{1} a \\frac{1}{T(r)} \\frac{d T(r)}{d r}-e_{3} a^{3} \\frac{m \\Omega^{2}}{2 T(r)} \\frac{1}{T(r)} \\frac{d T(r)}{d r}+e_{5}+e_{\\eta}\\right\\} \\tag{B.6}\n\\end{equation*}\n\n\nwhere the additional coefficient $e_{\\eta}$ is defined as\n\n$$\ne_{\\eta}=a\\left\\langle\\exp \\left\\{-\\mathcal{E}_{\\Omega, \\eta}(r, \\theta) / T_{\\|}\\right\\}\\left[-\\ln \\left(B / B_{0}\\right) \\frac{\\partial \\eta}{\\partial r}-\\frac{\\eta}{B} \\frac{\\partial B}{\\partial r}+\\frac{\\eta}{B_{0}} \\frac{\\partial B_{0}}{\\partial r}\\right]\\right\\rangle.\n$$\n\n\\section*{B.0.2 Anisotropic minorities (Bilato model)}\nIn the Bilato model (see Sec. 4.4.2), the poloidal density variation for the anisotropic minority is\n\n\n\\begin{equation*}\nn_{m}=n_{0} \\frac{T_{\\perp}(\\theta)}{T_{\\perp 0}} \\exp \\left(-\\mathcal{E}_{\\Omega} / T_{\\|}\\right)=n_{0} \\exp \\left(-\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}\\right) \\tag{B.7}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{equation*}\n\\frac{T_{\\perp}(\\theta)}{T_{\\perp 0}}=\\left[\\frac{T_{\\perp 0}}{T_{\\|}}+\\left(1-\\frac{T_{\\perp 0}}{T_{\\|}}\\right) \\frac{B_{0}}{B}\\right]^{-1} \\tag{B.8}\n\\end{equation*}\n\n\nThe radial deriviative then has additional terms\n\n\n\\begin{equation*}\n\\frac{\\partial n(r, \\theta)}{\\partial r}=-n_{0}\\left[\\frac{\\partial\\left(T_{\\perp 0} / T_{\\|}\\right)}{\\partial r}\\left(1-\\frac{B_{0}}{B}\\right)+\\left(-\\frac{B_{0}}{B^{2}} \\frac{\\partial B}{\\partial r}+\\frac{1}{B} \\frac{\\partial B_{0}}{\\partial r}\\right)\\left(1-\\frac{T_{\\perp 0}}{T_{\\|}}\\right)\\right] \\frac{T_{\\perp}(\\theta)}{T_{\\perp 0}} \\exp \\left(-\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}\\right)+\\cdots \\tag{B.9}\n\\end{equation*}\n\n\nwhere $\\cdots$ represents all the terms on the RHS of equation B. 1 with the generalised normalised energy $E=\\mathcal{E}_{\\Omega, \\eta} / T_{\\|}$in place of the former $E=\\mathcal{E}_{\\Omega} / T$ (as defined in Eq. 4.41). The coefficients $e_{0}, e_{1}, e_{2}, e_{3}, e_{4}, e_{5}$ are also generalised using this generalised energy in their definition. Then $\\mathcal{V}$ is extended as in Eq. B. 6 with the additional coefficient $e_{\\eta}$ is defined as\n\n$$\ne_{\\eta}=-a\\left\\langle\\exp \\left\\{-\\mathcal{E}_{\\Omega, \\eta}(r, \\theta) / T_{\\|}\\right\\}\\left[\\frac{\\partial\\left(T_{\\perp 0} / T_{\\|}\\right)}{\\partial r}\\left(1-\\frac{B_{0}}{B}\\right)+\\left(-\\frac{B_{0}}{B^{2}} \\frac{\\partial B}{\\partial r}+\\frac{1}{B} \\frac{\\partial B_{0}}{\\partial r}\\right)\\left(1-\\frac{T_{\\perp 0}}{T_{\\|}}\\right)\\right] \\frac{T_{\\perp}(\\theta)}{T_{\\perp 0}}\\right\\rangle\n$$\n\n\\section*{Bibliography}\n[1] A.G. Peeters, Y. Camenen, F.J. Casson, W.A. Hornsby, A.P. Snodin, D. Strintzi, G. Szepesi, Computer Physics Communications, 180, 2650, (2009). doi: 10.1016/j.cpc.2009.07.001.\\\\[0pt]\n[2] A.G. Peeters, D. Strintzi, Phys. Plasmas 11 (2004) 3748\\\\[0pt]\n[3] A.G. Peeters, C. Angioni, D. Strintzi, Phys. Rev. Lett. 98 (2007) 265003\\\\[0pt]\n[4] S.E. Parker, W.W. Lee, R.A. Sandtoro, Phys. Rev. Lett. 71 (1993) 2042\\\\[0pt]\n[5] Z. Lin, T.S. Hahm, W.W. Lee, et al., Science 281 (1998) 1835\\\\[0pt]\n[6] Y. Idomura, S. Tokuda, Y. Kishimoto, Nucl. Fusion 43 (2003) 234\\\\[0pt]\n[7] J.A. Heikkinen, J.S. Janhunen, T.P. Kiviniemi, et al., Contr. Plas. Phys. 44 (2004) 13\\\\[0pt]\n[8] A. Bottino, A.G. Peeters, R. Hatzky, et al., Phys. Plasmas 14 (2007) 010701\\\\[0pt]\n[9] S. Jolliet, A. Bottino, P. Angelino, et al., Comp. Phys. Comm. 177 (2007) 409\\\\[0pt]\n[10] V. Grandgirard, M. Brunetti, P. Bertrand, et al., J. Comp. Physics 217 (2006) 395\\\\[0pt]\n[11] M. Kotschenreuther, G. Rewoldt, W.M. Tang., Comp. Phys. Comm. 88 (1995) 128\\\\[0pt]\n[12] W. Dorland, F. Jenko, M. Kotschenreuther, et al., Phys. Rev. Lett. 85 (2000) 5579\\\\[0pt]\n[13] F. Jenko, Comp. Phys. Comm. 125 (2000) 196\\\\[0pt]\n[14] T. Dannert, F. Jenko, Phys Plasmas 12 (2005) 072309\\\\[0pt]\n[15] J. Candy, R.E. Waltz, J. Comp. Phys. 186 (2003) 545\\\\[0pt]\n[16] B.D. Scott delta-FEFI\\\\[0pt]\n[17] A.G. Peeters, C. Angioni, Phys. Plasmas 12 (2005) 072515\\\\[0pt]\n[18] A.G. Peeters, C. Angioni, A. Bottino, et al. Plasma Phys. Contr. Fusion 48 (2006) B413\\\\[0pt]\n[19] A.G. Peeters, C. Angioni, D. Strintzi, Phys. Plasmas 16 (2009) 034703\\\\[0pt]\n[20] A.G. Peeters, D. Strintzi, C. Angioni, et al., Phys. Plasmas 16 (2009) 042310 (Note also the Erratum to this paper)\\\\[0pt]\n[21] Y. Camenen, A.G. Peeters, C. Angioni, Phys. Rev. Lett. 102 (2009) 125001\\\\[0pt]\n[22] A.G. Peeters, C.Angioni, Y. Camenen, et al., Phys. Plasmas. 16 (2009) 062311\\\\[0pt]\n[23] Y. Camenen, A.G. Peeters, C. Angioni, et al., Phys. Plasmas 16 (2009) 062501\\\\[0pt]\n[24] F.J. Casson, A.G. Peeters, Y. Camenen, et al., Phys. Plasmas 16 (2009) 092303\\\\[0pt]\n[25] Y. Camenen, A.G. Peeters, C. Angioni, et al., Phys. Plasmas 16 (2009) 012503\\\\[0pt]\n[26] F.J. Casson, A.G. Peeters, C. Angioni, et al., Phys. Plasmas 17 (2010) 102305\\\\[0pt]\n[27] W.A. Hornsby, A.G. Peeters, A.P. Snodin, et. al., Phys. Plasmas 17 (2010) 092301\\\\[0pt]\n[28] W.A. Hornsby, A.G. Peeters, E. Poli, et al., Euro. Phys. Let. 91 (2010) 45001\\\\[0pt]\n[29] R.G. Littlejohn, J. Plasma Phys. 29 (1983) 111\\\\[0pt]\n[30] T.S. Hahm, Phys. Fluids 31 (1988) 043207\\\\[0pt]\n[31] A. Brizard, Phys. Plasmas 41 (1988) 541\\\\[0pt]\n[32] H. Sugama, Phys. Plasmas 7 (2000) 466\\\\[0pt]\n[33] A. Brizard, Rev. Modern Phys. 79 (2007) 421\\\\[0pt]\n[34] M. Beer, PhD thesis, Princeton University 1995\\\\[0pt]\n[35] A. J. Brizard, Phys. Plasmas 2 (1995) 459\\\\[0pt]\n[36] S. Hamada, Kakuyugo Kenkyu 1 (1958) 542\\\\[0pt]\n[37] R. L. Miller, M. S. Chu, J. M. Greene, Y. R. Lin-Liu, R. E. Waltz, Phys. Plasmas 5 (1998) 973\\\\[0pt]\n[38] J.Candy, Plasma Phys. Control. Fusion 51 (2009) 105009\\\\[0pt]\n[39] A.Thyagaraja, K.G.McClements, Phys. Plasmas 13, 062502 (2006)\\\\[0pt]\n[40] B. D. Scott, Phys Plasmas 5 (1998) 2334\\\\[0pt]\n[41] B. D. Scott, Phys Plasmas 8 (2001) 447\\\\[0pt]\n[42] H. L\u00fctjens, A. Bondeson and O. Sauter, Comput. Phys. Commun. 97 (1996) 219\\\\[0pt]\n[43] J. W. Connor, R. J. Hastie and J. B. Taylor, Phys. Rev. Let., 40 (1978) 396\\\\[0pt]\n[44] X. Lapillonne, S. Brunner, T. Dannert, S. Jolliet, A. Marinoni, L. Villard, T. Goerler, F. Jenko, and F. Merz, Phys. Plasmas, 16, 032308, (2009).\\\\[0pt]\n[45] W. Dorland, M. Kotschenreuther, Notes on Local Equilibrium Implementation available from \\href{http://w3.pppl.gov/}{http://w3.pppl.gov/} hammett/work/gs2/docs/geometry/g\\_short.pdf\\\\[0pt]\n[46] C. F. F. Karney, Comp. Phys. Reports 4 (1986) 183\\\\[0pt]\n[47] C. Veth, C. Angioni, 2011, Report on grid convergence with GKW available from \\href{http://www.gkw.org.uk/tikiwiki/Manual}{http://www.gkw.org.uk/tikiwiki/Manual}\\\\[0pt]\n[48] A.M. Dimits, Phys. Plasmas 7 (2000) 969\\\\[0pt]\n[49] G. L. Falchetto, B. D Scott, P. Angelino, A. Bottino, T. Dannert, V. Grandgirard, S. Janhunen, F. Jenko, S. Jolliet, A. Kendl, B. F. McMillan, V. Naulin, A. H. Nielsen, M. Ottaviani, A. G. Peeters, M. J. Pueschel, D. Reiser, T. T. Ribeiro, and M. Romanelli, Plasma Physics and Controlled Fusion 50 (2008) 124015\\\\[0pt]\n[50] C. M. Roach, et. Al. Plasma Phys. Control. Fusion 51, 124020, (2009).\\\\[0pt]\n[51] F. J. Casson, PhD Thesis, University of Warwick, 2011. \\href{http://wrap.warwick.ac.uk/36765/}{http://wrap.warwick.ac.uk/36765/}\\\\[0pt]\n[52] F. J. Casson, 2011, GKW benchmark of background ExB shear with GYRO available from \\href{http://www.gkw.org.uk/tikiwiki/Manual}{http://www.gkw.org.uk/tikiwiki/Manual}\\\\[0pt]\n[53] J. E. Kinsey, R. E. Waltz, and J. Candy, Phys. Plasmas 12, 062302 (2005).\\\\[0pt]\n[54] Fable, E., C. Angioni, F. J. Casson, D. Told, et al., Plasma Physics and Controlled Fusion 55, 124028 (2013)\\\\[0pt]\n[55] D. Told, F. Jenko, T. Goerler, F. J. Casson, E. Fable, and ASDEX Upgrade Team., Phys. Plasmas 20, 122312 (2013)\\\\[0pt]\n[56] M. Frigo, S. G. Johnson, Proc. IEEE 93 (2005) 216\\\\[0pt]\n[57] C. Campos, J. E. Roman, E. Romero and A. Tomas, SLEPc Users Manual DSIC-II/24/02 Revision 3.3, D. Sistemes Inform\u00e0tics i Computaci\u00f3, Universitat Polit\u00e8cnica de Val\u00e8ncia, 2012. \\href{http://www.grycap.upv.es/slepc/documentation/manual.htm}{http://www.grycap.upv.es/slepc/documentation/manual.htm}\\\\[0pt]\n[58] T. S. Hahm and K. H. Burrell. Phys. Plasmas, 2 (1995) 1648\\\\[0pt]\n[59] K. H. Burrell. Phys. Plasmas, 4 (1997) 1499\\\\[0pt]\n[60] R. E. Waltz, G. D. Kerbel, and J. Milovich, Phys. Plasmas 1 (1994) 2229\\\\[0pt]\n[61] R. L. Miller and R. E. Waltz, Phys. Plasmas 1 (1994) 2835\\\\[0pt]\n[62] F. Baron. PhD in physics, (Univ. Pierre et Marie Curie, Paris, France, 1982)\\\\[0pt]\n[63] U. Schumann, Algorithms for direct numerical simulation of shear-periodic turbulence, in Lecture Notes in Physics 218 (Berlin Springer Verlag 1985) pages 492\\\\[0pt]\n[64] T. Gerz, U. Schumann, and S. E. Elghobashi, Journal of Fluid Mechanics Digital Archive 200 (1989) 563\\\\[0pt]\n[65] R. S. Rogallo, Numerical experiments in homogeneous turbulence. NASA STI/Recon Technical Report $N$ (1981) 81:31508\\\\[0pt]\n[66] T. A. Zang, Applied Numerical Mathematics 7 (1991) 27\\\\[0pt]\n[67] Alain Pumir, Phys. Fluids, 8 (1996) 3112\\\\[0pt]\n[68] G. W. Hammett, W. Dorland, N. F. Loureiro, and T. Tatsuno. Implementation of Large Scale E x B Shear Flow in the GS2 Gyrokinetic Turbulence Code. APS Meeting Abstracts (2006) pages 1136\\\\[0pt]\n[69] F. Jenko, T. Dannert, C. Angioni, Plasma Phys. Contr. Fusion 47 (2005) B195\\\\[0pt]\n[70] W.W. Lee, J.L.V. Lewandowski, T.S. Hahm, and Z. Lin, Phys. Plasmas 8, 4435 (2001)\\\\[0pt]\n[71] F. Merz and F. Jenko, Nucl. Fusion 50, 054005 (2010)\\\\[0pt]\n[72] F. L. Hinton, M. N. Rosenbluth, Phys. Rev. Lett. 80 (1998) 724\\\\[0pt]\n[73] Y. Xiao, P. J. Catto, Phys. Plasmas 13 (2006) 102311\\\\[0pt]\n[74] A. G. Peeters, C. Angioni, M. Apostoliceanu et al., Phys. Plasma 12 (2005) 022505\\\\[0pt]\n[75] W. Nevins, et al., Phys. Plasmas 13 (2006) 122306\\\\[0pt]\n[76] A. Arakawa, J. Comp. Phys. 1 (1966) 119\\\\[0pt]\n[77] J.Dunkel, P.Talkner, B. H\u00e4nggi, New Journal of Physics 9 (2007) 114\\\\[0pt]\n[78] M. L. Reinke et al, Plasma Phys. Contr. Fusion 54 (2012) 045004\\\\[0pt]\n[79] R. Bilato, O. Maj, C. Angioni, Nucl. Fusion (letter), 56 (2014)\\\\[0pt]\n[80] T. Sung, R. Buchholz, F.J. Casson, E. Fable, S.R. Grosshauser, W.A. Hornsby, P. Migliano and A.G. Peeters, Phys. Plasmas 20, 042506 (2013)\n\n\\section*{Index}\nField aligned coordinates, 154\\\\\nfull-f simulations, 80\\\\\nGlobal simulations, 80\\\\\nHamada coordinates, 153\\\\\nKrook operator, 88\\\\\nLagrangian, 8, 81\\\\\nMagnetic field representation, 153, 156\\\\\nMaxwell distribution, 86\\\\\nNoether's theorem, Energy conservation, 83\\\\\nNon linear terms, 104\\\\\nNon-spectral, 80\\\\\nNormalization, 85\\\\\nPeriodicity on the torus, 156\\\\\nPoisson equation, 81\\\\\nProfile functions, 89\\\\\nVelocity nonlinearity, 88\n\n\\section*{Nomenclature}\nH The Hamiltonian\\\\\n$L \\quad$ The Lagrangian\\\\\n$L_{p} \\quad$ The particle Lagrangian\\\\\n$T \\quad$ The temperature\\\\\nX The gyro-centre spatial coordinate\\\\\n$Z \\quad$ The charge number\\\\\n$e \\quad$ The unit charge\\\\\n$f \\quad$ The perturbed distribution\\\\\n$F_{M} \\quad$ The Maxwell distribution\\\\\nv The velocity\\\\\n$\\phi \\quad$ The perturbed potential\\\\\n$\\rangle \\quad$ The gyro-average operation\\\\\n$\\left\\rangle^{\\dagger} \\quad\\right.$ The conjugate transpose of the gyro-average operator\n\n\n\\end{document}", "% This LaTeX document needs to be compiled with XeLaTeX.\n\\documentclass[10pt]{article}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n\\usepackage{amssymb}\n\\usepackage[version=4]{mhchem}\n\\usepackage{stmaryrd}\n\\usepackage{hyperref}\n\\hypersetup{colorlinks=true, linkcolor=blue, filecolor=magenta, urlcolor=cyan,}\n\\urlstyle{same}\n\\usepackage{graphicx}\n\\usepackage[export]{adjustbox}\n\\graphicspath{ {./images/} }\n\\usepackage[fallback]{xeCJK}\n\\usepackage{polyglossia}\n\\usepackage{fontspec}\n\\setCJKmainfont{Noto Serif CJK TC}\n\n\\setmainlanguage{english}\n\\setmainfont{CMU Serif}\n\n\\title{RESEARCH ARTICLE | APRIL 011998 }\n\n\\author{R. L. Miller, M. S. Chu, J. M. Greene, Y. R. Lin-Liu, and R. E. Waltz\\\\\nGeneral Atomics, San Diego, California 92186-5608}\n\\date{}\n\n\n\\begin{document}\n\\maketitle\n\\section*{Noncircular, finite aspect ratio, local equilibrium model}\n$\\qquad$\\\\\nR. L. Miller; M. S. Chu; J. M. Greene; Y. R. Lin-Liu; R. E. Waltz\n\nCheck for updates\\\\\nPhys. Plasmas 5, 973-978 (1998)\\\\\n\\href{https://doi.org/10.1063/1.872666}{https://doi.org/10.1063/1.872666}\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_42e8ebfddc819d9dcfb1g-1}\n\n\\section*{Articles You May Be Interested In}\nStability of liquid bridges between an elliptical and a circular supporting disk\\\\\nPhysics of Fluids (October 2003)\\\\\nDirect numerical simulations of two-phase laminar jet flows with different cross-section injection geometries Physics of Fluids (October 2002)\n\nDynamic measurement of optical fiber diameter\\\\\nRev. Sci. Instrum. (December 1973)\n\nPhysics of Plasmas\n\n\\section*{Special Topics Open for Submissions}\n\\section*{Noncircular, finite aspect ratio, local equilibrium model }\n(Received 6 August 1997; accepted 5 January 1998)\n\n\\begin{abstract}\nA tokamak equilibrium model, local to a flux surface, is introduced which is completely described in terms of nine parameters including aspect ratio, elongation, triangularity, and safety factor. By allowing controlled variation of each of these nine parameters, the model is particularly suitable for localized stability studies such as those carried out using the ballooning mode representation of the gyrokinetic equations. \u00a9 1998 American Institute of Physics. [S1070-664X(98)02204-6]\n\\end{abstract}\n\n\\section*{I. INTRODUCTION}\nEquilibrium information used for studying the stability of localized modes in a tokamak typically comes from one of two sources. One is the shifted circle $s-\\alpha$ model $^{1}$ which allows easy manipulation of the shear and pressure gradient but is unable to deal with essential equilibrium features such as elongation and triangularity. The other source is numerically generated equilibria which incorporate all of the correct geometry but require recomputation of an equilibrium when parameters are changed. It can also be difficult to keep some parameters constant while varying others when computing numerical equilibria. One exception is the generalized $s-\\alpha$ model of Greene and Chance ${ }^{2}$ which allows modification of the shear or pressure gradient on a flux surface without recomputing the equilibrium.\n\nHere we utilize the localized equilibrium analysis of Mercier and $\\mathrm{Luc}^{3}$ to develop a local model for finite aspect ratio, noncircular equilibria. The Mercier-Luc analysis has been used by Bishop and co-workers ${ }^{4-6}$ in ballooning mode studies and more recently by Roach et al. ${ }^{7}$ in the calculation of trapped particle precession. We introduce a parametrization technique for the poloidal field which extends the usefulness of this approach.\n\nWe are able to characterize exact local equilibria using nine parameters; s (global magnetic shear), $\\alpha$ (pressure gradient), $A$ (aspect ratio), $\\kappa$ (elongation), $\\delta$ (triangularity), $q$ (safety factor), and the variation of $\\kappa, \\delta$, and the major radius with flux surface. The purpose of developing this model is to facilitate variation of equilibrium parameters in localized stability studies such as those carried out using the ballooning mode representation of the gyrokinetic equations.\n\nIn Sec. II, we review the Mercier-Luc formalism and show the relationship between this analysis and the generalized $s-\\alpha$ model of Greene and Chance ${ }^{2}$ which was developed to study stability to ideal magnetohydrodynamic (MHD) ballooning modes. In Sec. III, we briefly show that the large $A$, shifted circle equilibrium model is a special case of the Mercier-Luc formalism. This has previously been shown by Bishop ${ }^{6}$ but serves as an introduction to our more general model developed in Sec. IV. Section V presents an example application to ideal MHD ballooning modes and Sec. VI contains a discussion and summary.\n\n\\section*{II. MERCIER-LUC FORMALISM}\nThe information required on a flux surface ( $\\psi=\\psi_{0}$ ) to completely specify an equilibrium in the neighborhood of that flux surface was given by Mercier and Luc. ${ }^{3}$ That information consists of (1) the flux surface shape $R_{s}(l), Z_{s}(l)$; (2) the poloidal field on the flux surface $B_{p s}(l)$; and (3) the components of the toroidal current $p^{\\prime}\\left(\\psi_{0}\\right)$ and $f f^{\\prime}\\left(\\psi_{0}\\right)$, where $R$ and $Z$ are the usual cylindrical coordinates and $l$ is the poloidal arc length. Of course, any poloidal coordinate will suffice. The symbol ' denotes a derivative with respect to poloidal flux $\\psi$, and the magnetic field is given by\n\n\n\\begin{equation*}\n\\bar{B}=\\overline{B_{p}}+\\overline{B_{T}}=\\nabla \\phi \\times \\nabla \\psi+f(\\psi) \\nabla \\phi, \\tag{1}\n\\end{equation*}\n\n\nwhere $\\phi$ is the toroidal angle.\\\\\nThe above is necessary and sufficient information to make a local expansion of the Grad-Shafranov equation about the flux surface $\\psi=\\psi_{0}$. One additional piece of information is required to determine the safety factor $q$ and the toroidal field, e.g., $f\\left(\\psi_{0}\\right)=R B_{T}$.\n\nTo perform the local expansion of the Grad-Shafranov equation and determine quantities in the neighborhood of $\\psi_{0}$, Mercier and Luc ${ }^{3}$ define an orthogonal coordinate system $\\rho, l, \\phi$ where $\\rho$ is the normal distance from flux surface $\\psi=\\psi_{0}, l$ is the poloidal distance along the flux surface $\\psi$ $=\\psi_{0}$, and $\\phi$ is the toroidal angle (see Fig. 1).\n\nAdditionally an angle $u$ is defined such that\n\n\n\\begin{equation*}\n\\frac{d R_{s}}{d l}=\\cos u \\tag{2}\n\\end{equation*}\n\n\nand\n\n\n\\begin{equation*}\n\\frac{d Z_{s}}{d l}=-\\sin u \\tag{3}\n\\end{equation*}\n\n\nWith this definition of $u$ we note that\n\n\n\\begin{equation*}\n\\frac{d u}{d l}=-\\frac{1}{R_{c}} \\tag{4}\n\\end{equation*}\n\n\nwhere $R_{c}(l)$ is the radius of curvature of the flux surface $\\psi$ $=\\psi_{0}$ \u3002\n\nIn terms of these coordinates, the cylindrical coordinates $R$ and $Z$ may be written\n\n\n\\begin{equation*}\nR=R(\\rho, l)=R_{s}(l)+\\rho \\sin u(l), \\tag{5}\n\\end{equation*}\n\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_11_06_42e8ebfddc819d9dcfb1g-3}\n\\end{center}\n\nFIG. 1. The Mercier-Luc coordinate system.\n\n\n\\begin{equation*}\nZ=Z(\\rho, l)=Z_{s}(l)+\\rho \\cos u(l) \\tag{6}\n\\end{equation*}\n\n\nand the Jacobian is given by\n\n\n\\begin{equation*}\nJ=\\left(1-\\frac{\\rho}{R_{c}}\\right) R \\tag{7}\n\\end{equation*}\n\n\nLet\n\n\n\\begin{equation*}\n\\psi=\\psi_{0}+\\psi_{1}(l) \\rho+\\psi_{2}(l) \\rho^{2}+\\cdots \\tag{8}\n\\end{equation*}\n\n\nTo calculate $B_{p}^{2}$ accurate to $O(\\rho)$ requires only\n\n\n\\begin{equation*}\n\\overline{B_{p}} \\cong \\frac{\\psi_{1}+2 \\rho \\psi_{2}}{R} \\hat{l} \\tag{9}\n\\end{equation*}\n\n\nSo for $\\psi=\\psi_{0}$, i.e., $\\rho=0$ we have\n\n\n\\begin{equation*}\n\\psi_{1}=R_{s}(l) B_{p s}(l) \\tag{10}\n\\end{equation*}\n\n\nand $\\psi_{1}$ is seen to be the gradient of $\\psi$ on the flux surface and completely specified by the original conditions for the local equilibrium.\n\nTo obtain $\\psi_{2}$, start with the Grad-Shafranov equation\n\n\n\\begin{equation*}\n\\Delta^{*} \\psi=R^{2} \\nabla \\cdot\\left(\\frac{\\nabla \\psi}{R^{2}}\\right)=-\\mu_{0} R^{2} p^{\\prime}(\\psi)-f f^{\\prime}(\\psi) \\tag{11}\n\\end{equation*}\n\n\nPlugging in the $\\psi$ expansion of Eq. (8) yields\n\n\n\\begin{align*}\nR^{2} \\nabla \\cdot\\left(\\frac{\\nabla \\psi}{R^{2}}\\right)= & \\frac{R^{2}}{J} \\partial_{l}\\left[\\frac{\\rho \\partial_{l} \\psi_{1}+\\rho^{2} \\partial_{l} \\psi_{2}}{R\\left(1-\\rho / R_{c}\\right)}\\right] \\\\\n& +\\frac{R^{2}}{J} \\partial_{\\rho}\\left[\\frac{\\psi_{1}+2 \\rho \\psi_{2}}{R}\\left(1-\\rho / R_{c}\\right)\\right] \\\\\n= & -\\mu_{0} R^{2} p^{\\prime}(\\psi)-f f^{\\prime}(\\psi) \\tag{12}\n\\end{align*}\n\n\nWe just need the leading order term (independent of $\\rho$ ) here which comes from the $\\rho$ derivative above and using Eq. (10) to eliminate $\\psi_{1}$ we have\n\n\n\\begin{equation*}\n\\psi_{2}=\\frac{1}{2}\\left[\\left(\\sin u+\\frac{R_{s}}{R_{c}}\\right) B_{p s}-\\mu_{0} R_{s}^{2} p^{\\prime}\\left(\\psi_{0}\\right)-f f^{\\prime}\\left(\\psi_{0}\\right)\\right] \\tag{13}\n\\end{equation*}\n\n\nIt is now possible to give expressions for the poloidal and toroidal fields correct to $O(\\rho)$ (Refs. 2, 3)\n\n\n\\begin{equation*}\nB_{p}^{2}=B_{p s}^{2}\\left[1+2 \\rho\\left(\\frac{1}{R_{c}}-\\frac{\\mu_{0} R_{s} p^{\\prime}\\left(\\psi_{0}\\right)}{B_{p s}}-\\frac{f f^{\\prime}\\left(\\psi_{0}\\right)}{R_{s} B_{p s}}\\right)\\right], \\tag{14}\n\\end{equation*}\n\n\nand\n\n\n\\begin{equation*}\nB_{\\phi}^{2}=\\frac{f^{2}\\left(\\psi_{0}\\right)}{R_{s}^{2}}\\left[1+\\frac{2 \\rho}{R_{s}}\\left(-\\sin u+\\frac{f^{\\prime}\\left(\\psi_{0}\\right)}{f\\left(\\psi_{0}\\right)} R_{s}^{2} B_{p s}\\right)\\right] \\tag{15}\n\\end{equation*}\n\n\nThe Mercier-Luc formulas for localized equilibria used here have a simple connection to the generalized $s-\\alpha$ analysis developed by Greene and Chance ${ }^{2}$ to study ideal MHD ballooning modes. We start with the formula for the safety factor $q$ given by\n\n\n\\begin{equation*}\nq=\\frac{f}{2 \\pi} \\int \\frac{d l_{p}}{R^{2} B_{p}} \\tag{16}\n\\end{equation*}\n\n\nwhere $d l_{p}$ is the differential poloidal length on a flux surface and equal to $d l$ for the surface $\\psi=\\psi_{0}$. By evaluating Eq. (16) for $\\rho \\neq 0$ using the expansions above we can calculate $\\partial q / \\partial \\psi$. The following formulas are derived from Eqs. (2)(7), (10), and (13) through Eq. (15),\n\n\n\\begin{align*}\n& d l_{p}=\\left(1-\\rho / R_{c}\\right) d l  \\tag{17}\\\\\n& R^{-2}=R_{s}^{-2}\\left(1-\\frac{2 \\rho}{R_{s}} \\sin u\\right)  \\tag{18}\\\\\n& B_{p}^{-1}=B_{p s}^{-1}\\left[1-\\rho\\left(\\frac{1}{R_{c}}-\\frac{\\mu_{0} R_{s} p^{\\prime}\\left(\\psi_{0}\\right)}{B_{p s}}-\\frac{f f^{\\prime}\\left(\\psi_{0}\\right.}{R_{s} B_{p s}}\\right)\\right] \\tag{19}\n\\end{align*}\n\n\nand\n\n\n\\begin{equation*}\n\\rho=\\frac{\\psi-\\psi_{0}}{\\psi_{1}}=\\frac{\\psi-\\psi_{0}}{R_{s} B_{p s}} \\tag{20}\n\\end{equation*}\n\n\nUsing Eqs. (17)-(20) we find\n\n\n\\begin{align*}\n\\frac{\\partial q}{\\partial \\psi}= & \\frac{f^{\\prime}\\left(\\psi_{0}\\right)}{f\\left(\\psi_{0}\\right)} q+\\frac{f\\left(\\psi_{0}\\right)}{2 \\pi} \\int \\frac{d l}{R_{s}^{3} B_{p s}^{2}}\\left[-\\frac{2}{R_{c}}-\\frac{2 \\sin u}{R_{s}}\\right. \\\\\n& \\left.+\\frac{\\mu_{0} p^{\\prime} R_{s}\\left(\\psi_{0}\\right)}{B_{p s}}+\\frac{f f^{\\prime}\\left(\\psi_{0}\\right)}{R_{s} B_{p s}}\\right] \\tag{21}\n\\end{align*}\n\n\nThis last expression shows that $s$ and $\\alpha\\left(q^{\\prime}\\right.$ and $\\left.p^{\\prime}\\right)$ can be modified by just changing $p^{\\prime}$ and $f f^{\\prime}$, without changing the shape or the magnetic field of local equilibrium. This is exactly what the Greene and Chance analysis does and the formulas for $\\partial q / \\partial \\psi$, etc., are in fact identical in the two approaches.\n\nFinally, although we do not consider rotation elsewhere in this paper, we note that it is a simple matter to extend the above analysis to include equilibria with toroidal velocity, $v=R \\Omega(\\psi) \\hat{\\phi}$. The equilibrium equation is then given by ${ }^{8}$\n\n\n\\begin{equation*}\n\\Delta^{*} \\psi=R^{2} \\nabla \\cdot\\left(\\frac{\\nabla \\psi}{R^{2}}\\right)=-\\mu_{0} R^{2} \\frac{\\partial p(\\psi, R)}{\\partial \\psi}-f f^{\\prime}(\\psi) \\tag{22}\n\\end{equation*}\n\n\nThe only change from Eq. (11) is that the pressure is no longer a flux function-due to centrifugal effects-and is instead given by\n\n\n\\begin{equation*}\np(\\psi, R)=p_{0}(\\psi) e^{m R^{2} \\Omega(\\psi)^{2} / 2 T(\\psi)} \\tag{23}\n\\end{equation*}\n\n\nwhere the mass $m$ and temperature $T(\\psi)$ have entered via the ratio of pressure to mass density $p(\\psi, R) / \\rho(\\psi, R)$ $=T(\\psi) / \\mathrm{m}$. We can include toroidal rotation in the local equilibrium above by making the substitution\n\n\n\\begin{align*}\np^{\\prime}(\\psi) \\rightarrow & \\left\\{p_{0}^{\\prime}(\\psi)+R^{2} p_{0}(\\psi)\\right. \\\\\n& \\left.\\times\\left[\\frac{m \\Omega^{2}(\\psi)}{2 T(\\psi)}\\right]^{\\prime}\\right\\} e^{m R^{2} \\Omega^{2}(\\psi) / 2 T(\\psi)}, \\tag{24}\n\\end{align*}\n\n\nin Eqs. (13), (14), (19), and (21). Rotation thus requires four numbers to replace $p^{\\prime}\\left(\\psi_{0}\\right)$, namely, $p_{0}\\left(\\psi_{0}\\right), \\quad p_{0}^{\\prime}\\left(\\psi_{0}\\right)$, $\\left[m \\Omega^{2}\\left(\\psi_{0}\\right) / 2 T\\left(\\psi_{0}\\right)\\right.$,] and $\\left[m \\Omega^{2}\\left(\\psi_{0}\\right) / 2 T\\left(\\psi_{0}\\right)\\right]^{\\prime}$. Of course, stability analyses will also require $\\Omega, \\Omega^{\\prime}, T$, and $T^{\\prime}$ be separately specified. ${ }^{9}$\n\n\\section*{III. LARGE $A$, SHIFTED CIRCLE MODEL}\nIn this section we show that the shifted circle model ${ }^{1,6}$ is a special case of the local equilibrium expansion described in the last section. The shifted circle model geometry is usually written as\n\n\n\\begin{align*}\n& R=\\left[R_{0}+\\Delta(r)\\right]+r \\cos \\theta, \\\\\n& Z=r \\sin \\theta . \\tag{25}\n\\end{align*}\n\n\nIt is important to realize that the above equilibrium specification is quite different from the local equilibrium approach described in the previous section. Equation (25) is global in that it specifies the flux surface shape on EVERY flux surface. In general, such an ad hoc specification of every flux surface is not an equilibrium because it will not satisfy the Grad-Shafranov equation. The shifted circle model is self-consistent only at low $\\beta_{p}$ and large $A$ (Ref. 10) and we demonstrate this below.\n\nEquation (25) determines the variation of $B_{p}$ on a flux surface, as well as shape, since ALL surfaces are specified. Note $\\psi=\\psi(r)$. We can readily calculate from Eq. (25),\n\n\n\\begin{equation*}\nB_{p}=|\\nabla \\phi \\times \\nabla \\psi|=\\frac{\\partial_{r} \\psi}{R}|\\nabla r|=\\frac{\\partial_{r} \\psi}{R\\left(1+\\partial_{r} \\Delta \\cos \\theta\\right)} \\tag{26}\n\\end{equation*}\n\n\nPutting Eqs. (25) and (26) in the Grad-Shafranov equation, the formula for the Shafranov shift emerges ${ }^{11}$\n\n\n\\begin{equation*}\n\\partial_{r} \\Delta=-\\frac{r}{R_{0}}\\left(\\beta_{p}+\\frac{l_{i}}{2}\\right) . \\tag{27}\n\\end{equation*}\n\n\n$B_{p}$ on the reference surface is given in the Mercier-Luc approach and is thus constrained to agree with Eq. (26). To make a meaningful comparison we look at a nearby flux surface with $\\psi=\\psi_{0}+\\delta \\psi$. We expand $B_{p}$ in Eq. (26) to first order in $\\delta r$, where $\\delta \\psi=\\delta r \\partial_{r} \\psi$ and obtain\n\n\n\\begin{align*}\nB_{p s c}= & B_{p s}\\left\\{1+\\frac{\\delta \\psi}{R B_{p s}\\left(1+\\partial_{r} \\Delta \\cos \\theta\\right)}\\left[-\\frac{\\cos \\theta+\\partial_{r} \\Delta}{R}\\right.\\right. \\\\\n& \\left.\\left.-\\frac{\\partial_{r r} \\Delta \\cos \\theta}{\\left(1+\\partial_{r} \\Delta \\cos \\theta\\right)}+\\frac{\\partial_{r r} \\psi}{\\partial_{r} \\psi}\\right]\\right\\} \\tag{28}\n\\end{align*}\n\n\nwhere the subscript sc refers to shifted circle. To facilitate the comparison with Eq. (14) we eliminate $\\cos \\theta$ in favor of $R$ and $B_{p}$ using Eqs. (25) and (26),\n\n\n\\begin{align*}\nB_{p s c}= & B_{p s}\\left\\{1+\\frac{\\delta \\psi}{R_{s} B_{p s}}\\left[-\\frac{1}{R_{s} \\partial_{r} \\Delta}+\\frac{B_{p s}}{\\partial_{r} \\psi}\\left(\\frac{1}{\\partial_{r} \\Delta}-\\partial_{r} \\Delta\\right)\\right.\\right. \\\\\n& \\left.\\left.+\\frac{R_{s} B_{p s}}{\\partial_{r} \\psi}\\left(\\frac{\\partial_{r r} \\psi}{\\partial_{r} \\psi}-\\frac{\\partial_{r r} \\Delta}{\\partial_{r} \\Delta}\\right)+\\left(\\frac{R_{s} B_{p s}}{\\partial_{r} \\psi}\\right)^{2} \\frac{\\partial_{r r} \\Delta}{\\partial_{r} \\Delta}\\right]\\right\\} . \\tag{29}\n\\end{align*}\n\n\nBy contrast, for the localized equilibrium approach of the last section we start with Eq. (25) giving the flux surface shape for $r=r_{0}$ only, and Eq. (26) giving the poloidal field for $r=r_{0}$ only. Then using the expansion in $\\rho$ given by Eq. (14), for flux surface $\\psi=\\psi_{0}+\\delta \\psi$ we have\n\n\n\\begin{align*}\nB_{p \\mathrm{ml}}= & B_{p s}\\left[1+\\frac{\\delta \\psi}{R_{s} B_{p s}}\\left(-\\frac{1}{r_{0}}-\\frac{\\mu_{0} R_{s} p^{\\prime}\\left(\\psi_{0}\\right)}{B_{p s}}\\right.\\right. \\\\\n& \\left.\\left.-\\frac{f f^{\\prime}\\left(\\psi_{0}\\right)}{R_{s} B_{p s}}\\right)\\right] \\tag{30}\n\\end{align*}\n\n\nwhere the subscript ml refers to Mercier-Luc. A comparison of Eqs. (29) and (30) shows that they are quite different functions of $R$ and $B_{p}$. They do, however, agree at large $R / r=\\epsilon^{-1}$ assuming that $p^{\\prime}$ is $O(1)$. Performing the $\\epsilon$ expansion and setting $B_{p \\mathrm{ml}}=B_{p \\mathrm{sc}}$, the terms of $O(1)$ yield\n\n\n\\begin{equation*}\nr^{-1} \\partial_{r}\\left(r \\partial_{r} \\psi\\right)=-\\mu_{0} R_{0}^{2} p^{\\prime}-f f^{\\prime} \\tag{31}\n\\end{equation*}\n\n\nand the terms of $O(\\epsilon \\cos \\theta)$ yield\n\n\n\\begin{equation*}\n\\partial_{r}\\left[r\\left(\\partial_{r} \\psi\\right)^{2} \\partial_{r} \\Delta\\right]=2 \\mu_{0} r^{2} R_{0} \\partial_{r} p-\\frac{r}{R_{0}}\\left(\\partial_{r} \\psi\\right)^{2} \\tag{32}\n\\end{equation*}\n\n\nwhich integrates to the Shafranov shift equation given by Eq. (27). The shifted circle is a special case of the Mercier-Luc analysis. ${ }^{6}$\n\nAlternatively, if we assume large $\\beta_{p} \\sim 1 / \\epsilon$, then $p^{\\prime}$ is $O(1 / \\epsilon)$. This requires that $f f^{\\prime} \\sim 1 / \\epsilon$ and that the combination $-\\mu_{0} R_{0}^{2} p^{\\prime}-f f^{\\prime}$ is $O(1)$, however, there is now another $O(1)$ pressure term and Eq. (31) becomes\n\n\n\\begin{align*}\nr^{-1} \\partial_{r}\\left(r \\partial_{r} \\psi\\right)= & -\\mu_{0} R_{0}^{2} p^{\\prime}-f f^{\\prime}-2 \\mu_{0} R_{0} \\Delta(r) p^{\\prime} \\\\\n& -2 \\mu_{0} R_{0}^{2} \\epsilon p^{\\prime} \\cos \\theta \\tag{33}\n\\end{align*}\n\n\nThe $\\theta$ dependence of the last term on the right-hand side shows that this equation cannot be satisfied because all of the other quantities are independent of $\\theta$. In other words, the shifted circle equilibrium is not valid for large $\\beta_{p}$; one flux surface can be a circle, but nearby flux surfaces will be noncircular. The next section shows how the restrictions of large $A$, circularity, and small $\\epsilon \\beta_{p}$ can all be overcome with the generalized model.\n\n\\section*{IV. FINITE A, NONCIRCULAR MODEL}\nWe now introduce a model appropriate for finite aspect ratio and noncircular cross section, and a parametrization of localized equilibrium for arbitrary $\\kappa, \\delta$, and $A$.\n\nTo specify the shape we use a standard formula for Deeshaped plasmas, ${ }^{12}$\n\n\n\\begin{align*}\n& R_{s}=R_{0}+r \\cos \\left[\\theta+\\left(\\sin ^{-1} \\delta\\right) \\sin \\theta\\right] \\\\\n& Z_{s}=\\kappa r \\sin \\theta \\tag{34}\n\\end{align*}\n\n\nwith $A=R_{0} / r$. The real problem is how to parametrize $B_{p}(\\theta)$. To do this we assume, analogous to the shifted circle model, that nearby flux surfaces are given by the same formula as Eq. (34) with modified $R_{0}, \\kappa$, and $\\delta$, i.e., assume\n\n\n\\begin{align*}\n& R_{s r}=R_{0}(r)+r \\cos \\left\\{\\theta+\\left[\\sin ^{-1} \\delta(r)\\right] \\sin \\theta\\right\\}  \\tag{35}\\\\\n& Z_{s r}=\\kappa(r) r \\sin \\theta\n\\end{align*}\n\n\nNote that $r$, the minor radius, is a flux function. Then $B_{p}$ can be calculated as in Eq. (26),\n\n\n\\begin{equation*}\nB_{p}=|\\nabla \\phi \\times \\nabla \\psi|=\\frac{\\partial_{r} \\psi}{R}|\\nabla r|, \\tag{36}\n\\end{equation*}\n\n\nand $\\nabla r$ can be calculated from $R_{s r}$ and $Z_{s r}$ in Eq. (35) yielding after some algebra\n\n\n\\begin{equation*}\nB_{p}=\\frac{\\partial_{r} \\psi \\kappa^{-1} R^{-1}\\left[\\sin ^{2}(\\theta+x \\sin \\theta)(1+x \\cos \\theta)^{2}+\\kappa^{2} \\cos ^{2} \\theta\\right]^{1 / 2}}{\\cos (x \\sin \\theta)+\\partial_{r} R_{0} \\cos \\theta+\\left[s_{\\kappa}-s_{\\delta} \\cos \\theta+\\left(1+s_{\\kappa}\\right) x \\cos \\theta\\right] \\sin \\theta \\sin (\\theta+x \\sin \\theta)}, \\tag{37}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{align*}\n& \\sin x=\\delta  \\tag{38}\\\\\n& s_{\\kappa}=\\frac{r \\partial_{r} \\kappa}{\\kappa} \\tag{39}\n\\end{align*}\n\n\nand\n\n\n\\begin{equation*}\ns_{\\delta}=\\frac{r \\partial_{r} \\delta}{\\sqrt{1-\\delta^{2}}} \\tag{40}\n\\end{equation*}\n\n\nWe want to emphasize that the shape assumption made in Eq. (35) for nearby flux surfaces is merely a device for constructing the poloidal magnetic field given by Eq. (37). Once Eq. (37) is obtained we discard the information in Eq. (35) so in contrast to the shifted circle model of the previous section, there is no question concerning whether the GradShafranov equation is locally satisfied. It is. If we chose to do so we could construct nearby flux surfaces, using Eq. (14), which in general will approximate Eq. (35) but not be exactly the same. The difference is the difference required to assure that the Grad-Shafranov equation is locally satisfied.\n\nIn accordance with the Mercier-Luc prescription given in Sec. I, our complete local model is given by Eq. (34) for the shape of the surface, Eq. (37) for the poloidal field on the surface, and the components of the toroidal current $p^{\\prime}\\left(\\psi_{0}\\right)$ and $f f^{\\prime}\\left(\\psi_{0}\\right)$. In total, our localized model requires nine parameters plus two normalization constants. The shape requires three parameters, $A, \\kappa$, and $\\delta$. The poloidal field requires four additional parameters, $s_{\\kappa}, s_{\\delta}, \\partial_{r} R_{0}$, and $q$. (We choose to specify the safety factor $q$ instead of $\\partial_{r} \\psi$.) Finally we need to specify $p^{\\prime}\\left(\\psi_{0}\\right)$ and $f f^{\\prime}\\left(\\psi_{0}\\right)$ which we do via the dimensionless quantities, $s$ and $\\alpha$, where ${ }^{13}$\n\n\n\\begin{align*}\n& s \\equiv \\frac{2 V \\partial_{\\psi} q}{\\partial_{\\psi} V}  \\tag{41}\\\\\n& \\alpha \\equiv-\\frac{2 \\partial_{\\psi} V}{(2 \\pi)^{2}}\\left(\\frac{V}{2 \\pi^{2} R_{0}}\\right)^{1 / 2} \\mu_{0} p^{\\prime} \\tag{42}\n\\end{align*}\n\n\nand $V$ is the volume enclosed by the flux surface.\\\\\nThe above nine parameters are dimensionless. We can establish physical units by specifying the minor radius $r$, and\\\\\nthe toroidal field $B_{0}=f_{0} / R_{0}$. The $B_{0}$ value will determine $\\partial_{r} \\psi$ in Eq. (37) through the safety factor relation given by Eq. (16).\n\nProbably the least familiar or intuitive parameters in the above set are $S_{\\kappa}, S_{\\delta}$, and $\\partial_{r} R_{0}$; this can present some difficulty in deciding what values to assign these parameters. Experience with numerically generated equilibria has shown that $S_{\\kappa}$ is typically quite small and positive, that is $\\partial_{r} \\kappa$ $<\\kappa / r$. The triangularity $\\delta$ is defined as $\\left[R_{0}-R_{\\max (z)}\\right] / r$. [This can be verified by Eq. (34).] $R_{\\max (z)}$ is defined as the $R$ value on the flux surface where the maximum $Z$ occurs. This definition of triangularity goes to zero at the magnetic axis where flux surfaces become elliptical. Again, experience with numerical equilibria shows that as a rough approximation $\\delta \\propto r$ and therefore a reasonable value for $S_{\\delta}$ is $\\delta /(1$ $\\left.-\\delta^{2}\\right)^{1 / 2}$. Finally, the parameter $\\partial_{r} R_{0}$, is related to $\\beta_{p}$ and $l_{i}$ as Eq. (27) shows for the shifted circle model. Lao et al. ${ }^{14}$ have derived a large $A$, elliptical generalization of this result\n\n\n\\begin{equation*}\n\\partial_{r} R_{0}=-\\frac{r}{R_{0}}\\left[\\frac{2\\left(\\kappa^{2}+1\\right)}{3 \\kappa^{2}+1}\\left(\\beta_{p}+\\frac{l_{i}}{2}\\right)+\\frac{1}{2} \\frac{\\kappa^{2}-1}{3 \\kappa^{2}+1}\\right], \\tag{43}\n\\end{equation*}\n\n\nwhere\n\n\n\\begin{align*}\n& \\beta_{p}=\\frac{2 \\mu_{0}\\left[\\langle p\\rangle_{v}-p(r)\\right]}{\\overline{B_{p}^{2}}}  \\tag{44}\\\\\n& l_{i}=\\frac{1}{2} \\frac{\\left\\langle B_{p}^{2}\\right\\rangle_{v}}{\\overline{B_{p}^{2}}} \\tag{45}\n\\end{align*}\n\n\nand\n\n\n\\begin{equation*}\n\\overline{B_{p}}=\\frac{\\mu_{0} I(r)}{L_{p}(r)} \\tag{46}\n\\end{equation*}\n\n\nwhere $\\left\\rangle_{v}\\right.$ is a volume average and $L_{p}(r)$ is the poloidal circumference.\n\nIn comparing with numerical equilibria at finite $A$ and $\\delta>0$, we find the above formula tends to overweight $l_{i}$ but the formula is fairly accurate, to within $20 \\%-30 \\%$, down to $A \\sim 3$. It should be possible to generate a large number of numerical equilibria with a range of $A, \\kappa, \\delta, \\beta_{p}$, and $l_{i}$ and by fitting these data obtain an improved expression for $\\partial_{r} R_{0}$\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_42e8ebfddc819d9dcfb1g-6(2)}\n\nFIG. 2. Comparison of flux surface shape from numerical equilibrium at $\\widetilde{\\psi}=0.77$ to the flux surface from Eq. (34) using the parameters $A, \\kappa$, and $\\delta$ obtained from numerical equilibrium. The outer boundary is the fixed boundary of the numerical equilibrium.\\\\\nover that given by Eq. (43). Such data could also be used to obtain expressions for $S_{\\kappa}$ and $S_{\\delta}$. We have not attempted to do this.\n\nNext we look at how well a parametrized shape and $B_{p}$ compare with a numerically generated equilibrium. We generated a numerical equilibrium using the fixed boundary code TOQ (Ref. 14) by specifying the outer boundary using Eq. (34) with $\\kappa=2, \\delta=0.7, R_{0}=1.7$, and $r=0.65$. The pressure gradient profile is given as $p^{\\prime}=C(1-\\widetilde{\\psi})$ with $C$ adjusted to give $\\beta_{\\text {axis }}=20 \\%$. Finally, the safety factor profile is specified as $q=1.1+4 \\widetilde{\\psi}{ }^{3}$, where $\\widetilde{\\psi}$ is the normalized poloidal flux ranging from 0 on axis to 1 at the edge. Data from the numerical equilibrium were then used to calculate the required nine parameters on a range of flux surfaces. For the flux surface $\\widetilde{\\psi}=0.77$, they are $A=3.17, \\kappa=1.66, \\delta=0.416$, $s_{\\kappa}=0.70, s_{\\delta}=1.37, \\partial_{r} R_{0}=-0.354, q=3.03, s=2.47$, and $\\alpha=1.22$. Figure 2 shows a comparison of the actual flux surface shape at $\\widetilde{\\psi}=0.77$ compared to the flux surface derived from the parameters $A, \\kappa$, and $\\delta$. They are seen to lie on top of each other indicating excellent agreement.\n\nIn Fig. 3, we plot the actual poloidal magnetic field vs an equal arc-length angular variable on the surface $\\widetilde{\\psi}=0.77$ as well as the poloidal magnetic field given by Eq. (37) using the above parameter values. Although not as good as the shape comparison, the agreement is still quite good. One measure of how good it is, is to compare the ideal MHD ballooning mode stability of the numerical data with the parametrized local equilibrium approximation. This is done in the next section.\n\nOf course there are limitations to the shapes which can be described by these parameters. If the plasma shape has a large square component, for example, elongation and trian-\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_42e8ebfddc819d9dcfb1g-6(1)}\n\nFIG. 3. Comparison of poloidal magnetic field from numerical equilibrium at $\\tilde{\\psi}=0.77$ to the poloidal magnetic field from Eq. (37) using the parameters obtained from numerical equilibrium.\\\\\ngularity will probably not be adequate to describe it. Using the technique described in this section, however, any shape parametrization can be used to generate a local equilibrium mode. In general, if $n$ parameters are required to describe the shape, then $2 n+3$ parameters will be required to specify the equilibrium; $n$ parameters for the shape, $\\partial_{r}$ derivations of the $n$ parameters for $B_{p}$ plus $s, \\alpha$, and $q$.\n\n", "\\section*{V. APPLICATION TO IDEAL MHD BALLOONING MODES}\nWe used the ballooning code BALOO (Ref. 15) to compare the ideal MHD ballooning mode stability of the numerical equilibrium in the last section on flux surface $\\widetilde{\\psi}=0.77$ with the parameterized local equilibrium. BALOO uses the Greene and Chance ${ }^{2}$ technique for varying $s$ and $\\alpha$ on a given flux surface. The results for the marginally stable curve in $s-\\alpha$ space are shown in Fig. 4 and show good agreement as is to be expected from the good agreement in shape and poloidal field.\n\nVarying $s$ and $\\alpha$ are of comparable difficulty using numerical equilibria with Greene and Chance or the local equilibrium model. The real advantage of the local equilibrium model comes when other parameters such as the triangularity are varied as well. Using numerical equilibria, this would require generating a new equilibrium each time the triangularity is changed and as a practical matter many equilibria\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_42e8ebfddc819d9dcfb1g-6}\n\nFIG. 4. Ballooning mode marginal stability curves in $\\alpha-s$ space for numerical equilibrium at $\\widetilde{\\psi}=0.77$ and local equilibrium parametrization.\\\\\n\\includegraphics[max width=\\textwidth, center]{2024_11_06_42e8ebfddc819d9dcfb1g-7}\n\nFIG. 5. Ballooning mode marginal stability curves in $\\alpha-s$ space for a range of triangularities using local equilibrium parametrization. Based upon numerical equilibrium at $\\tilde{\\psi}=0.77$.\\\\\nwould be required through an iteration process if other parameters such as the elongation of the flux surface were to be held fixed.\n\nTo demonstrate the ease of varying additional parameters using the local equilibrium, the marginal stability curves of the present local equilibrium varying $s, \\alpha$, and $\\delta$ while holding the other six parameters fixed is given in Fig. 5. The figure illustrates the well-known improved access to the second stable region that can be obtained by increasing plasma triangularity. This result, of course, required no additional equilibrium calculations.\n\n\\section*{VI. SUMMARY}\nA generalization of the large aspect ratio shifted circle equilibrium model has been introduced which includes the effects of elongation, triangularity, and finite aspect ratio. Nine parameters are required to fully describe the local equilibrium; $\\kappa, \\delta, A, s_{\\kappa}, s_{\\delta}, \\partial_{r} R_{0}, q, s$, and $\\alpha$. The technique of Sec. IV could be applied to other shape parametrizations. In general, if $n$ shape parameters are introduced including $A$, then $2 n+3$ parameters will be required to specify the local equilibrium.\n\nA comparison of ideal MHD ballooning mode results shows good agreement for a numerical equilibrium vs a local equilibrium generated from the above nine parameters obtained from the numerical equilibrium.\n\nAn initial equilibrium in the neighborhood of a flux surface may be constructed directly from the model or may be obtained from a numerical equilibrium which is then represented locally in terms of the above parameters. In either case, using the model, the above parameters can then be individually varied and when input to stability codes can be used to study the effects of each upon stability.\n\nThis model is particularly suitable for localized stability studies such as those using the ballooning mode representation of the gyrokinetic equations. Many of these gyrofluid ${ }^{16-18}$ and gyrokinetic ${ }^{19,20}$ computer simulations being carried out today use the shifted circle $s-\\alpha$ model. This work allows easy modification of these codes to obtain a more realistic treatment of shape and a means of individually varying shape parameters. The illustration of the model in\\\\\nthe paper was the ideal MHD ballooning mode, this was meant as an illustration of the ease with which individual parameters can be varied using this model.\n\nWhile the best application of this work is probably for realistic shape and controlled shape variation in microstability codes, the illustration of the model in this paper was for ideal MHD ballooning and we believe the model has its uses here as well. For example, data analysis on DIII-D (Ref. 21) often includes a ballooning mode analysis including an assessment of the location of the first and second stability boundaries to ballooning modes. Those stability boundaries are determined by constructing an $s-\\alpha$ diagram starting from the initial numerical equilibrium fit to the data. A new numerical equilibrium is NOT calculated for every new choice of $s$ and $\\alpha$ to map out the boundaries. Because of the work of Greene and Chance, ${ }^{2}$ additional equilibria need not be computed. As described in this paper, this work is, in a sense, an extension of that model and now stability boundaries can be mapped out in elongation or triangularity, for example, without reconstructing a numerical equilibrium for each parameter change as well. A researcher could answer the question of how additional edge triangularity would affect ballooning stability boundaries with a minimum of effort.\n\n\\section*{ACKNOWLEDGMENT}\nThis is a report of work supported by the U.S. Department of Energy under Grant No. DE-FG03-95ER54309.\\\\\n${ }^{1}$ J. W. Connor, R. J. Hastie, and J. B. Taylor, Phys. Rev. Lett. 40, 396 (1978).\\\\\n${ }^{2}$ J. M. Greene and M. S. Chance, Nucl. Fusion 21, 453 (1981).\\\\\n${ }^{3}$ C. Mercier and N. Luc, Report No. EUR-5127e 140 (Commission of the European Communities, Brussels, 1974).\\\\\n${ }^{4}$ C. M. Bishop, P. Kirby, J. W. Connor, R. J. Hastie, and J. B. Taylor, Nucl. Fusion 24, 1579 (1984).\\\\\n${ }^{5}$ C. M. Bishop, Nucl. Fusion 26, 1063 (1986).\\\\\n${ }^{6}$ C. M. Bishop, UKAEA, Culham Laboratory (personal communication, 1985).\\\\\n${ }^{7}$ C. M. Roach, J. W. Connor, and S. Janjua, Plasma Phys. Controlled Fusion 37, 679 (1995).\\\\\n${ }^{8}$ E. Hameiri, Phys. Fluids 26, 230 (1983).\\\\\n${ }^{9}$ R. L. Miller, F. L. Waelbroeck, A. B. Hassam, and R. E. Waltz, Phys. Plasmas 2, 3676 (1995).\\\\\n${ }^{10}$ J. M. Greene, Plasma Phys. Controlled Fusion 30, 327 (1988).\\\\\n${ }^{11}$ R. B. White, Theory of Tokamak Plasmas (North-Holland, Amsterdam, 1989), p. 47.\\\\\n${ }^{12}$ A. M. M. Todd, J. Manickam, M. Okabayashi, M. S. Chance, R. C. Grimm, J. M. Greene, and J. L. Johnson, Nucl. Fusion 19, 743 (1979).\\\\\n${ }^{13}$ M. S. Chu and M. S. Chance, General Atomics (personal communication, 1989). Definitions used in General Atomics version of camino code.\\\\\n${ }^{14}$ L. L. Lao, S. P. Hirshman, and R. M. Wieland, Phys. Fluids 24, 1431 (1981).\\\\\n${ }^{15}$ R. L. Miller, Y. R. Lin-Liu, A. D. Turnbull, V. S. Chan, L. D. Pearlstein, O. Sauter, and L. Villard, Phys. Plasmas 4, 1062 (1997).\\\\\n${ }^{16}$ R. E. Waltz, G. D. Kerbel, J. Milovich, and G. W. Hammett, Phys. Plasmas 2, 2408 (1995).\\\\\n${ }^{17}$ R. E. Waltz, G. M. Staebler, W. Dorland, G. W. Hammett, M. Kotschenreuther, and J. A. Konings, Phys. Plasmas 4, 2482 (1997).\\\\\n${ }^{18}$ M. A. Beer, G. W. Hammett, G. Rewoldt, E. J. Synakowski, M. C. Zarnstorff, and W. Dorland, Phys. Plasmas 4, 1792 (1997).\\\\\n${ }^{19}$ M. Kotschenreuther, G. Rewoldt, and W. M. Tang, Comput. Phys. Commun. 88, 128 (1991).\\\\\n${ }^{20}$ S. E. Parker, H. E. Mynick, M. Artun, J. C. Cummings, V. Decyk, J. F. Kepner, W. W. Lee, and W. M. Tang, Phys. Plasmas 3, 1459 (1996).\\\\\n${ }^{21}$ J. L. Luxon and L. G. Davis, Fusion Technol. 8, 441 (1985).\n\n\n\\end{document}"]