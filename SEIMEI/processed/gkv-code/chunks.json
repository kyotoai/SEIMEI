["MODULE GKV_freq\n!-------------------------------------------------------------------------------\n!\n!    Module for evaluating linear growth rate and real frequency\n!    (without shearflows)\n!\n!    Update history of gkvp_freq.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - nxfrq=min(5,nx,nx0) to avoid zero division when nx0=0.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  real(kind=DP), parameter :: eps_omega = 1.d-2, &\n                              eps_gamma = 1.d-2, &\n                              eps_ineq  = 1.d-2\n\n  integer, save :: nxfrq = nx\n  real(kind=DP), save :: time0 = 0._DP\n  complex(kind=DP), allocatable, save, dimension(:,:,:) :: phi0\n  complex(kind=DP), allocatable, save, dimension(:,:) :: omega0\n  real(kind=DP), allocatable, save, dimension(:,:) :: phi0_norm2\n\n  complex(kind=DP), allocatable, save, dimension(:,:) :: omega_g\n  complex(kind=DP), allocatable, save, dimension(:,:) :: diff_g\n  real(kind=DP), allocatable, save, dimension(:,:) :: ineq_g\n  logical, allocatable, save, dimension(:,:) :: freq_conv\n\n  public :: freq_set, freq_write_frq, freq_write_dsp, freq_conv\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE freq_set ( time )\n!--------------------------------------\n\n    real(kind=DP), intent(in)           :: time\n\n    integer :: mx, my\n\n\n      nxfrq = min( 5, nx, nx0 )\n      time0 = time\n  \n      allocate( phi0(-nxfrq:nxfrq,0:ny,-nz:nz-1) )\n      allocate( omega0(-nxfrq:nxfrq,0:ny) )\n      allocate( phi0_norm2(-nxfrq:nxfrq,0:ny) )\n      allocate( omega_g(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n      allocate( diff_g(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n      allocate( ineq_g(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n      allocate( freq_conv(-nxfrq:nxfrq,0:(ny+1)*nprocw-1) )\n  \n      phi0(:,:,:) = ( 0._DP, 0._DP )\n      omega0(:,:) = ( 0._DP, 0._DP )\n      phi0_norm2(:,:) = 0._DP\n      omega_g(:,:) = ( 0._DP, 0._DP )\n      diff_g(:,:) = ( 0._DP, 0._DP )\n      ineq_g(:,:) = 0._DP\n      freq_conv(:,:) =.false.\n      \n!- write hst/*.frq.* -\n      if ( rankg == 0 ) then\n        write(ofrq, fmt=\"(a)\") \"#  Re[omega], Im[omega] for (kx,ky)\"\n        write(ofrq, fmt=\"(99a17)\", advance=\"no\") \"#            time\"\n        do mx = 0, nxfrq\n          do my = 1, global_ny\n            write(ofrq, \"(a,f7.3,a,f7.3,a)\", advance=\"no\")  &\n                \"(\", kx(mx), \",\", ky(1) * real(my, kind=DP), \")\"\n            write(ofrq, \"(a17)\", advance=\"no\") \" \"\n          end do\n        end do\n        if (nxfrq > 0) then\n          do mx = -nxfrq, -1\n            do my = 1, global_ny\n              write(ofrq, \"(a,f7.3,a,f7.3,a)\", advance=\"no\")  &\n                  \"(\", kx(mx), \",\", ky(1) * real(my, kind=DP), \")\"\n              write(ofrq, \"(a17)\", advance=\"no\") \" \"\n            end do\n          end do\n        end if\n        write(ofrq, *)\n      end if\n\n  END SUBROUTINE freq_set\n\n\n!--------------------------------------\n  SUBROUTINE freq_reset\n!--------------------------------------\n\n\n      deallocate( phi0 )\n      deallocate( omega0 )\n      deallocate( phi0_norm2 )\n      deallocate( omega_g )\n      deallocate( diff_g )\n      deallocate( ineq_g )\n      deallocate( freq_conv )\n                                     !%%% For debug %%%\n                                     !write(olog,*) \"freq_reset\"\n                                     !%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE freq_reset\n\n\n!--------------------------------------\n  SUBROUTINE freq_write_frq ( time, phi )\n!--------------------------------------\n\n    real(kind=DP), intent(in)           :: time\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)   :: phi\n\n    complex(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: phi0phi, omega_l, diff_l\n    real(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: phi_norm2, ineq_l\n    complex(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: wc3\n    real(kind=DP), dimension(-nxfrq:nxfrq,0:ny) :: wr3\n    integer :: mx, my, iz\n\n    integer, save ::  iflg\n    data iflg / 0 /\n\n\n      if( iflg == 0 ) then\n        iflg = 1\n        phi0(-nxfrq:nxfrq,:,:) = phi(-nxfrq:nxfrq,:,:)\n        phi0_norm2(:,:) = 0._DP\n        wr3(:,:) = 0._DP\n        do iz = -nz, nz-1\n          do my = ist1_y, iend_y\n            do mx = -nxfrq, nxfrq\n              wr3(mx,my) = wr3(mx,my) + abs( phi(mx,my,iz) )**2\n            end do\n          end do\n        end do\n        call MPI_Allreduce( wr3, phi0_norm2, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n        return\n      end if\n\n\n!- calculate interior products -\n      phi0phi(:,:) = (0._DP, 0._DP)\n      wc3(:,:) = (0._DP, 0._DP)\n      do iz = -nz, nz-1\n        do my = ist1_y, iend_y\n          do mx = -nxfrq, nxfrq\n            wc3(mx,my) = wc3(mx,my) + conjg( phi0(mx,my,iz) ) * phi(mx,my,iz)\n          end do\n        end do\n      end do\n      call MPI_Allreduce( wc3, phi0phi, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n      phi_norm2(:,:) = 0._DP\n      wr3(:,:) = 0._DP\n      do iz = -nz, nz-1\n        do my = ist1_y, iend_y\n          do mx = -nxfrq, nxfrq\n            wr3(mx,my) = wr3(mx,my) + abs( phi(mx,my,iz) )**2\n          end do\n        end do\n      end do\n      call MPI_Allreduce( wr3, phi_norm2, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n!- calculate frequency -\n      omega_l(:,:) = (0._DP, 0._DP)\n      do my = ist1_y, iend_y\n        do mx = -nxfrq, nxfrq\n          omega_l(mx,my) = log( phi0phi(mx,my) / phi0_norm2(mx,my) )  &\n                                      / ( ui * ( time0 - time ) )\n        end do\n      end do\n      call MPI_Allgather( omega_l, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          omega_g, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          fft_comm_world, ierr_mpi )\n\n!- convergence check -\n      diff_l(:,:) = (0._DP, 0._DP)\n      do my = ist1_y, iend_y\n        do mx = -nxfrq, nxfrq\n          diff_l(mx,my) = abs(real(omega_l(mx,my) - omega0(mx,my), kind=DP)  &\n                                      / real(omega_l(mx,my), kind=DP)) / (time - time0) &\n                        + ui * abs(aimag(omega_l(mx,my) - omega0(mx,my))     &\n                                      / aimag(omega_l(mx,my)) ) / (time - time0)\n        end do\n      end do\n      call MPI_Allgather( diff_l, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          diff_g, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_COMPLEX, &\n                          fft_comm_world, ierr_mpi )\n\n      ineq_l(:,:) = 0._DP\n      do my = ist1_y, iend_y\n        do mx = -nxfrq, nxfrq\n          ineq_l(mx,my) = sqrt(abs(phi0phi(mx,my))**2 / (phi0_norm2(mx,my) * phi_norm2(mx,my)))\n        end do\n      end do\n      call MPI_Allgather( ineq_l, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                          ineq_g, (2*nxfrq+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                          fft_comm_world, ierr_mpi )\n\n      do my = 1, global_ny\n        do mx = -nxfrq, nxfrq\n          if ( real( diff_g(mx,my), kind=DP ) < eps_omega.and.  &\n               aimag( diff_g(mx,my) ) < eps_gamma.and.          &\n               abs(1._DP - ineq_g(mx,my)) < eps_ineq ) then\n            freq_conv(mx,my) =.true.\n          else\n            freq_conv(mx,my) =.false.\n          end if\n        end do\n      end do\n\n      freq_conv(:,0) =.true.\n      if ( global_ny < (ny+1)*nprocw-1 ) then\n        do my = global_ny+1, (ny+1)*nprocw-1\n          diff_g(:,my) = ( 0._DP, 0._DP )\n          omega_g(:,my) = ( 0._DP, 0._DP )\n          ineq_g(:,my) = 0._DP\n          freq_conv(:,my) =.true.\n        end do\n      end if\n\n!- remember the values -\n      time0 = time\n      phi0(-nxfrq:nxfrq,:,:) = phi(-nxfrq:nxfrq,:,:)\n      omega0(:,:) = omega_l(:,:)\n      phi0_norm2(:,:) = phi_norm2(:,:)\n\n!- write hst/*.frq.* -\n      if ( rankg == 0 ) then\n       !write( ofrq, '(9999G17.7e3)' ) time, (omega_g(0,my), my=1,global_ny)\n         write( ofrq, '(9999G17.7e3)' ) time, ((omega_g(mx,my), my=1,global_ny), mx=0,nxfrq)\n      end if\n                                     !%%% For debug %%%\n                                     !write(olog,*) \"freq_write_frq at t=\",time\n                                     !%%%%%%%%%%%%%%%%%\n\nEND SUBROUTINE freq_write_frq\n\n\n!--------------------------------------\n  SUBROUTINE freq_write_dsp\n!--------------------------------------\n\n    integer :: mx, my\n\n\n      if ( rankg == 0 ) then\n        write( odsp, '(99A17)' ) \"#              kx\",\"ky\",\"frequency\",\"growthrate\",&\n                                           \"diff(freq)\",\"diff(grow)\",\"1-ineq\"\n        do mx = -nxfrq, nxfrq\n          do my = 1, global_ny\n            if ( freq_conv(mx,my) ) then\n              write( odsp, '(9999G17.7e3)' ) kx(mx), ky(1) * real( my, kind=DP ),       &\n                         real( omega_g(mx,my), kind=DP ), aimag( omega_g(mx,my) ),    &\n                         real( diff_g(mx,my), kind=DP ), aimag( diff_g(mx,my) ),      &\n                         abs(1._DP - ineq_g(mx,my))\n            else\n              write( odsp, '(A2,9999G17.7e3)' ) \"# \", kx(mx), ky(1) * real( my, kind=DP ),&\n                         real( omega_g(mx,my), kind=DP ), aimag( omega_g(mx,my) ),      &\n                         real( diff_g(mx,my), kind=DP ), aimag( diff_g(mx,my) ),        &\n                         abs(1._DP - ineq_g(mx,my))\n            end if\n          end do\n          write( odsp, * )\n        end do\n\n      end if\n  \n      call freq_reset\n                                     !%%% For debug %%%\n                                     !write(olog,*) \"freq_write_dsp\"\n                                     !%%%%%%%%%%%%%%%%%\n\n\n  END SUBROUTINE freq_write_dsp\n\n\nEND MODULE GKV_freq\n", "MODULE GKV_vmecin\n!-------------------------------------------------------------------------------\n!\n!    Calculate the magnetic field components and metric coefficients\n!      from the VMEC equilibrium\n!\n!      GKV-plus r0.6 ( T.-H.Watanabe and M. Nunami, Dec 2011 )\n!\n!      This module utilizes subroutines developed by M. Nunami\n!         for the GKV-X code\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public :: vmecin_fileopen, vmecin_coeff, vmecin_read\n\n\n!*****************************************************************************************\n!****************                                                         ****************\n!********                    shot# 088343   t = 1.833 [s]                         ********\n!****************                                                         ****************\n!*****************************************************************************************\n\n!== Paramters at rho=0.65 ======I N W A R D============================================\n!-*** common parameter at rho=0.65 ***------------------------------------------------\n!   real(kind=DP), parameter :: Ln_unit =-4.230701_DP                      ! Ln [m]\n!   real(kind=DP), parameter :: Lt_unit = 0.3135611_DP                     ! Lt [m]\n!-------------------------------------------------------------------------------------\n\n!-- For inward-LHD vacuum\" -----------------------------------------------------------\n!   real(kind=DP), parameter :: R0_unit = 3.599858_DP                      ! R0 [m]\n!   real(kind=DP), parameter :: r_edge  = 0.6362872D0                      ! r_edge [m]\n!   real(kind=DP), parameter :: b0b00   = 2.88846853946973647d0/2.940307D0 ! b00mode/B0\n!-------------------------------------------------------------------------------------\n\n\n!========================================================================\n!==  MODULES variables FOR VMEC                                                            \n!========================================================================\n\n!!!!! === MODULE NEWBOZ\n! ... originally contained param.\n  integer(kind=4), parameter :: NBZMIN = -20,NBZMAX = 20, MBZMAX = 100, &\n                                IBHAR  = ( NBZMAX - NBZMIN + 1 )*MBZMAX \n! ... from pmnsd\n  integer(kind=4), parameter :: NSD_MAX=501\n\n! ... from pmims\n! integer(kind=4), parameter :: KMSH_MAX=NSD_MAX-1, MDMX_MAX=101\n! ... from newboz\n  real(kind=8), save, dimension(IBHAR,NSD_MAX) :: BBOZH,RBOZH,ZBOZH,PBOZH\n  real(kind=8), save, dimension(NSD_MAX)       :: PSIBZ,EOTBZ,CUIBZ,CUGBZ\n  integer(kind=4), save, dimension(IBHAR)      :: MBOZ,NBOZ\n  integer(kind=4), save                        :: NFP,NMBOZ\n\n!!!!! === MODULE bcoef\n  real(kind=8), save, dimension(:,:), allocatable :: BCO,C1BF,C2BF,C3BF\n  real(kind=8), save, dimension(:),   allocatable :: CM,CN,SPOS,PSIB,    &\n       EOT,C1ET,C2ET,C3ET,CUI,C1I,C2I,C3I,CUG,C1G,C2G,C3G,         &\n       TXI,C1TI,C2TI,C3TI,TXE,C1TE,C2TE,C3TE,DXI,C1DI,C2DI,C3DI,   &\n       DLN,C1LN,C2LN,C3LN     \n  real(kind=8), save, dimension(:,:), allocatable :: bco0\n  real(kind=8), save, dimension(:),   allocatable :: spos0\n\n!!!!! === MODULE xcoef\n  real(kind=8), save, dimension(:,:), allocatable :: RCO,ZCO,PCO,        &\n                               C1R,C2R,C3R,C1Z,C2Z,C3Z,C1P,C2P,C3P\n  real(kind=8), save, dimension(:,:), allocatable :: rco0,zco0,pco0\n\n!!!!! === MODULE pcoef\n  real(kind=8), save, dimension(0:10) :: dn0,ti0,te0\n\n!!!!! === MODULE param1\n  integer(kind=4), save :: kmsh, kmsh1, nsd, mdmx, itype\n!\n!!!!! === MODULE bpara\n  real(kind=8), save    :: bb0,psia,sa,rmaj0,zi,nmass\n\n  real(kind=DP), save   :: ss, cug1, cui1\n\n  integer, save :: jp0\n\n!========================================================================\n\n  integer :: ndiskc = inbz\n!!!  integer :: ndiskc = 14\n!!!  integer :: ivmc = 15, ovmc = olog  ! move to GKV_header\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE vmecin_fileopen\n!--------------------------------------\n\n    implicit none\n\n    character(512) :: f_nbz, f_vmc\n\n    namelist /vmecf/ f_nbz, f_vmc\n\n\n      read(inml,nml=vmecf)\n\n      write(olog,*) \"# newboz and vmec input files : \"\n      write(olog,*) trim(f_nbz), trim(f_vmc)\n\n      open( inbz, file=trim(f_nbz), form=\"unformatted\", &\n                  status=\"old\", action=\"read\" )\n      open( ivmc, file=trim(f_vmc), &\n                  status=\"old\", action=\"read\" )\n\n\n  END SUBROUTINE vmecin_fileopen\n\n\n!--------------------------------------\n  SUBROUTINE vmecin_coeff( rad_a, R0_unit, rho2R_0, q_input, theta, alpha_fix, &\n                           r_0, r_minor, s_hat,                                &\n                           gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz,           &\n                           gupss, guptt, gupzz, gupst, gupsz, guptz,           &\n                           babs, Bs, Bth, Bzt, dBds, dBdt, dBdz,               &\n                           dBdt_mir, rootg, rootgft, rootgbz )\n!--------------------------------------\n    implicit none\n\n! --- arguments\n\n    real(kind=DP), intent(in)  :: rad_a, R0_unit, rho2R_0, q_input, theta, alpha_fix\n    real(kind=DP), intent(out) :: r_0, r_minor, s_hat \n    real(kind=DP), intent(out) ::                          &\n                 gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz, &\n                 gupss, guptt, gupzz, gupst, gupsz, guptz, &\n                 babs, Bs  , Bth , Bzt , dBds, dBdt, dBdz, &\n                 dBdt_mir, rootg, rootgft, rootgbz\n\n\n! -- For read_VMEC routine -------------------------------------\n!!!    integer, parameter :: npmax=100\n!!!    real(kind=DP)  :: ssi(npmax)\n    real(kind=DP), dimension(:), allocatable  :: ssi\n\n    integer, save  :: npsi=0,ntheta,nzeta\n\n    real(kind=DP)  :: zeta,rmaj,ph,cx,sx\n    real(kind=DP)  :: dRds,dZds,dPds\n    real(kind=DP)  :: dRdt,dZdt,dPdt\n    real(kind=DP)  :: dRdz,dZdz,dPdz\n    real(kind=DP)  :: bci, rci, zci, pci\n    real(kind=DP)  :: dbci,drci,dzci,dpci\n\n    real(kind=DP)  :: rg2inv\n\n!!!12.22    real(kind=DP)  :: Bs, Bth, Bzt\n\n    real(kind=DP)  :: B00mode, dB00mode\n    real(kind=DP)  :: Bm1_0mode,   dBm1_0mode\n    real(kind=DP)  :: Bm1_10mode,   B0_10mode,  Bp1_10mode\n    real(kind=DP)  :: dBm1_10mode,  dB0_10mode, dBp1_10mode\n\n    real(kind=DP)  :: ds, ss, r_a\n    real(kind=DP)  :: q_00, dq00, eot0, diff_q, q_vmec\n    real(kind=DP)  :: dq_0, eot1, cug1, cui1\n    real(kind=DP)  :: dsfix\n    integer        :: inm, is, iis, jp, jp0\n\n    real(kind=DP)  :: q_0\n\n!!!12.22    real(kind=DP)  :: rho_unit, L_n, L_t, rho2R_0  ! nunami (10.04.15)\n\n\n    integer, save :: isw = 0\n  \n\n    namelist /zahyoin/npsi,ntheta,nzeta\n\n\n    if( isw == 0 ) then\n      read(inml,nml=zahyoin)\n    end if\n\n    allocate ( ssi(npsi+1) )\n\n\n    r_a      = rad_a * rho2R_0             ! --- rad_a / R_0\n\n    do iis=1,npsi+1\n      ssi(iis) = dble(iis-1)/dble(npsi)\n      ss       = ssi(iis)\n      jp0      = int(ss*dble(kmsh))+1\n      ds       = ss - spos(jp0)\n\n! -- For Safety Factor----------------------------------------------------------------------\n      eot0  =   eot(jp0)+(c1et(jp0)+(c2et(jp0)+c3et(jp0)*ds)*ds)*ds          ! rotational transform\n      q_00  =   1.d0/eot0                                                    ! safety factor\n      dq00  = - q_00 * q_00 * (c1et(jp0)+(2.d0*c2et(jp0)+3.d0*c3et(jp0)*ds)*ds)  ! dq/ds\n! ------------------------------------------------------------------------------------------\n\n      diff_q  = q_input - q_00\n\n      if(abs(diff_q) < 0.02d0 ) then\n        q_0   = q_input\n        q_vmec= q_00\n        eot1  = eot0\n        is    = iis\n        dq_0  = dq00\n        jp    = jp0\n        dsfix = ds\n      endif\n\n    enddo\n\n    ss = ssi(is)\n    ds = dsfix\n\n! This is to adjust to Nunami's version (Dec 2011)\n! It should be confirmed how q is determined in consistent with r_minor\n    r_minor  = rad_a * ss                       ! in unit of rho\n\n    s_hat    = (ss / q_0) * dq_0\n\n    r_0  = r_minor * rho2R_0    !! by nunami (10.04.18)\n\n!!!    s_hat0   = (r_0 / q_0) * dq_0\n\n! -- troidal & poloidal current ------------------------------------------------------------\n    cug1  = cug(jp) + ( c1g(jp) + ( c2g(jp) + c3g(jp) * ds ) * ds ) * ds   ! G : poloidal\n    cui1  = cui(jp) + ( c1i(jp) + ( c2i(jp) + c3i(jp) * ds ) * ds ) * ds   ! I : toroidal\n! ------------------------------------------------------------------------------------------\n\n\n\n! ======================================================================================\n\n!!!    th_shift = -alpha_fix / q_0\n\n!!!      theta = zz(iz)                   ! theta\n      zeta  = theta * q_0 + alpha_fix  ! from alpha = zeta - q*theta = 0\n\n      rmaj = 0.0d0\n      babs = 0.0d0\n\n      dBds = 0.0d0\n      dRds = 0.0d0\n      dZds = 0.0d0\n      dPds = 0.0d0\n\n      dBdt = 0.0d0\n      dRdt = 0.0d0\n      dZdt = 0.0d0\n      dPdt = 0.0d0\n\n      dBdt_mir = 0.0d0\n\n      dBdz = 0.0d0\n      dRdz = 0.0d0\n      dZdz = 0.0d0\n      dPdz = 1.0d0   ! !!should be 1.0, not 0.0!!\n\n! --- Summation of Fourier components ---\n      do inm=1, mdmx+1\n        bci  = bco(jp,inm) + ( c1bf(jp,inm)+ ( c2bf(jp,inm) + c3bf(jp,inm) * ds ) * ds ) * ds\n        rci  = rco(jp,inm) + ( c1r(jp,inm) + ( c2r(jp,inm)  + c3r(jp,inm)  * ds ) * ds ) * ds\n        zci  = zco(jp,inm) + ( c1z(jp,inm) + ( c2z(jp,inm)  + c3z(jp,inm)  * ds ) * ds ) * ds\n        pci  = pco(jp,inm) + ( c1p(jp,inm) + ( c2p(jp,inm)  + c3p(jp,inm)  * ds ) * ds ) * ds\n        dbci = c1bf(jp,inm)+ ( 2.d0 * c2bf(jp,inm) + 3.d0 * c3bf(jp,inm) * ds ) * ds \n        drci = c1r(jp,inm) + ( 2.d0 * c2r(jp,inm)  + 3.d0 * c3r(jp,inm)  * ds ) * ds\n        dzci = c1z(jp,inm) + ( 2.d0 * c2z(jp,inm)  + 3.d0 * c3z(jp,inm)  * ds ) * ds\n        dpci = c1p(jp,inm) + ( 2.d0 * c2p(jp,inm)  + 3.d0 * c3p(jp,inm)  * ds ) * ds\n\n        if(cn(inm)==0 .and. cm(inm)==0) then\n          B00mode = bci !bco(jp,inm)               ! (m,n)=(0,0) component of B\n          dB00mode = dbci\n        endif\n\n        if(cn(inm)==0) then\n          if(cm(inm)==-1) then\n             Bm1_0mode  =  bci\n            dBm1_0mode  = dbci\n          endif\n        endif\n\n\n        if(cn(inm)==-10) then\n          if(cm(inm)==-2) then                 ! (m,n)=(0,10) mode\n             B0_10mode  =  bci\n            dB0_10mode  = dbci\n          elseif(cm(inm)==-3) then\n             Bm1_10mode =  bci\n            dBm1_10mode = dbci\n          elseif(cm(inm)==-1) then\n             Bp1_10mode =  bci\n            dBp1_10mode = dbci\n          endif\n        endif\n\n        ph = cn(inm) * zeta - cm(inm) * theta\n        cx = cos(ph)                          ! cos(n*zeta - m*theta)\n        sx = sin(ph)                          ! sin(n*zeta - m*theta)\n\n        rmaj =  rci * cx + rmaj               ! R in (R,Phi,Z)\n        babs =  bci * cx + babs               ! Absolute of B \n\n        dBds =  dbci * cx + dBds              ! dB/ds\n        dRds =  drci * cx + dRds              ! dR/ds\n        dZds =  dzci * sx + dZds              ! dZ/ds\n        dPds =  dpci * sx + dPds              ! d(phi)/ds\n\n        dBdt =  bci  * sx * cm(inm) + dBdt    ! dB/d(theta)\n        dRdt =  rci  * sx * cm(inm) + dRdt    ! dR/d(theta)\n        dZdt = -zci  * cx * cm(inm) + dZdt    ! dZ/d(theta)\n        dPdt = -pci  * cx * cm(inm) + dPdt    ! d(phi)/d(theta)\n\n!-- dB/d(theta) for mirror term \"mir\"  --- 100109 nunami -----------------\n        dBdt_mir =  bci  * sx * (cm(inm)-cn(inm)*q_0) + dBdt_mir\n!-------------------------------------------------------------------------\n\n        dBdz = -bci  * sx * cn(inm) + dBdz    ! dB/d(zeta)\n        dRdz = -rci  * sx * cn(inm) + dRdz    ! dR/d(zeta)\n        dZdz =  zci  * cx * cn(inm) + dZdz    ! dZ/d(zeta)\n        dPdz =  pci  * cx * cn(inm) + dPdz    ! d(phi)/d(zeta)\n      end do\n! ------------------------------------------------------------------------\n!\n! ---- Covariant componets of the metric tensor --------------------------------------\n      gdwss  = dRds**2   + dZds**2   + (rmaj*dPds)**2         ! g_s_s\n      gdwtt  = dRdt**2   + dZdt**2   + (rmaj*dPdt)**2         ! g_theta_theta\n      gdwzz  = dRdz**2   + dZdz**2   + (rmaj*dPdz)**2         ! g_zeta_zeta\n      gdwst  = dRds*dRdt + dZds*dZdt + (rmaj**2)*dPds*dPdt    ! g_s_theta\n      gdwsz  = dRds*dRdz + dZds*dZdz + (rmaj**2)*dPds*dPdz    ! g_s_zeta\n      gdwtz  = dRdt*dRdz + dZdt*dZdz + (rmaj**2)*dPdt*dPdz    ! g_theta_zeta\n! ------------------------------------------------------------------------------------\n!\n! ---- For Jacobian in (s,theta,zeta) coordinates ------------------------------------\n      rootg  = (2.d0 * ss * psia) * ( cug1 + eot1 * cui1 ) /  babs / babs  ! sqrt(g)\n      rg2inv = 1.0d0 / rootg / rootg                          ! 1/g\n\n!!! THW (Dec 7, 2011)\n!!!      jcob(iz) = rootg\n!!! THW (Dec 7, 2011)\n\n! ------------------------------------------------------------------------------------\n!\n! ---- Contravariant componets of the metric tensor ----------------------------------\n      gupss  = rg2inv * ( gdwtt * gdwzz - gdwtz * gdwtz )     ! g^s^s\n      guptt  = rg2inv * ( gdwss * gdwzz - gdwsz * gdwsz )     ! g^theta^theta\n      gupzz  = rg2inv * ( gdwss * gdwtt - gdwst * gdwst )     ! g^zeta^zeta \n      gupst  = rg2inv * ( gdwtz * gdwsz - gdwst * gdwzz )     ! g^s^theta\n      gupsz  = rg2inv * ( gdwst * gdwtz - gdwtt * gdwsz )     ! g^s^zeta\n      guptz  = rg2inv * ( gdwst * gdwsz - gdwss * gdwtz )     ! g^theta^zeta\n! ------------------------------------------------------------------------------------\n!\n! ---- Covariant componets of B ------------------------------------------------------\n      Bs   = ( gdwsz + eot1 * gdwst ) / rootg                 ! B_s\n      Bth  = cui1                                             ! B_theta\n      Bzt  = cug1                                             ! B_zeta\n! ------------------------------------------------------------------------------------\n!\n\n! *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*= Edit by nunami 10.04.15 =*=*=*=*=*=*=*=*\n! ---- Normalization for length with R_0 ---------------------------------------------\n      rmaj  = rmaj  / R0_unit\n!     ---------------------------------\n      gdwss = gdwss / R0_unit / R0_unit\n      gdwtt = gdwtt / R0_unit / R0_unit\n      gdwzz = gdwzz / R0_unit / R0_unit\n      gdwst = gdwst / R0_unit / R0_unit\n      gdwsz = gdwsz / R0_unit / R0_unit\n      gdwtz = gdwtz / R0_unit / R0_unit\n!     ---------------------------------\n      gupss = gupss * R0_unit * R0_unit\n      guptt = guptt * R0_unit * R0_unit\n      gupzz = gupzz * R0_unit * R0_unit\n      gupst = gupst * R0_unit * R0_unit\n      gupsz = gupsz * R0_unit * R0_unit\n      guptz = guptz * R0_unit * R0_unit\n! ------------------------------------------------------------------------------------\n!\n!\n! ---- Normalization for B componets etc. --------------------------------------------\n      babs  = babs / B00mode\n      Bs    = Bs   / B00mode / R0_unit\n      Bth   = Bth  / B00mode / R0_unit\n      Bzt   = Bzt  / B00mode / R0_unit\n      dBds  = dBds / B00mode\n      dBdt  = dBdt / B00mode\n      dBdz  = dBdz / B00mode\n\n      dBdt_mir  = dBdt_mir / B00mode\n! ------------------------------------------------------------------------------------\n\n! *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*= Edit by nunami 10.04.15 =*=*=*=*=*=*=*=*\n\n\n! --- Normalization for rootg with R_0 -- by nunami 10.04.15 -------------------------\n      rootg = rootg / R0_unit / R0_unit / R0_unit\n\n! ---- sqrt(g) in (x,y,z), i.e. flux tube coordinates --------------------------------\n      rootgft   = ( q_0 / (r_0 * r_a) ) * rootg  ! sqrt(g_ft)\n\n! ---- sqrt(g) in (r,theta,zeta), i.e. Boozer coordinates ----------------------------\n      rootgbz   = rootg / r_a\n\n\n! ======================================================================================\n\n\n      if( isw == 0 ) then\n\n        write( olog, * ) \"================= \"\n        write( olog, * ) \" #  B00mode     = \",  B00mode\n        write( olog, * ) \" #  Bm1_0mode   = \",  Bm1_0mode\n        write( olog, * ) \" #  B0_10mode   = \",  B0_10mode\n        write( olog, * ) \" #  Bm1_10mode  = \",  Bm1_10mode\n        write( olog, * ) \" #  Bp1_10mode  = \",  Bp1_10mode\n        write( olog, * ) \" # dB00mode     = \", dB00mode\n        write( olog, * ) \" # dBm1_0mode   = \", dBm1_0mode\n        write( olog, * ) \" # dB0_10mode   = \", dB0_10mode\n        write( olog, * ) \" # dBm1_10mode  = \", dBm1_10mode\n        write( olog, * ) \" # dBp1_10mode  = \", dBp1_10mode\n        write( olog, * ) \"=================\"\n\n        write( olog, * ) \"\"\n\n        write( olog, * ) \"================= \"\n        write( olog, * ) \" # eps_t        = \",  - Bm1_0mode  / B00mode\n        write( olog, * ) \" # eps_h/eps_t  = \",  - B0_10mode  / Bm1_0mode\n        write( olog, * ) \" # eps_-/eps_t  = \",  - Bp1_10mode / Bm1_0mode\n        write( olog, * ) \" # eps_+/eps_t  = \",  - Bm1_10mode / Bm1_0mode\n        write( olog, * ) \" # rdeps00/eps_t= \",  ss * dB00mode    / Bm1_0mode\n        write( olog, * ) \" # rdeps_t/eps_t= \",  ss * dBm1_0mode  / Bm1_0mode\n        write( olog, * ) \" # rdeps_h/eps_t= \",  -ss * dB0_10mode  / Bm1_0mode\n        write( olog, * ) \" # rdeps_-/eps_t= \",  -ss * dBp1_10mode / Bm1_0mode\n        write( olog, * ) \" # rdeps_+/eps_t= \",  -ss * dBm1_10mode / Bm1_0mode\n        write( olog, * ) \"=================\"\n\n      end if\n\n      isw = 1\n\n\n    deallocate ( ssi )\n\n\n  END SUBROUTINE vmecin_coeff\n\n\n\n!--------------------------------------\n  SUBROUTINE vmecin_read\n!--------------------------------------\n\n! +------------------------------------------------------------------------+\n! |    Read VMEC equiblium                                                 |\n! |    (programme for interface vmec(newboz))                              | \n! |                                                                        |\n! |                                  by M. Nunami (Nov. 2009)              |\n! +------------------------------------------------------------------------+\n\n\n! --- read vmec-nwboz field ----------\n    call iodisk\n\n! --- calculate spline coeff ---------\n    call setfld\n\n\n  END SUBROUTINE vmecin_read\n\n\n!--------------------------------------\n  ", "SUBROUTINE iodisk\n!--------------------------------------\n\n! +-------------------------------------------------------------------------+\n! |   iodisk ; read input data from newboz                                  |\n! |                                                                         |\n! |   nsd          number of vmec grid points                               |\n! |   mbzmax       number of boozer theta harmonics desired                 |\n! |   nbzmin       number of negative boozer zeta harmonics desired         |\n! |   nbzmax       number of positive boozer zeta harmonics desired         |\n! |                                                                         |\n! |   bbozh : mod b spectrum in boozer coordinates                          |\n! |                                                                         |\n! |         b(i,t,z) =     sum bbozh(m,i) cos(-t*mboz(m) + z*nboz(m) )      |\n! |                                                                         |\n! |   note   bco(i,m) = bbozh(m,i)                                          |\n! |                                                                         |\n! |   transformation from boozer to cylindrical coordinates                 |\n! |                                                                         |\n! |       ( psi, theta, zeta ) -> ( r, phi, z )                             |\n! |                                                                         |\n! |         r(i,t,z) =     sum rbozh(m,i) cos(-t*mboz(m) + z*nboz(m) )      |\n! |         p(i,t,z) = z + sum pbozh(m,i) sin(-t*mboz(m) + z*nboz(m) )      |\n! |         z(i,t,z) =     sum zbozh(m,i) sin(-t*mboz(m) + z*nboz(m) )      |\n! |                                                                         |\n! |   surface quantities ( after renormalized )                             |\n! |                                                                         |\n! |         psib   : toroidal flux within a flux surface / ( 2*pi )         |\n! |         eot    : rotational transform                                   |\n! |         cui    : toroidal current within a flux surface                 |\n! |         cug    : poloidal current without a flux surface                |\n! |                                                                         |\n! |   ---------------------------------------------------------------       |\n! |                                                                         |\n! |  Input Parameters                                                       |\n! |  NEWBZ:                                                                 |\n! |   mdmx : number of important modes extracted from nmboz modes           |\n! |              ( nmboz - 1 >= mdmx is required )                          |\n! |            Note : total mode is mdmx+1 (including B_(0,0) mode)         |\n! |   nlim : if nlim/=0, |n|>nlim modes are skipped.                        |\n! |                                                                         |\n! |   kmsh : number of radial mesh of field data for FORTEC-3D              |\n! |            Note : total mesh is kmsh+1 (including rho=0.0)              |\n! |   dcheck : if TRUE, original data from NEWBOZ is put out.               |\n! |   lrchk  : if TRUE, check and adjust the coordinate system to RHS.      |\n! |   bmag  : magnification factor of the magnetic field strength.          |\n! +-------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n  logical dcheck,lrchk\n!\n  dimension ifsel(ibhar)\n  dimension bmax(nsd_max), bmin(nsd_max)\n  dimension bsel(ibhar),icont(ibhar), msel(ibhar)\n!\n!!  COMMON/BPARA/BB0,psia,sa,rmaj0,zi,nmass\n!!  common/param1/kmsh,kmsh1,nsd,mdmx,itype\n  namelist/newbz/dcheck,lrchk,mdmx,kmsh,nlim,bmag\n! ----------------------------------------------------------------------------- !\n!\n!\n  read(inml,nml=newbz)\n  if ( rank == 0 ) then\n    write(ovmc,nml=newbz)\n  endif\n!\n!\n! ... Read input data (the same file used to make input data for VMEC) for density and temp.\n! ... The density and temperature profiles -> given by subroutine \"ntfunc0\" or \"ntfunc1\"\n! ... Choose input type ( Satake's exponential style      : itype=0, \n! ...                     expansion in rho like in GSRAKE : itype=1, \n! ...                     Idomura's style                 : itype=2 )\n!\n  read(ivmc,*)\n  read(ivmc,*) itype\n  if(itype==0) len=4\n  if(itype==1) len=10\n  if(itype==2) len=3\n!\n  read(ivmc,*)\n  read(ivmc,*)dn0(0:len)\n  read(ivmc,*)\n  read(ivmc,*)ti0(0:len)\n  read(ivmc,*)\n  read(ivmc,*)te0(0:len)\n  read(ivmc,*)\n  read(ivmc,*)dummy\n  read(ivmc,*)\n  read(ivmc,*)dummy,R0,dummy,a0,zi,nmass\n!\n  if(itype==2) then \n    dn0(2)=dn0(1)*dn0(2)*a0/R0\n    ti0(2)=ti0(1)*ti0(2)*a0/R0\n    te0(2)=te0(1)*te0(2)*a0/R0\n  end if\n!\n!!    dn0: ni(0) [m^(-3)]\n!!    ti0, te0: temperature at the axis [keV]\n!!    zi:  ion charge number\n!!    nmass : relative mass of the ion species to proton\n!\n!!    BB0:  toroidal field strength at the magnetic axis  [T]\n!!    Rmaj0 and a0 : major and minor radius [m]\n!\n! --- constant parameters --------\n  pi2    = twopi\n  cmu0   = 4.0d0*pi*1.0d-7\n!\n! --- Read newboz data ------------- \n  read(ndiskc) nmboz, nsd, nfp\n  read(ndiskc) Rmaj0, BB0\n!\n  if ( rank == 0 ) then\n    write(ovmc,6001) nmboz, nsd, nfp\n  endif\n!\n  nsd=nsd+1\n  kmsh1=kmsh+1\n  mmx1=mdmx+1\n!\n  if(nmboz-1.lt.mdmx) then\n    if ( rank == 0 ) then\n      write(ovmc,9001) nmboz - 1, mdmx\n    endif\n    stop\n  else\n    if ( rank == 0 ) then\n      write(ovmc,9003) nmboz - 1, mdmx\n    endif\n  endif\n!\n  if ( rank == 0 ) then\n    write(ovmc,9004)nsd,kmsh\n  endif\n!\n  allocate(CUI(kmsh1), CUG(kmsh1), TXI(kmsh1), TXE(kmsh1), DXI(kmsh1), DLN(kmsh1),    &\n           C1I(kmsh1), C2I(kmsh1), C3I(kmsh1), C1G(kmsh1), C2G(kmsh1), C3G(kmsh1),    &\n           C1TI(kmsh1),C2TI(kmsh1),C3TI(kmsh1),C1TE(kmsh1),C2TE(kmsh1),C3TE(kmsh1),   &\n           C1DI(kmsh1),C2DI(kmsh1),C3DI(kmsh1),SPOS(kmsh1),PSIB(kmsh1),EOT(kmsh1),    &\n           C1ET(kmsh1),C2ET(kmsh1),C3ET(kmsh1),C1LN(kmsh1),C2LN(kmsh1),C3LN(kmsh1))\n  allocate(BCO(kmsh1,MMX1),C1BF(kmsh1,MMX1),C2BF(kmsh1,MMX1),C3BF(kmsh1,MMX1),        &\n           CM(MMX1),CN(MMX1))\n  allocate(RCO(kmsh1,MMX1),ZCO(kmsh1,MMX1),PCO(kmsh1,MMX1),                           &\n           C1R(kmsh1,MMX1),C2R(kmsh1,MMX1),C3R(kmsh1,MMX1),                           &\n           C1Z(kmsh1,MMX1),C2Z(kmsh1,MMX1),C3Z(kmsh1,MMX1),                           &\n           C1P(kmsh1,MMX1),C2P(kmsh1,MMX1),C3P(kmsh1,MMX1))\n  allocate(bco0(nsd,mmx1),rco0(nsd,mmx1),zco0(nsd,mmx1),pco0(nsd,mmx1),               &\n           spos0(nsd))\n!\n!\n! --- Read newboz data ----------------------\n  READ(ndiskc) (PSIBZ(i), i = 2, NSD)\n  READ(ndiskc) (EOTBZ(i), i = 2, NSD)\n!\n  READ(ndiskc) (CUIBZ(i), i = 2, NSD)\n  READ(ndiskc) (CUGBZ(i), i = 2, NSD)\n!\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (BBOZH(M,I), I = 2, NSD)\n  END DO\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (RBOZH(M,I), I = 2, NSD)\n  END DO\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (ZBOZH(M,I), I = 2, NSD)\n  END DO\n!\n  DO M = 1, NMBOZ\n    READ(ndiskc)  MBOZ(M), NBOZ(M)\n    READ(ndiskc) (PBOZH(M,I), I = 2, NSD)\n  END DO\n!\n!\n! --- magnetic field magnification -------------------------------------\n  if(bmag/=1.0d0) then\n    if( rank == 0 ) then\n      write(ovmc,\"(a,f8.3,a)\")'** bfield is magnified by ',bmag,' **'\n    endif\n    BB0=BB0*bmag\n    PSIBZ=PSIBZ*bmag\n    CUIBZ=CUIBZ*bmag\n    CUGBZ=CUGBZ*bmag\n    BBOZH=BBOZH*bmag\n  end if\n!\n! --- check of LHS or RHS ----------------------------------------------\n  if ( .not.lrchk ) goto  999 !check lhs or rhs if lrchk = .true.\n!\n  ichk = nsd/2\n  chi = pi2/90.0d0\n  zsum  =  0.0d0\n  do i = 1, nmboz\n    zsum  =  zsum + zbozh(i,ichk)*dsin(-mboz(i)*chi)\n  end do\n!\n  if( zsum .gt. 0.0d0 ) then\n!  ....   counterclockwise\n    drthta =  1.0d0\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'     LHS ( theta is counterclockwise ) '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  else\n!  ....   clockwise\n    drthta = -1.0d0\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'       RHS ( theta is clockwise )      '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  endif\n!\n!\n!+++++ updated on  9/29 94 by N^2 : for left -> right start\n!\n!      - theta -> theta in VMEC\n!\n! irtchg = 0\n  if( drthta .gt. 0.0d0 ) then\n!   irtchg = 1\n    do i = 2, nsd\n!      change of sign of psi is due to miss-interface\n      PSIBZ(i) = - PSIBZ(i)\n      EOTBZ(i) = - EOTBZ(i)\n      CUIBZ(i) = - CUIBZ(i)\n    end do\n!\n    do m = 1, nmboz\n      mboz(m) = - mboz(m)\n    end do\n!\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'     LHS -> RHS ( theta is clockwise ) '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n    drthta = -1.0d0\n  endif\n!\n!..... psi > 0 must be ensured in the usual Boozer coordinates\n!\n!      - curpol -> curpol\n!      - curtor -> curtor in VMEC\n!\n! ipschg = 0\n  if( psibz(2) .lt. 0.0d0 ) then\n!   ipschg = 1\n    do i = 2, nsd\n      PSIBZ(i) = - PSIBZ(i)\n      CUIBZ(i) = - CUIBZ(i)\n      CUGBZ(i) = - CUGBZ(i)\n    end do\n!\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'                    psi < 0 -> psi > 0 '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  endif\n!\n!      winding law is inverted\n!      - curtor -> curtor\n!\n  if( eotbz(nsd) .lt. 0.0d0 ) then\n    sgniot =-1.0d0\n  else\n    sgniot = 1.0d0\n  endif\n! iitchg = 0\n! if( litchg .and. sgniot .lt. 0.0d0 ) then\n  if(sgniot .lt. 0.0d0 ) then\n!   iitchg = 1\n    do i = 2, nsd\n      EOTBZ(i) = - EOTBZ(i)\n      CUIBZ(i) = - CUIBZ(i)\n    end do\n    do m = 1, nmboz\n      nboz(m) = - nboz(m)\n      do i = 2, nsd\n        pbozh(m,i) = - pbozh(m,i)\n      end do\n    end do\n    sgniot = 1.0d0\n!\n    if( rank == 0 ) then\n      write(ovmc,*)\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)'                  iota < 0 -> iota > 0 '\n      write(ovmc,*)' --------------------------------------'\n      write(ovmc,*)\n    endif\n  endif\n!\n!...  transpose LHS --> RHS end \n!\n999 continue\n!     \n!.... from half mesh to integer mesh\n!\n  do i = 2, nsd-1\n    psibz(i)   = ( psibz(i) + psibz(i+1) )/2.0d0\n    eotbz(i)   = ( eotbz(i) + eotbz(i+1) )/2.0d0\n    cuibz(i)   = ( cuibz(i) + cuibz(i+1) )/2.0d0\n    cugbz(i)   = ( cugbz(i) + cugbz(i+1) )/2.0d0\n    do j = 1, nmboz\n      bbozh(j,i) = ( bbozh(j,i) + bbozh(j,i+1) )/2.0d0\n      rbozh(j,i) = ( rbozh(j,i) + rbozh(j,i+1) )/2.0d0\n      zbozh(j,i) = ( zbozh(j,i) + zbozh(j,i+1) )/2.0d0\n      pbozh(j,i) = ( pbozh(j,i) + pbozh(j,i+1) )/2.0d0\n    enddo\n  enddo\n\n!     \n!+++++ extrapolation of the values at the magnetic axis\n!\n  do j = 1, nmboz\n    if( mboz(j) .eq. 0 ) then\n      bbozh(j,1) = 3.0d0*bbozh(j,2) - 3.0d0*bbozh(j,3) + bbozh(j,4)\n      rbozh(j,1) = 3.0d0*rbozh(j,2) - 3.0d0*rbozh(j,3) + rbozh(j,4)\n      zbozh(j,1) = 3.0d0*zbozh(j,2) - 3.0d0*zbozh(j,3) + zbozh(j,4)\n      pbozh(j,1) = 3.0d0*pbozh(j,2) - 3.0d0*pbozh(j,3) + pbozh(j,4)\n    else\n      bbozh(j,1) = 0.0d0\n      rbozh(j,1) = 0.0d0\n      zbozh(j,1) = 0.0d0\n      pbozh(j,1) = 0.0d0\n    endif\n  enddo\n\n  if( psibz(nsd-1) .gt. 0.0d0 ) then\n    psisgn   =  1.0d0\n  else\n    psisgn   = -1.0d0\n  endif\n  psibz(  1) = 1.0d-18*psisgn\n  eotbz(  1) = 3.0d0*eotbz(  2) - 3.0d0*eotbz(  3) + eotbz(  4)\n  cuibz(  1) = 3.0d0*cuibz(  2) - 3.0d0*cuibz(  3) + cuibz(  4)\n  cugbz(  1) = 3.0d0*cugbz(  2) - 3.0d0*cugbz(  3) + cugbz(  4)\n!\n!+++++ extrapolation of the values at the boundary\n!\n  do j = 1, nmboz\n    bbozh(j,nsd) = 3.0d0*bbozh(j,nsd-1)-3.0d0*bbozh(j,nsd-2)+bbozh(j,nsd-3)\n    rbozh(j,nsd) = 3.0d0*rbozh(j,nsd-1)-3.0d0*rbozh(j,nsd-2)+rbozh(j,nsd-3)\n    zbozh(j,nsd) = 3.0d0*zbozh(j,nsd-1)-3.0d0*zbozh(j,nsd-2)+zbozh(j,nsd-3)\n    pbozh(j,nsd) = 3.0d0*pbozh(j,nsd-1)-3.0d0*pbozh(j,nsd-2)+pbozh(j,nsd-3)\n  enddo\n!\n  psibz(nsd) = 3.0d0*psibz(nsd-1)-3.0d0*psibz(nsd-2)+psibz(nsd-3)\n  eotbz(nsd) = 3.0d0*eotbz(nsd-1)-3.0d0*eotbz(nsd-2)+eotbz(nsd-3)\n  cuibz(nsd) = 3.0d0*cuibz(nsd-1)-3.0d0*cuibz(nsd-2)+cuibz(nsd-3)\n  cugbz(nsd) = 3.0d0*cugbz(nsd-1)-3.0d0*cugbz(nsd-2)+cugbz(nsd-3)\n!     \n!.... normalization to vmec calculation\n!\n  cnorm  = rmaj0*bb0/cugbz(nsd)\n  do i = 1, nsd\n    cuibz(i)   = cuibz(i)*cnorm\n    cugbz(i)   = cugbz(i)*cnorm\n    psibz(i)   = psibz(i)*cnorm\n    do j = 1, nmboz\n      bbozh(j,i) = bbozh(j,i)*cnorm\n    enddo\n  enddo\n\n  psia = psibz(nsd)\n  sa    = sqrt(psia*2.d0/bb0)\n  if( rank == 0 ) then\n    write(ovmc,305) rmaj0,bb0,psia,sa\n    write(ovmc,306) cnorm\n  endif\n305 format(' rmaj0= ',d15.7,' , bb0 = ',d15.7,' , psia = ',d15.7,' , sa = ',d15.7)\n306 format(' cnom =',d15.7)\n!\n  if( rank == 0 ) then\n    write(ovmc,6002)\n    write(ovmc,6003) (i, psibz(i), eotbz(i), cuibz(i), cugbz(i), i = 1, nsd)\n  endif\n!\n  if( dcheck ) then                            !check bbozh\n    nout  = 5\n    nprt  = nsd/nout\n    if( mod(nsd,nout) .ne. 0 ) nprt = nprt + 1\n!     \n    do ii=1,nprt\n      iis  =(ii-1)*nout+1\n      iie  = ii   *nout\n      if( iie .gt. nsd) iie=nsd \n      if( rank == 0 ) then\n        write(ovmc,6011)         ( kk , kk = iis, iie )\n      endif\n!     \n      do j = 1, nmboz\n        if( rank == 0 ) then\n          write(ovmc,6012) j, mboz(j), nboz(j),( bbozh(j,kk), kk = iis, iie )\n        endif\n      enddo\n    enddo\n  endif\n!\n!        modified by Satake 2004/02/26\n!\n!..... assuming ijf = 1 correponds to mboz = 0 and nboz = 0.\n!\n!\n!..... initialization of labels of fourier modes for each surface\n!\n  do ijf = 2, nmboz\n    bsel(ijf) = -1.0d0\n    msel(ijf) = 0\n    icont(ijf)= 0\n  end do\n  icont(1)=1\n  imttl   =1\n!\n!..... remove |n|>nlim modes \n  if(nlim.ne.0) then\n    if( rank == 0 ) then\n      write(ovmc,*)\n!     write(ovmc,'(\"***    |n|>\",i3,\" modes are skipped.   ***\")'),nlim\n    endif\n    do ijf = 2, nmboz\n      if(abs(nboz(ijf))>nlim) then\n        bbozh(ijf,:)=0.0d0\n      end if\n    end do\n  end if\n!\n!..... selection of modes for each surface\n!\n  do is = 1, nsd\n!\n    bmax(is)  = -100.0*bb0\n    bmin(is)  =  100.0*bb0\n    do ijf = 2, nmboz\n      bmax(is)  = dmax1( bbozh(ijf,is), bmax(is) )\n      bmin(is)  = dmin1( bbozh(ijf,is), bmin(is) )\n    end do\n!     \n    bamax = dmax1( dabs(bmax(is)), dabs(bmin(is)) )\n!     \n    do ijf = 2, nmboz\n      asel = dabs(bbozh(ijf,is))/bamax\n      if (asel.ge.bsel(ijf)) then\n        bsel(ijf) = asel\n        msel(ijf) = is\n      end if\n    end do\n  end do\n!     \n!.. selection of modes \n!.. search major modes of mag. field spectrum (total mdmx+1 modes)\n!.. b(m=0,n=0) mode is always comes first.\n!\n  do ijf = 2, nmboz\n    igt = 0\n    do ijf2 = 2, nmboz\n      if (ijf==ijf2) cycle\n      if (bsel(ijf2).gt.bsel(ijf)) then\n        igt = igt+1\n        cycle\n      end if\n      if (bsel(ijf2)==1.0d0.and.bsel(ijf)==1.0d0) then\n        if (dabs( bbozh(ijf2,msel(ijf2))).gt.dabs( bbozh(ijf,msel(ijf)))) then\n          igt = igt+1\n        end if\n      end if\n    end do\n!     \n    if (igt.lt.mdmx) then \n      icont(ijf) = igt+2\n      imttl=imttl+1\n    end if\n  end do\n!\n  if( rank == 0 ) then\n    write(ovmc,6035) \n  endif\n!\n  do i=1,imttl\n    do ijf = 1, nmboz\n      if (icont(ijf)==i) then\n        bmax1=-100.0*bb0\n        do is=1,nsd\n          bmax1=dmax1(dsqrt(bbozh(ijf,is)**2),bmax1)\n        end do\n        if( rank == 0 ) then\n          write(ovmc,6036) i,mboz(ijf),nboz(ijf),icont(ijf),msel(ijf),bsel(ijf),bmax1\n        endif\n        do is = 1, nsd\n          bco0(is,i) = bbozh(ijf,is)\n          rco0(is,i) = rbozh(ijf,is)\n          zco0(is,i) = zbozh(ijf,is)\n          pco0(is,i) = pbozh(ijf,is)\n        end do\n        cm(i) = dble(mboz(ijf))\n        cn(i) = dble(nboz(ijf))\n        cycle\n      end if\n    end do\n  end do\n!\n  ", "if (imttl.ne.mmx1) then\n    if( rank == 0 ) then\n      write(ovmc,*) 'imttl diff. from mmx1. abort! '\n    endif\n    stop\n  end if\n!\n  if( rank == 0 ) then\n    write(ovmc,*)\n    write(ovmc,*)' selected fourier spectrum of b '\n    write(ovmc,*)\n  endif\n!\n  nout  = 5\n  nprt  = nsd/nout\n  if( mod(nsd,nout) .ne. 0 ) nprt = nprt + 1\n!     \n  do ii=1,nprt\n    iis  =(ii-1)*nout+1\n    iie  = ii   *nout\n    if( ii .eq. nprt ) iie  = nsd\n    if( rank == 0 ) then\n      write(ovmc,6033)  ( kk , kk = iis, iie )\n    endif\n!\n    do j = 1, imttl\n      if( rank == 0 ) then\n        write(ovmc,6034) j, idint(cm(j)), idint(cn(j)),( bco0(kk,j), kk = iis, iie )\n      endif\n    end do\n  end do\n!\n6033 format(//4x,' j',2x,'(   m,   n)',5(5x,'b _',i4)/)\n6034 format(  2x,i4,2x,'(',i4,',',i4,')',5(1x,1pd11.4))\n6035 format(/2x,'selected mode j   (   m,   n)_j','  rank   most significant on', &\n     &       '   b_max(rel.)     b_max(abs.)')\n6036 format(10x,i4,'      (',i4,',',i4,')',4x,i4,8x,i6,8x,1p,2e13.5)\n!\n6001 format(//9x,'nmboz  = ',i4,' : nsd - 1 = ',i4,' : nfp    =',i4,//)\n6002 format(//6x,'i',11x,'psi',10x,'iota',13x,'i',13x,'g'/)\n6003 format(/(2x,i5,4(2x,1pd12.5)))\n6011 format(//3x,' j',3x,'(   m,   n)',5(5x,'b _',i4)/)\n6012 format(  2x,i4,2x,'(',i4,',',i4,')',5(1x,1pd11.4))\n9001 format(//10x,'!err! nmboz - 1 = ',i4,', mdmx  = ',i4//)\n9003 format(//10x,'nmboz - 1 = ',i4,' >= mdmx  = ',i4//)\n!!c 9002 format(//10x,'!err! nsd   - 1 = ',i4,' =/ kmsh = ',i4//)\n9004 format(//10x,'nsd = ',i4,', kmsh = ',i4//)\n\n  return\n\n\n  END SUBROUTINE iodisk\n\n\n\n!\n!\n!\n!--------------------------------------\n  SUBROUTINE setfld\n!--------------------------------------\n\n! +-------------------------------------------------------------------------+\n! |   Set field data                                                        |\n! |                                                                         |\n! |   Modified 2004/3/9: Spline tables are in s_bar=psi/psia coordinate.    |\n! |   Modified 2005/10/24: kmsh can be taken to be different from nsd.      |\n! +-------------------------------------------------------------------------+\n!********************************************************************************\n! ----------------------------------------------------------------------------- !\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n!\n  real(KIND=8), dimension(kmsh1) :: wkbf,wkc1,wkc2,wkc3,ds,dsl\n  real(KIND=8), dimension(nsd) :: wkbf0,wkc10,wkc20,wkc30\n  integer(kind=4), dimension(kmsh1) :: jpl\n  real(KIND=8) dy(2),fu(0:3)\n!!  COMMON/BPARA/bb0,psia,sa,rmaj0,zi,nmass\n!!  common/param1/kmsh,kmsh1,nsd,mdmx,itype\n! ----------------------------------------------------------------------------- !\n!\n!\n!------  radial position -----\n!\n  spos0(1) = 0.0d0\n  spos(1)  = 0.0d0\n  psib(1)  = psibz(1)\n  do j=2,nsd\n    spos0(j) = sqrt( psibz(j)/psia ) ! normalized minor radius\n  end do\n!\n  dsp=1.0d0/dble(kmsh)\n  do j=2,kmsh1\n    spos(j)  = dsp*dble(j-1)\n    psib(j)  = psia*spos(j)**2\n    ds(j-1)  = spos(j)-spos(j-1)\n  end do\n  ds(kmsh1)=ds(kmsh)\n!... relation between spos0 and spos\n  dsl(1)=0.0d0\n  jpl(1)=1\n  do j=2,kmsh1\n    sp = spos(j)\n    jpl(j)=nsd\n    do k=2,nsd\n      if(sp<spos0(k)) then\n        jpl(j)=k-1\n        exit\n      end if\n    end do\n    sj     = spos0(jpl(j))\n    dsl(j) = sp - sj\n  end do\n!\n!------  make n,t,ln_lambda tables on spos ---!\n!\n  do j=1,kmsh1\n    select case(itype)\n    case(0)\n      call ntfunc0(spos(j),txe(j),txi(j),dxi(j))\n    case(1)\n      call ntfunc1(spos(j),txe(j),txi(j),dxi(j))\n    case(2)\n      call ntfunc2(spos(j),txe(j),txi(j),dxi(j))\n    end select\n    dln(j)=32.2d0+1.15d0*dlog10(txe(j)**2*1.0d6/dxi(j)/zi)\n  end do\n!\n!--------------------------------------------!\n!\n!   make the spline table for magnetic field and (r,phi,z)\n!   \n!--------------------------------------------!\n!\n  do i=1,mdmx+1\n!... first, make spline table on spos0\n    do j=1,nsd\n      wkbf0(j)=bco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!... second, interporate value at spos\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!... last, make spline table on spos\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh\n      bco (j,i) =  wkbf(j)\n      c1bf(j,i) =  wkc1(j)\n      c2bf(j,i) =  wkc2(j)\n      c3bf(j,i) =  wkc3(j)\n    end do\n!.. on the outer edge\n    bco (kmsh1,i) = fu(0)\n    c1bf(kmsh1,i) = fu(1)\n    c2bf(kmsh1,i) = fu(2)\n    c3bf(kmsh1,i) = fu(3)\n!!\n    do j=1,nsd\n      wkbf0(j)=rco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh\n      rco(j,i) =  wkbf(j)\n      c1r(j,i) =  wkc1(j)\n      c2r(j,i) =  wkc2(j)\n      c3r(j,i) =  wkc3(j)\n    end do\n    rco(kmsh1,i) = fu(0)\n    c1r(kmsh1,i) = fu(1)\n    c2r(kmsh1,i) = fu(2)\n    c3r(kmsh1,i) = fu(3)\n!!\n    do j=1,nsd\n      wkbf0(j)=zco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh1\n      zco(j,i) =  wkbf(j)\n      c1z(j,i) =  wkc1(j)\n      c2z(j,i) =  wkc2(j)\n      c3z(j,i) =  wkc3(j)\n    end do\n    zco(kmsh1,i) = fu(0)\n    c1z(kmsh1,i) = fu(1)\n    c2z(kmsh1,i) = fu(2)\n    c3z(kmsh1,i) = fu(3)\n!!\n    do j=1,nsd\n      wkbf0(j)=pco0(j,i)\n    end do\n!\n    call fit_x3(spos0(1:4),wkbf0(1:4),1,dy(1),fu)\n    call fit_x3(spos0(nsd-3:nsd),wkbf0(nsd-3:nsd),2,dy(2),fu)\n    call spline_fit2(spos0,wkbf0,dy,nsd,wkc10,wkc20,wkc30)\n!\n    call val_intp(jpl,dsl,wkbf0,wkc10,wkc20,wkc30,kmsh1,nsd,wkbf)\n!\n    call fit_x3(spos(1:4),wkbf(1:4),1,dy(1),fu)\n    call fit_x3(spos(kmsh-2:kmsh1),wkbf(kmsh-2:kmsh1),2,dy(2),fu)\n    call spline_fit2(spos,wkbf,dy,kmsh1,wkc1,wkc2,wkc3)\n!\n    do j=1, kmsh1\n      pco(j,i) =  wkbf(j)\n      c1p(j,i) =  wkc1(j)\n      c2p(j,i) =  wkc2(j)\n      c3p(j,i) =  wkc3(j)\n    end do\n    pco(kmsh1,i) = fu(0)\n    c1p(kmsh1,i) = fu(1)\n    c2p(kmsh1,i) = fu(2)\n    c3p(kmsh1,i) = fu(3)\n!\n  end do\n!\n!...\n!\n!!$if( rank == 0 ) then\n!!$  write(8,*)'### spline coefficients for B ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### bco          c1bf           c2bf           c3bf            (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    do j=1,kmsh1\n!!$      write(8,7002)bco(j,i),c1bf(j,i),c2bf(j,i),c3bf(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$  write(8,*)'### spline coefficients for R ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### rco          c1r            c2r            c3r             (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    write(8,7000)int(cm(i)),int(cn(i))\n!!$    do j=1,kmsh1\n!!$      write(8,7002)rco(j,i),c1r(j,i),c2r(j,i),c3r(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$  write(8,*)'### spline coefficients for Z ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### zco          c1z            c2z            c3z             (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    do j=1,kmsh1\n!!$      write(8,7002)zco(j,i),c1z(j,i),c2z(j,i),c3z(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$  write(8,*)'### spline coefficients for PHI ###'\n!!$  write(8,*)'### kmsh    mdmx ###'\n!!$  write(8,7001)kmsh,mdmx\n!!$  write(8,*)'### pco          c1p            c2p            c3p             (  j,  i)###'\n!!$  do i=1,mdmx+1\n!!$    do j=1,kmsh1\n!!$      write(8,7002)pco(j,i),c1p(j,i),c2p(j,i),c3p(j,i),j,i\n!!$    end do\n!!$  end do\n!!$!\n!!$endif\n!!\n7000 format(4x,'cm = ',i4,' , cn = ',i4)\n7001 format(6x,i4,4x,i4)\n7002 format(4(1x,d14.6),1x,2i4)\n!\n!--------------------------------------------!\n!\n!     make the spline table for the flux functions;\n!     eot, cui, cug, txi, txe, dxi, dln\n!     Note that dT/dx, dn/dx (at x=0) = 0 are assumed. \n!--------------------------------------------!\n!\n!!!   eot\n  call fit_x3(spos0(1:4),eotbz(1:4),1,dy(1),fu)\n  call fit_x3(spos0(nsd-3:nsd),eotbz(nsd-3:nsd),2,dy(2),fu)\n  call spline_fit2(spos0,eotbz,dy,nsd,wkc10,wkc20,wkc30)\n!\n  call val_intp(jpl,dsl,eotbz,wkc10,wkc20,wkc30,kmsh1,nsd,eot)\n!\n  call fit_x3(spos(1:4),eot(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),eot(kmsh-2:kmsh1) ,2,dy(2),fu)\n  call spline_fit2(spos,eot,dy,kmsh1,c1et,c2et,c3et)\n!.. on the outer edge\n  eot (kmsh1) = fu(0)\n  c1et(kmsh1) = fu(1)\n  c2et(kmsh1) = fu(2)\n  c3et(kmsh1) = fu(3)\n!!!   cui\n  call fit_x3(spos0(1:4),cuibz(1:4),1,dy(1),fu)\n  call fit_x3(spos0(nsd-3:nsd),cuibz(nsd-3:nsd),2,dy(2),fu)\n  call spline_fit2(spos0,cuibz,dy,nsd,wkc10,wkc20,wkc30)\n!\n  call val_intp(jpl,dsl,cuibz,wkc10,wkc20,wkc30,kmsh1,nsd,cui)\n!\n  call fit_x3(spos(1:4),cui(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),cui(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,cui,dy,kmsh1,c1i,c2i,c3i)\n  cui(kmsh1) = fu(0)\n  c1i(kmsh1) = fu(1)\n  c2i(kmsh1) = fu(2)\n  c3i(kmsh1) = fu(3)\n!!!  cug\n  call fit_x3(spos0(1:4),cugbz(1:4),1,dy(1),fu)\n  call fit_x3(spos0(nsd-3:nsd),cugbz(nsd-3:nsd),2,dy(2),fu)\n  call spline_fit2(spos0,cugbz,dy,nsd,wkc10,wkc20,wkc30)\n!\n  call val_intp(jpl,dsl,cugbz,wkc10,wkc20,wkc30,kmsh1,nsd,cug)\n!\n  call fit_x3(spos(1:4),cug(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),cug(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,cug,dy,kmsh1,c1g,c2g,c3g)\n  cug(kmsh1) = fu(0)\n  c1g(kmsh1) = fu(1)\n  c2g(kmsh1) = fu(2)\n  c3g(kmsh1) = fu(3)\n!!!  txi\n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),txi(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),txi(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,txi,dy,kmsh1,c1ti,c2ti,c3ti)\n  txi(kmsh1) = fu(0)\n  c1ti(kmsh1) = fu(1)\n  c2ti(kmsh1) = fu(2)\n  c3ti(kmsh1) = fu(3)\n!!!  txe\n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),txe(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),txe(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,txe,dy,kmsh1,c1te,c2te,c3te)\n  txe(kmsh1) = fu(0)\n  c1te(kmsh1) = fu(1)\n  c2te(kmsh1) = fu(2)\n  c3te(kmsh1) = fu(3)\n!!!  dxi \n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),dxi(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),dxi(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,dxi,dy,kmsh1,c1di,c2di,c3di)\n  dxi(kmsh1) = fu(0)\n  c1di(kmsh1) = fu(1)\n  c2di(kmsh1) = fu(2)\n  c3di(kmsh1) = fu(3)\n!!!  dln\n  dy(1)=0.0d0\n!!$      call fit_x3(spos(1:4),dln(1:4),1,dy(1),fu)\n  call fit_x3(spos(kmsh-2:kmsh1),dln(kmsh-2:kmsh1),2,dy(2),fu)\n  call spline_fit2(spos,dln,dy,kmsh1,c1ln,c2ln,c3ln)\n  dln(kmsh1) = fu(0)\n  c1ln(kmsh1) = fu(1)\n  c2ln(kmsh1) = fu(2)\n  c3ln(kmsh1) = fu(3)\n!\n!\n!!$  write(8,*)'### spline coefficients for flux-surface funcs. ###'\n!!$  write(8,*)'### eot         c1et           c2et            c3et'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)eot(j),c1et(j),c2et(j),c3et(j),j\n!!$  end do\n!!$  write(8,*)'### cui         c1i            c2i             c3i '\n!!$  do j=1,kmsh1\n!!$    write(8,7003)cui(j),c1i(j),c2i(j),c3i(j),j\n!!$  end do\n!!$  write(8,*)'### cug         c1g            c2g             c3g '\n!!$  do j=1,kmsh1\n!!$    write(8,7003)cug(j),c1g(j),c2g(j),c3g(j),j\n!!$  end do\n!!$  write(8,*)'### txi         c1ti           c2ti            c3ti'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)txi(j),c1ti(j),c2ti(j),c3ti(j),j\n!!$  end do\n!!$  write(8,*)'### txe         c1te           c2te            c3te'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)txe(j),c1te(j),c2te(j),c3te(j),j\n!!$  end do\n!!$  write(8,*)'### dxi         c1di           c2di            c3di'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)dxi(j),c1di(j),c2di(j),c3di(j),j\n!!$  end do\n!!$  write(8,*)'### dln         c1ln           c2ln            c3ln'\n!!$  do j=1,kmsh1\n!!$    write(8,7003)dln(j),c1ln(j),c2ln(j),c3ln(j),j\n!!$  end do\n!!$!     \n!!$  write(8,*)'### psib        spos           spos0           ds &\n!!$     &           jp  jpl    dsl   ###'\n!!$  write(8,7004)psib(1),spos(1),spos0(1),0.0d0,1,jpl(1),dsl(1)\n!!$  do j=2,kmsh1\n!!$    jp=jpl(j)\n!!$    write(8,7004)psib(j),spos(j),spos0(jp),spos(j)-spos(j-1),j,jp,dsl(j)\n!!$  end do\n!\n7003 format(4(1x,d14.6),i4)\n7004 format(4(1x,d14.6),2i4,d14.6)\n!\n  deallocate(bco0,rco0,zco0,pco0,spos0)\n!\n  return\n!\n\n  END SUBROUTINE setfld\n\n\n\n!\n!\n!********************************************************************************\nSUBROUTINE val_intp(jpl,dsl,c0,c1,c2,c3,kmsh1,nsd,cval)\n!********************************************************************************\n  IMPLICIT REAL(KIND=8) (A-H,O-Z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n  integer(kind=4) :: kmsh1,nsd,jpl(kmsh1)\n  real(kind=8), dimension(nsd) :: c0,c1,c2,c3\n  real(kind=8), dimension(kmsh1) ::dsl,cval\n! ----------------------------------------------------------------------------- !\n!\n  do j=1,kmsh1\n    jp=jpl(j)\n    ds=dsl(j)\n    cval(j)=c0(jp)+(c1(jp) +(c2(jp) +c3(jp)*ds)*ds)*ds\n  end do\n\n  return\n\nEND SUBROUTINE val_intp\n\n\n!\n!********************************************************************************\nSUBROUTINE  spline_fit2(X,Y,DY,N,C,D,E)\n!********************************************************************************\n  IMPLICIT REAL(KIND=8) (A-H,O-Z)\n\n  implicit integer (i-n) ! by THW Dec 22, 2011\n\n  real(kind=8) ::  X(N),Y(N),DY(2),C(N),D(N),E(N)\n! ----------------------------------------------------------------------------- !\n!\n  N1 = N - 1\n!!! dy/dx on edges are specified by dy\n!\n  d(1)=6.0d0*((y(2)-y(1))/(x(2)-x(1))-dy(1))\n  d(n)=6.0d0*(dy(2)-(y(n)-y(n1))/(x(n)-x(n1)))\n  c(1)=2.0d0*(x(2)-x(1)) !u(1,1)!\n  do i=2,n1\n    d(i)=6.0d0*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))\n  end do\n!\n  do i=1,n-2\n    e(i)=(x(i+1)-x(i))/c(i)   !l(i+1,i)!\n    c(i+1)=2.0d0*(x(i+2)-x(i))-e(i)*(x(i+1)-x(i))   !u(i+1,i+1)!\n  end do\n  e(n1)=(x(n)-x(n1))/c(n1)\n  c(n)=2.0d0*(x(n)-x(n1))-e(n1)*(x(n)-x(n1))   \n!\n  do i=2,n\n    d(i)=d(i)-e(i-1)*d(i-1)\n  end do\n!\n  d(n)=d(n)/c(n)\n  do i=n-1,1,-1\n    d(i)=(d(i)-(x(i+1)-x(i))*d(i+1))/c(i)\n  end do\n!\n  do i=1,n1\n    xh=(x(i+1)-x(i))\n    c(i)=(y(i+1)-y(i))/xh-xh*(2.0d0*d(i)+d(i+1))/6.0d0\n    e(i)=(d(i+1)-d(i))/6.0d0/xh\n    d(i)=0.5d0*d(i)\n  end do\n  xh=(x(n)-x(n1))\n  c(n)=(y(n)-y(n1))/xh+xh*(2.0d0*d(n)+d(n1))/6.0d0\n  e(n)=(d(n)-d(n1))/6.0d0/xh\n  d(n)=0.5d0*d(n)\n!\n  return\n\nEND SUBROUTINE spline_fit2\n\n\n\n!\n!********************************************************************************\n", "SUBROUTINE fit_x3(x,y,icon,dy,fu)\n!-------------------------------------------\n  implicit real(kind=8) (a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n  real(kind=8) :: x(4),y(4),fu(0:3)\n  integer(kind=4) :: icon\n! -----------------------------------------------------------------------------!\n!\n! evaluate dy/dx on x=x(1) (icon==1) or x=x(4) (icon/=1)\n!\n  x1=x(1)\n  x2=x(2)\n  x3=x(3)\n  x4=x(4)\n  y1=y(1)\n  y2=y(2)\n  y3=y(3)\n  y4=y(4)\n!\n  a=y4/(x4-x1)/(x4-x2)/(x4-x3)\n  b=y1/(x1-x2)/(x1-x3)/(x1-x4)\n  c=y2/(x2-x3)/(x2-x4)/(x2-x1)\n  d=y3/(x3-x4)/(x3-x1)/(x3-x2)\n!\n  if(icon==1) then     ! factor at x=x1\n    dy=a*(x1-x2)*(x1-x3)+c*(x1-x3)*(x1-x4)+d*(x1-x4)*(x1-x2)\n    dy=dy+y1*(1.0d0/(x1-x2)+1.0d0/(x1-x3)+1.0d0/(x1-x4))\n    fu(0)=y1\n    fu(1)=dy\n    fu(2)=a*(2.0d0*x1-x2-x3)+b*(3.0d0*x1-x2-x3-x4)+c*(2.0d0*x1-x3-x4)+d*(2.0d0*x1-x4-x2)\n    fu(3)=a+b+c+d\n  else                 ! factor at x=x4\n    dy=b*(x4-x2)*(x4-x3)+c*(x4-x3)*(x4-x1)+d*(x4-x1)*(x4-x2)\n    dy=dy+y4*(1.0d0/(x4-x1)+1.0d0/(x4-x2)+1.0d0/(x4-x3))\n    fu(0)=y4\n    fu(1)=dy\n    fu(2)=a*(3.0d0*x4-x1-x2-x3)+b*(2.0d0*x4-x2-x3)+c*(2.0d0*x4-x3-x1)+d*(2.0d0*x4-x1-x2)\n    fu(3)=a+b+c+d\n  end if\n!... Here, fu(i) is the coefficient if y(x) is written in the forrowings\n!    y(x)=fu(0)+fu(1)(x-xa)+fu(2)(x-xa)**2+fu(3)(x-xa)**3 where xa= x1 or x4.\n\n  return\n\nEND SUBROUTINE fit_x3\n\n\n\n!\n!********************************************************************************\nSUBROUTINE ntfunc0(xx,te,ti,dni)\n! +---------------------------------------------------------------------------+\n! |  xx = sqrt (psib/psia) : label of flux surface, psib = toroidal flux      |\n! |  answer ion temp ti, electron temp. te, and ion density dni               |\n! |         as functions of xx.                                               |\n! |                                                                           |\n! |   == satake's way ==                                                      |\n! +---------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n! -----------------------------------------------------------------------------!\n!\n  dni=dn0(0)*(dn0(1)+dn0(2)*dexp(-dn0(3)*xx**dn0(4)))\n  ti =ti0(0)*(ti0(1)+ti0(2)*dexp(-ti0(3)*xx**ti0(4)))\n  te =te0(0)*(te0(1)+te0(2)*dexp(-te0(3)*xx**te0(4)))\n!\n  return\n\nEND SUBROUTINE ntfunc0\n\n\n\n!\n!********************************************************************************\nSUBROUTINE ntfunc1(xx,te,ti,dni)\n! +---------------------------------------------------------------------------+\n! |   == GSRAKE input type ==                                                 |\n! +---------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n! -----------------------------------------------------------------------------!\n!\n  te =0.0d0\n  ti =0.0d0\n  dni=0.0d0\n  do i=10,1,-1\n    dni=(dni+dn0(i))*xx\n    ti =(ti +ti0(i))*xx\n    te =(te +te0(i))*xx\n  end do\n!\n  dni=dni+dn0(0)\n  ti =ti +ti0(0)\n  te =te +te0(0)\n!\n  return\n\nEND SUBROUTINE ntfunc1\n\n\n\n!\n!********************************************************************************\nSUBROUTINE ntfunc2(xx,te,ti,dni)\n! +---------------------------------------------------------------------------+\n! |   ==??? input type ==                                                    |\n! +---------------------------------------------------------------------------+\n!********************************************************************************\n  implicit real(KIND=8)(a-h,o-z)\n\n  implicit integer (i-n)! by THW Dec 22, 2011\n\n  integer, parameter :: n=10\n! -----------------------------------------------------------------------------!\n!\n  dni=dn0(0)*exp(-dn0(2)*tanh((xx-dn0(3))/dn0(1)))\n  ti =ti0(0)*exp(-ti0(2)*tanh((xx-ti0(3))/ti0(1)))\n  te =te0(0)*exp(-te0(2)*tanh((xx-te0(3))/te0(1)))\n!\n  return\n\nEND SUBROUTINE ntfunc2\n\n\nEND MODULE GKV_vmecin\n", "MODULE GKV_bndry\n!-------------------------------------------------------------------------------\n!\n!    Some useful tools and tips\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   bndry_zvm_bound_f, bndry_bound_e,  &\n      bndry_bound_f_buffin, bndry_bound_f_sendrecv, bndry_bound_f_buffout,  &\n      bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout,  &\n      bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout, &\n      bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n      bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout, &\n      bndry_vm_sendrecv_v2, bndry_zv_buffin_v2, bndry_zv_sendrecv_v2, bndry_zv_buffout_v2\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zvm_bound_f( ff )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n    integer :: im\n\n      allocate( zb1_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n\n!$OMP parallel default (none) &\n!$OMP shared(ff,zb1_bottom,zb1_top,zb2_bottom,zb2_top,vb1,vb2,mb1,mb2) &\n!$OMP private(im)\n      do im = 0, nm\n        call bndry_bound_f_buffin ( ff(:,:,:,:,im), zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_bound_f_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                      zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_bound_f_buffout ( zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      do im = 0, nm\n        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!$OMP barrier\n!$OMP master\n      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!$OMP end master\n!$OMP barrier\n      call bndry_shifts_m_buffout ( mb2, ff )\n!$OMP end parallel\n\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n      deallocate( vb1 )\n      deallocate( vb2 )\n      deallocate( mb1 )\n      deallocate( mb2 )\n\n  END SUBROUTINE bndry_zvm_bound_f\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffin( ff, zb1_bottom, zb1_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                zb1_bottom(mx,my,iz,iv) = ff(mx,my,-nz+iz  ,iv)\n                zb1_top   (mx,my,iz,iv) = ff(mx,my, nz-nzb+iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_bound_f_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffout ( zb2_bottom, zb2_top, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffout\n\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_buffin( ff, vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1, vb2\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1361)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1361,1)\n!$OMP end master\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do iv = 1, 2*nvb\n!$OMP do schedule (dynamic)\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                vb1(mx,my,iz,iv    ) = ff(mx,my,iz,         iv)\n                vb1(mx,my,iz,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv)\n!              vb1(mx,my,iz,1) = ff(mx,my,iz,     1)\n!              vb1(mx,my,iz,2) = ff(mx,my,iz,     2)\n!              vb1(mx,my,iz,3) = ff(mx,my,iz,     3)\n!              vb1(mx,my,iz,4) = ff(mx,my,iz,2*nv-2)\n!              vb1(mx,my,iz,5) = ff(mx,my,iz,2*nv-1)\n!              vb1(mx,my,iz,6) = ff(mx,my,iz,2*nv  )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1361,1)\n                                           call clock_end(1361)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_sendrecv( vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    integer  ::  slngv\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1362)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1362,1)\n!      call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n!                         vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n!                         vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1362,1)\n                                           call clock_end(1362)\n\n\n  END SUBROUTINE bndry_shifts_v_sendrecv\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_shifts_v_buffout( vb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1363)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1363,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                ff(mx,my,iz,-nvb+iv) = vb2(mx,my,iz,iv    )\n                ff(mx,my,iz,2*nv+iv) = vb2(mx,my,iz,iv+nvb)\n!              ff(mx,my,iz,    -2) = vb2(mx,my,iz,1)\n!              ff(mx,my,iz,    -1) = vb2(mx,my,iz,2)\n!              ff(mx,my,iz,     0) = vb2(mx,my,iz,3)\n!              ff(mx,my,iz,2*nv+1) = vb2(mx,my,iz,4)\n!              ff(mx,my,iz,2*nv+2) = vb2(mx,my,iz,5)\n!              ff(mx,my,iz,2*nv+3) = vb2(mx,my,iz,6)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1363,1)\n                                           call clock_end(1363)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffin( ff, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1, mb2\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do im = 1, 2*nvb\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mb2(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                mb1(mx,my,iz,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n                mb1(mx,my,iz,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n!              mb1(mx,my,iz,iv,1) = ff(mx,my,iz,iv,   0)\n!              mb1(mx,my,iz,iv,2) = ff(mx,my,iz,iv,   1)\n!              mb1(mx,my,iz,iv,3) = ff(mx,my,iz,iv,   2)\n!              mb1(mx,my,iz,iv,4) = ff(mx,my,iz,iv,nm-2)\n!              mb1(mx,my,iz,iv,5) = ff(mx,my,iz,iv,nm-1)\n!              mb1(mx,my,iz,iv,6) = ff(mx,my,iz,iv,nm  )\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_sendrecv( mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    integer  ::  slngm\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngm = (2*nx+1)*(ny+1)*(2*nz)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n!                         mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n!                         mb2(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n\n  END SUBROUTINE bndry_shifts_m_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffout( mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iz,iv,im+nvb)\n!              ff(mx,my,iz,iv,  -3) = mb2(mx,my,iz,iv,1)\n!              ff(mx,my,iz,iv,  -2) = mb2(mx,my,iz,iv,2)\n!              ff(mx,my,iz,iv,  -1) = mb2(mx,my,iz,iv,3)\n!              ff(mx,my,iz,iv,nm+1) = mb2(mx,my,iz,iv,4)\n!              ff(mx,my,iz,iv,nm+2) = mb2(mx,my,iz,iv,5)\n!              ff(mx,my,iz,iv,nm+3) = mb2(mx,my,iz,iv,6)\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_e ( ew )\n!--------------------------------------\n!  Impose the modified periodic boundary condition \n!    in the z-direction for the electric field\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)   :: ew\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb1e_bottom, zb1e_top\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb2e_bottom, zb2e_top\n    integer  ::  mx, my, iz, im, mwn, mwp\n    integer  ::  slngze\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      allocate( zb1e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb1e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n\n      slngze  = (2*nx+1)*(ny+1)*(nm+1) * nzb\n\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP private(mx,my,iz,im)\n!$OMP master\n                                           call clock_sta(1381)\n                                         ! call fapp_start(\"literm_bounde_bufferin\",1381,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2e_bottom(mx,my,iz,im) = ( 0._DP, 0._DP )\n              zb2e_top   (mx,my,iz,im) = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb1e_bottom(mx,my,iz,im) = ew(mx,my,-nz+iz  ,im)\n              zb1e_top   (mx,my,iz,im) = ew(mx,my, nz-nzb+iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferin\",1381,1)\n                                           call clock_end(1381)\n!$OMP end master\n!$OMP end parallel\n\n                                           call clock_sta(1382)\n                                         ! call fapp_start(\"literm_bounde_sendrecv\",1382,1)\n!      call MPI_sendrecv( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_bounde_sendrecv\",1382,1)\n                                           call clock_end(1382)\n\n! --- substitution\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP shared(rankz,z_bound,ck,dj) &\n!$OMP private(mx,my,iz,im,mwp,mwn)\n!$OMP master\n                                           call clock_sta(1383)\n                                         ! call fapp_start(\"literm_bounde_bufferout\",1383,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,-nz-nzb+iz,im) = zb2e_bottom(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-1,im)   =   ew(mx,my,-nz  ,im)\n                    ew(mx,my,-nz-2,im)   = - ew(mx,my,-nz+1,im) + 2._DP * ew(mx,my,-nz  ,im)\n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-nzb+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,nz+iz,im) = zb2e_top(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz  ,im)   =   ew(mx,my,nz-1,im)\n                    ew(mx,my,nz+1,im)   = - ew(mx,my,nz-2,im) + 2._DP * ew(mx,my,nz-1,im) \n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferout\",1383,1)\n                                           call clock_end(1383)\n!$OMP end master\n!$OMP end parallel\n\n      deallocate( zb1e_bottom )\n      deallocate( zb1e_top )\n      deallocate( zb2e_bottom )\n      deallocate( zb2e_top )\n\n\n  END SUBROUTINE bndry_bound_e\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_zv_buffin( ff, zb1_bottom, zb1_top, vb1 )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n\n    integer :: iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            zb1_bottom(:,:,iz,iv) = ff(:,:,-nz+iz  ,iv)\n            zb1_top   (:,:,iz,iv) = ff(:,:, nz-nzb+iz,iv)\n          end do\n        end do\n!$OMP end do nowait\n\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!!$OMP do schedule(dynamic)\n!          do iz = -nz, nz-1\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!          end do\n!!$OMP end do nowait\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            vb1(:,:,iz,iv    ) = ff(:,:,iz,         iv)\n            vb1(:,:,iz,iv+nvb) = ff(:,:,iz,2*nv-nvb+iv)\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top, vb1, vb2 )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n\n    integer :: slngz, slngv\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n     !call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n     !                   zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n     !                   zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n     !                   vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n     !                   vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_zv_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_buffout ( zb2_bottom, zb2_top, vb2, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer :: mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,-nz-nzb+iz,iv) = zb2_bottom(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,nz+iz,iv) = zb2_top(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n\n        if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = (0._DP, 0._DP)\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = (0._DP, 0._DP)\n            end do\n          end do\n!$OMP end do nowait\n        else\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffin( iz, ff, vb1, mb1 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    integer :: mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!        do im = 0, nm\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,im,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im)\n                vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do im = 1, 2*nvb\n!        do iv = 1, 2*nv\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                mb2(mx,my,iv,im) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffin\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_vm_sendrecv ( vb1, vb2, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n\n    integer :: slngv, slngm\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(nm+1) * nvb\n      slngm = (2*nx+1)*(ny+1)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n     !call MPI_sendrecv( vb1(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n     !                   vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n     !                   vb2(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n     !                   mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n     !                   mb2(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n  END SUBROUTINE bndry_vm_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffout ( iz, vb2, mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iv, im\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = (0._DP, 0._DP)\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = (0._DP, 0._DP)\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_sendrecv_v2 ( vb1, vb2, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n!mae> modify\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb,0:nm) :: vb1\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb,0:nm) :: vb2\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb,0:nm) :: mb1\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb,0:nm) :: mb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n!<\n\n    integer :: slngv, slngm\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(2*nz)*(nm+1) * nvb\n      slngm = (2*nx+1)*(ny+1)*(2*nz)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n     !call MPI_sendrecv( vb1(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n     !                   vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n     !                   vb2(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n     !                   mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n     !                   mb2(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n  END SUBROUTINE bndry_vm_sendrecv_v2\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_buffin_v2( ff, zb1_bottom, zb1_top, vb1 )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n\n    integer :: iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            zb1_bottom(:,:,iz,iv,im) = ff(:,:,-nz+iz    ,iv,im)\n            zb1_top   (:,:,iz,iv,im) = ff(:,:, nz-nzb+iz,iv,im)\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!!$OMP do schedule(dynamic)\n!          do iz = -nz, nz-1\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!          end do\n!!$OMP end do nowait\n!      end do\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n        do im = 0, nm\n          do iz = -nz, nz-1\n            vb1(:,:,iz,im,iv    ) = ff(:,:,iz,         iv,im)\n            vb1(:,:,iz,im,iv+nvb) = ff(:,:,iz,2*nv-nvb+iv,im)\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffin_v2\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_sendrecv_v2 ( zb1_bottom, zb1_top, zb2_bottom, zb2_top, vb1, vb2 )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &     \n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n\n    integer :: slngz, slngv\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngz = (2*nx+1)*(ny+1)*(2*nv)*(nm+1) * nzb\n      slngv = (2*nx+1)*(ny+1)*(2*nz)*(nm+1) * nvb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n     !call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n     !                   zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n     !                   zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n     !                   vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n     !                   vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_zv_sendrecv_v2\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_zv_buffout_v2 ( zb2_bottom, zb2_top, vb2, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iz, iv, im, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                        ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,-nz-nzb+iz,iv,im) = zb2_bottom(:,:,iz,iv,im)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n      else ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\".OR. trim(z_bound) == \"mixed\") then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv,im) = ( 0._DP, 0._DP )\n                      end do\n                    else                      ! outflow\n                      ff(mx,my,-nz-1,iv,im) =   ff(mx,my,-nz ,iv,im)\n                      ff(mx,my,-nz-2,iv,im) = - ff(mx,my,-nz+1,iv,im) + 2._DP * ff(mx,my,-nz ,iv,im)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv,im) = ck(my) * zb2_bottom(mwn,my,iz,iv,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv,im) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv,im) = ck(my) * zb2_bottom(mwn,my,iz,iv,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,nz+iz,iv,im) = zb2_top(:,:,iz,iv,im)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n      else! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\".OR. trim(z_bound) == \"mixed\") then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then! outflow\n                      ff(mx,my,nz ,iv,im) =   ff(mx,my,nz-1,iv,im)\n                      ff(mx,my,nz+1,iv,im) = - ff(mx,my,nz-2,iv,im) + 2._DP * ff(mx,my,nz-1,iv,im)\n                    else                      ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv,im) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv,im) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv,im) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv,im) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n\n        if ( rankv == 0 ) then\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n          do im = 0, nm\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv,im) = (0._DP, 0._DP)\n              ff(:,:,iz,2*nv+iv,im) = vb2(:,:,iz,im,iv+nvb)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n        else if ( rankv == nprocv-1 ) then\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n          do im = 0, nm\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv,im) = vb2(:,:,iz,im,iv    )\n              ff(:,:,iz,2*nv+iv,im) = (0._DP, 0._DP)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n        else\n!!TBI!!!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n          do im = 0, nm\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv,im) = vb2(:,:,iz,im,iv    )\n              ff(:,:,iz,2*nv+iv,im) = vb2(:,:,iz,im,iv+nvb)\n            end do\n          end do\n          end do\n!!TBI!!!$OMP end do nowait\n        end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffout_v2\n\n\nEND MODULE GKV_bndry\n", "MODULE GKV_out\n!-------------------------------------------------------------------------------\n!\n!    Data writing\n!\n!    Update history of gkvp_out.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Use fileio module to switch Fortran/NetCDF binary output.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Frequency analysis is applied only when calc_type=\"lin_freq\".\n!        - menegy=0 when beta=0.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_intgrl, only: intgrl_thet, intgrl_fsrf, &\n                        intgrl_v0_moment, intgrl_v2_moment\n  use GKV_fld, only: fld_emfield_hh\n  use GKV_trans, only: trans_sum, trans_triad\n  use GKV_freq, only: freq_write_frq, freq_write_dsp\n  use GKV_advnc, only: caldlt_rev\n  use GKV_colliimp, only: colliimp_colli\n  use GKV_dtc,   only: flag_time_advnc, flag_time_split\n  use GKV_tips,  only: tips_flush, tips_rescale_for_linear_runs\n  !fj start 202010\n  use GKV_fileio\n  !fj end 202010\n\n  implicit none\n\n  private\n\n  public   out_cntrl, out_contnu\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE out_cntrl( ff, phi, Al, hh, time, id )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    real(kind=DP), intent(in) :: time\n    integer, intent(in) :: id\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dh, cf, ef\n    real(kind=DP), save :: tout_fxv, tout_ptn, tout_eng\n    integer :: flag_updated\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      flag_updated = 0\n\n      if( id == 0 ) then\n\n        if ( time == 0._DP ) then\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 0 )\n          call wrt ( ff, phi, Al, dh, cf, time, 1 )\n          call wrt ( ff, phi, Al, dh, cf, time, 2 )\n        end if\n\n        tout_fxv  = ( int( ( time + eps )/dtout_fxv ) + 1 ) * dtout_fxv\n        tout_ptn  = ( int( ( time + eps )/dtout_ptn ) + 1 ) * dtout_ptn\n        tout_eng  = ( int( ( time + eps )/dtout_eng ) + 1 ) * dtout_eng\n \n      else if( id == 1 ) then\n\n        if ( time >= tout_fxv - eps ) then\n          tout_fxv   = tout_fxv + dtout_fxv\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 0 )\n          write( olog, * ) \" # delta-f data output at time = \", time\n        end if\n\n        if ( time >= tout_ptn - eps ) then\n          tout_ptn   = tout_ptn + dtout_ptn\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 1 )\n          write( olog, * ) \" # field data output at time = \", time\n        end if\n\n        if ( time >= tout_eng - eps ) then\n          tout_eng   = tout_eng + dtout_eng\n          if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n          call wrt ( ff, phi, Al, dh, cf, time, 2 )\n        end if\n\n      else if( id == 2 ) then\n\n        if (flag_updated == 0) call update_dh(ff, phi, al, hh, dh, cf, ef, flag_updated)\n        call out_contnu ( ff, time )\n        !- OUTPUT ascii data hst/*.dsp.* for linear runs\n        if ( trim(calc_type) == \"lin_freq\" ) then\n           call freq_write_dsp\n        end if\n\n      end if\n\n      if (flag_time_split == 0) then\n        if ( trim(calc_type) == \"linear\" .or. &\n             trim(calc_type) == \"lin_freq\" ) then\n          call tips_rescale_for_linear_runs(ff, phi, Al, hh, time)\n        end if\n      end if\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n\n  END SUBROUTINE out_cntrl\n\n\n!--------------------------------------\nSUBROUTINE update_dh( ff, phi, Al, hh, dh, cf, ef, flag_updated )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh, cf, ef\n    integer, intent(out) :: flag_updated\n\n    character(15) :: colliflag\n\n\n      if (flag_time_advnc == 1) then ! Operator split + implicit collision\n        if (flag_time_split == 1) then ! dt/2 integration for 2nd-order split\n          call colliimp_colli(0.5_DP*dt, ff, phi, al, hh)\n                                               !%%% For debug %%%\n                                               ! if (rankg==0) write(olog,*) &\n                                               !       \"half-step for output\"\n                                               !%%%%%%%%%%%%%%%%%\n        end if\n        flag_time_split = 0 ! flag_time_split==0 means you have physical quantities at time\n      end if\n\n      colliflag = \"collisional\"\n      call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n      flag_updated = 1\n\nEND SUBROUTINE update_dh\n\n\n!--------------------------------------\n  SUBROUTINE out_contnu ( ff, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    real(kind=DP), intent(in) :: time\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    integer ::mx, my, iz, iv, im\n\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n!$OMP parallel workshare\n      wf(:,:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      !fj start 202010\n      !rewind ocnt\n      !write( unit=ocnt ) time, wf\n      call fileio_write_cnt( wf, time )\n      !fj end time202010\n\n      deallocate( wf )\n\n\n  END SUBROUTINE out_contnu\n\n\n!--------------------------------------\n  SUBROUTINE wrt ( ff, phi, Al, dh, cf, time, id )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh, cf\n    real(kind=DP), intent(in) :: time\n    integer, intent(in) :: id\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: fout\n    real(kind=DP), dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy,          &\n                                             peint, pmint, neint, nmint, dcd, &\n                                             pflux_es, pflux_em, eflux_es, eflux_em\n    real(kind=DP), dimension(0:(ny+1)*nprocw-1) :: mode_y\n    real(kind=DP) :: totl\n    integer :: mx, my, iv, im\n\n\n      if( id == 0 ) then\n\n        allocate( fout(-nx:nx,0:ny,1:2*nv,0:nm) )\n\n        !- OUTPUT binary data fxv/*.fxv.* -\n!$OMP parallel workshare\n        fout(:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n!$OMP parallel do collapse(2) private(mx,my,iv,im)\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                fout(mx,my,iv,im) = ff(mx,my,-nz  ,iv,im)\n              end do\n            end do\n          end do\n        end do\n        !fj start 202010\n        !write( unit=ofxv ) time, fout\n        call fileio_write_fxv( fout, time )\n        !fj end 202010\n\n        deallocate( fout )\n\n      else if( id == 1 ) then\n\n        !- OUTPUT binary data phi/*.phi.* and phi/*.Al.*\n        !fj start 202011\n        !if ( ranks == 0 .AND. vel_rank == 0 ) then\n          !write( unit=ophi ) time, phi\n          !write( unit=oAl  ) time, Al\n        !end if\n        call fileio_write_phi( phi, time )\n        call fileio_write_Al ( Al,  time )\n        !fj end 202011\n\n        !- OUTPUT binary data phi/*.mom.*\n        call write_moments ( ff, time )\n\n        !- OUTPUT binary data phi/*.tri.*\n        if( trim(calc_type) == \"nonlinear\" ) then\n          if ( num_triad_diag > 0 ) then\n            call trans_triad ( time, ff, phi, Al )\n          end if\n        end if\n\n      else if( id == 2 ) then\n\n        !- OUTPUT ascii data hst/*.bln.*\n        call balance ( ff, phi, Al, dh, cf, time,                          &\n                       entrpy, fenegy, menegy, peint, pmint, neint, nmint, &\n                       dcd, pflux_es, pflux_em, eflux_es, eflux_em )\n\n        !- OUTPUT binary data phi/*.trn.*\n        !fj start 202011\n        !if ( zsp_rank == 0 .and. vel_rank == 0 ) then\n          !write( unit=otrn ) time, entrpy, fenegy, menegy,    &\n          !                   peint, pmint, neint, nmint, dcd, &\n          !                   pflux_es, pflux_em, eflux_es, eflux_em\n        !end if\n        call fileio_write_trn( entrpy, fenegy, menegy,    &\n             peint, pmint, neint, nmint, dcd, &\n             pflux_es, pflux_em, eflux_es, eflux_em, time )\n        !fj end 202011\n\n        !- OUTPUT ascii data hst/*.eng.*, *.men.*, *.wes.*, *.wem.*,\n        !                        *.ges.*, *.gem.*, *.qes.*, *.qem.*\n        call mode_energy ( phi, totl, mode_y )\n        if( rankg == 0 ) then\n          write( unit=oeng, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call mode_energy ( Al, totl, mode_y )\n        if ( rankg == 0 ) then\n          write( unit=omen, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( fenegy, totl, mode_y )\n        if ( rankg == 0 ) then\n          write( unit=owes, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( menegy, totl, mode_y )\n        if ( rankg == 0 ) then\n          write( unit=owem, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( pflux_es, totl, mode_y )\n        if ( rank == 0 ) then\n          write( unit=oges, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( pflux_em, totl, mode_y )\n        if ( rank == 0 ) then\n          write( unit=ogem, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        call calc_kyspectrum ( eflux_es, totl, mode_y )\n        if ( rank == 0 ) then\n          write( unit=oqes, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n        call calc_kyspectrum ( eflux_em, totl, mode_y )\n\n        if ( rank == 0 ) then\n          write( unit=oqem, fmt=\"(f15.8, SP, 9999ES24.15e3)\" ) &\n                               time, totl, mode_y(0:global_ny)\n        end if\n\n        !- OUTPUT ascii data hst/*.frq.* for linear runs\n        if ( trim(calc_type) == \"lin_freq\" ) then\n          call freq_write_frq ( time, phi )\n        end if\n\n      end if\n\n\n  END SUBROUTINE wrt\n\n\n!--------------------------------------\n  SUBROUTINE mode_energy ( phi, totl, mode_y )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    real(kind=DP), intent(out), &\n      dimension(0:(ny+1)*nprocw-1)    :: mode_y\n    real(kind=DP), intent(out)        :: totl\n\n    real(kind=DP), dimension(:,:,:), allocatable :: wr3\n    real(kind=DP), dimension(-nx:nx,0:ny)        :: wr2\n    real(kind=DP), dimension(0:ny)               :: mode_wk\n    integer  ::  mx, my, iz\n\n      allocate( wr3(-nx:nx,0:ny,-nz:nz-1) )\n\n      totl    = 0._DP\n      mode_y  = 0._DP\n      mode_wk = 0._DP\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            wr3(mx,my,iz) = real( phi(mx,my,iz) * conjg( phi(mx,my,iz) )  &\n                                 , kind=DP )\n          end do\n        end do\n      end do\n\n      call intgrl_thet ( wr3, wr2 )\n\n!$OMP parallel do reduction(+:mode_wk)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          mode_wk(my) = mode_wk(my) + wr2(mx,my)\n        end do\n      end do\n\n      if( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            mode_wk(my) = mode_wk(my) + wr2(mx,my)\n          end do\n      endif\n\n      call MPI_Gather( mode_wk, ny+1, MPI_DOUBLE_PRECISION, &\n                       mode_y,  ny+1, MPI_DOUBLE_PRECISION, &\n                       0, fft_comm_world, ierr_mpi )\n\n      do my = 0, global_ny\n        totl = totl + mode_y(my)\n      end do\n\n      deallocate( wr3 )\n\n  END SUBROUTINE mode_energy\n\n\n!--------------------------------------\n  SUBROUTINE calc_kyspectrum ( fenegy, totl, mode_y )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny)          :: fenegy\n    real(kind=DP), intent(out), &\n      dimension(0:(ny+1)*nprocw-1)    :: mode_y\n    real(kind=DP), intent(out)        :: totl\n\n    real(kind=DP), dimension(0:ny) :: mode_wk\n    integer :: mx, my\n\n\n      totl    = 0._DP\n      mode_y  = 0._DP\n      mode_wk = 0._DP\n\n!$OMP parallel do reduction(+:mode_wk)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          mode_wk(my) = mode_wk(my) + fenegy(mx,my)\n        end do\n      end do\n\n      if( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            mode_wk(my) = mode_wk(my) + fenegy(mx,my)\n          end do\n      endif\n\n      call MPI_Gather( mode_wk, ny+1, MPI_DOUBLE_PRECISION, &\n                       mode_y,  ny+1, MPI_DOUBLE_PRECISION, &\n                       0, fft_comm_world, ierr_mpi )\n\n      mode_y(:) = 2._DP * mode_y(:)\n      do my = 0, global_ny\n        totl = totl + mode_y(my)\n      end do\n\n\n  END SUBROUTINE calc_kyspectrum\n\n\n!--------------------------------------\n  ", "SUBROUTINE balance ( ff, phi, Al, dh, cf, time,                    &\n                       entrpy, fenegy, menegy, peint, pmint, neint, nmint, &\n                       dcd, pflux_es, pflux_em, eflux_es, eflux_em )\n!--------------------------------------\n!     Check the entropy balance equation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh, cf\n    real(kind=DP), intent(in) :: time\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy, peint, pmint, neint, nmint, dcd, &\n                                pflux_es, pflux_em, eflux_es, eflux_em\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: dens, upara, pres, qpara, ni, wc3\n    complex(kind=DP), dimension(-nx:nx,0:ny)            :: wc2\n    complex(kind=DP), dimension(-nx:nx)                 :: zf\n    real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1)      :: wr3\n    real(kind=DP) :: entrpy_nz, entrpy_zf, fenegy_nz, fenegy_zf, menegy_nz, menegy_zf, &\n                     peint_nz, peint_zf, pmint_nz, pmint_zf, neint_nz, neint_zf, nmint_nz, nmint_zf, &\n                     dcd_nz, dcd_zf, dgp_es, dgp_em, dqp_es, dqp_em\n    real(kind=DP) :: entrpy_wk, fenegy_wk, menegy_wk, peint_wk, pmint_wk, neint_wk, nmint_wk, dcd_wk, dgp_wk, dqp_wk\n    integer :: mx, my, iz, iv, im\n\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate(  dens(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( upara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  pres(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( qpara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(    ni(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(   wc3(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel workshare\n      wc3(:,:,:) = ( 0._DP, 0._DP )\n      wr3(:,:,:) =   0._DP\n      wc2(:,:)   = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, dens )\n      call intgrl_v2_moment( wf, pres )\n     \n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = vl(iv) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, upara )\n      call intgrl_v2_moment( wf, qpara )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n             dens(mx,my,iz) = fcs(ranks) / Znum(ranks) * dens(mx,my,iz)\n            upara(mx,my,iz) = fcs(ranks) / Znum(ranks)  &\n                            * sqrt( tau(ranks) / Anum(ranks) ) * upara(mx,my,iz)\n             pres(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks) * pres(mx,my,iz)\n            qpara(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks)  &\n                            * sqrt( tau(ranks) / Anum(ranks) ) * qpara(mx,my,iz)\n          end do\n        end do\n      end do\n\n\n! --- \\begin{entropy_calculation}\n\n      entrpy(:,:) = 0._DP\n      entrpy_nz   = 0._DP\n      entrpy_zf   = 0._DP\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) =                                     &\n                        ff(mx,my,iz,iv,im) * conjg( ff(mx,my,iz,iv,im) ) &\n                        / fmx(iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          entrpy(mx,my) = 0.5_DP * fcs(ranks) * tau(ranks) / Znum(ranks) * real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n!$OMP parallel do reduction(+:entrpy_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          entrpy_nz = entrpy_nz + entrpy(mx,my)\n        end do\n      end do\n      entrpy_wk  =   0._DP\n      call MPI_Allreduce( entrpy_nz, entrpy_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      entrpy_nz = 2._DP * entrpy_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            entrpy_zf = entrpy_zf + entrpy(mx,my)\n          end do\n      endif\n      entrpy_zf = 2._DP * entrpy_zf\n\n! --- \\end{entropy_calculation}\n\n\n! --- \\begin{electric_energy_calculation}\n\n      fenegy_nz   = 0._DP\n      fenegy_zf   = 0._DP\n\n      if ( ns == 1 ) then    ! --- for ITG-ae, ETG-ai\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = 0.5_DP * real( phi(mx,my,iz) * conjg( phi(mx,my,iz) )  &\n                             , kind=DP ) * ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )\n            end do\n          end do\n        end do\n      else                   ! --- for multi-species\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = 0.5_DP * fct_e_energy(mx,my,iz)  &\n                            * real( phi(mx,my,iz) * conjg( phi(mx,my,iz) ), kind=DP )\n            end do\n          end do\n        end do\n      end if\n\n      call intgrl_thet ( wr3, fenegy )\n\n!$OMP parallel do reduction(+:fenegy_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          fenegy_nz   = fenegy_nz + fenegy(mx,my)\n        end do\n      end do\n      fenegy_wk  =   0._DP\n      call MPI_Allreduce( fenegy_nz, fenegy_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      fenegy_nz = 2._DP * fenegy_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            fenegy_zf = fenegy_zf + fenegy(mx,my)\n          end do\n      endif\n\n      if ( ns == 1 .and. sgn(0) > 0._DP ) then ! --- for ITG-ae\n\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n  \n        call intgrl_v0_moment( wf, ni )\n  \n        if( rankw == 0 )  then\n          do iz = -nz, nz-1\n            ni(0,0,iz) = ( 0._DP, 0._DP )\n          end do\n        endif\n  \n        zf = ( 0._DP, 0._DP )\n\n        if( rankw == 0 ) then\n\n          my   = 0\n!$OMP parallel do\n            do iz = -nz, nz-1\n              do mx = -nx, -1\n                wc3(mx,my,iz)   = ni(mx,my,iz)                                    &\n                                 / ( (  1._DP - g0(mx,my,iz) + tau(0)*tau_ad ) * fctgt(mx) )\n              end do\n              mx = 0\n                wc3(mx,my,iz) = (0._DP, 0._DP)\n              do mx = 1, nx\n                wc3(mx,my,iz)   = ni(mx,my,iz)                                    &\n                                 / ( (  1._DP - g0(mx,my,iz) + tau(0)*tau_ad ) * fctgt(mx) )\n              end do\n            end do\n  \n          call intgrl_fsrf ( wc3, zf )\n  \n          zf(0)   = ( 0._DP, 0._DP )\n\n          do mx = 0, nx\n            fenegy_zf   = fenegy_zf - 0.5_DP * real( zf(mx) * conjg( zf(mx) ), kind=DP) * tau(0)*tau_ad\n          end do\n\n        end if\n\n      end if\n      fenegy_zf = 2._DP * fenegy_zf\n\n! --- \\end{electric_energy_calculation}\n\n\n! --- \\begin{magnetic_energy_calculation}\n\n      menegy_nz   = 0._DP\n      menegy_zf   = 0._DP\n\n      if ( beta .ne. 0._DP ) then\n\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = 0.5_DP * fct_m_energy(mx,my,iz)  &\n                            * real( Al(mx,my,iz) * conjg( Al(mx,my,iz) ), kind=DP )\n            end do\n          end do\n        end do\n  \n        call intgrl_thet ( wr3, menegy )\n  \n!$OMP parallel do reduction(+:menegy_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            menegy_nz = menegy_nz + menegy(mx,my)\n          end do\n        end do\n        menegy_wk  =   0._DP\n        call MPI_Allreduce( menegy_nz, menegy_wk, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, fft_comm_world, ierr_mpi )\n        menegy_nz = 2._DP * menegy_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n            do mx = 0, nx\n              menegy_zf = menegy_zf + menegy(mx,my)\n            end do\n        endif\n        menegy_zf = 2._DP * menegy_zf\n\n      else\n        menegy(:,:) = 0._DP\n      end if\n\n! --- \\end{magnetic_energy_calculation}\n\n\n! --- \\begin{particle_field_interaction}\n\n      peint(:,:) = 0._DP\n      peint_nz   = 0._DP\n      peint_zf   = 0._DP\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment( wf, wc3 )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            wr3(mx,my,iz) = - real( conjg( phi(mx,my,iz) ) * wc3(mx,my,iz), kind=DP )\n          end do\n        end do\n      end do\n\n      call intgrl_thet ( wr3, peint )\n\n!$OMP parallel do reduction(+:peint_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          peint_nz = peint_nz + peint(mx,my)\n        end do\n      end do\n      peint_wk  =   0._DP\n      call MPI_Allreduce( peint_nz, peint_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      peint_nz = 2._DP * peint_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            peint_zf = peint_zf + peint(mx,my)\n          end do\n      endif\n      peint_zf = 2._DP * peint_zf\n\n\n      pmint(:,:) = 0._DP\n      pmint_nz   = 0._DP\n      pmint_zf   = 0._DP\n\n      ", "if ( beta.ne. 0._DP ) then\n\n        call fld_emfield_hh ( dh, wc3 )\n  \n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wr3(mx,my,iz) = - real( conjg( upara(mx,my,iz) )  &\n                    * sgn(ranks) * Znum(ranks) * wc3(mx,my,iz), kind=DP )\n            end do\n          end do\n        end do\n  \n        call intgrl_thet ( wr3, pmint )\n  \n!$OMP parallel do reduction(+:pmint_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            pmint_nz = pmint_nz + pmint(mx,my)\n          end do\n        end do\n        pmint_wk  =   0._DP\n        call MPI_Allreduce( pmint_nz, pmint_wk, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, fft_comm_world, ierr_mpi )\n        pmint_nz = 2._DP * pmint_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n            do mx = 0, nx\n              pmint_zf = pmint_zf + pmint(mx,my)\n            end do\n        endif\n        pmint_zf = 2._DP * pmint_zf\n\n      end if\n\n! --- \\begin{particle_field_interaction}\n\n\n! --- \\begin{nonlinear_interaction}\n\n      neint(:,:) = 0._DP\n      nmint(:,:) = 0._DP\n      neint_nz   = 0._DP\n      neint_zf   = 0._DP\n      nmint_nz   = 0._DP\n      nmint_zf   = 0._DP\n\n      if( trim(calc_type) == \"nonlinear\" ) then\n\n        call trans_sum ( ff, phi, Al, neint, nmint )\n\n!$OMP parallel do reduction(+:neint_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            neint_nz = neint_nz + neint(mx,my)\n          end do\n        end do\n        neint_wk = 0._DP\n        call MPI_Allreduce( neint_nz, neint_wk, 1, MPI_DOUBLE_PRECISION, &\n                              MPI_SUM, fft_comm_world, ierr_mpi )\n        neint_nz = 2._DP * neint_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n!$OMP parallel do reduction(+:neint_zf)\n            do mx = 0, nx\n              neint_zf = neint_zf + neint(mx,my)\n            end do\n        endif\n        neint_zf = 2._DP * neint_zf\n  \n!$OMP parallel do reduction(+:nmint_nz)\n        do my = ist1_y, iend_y\n          do mx = -nx, nx\n            nmint_nz = nmint_nz + nmint(mx,my)\n          end do\n        end do\n        nmint_wk = 0._DP\n        call MPI_Allreduce( nmint_nz, nmint_wk, 1, MPI_DOUBLE_PRECISION, &\n                              MPI_SUM, fft_comm_world, ierr_mpi )\n        nmint_nz = 2._DP * nmint_wk\n  \n        if( rankw == 0 )  then\n          my   = 0\n            do mx = 0, nx\n              nmint_zf = nmint_zf + nmint(mx,my)\n            end do\n        endif\n        nmint_zf = 2._DP * nmint_zf\n\n      end if\n\n! --- \\end{nonlinear_interaction}\n\n\n! --- \\begin{flux_calculation}\n\n      call calc_flux ( dens, phi, pflux_es )\n      dgp_es = 0._DP\n!$OMP parallel do reduction(+:dgp_es)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dgp_es = dgp_es + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_es(mx,my)\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dgp_es = dgp_es + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_es(mx,my)\n          end do\n      endif\n      dgp_wk = 0._DP\n      call MPI_Allreduce( dgp_es, dgp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dgp_es = 2._DP * dgp_wk\n\n      call calc_flux ( upara, -Al, pflux_em )\n      dgp_em = 0._DP\n!$OMP parallel do reduction(+:dgp_em)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dgp_em = dgp_em + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_em(mx,my)\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dgp_em = dgp_em + tau(ranks) * (R0_Ln(ranks) + R0_Lt(ranks)) * pflux_em(mx,my)\n          end do\n      endif\n      dgp_wk = 0._DP\n      call MPI_Allreduce( dgp_em, dgp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dgp_em = 2._DP * dgp_wk\n\n      call calc_flux ( pres, phi, eflux_es )\n      dqp_es = 0._DP\n!$OMP parallel do reduction(+:dqp_es)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dqp_es = dqp_es + R0_Lt(ranks) * ( eflux_es(mx,my) - 2.5_DP * tau(ranks) * pflux_es(mx,my) )\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dqp_es = dqp_es + R0_Lt(ranks) * ( eflux_es(mx,my) - 2.5_DP * tau(ranks) * pflux_es(mx,my) )\n          end do\n      endif\n      dqp_wk = 0._DP\n      call MPI_Allreduce( dqp_es, dqp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dqp_es = 2._DP * dqp_wk\n\n      call calc_flux ( qpara, -Al, eflux_em )\n      dqp_em = 0._DP\n!$OMP parallel do reduction(+:dqp_em)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dqp_em = dqp_em + R0_Lt(ranks) * ( eflux_em(mx,my) - 2.5_DP * tau(ranks) * pflux_em(mx,my) )\n        end do\n      end do\n      if( rankw == 0 )   then\n        my = 0\n          do mx = 0, nx\n            dqp_em = dqp_em + R0_Lt(ranks) * ( eflux_em(mx,my) - 2.5_DP * tau(ranks) * pflux_em(mx,my) )\n          end do\n      endif\n      dqp_wk = 0._DP\n      call MPI_Allreduce( dqp_em, dqp_wk, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, fft_comm_world, ierr_mpi )\n      dqp_em = 2._DP * dqp_wk\n\n! --- \\end{flux_calculation}\n\n\n! --- \\begin{collisionaldissipation_calculation}\n\n      dcd(:,:) = 0._DP\n      dcd_nz   = 0._DP\n      dcd_zf   = 0._DP\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im)   = fcs(ranks) / Znum(ranks) * cf(mx,my,iz,iv,im)  &\n                      * ( tau(ranks) * conjg( ff(mx,my,iz,iv,im) ) / fmx(iz,iv,im)    &\n                        + sgn(ranks) * Znum(ranks) * j0(mx,my,iz,im) * conjg( phi(mx,my,iz) ) )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment ( wf, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          dcd(mx,my) = real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n!$OMP parallel do reduction(+:dcd_nz)\n      do my = ist1_y, iend_y\n        do mx = -nx, nx\n          dcd_nz = dcd_nz + dcd(mx,my)\n        end do\n      end do\n      dcd_wk = 0._DP\n      call MPI_Allreduce( dcd_nz, dcd_wk, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, fft_comm_world, ierr_mpi )\n      dcd_nz = 2._DP * dcd_wk\n\n      if( rankw == 0 )  then\n        my   = 0\n          do mx = 0, nx\n            dcd_zf = dcd_zf + dcd(mx,my)\n          end do\n      endif\n      dcd_zf = 2._DP * dcd_zf\n\n! --- \\end{collisionaldissipation_calculation}\n\n\n      if ( rank == 0 ) then\n        write( unit=obln, fmt=\"(f15.8, SP, 256ES24.15e3)\" ) &\n             time,      &! [ 1] Time\n             entrpy_nz, &! [ 2] Entropy S_s (ky/=0)\n             entrpy_zf, &! [ 3] Entropy S_s (ky==0)\n             fenegy_nz, &! [ 4] Electrostatic field energy W_E (ky/=0)\n             fenegy_zf, &! [ 5] Electrostatic field energy W_E (ky/=0)\n             menegy_nz, &! [ 6] Magnetic field energy W_M (ky/=0)\n             menegy_zf, &! [ 7] Magnetic field energy W_M (ky/=0)\n             peint_nz,  &! [ 8] W_E to S_s interaction R_sE (ky/=0)\n             peint_zf,  &! [ 9] W_E to S_s interaction R_sE (ky==0)\n             pmint_nz,  &! [10] W_M to S_s interaction R_sM (ky/=0)\n             pmint_zf,  &! [11] W_M to S_s interaction R_sM (ky==0)\n             neint_nz,  &! [12] S_s(ky==0) to S_s(ky/=0) entropy transfer via ExB nonlinearity -I_sE^(z) (ky/=0)\n             neint_zf,  &! [13] S_s(ky/=0) to S_s(ky==0) entropy transfer via ExB nonlinearity  I_sE^(z) (ky==0)\n             nmint_nz,  &! [14] S_s(ky==0) to S_s(ky/=0) entropy transfer via magnetic nonlinearity -I_sM^(z) (ky/=0)\n             nmint_zf,  &! [15] S_s(ky==0) to S_s(ky/=0) entropy transfer via magnetic nonlinearity  I_sM^(z) (ky==0)\n             dcd_nz,    &! [16] Collisional dissipation D_s (ky/=0)\n             dcd_zf,    &! [17] Collisional dissipation D_s (ky==0)\n             dgp_es,    &! [18] Particle flux term by ExB flows T_s*G_sE/L_ps\n             dgp_em,    &! [19] Particle flux term by magnetic flutters T_s*G_sM/L_ps\n             dqp_es,    &! [20] Heat flux term by ExB flows Theta_sE/L_Ts\n             dqp_em      ! [21] Heat flux term by magnetic flutters Theta_sM/L_Ts\n      end if\n\n      deallocate( wf )\n      deallocate(  dens )\n      deallocate( upara )\n      deallocate(  pres )\n      deallocate( qpara )\n      deallocate(    ni )\n      deallocate(   wc3 )\n\n! --- divergence trap\n        if( trim(calc_type) == \"nonlinear\" ) then\n          if ( entrpy_nz > 1.d100 ) then \n            write(olog,*) \"DIVERGE!! at \", time, entrpy_nz\n            call tips_flush\n            call MPI_Abort(MPI_COMM_WORLD, ierr_mpi)\n            stop \"STOPPED at DIVERGENCE trap!\"\n          end if\n        end if\n! --- \n\n\n  END SUBROUTINE balance\n\n\n!--------------------------------------\n  SUBROUTINE calc_flux ( mom, phi, flux )\n!--------------------------------------\n!     Calculate turbulent flux\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: mom, phi\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny) :: flux\n\n    real(kind=DP), dimension(:,:,:), allocatable :: wr3\n    integer  ::  mx, my, iz\n\n      allocate( wr3(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            wr3(mx,my,iz) = real( - ui * ky(my) * phi(mx,my,iz)  &\n                                * conjg( mom(mx,my,iz) ), kind=DP )\n          end do\n        end do\n      end do\n\n      call intgrl_thet ( wr3, flux )\n\n      deallocate( wr3 )\n\n  END SUBROUTINE calc_flux\n\n\n!--------------------------------------\n  SUBROUTINE write_moments ( ff, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    real(kind=DP), intent(in) :: time\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: dens, upara, ppara, pperp, qlpara, qlperp\n    integer :: mx, my, iz, iv, im\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate(   dens(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  upara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  ppara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate(  pperp(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( qlpara(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( qlperp(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, dens )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = vl(iv) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, upara )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = 0.5_DP * vl(iv)**2 * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, ppara )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = mu(im) * omg(iz) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, pperp )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = 0.5_DP * vl(iv)**3 * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, qlpara )\n\n!$OMP parallel do collapse(2) private(mx,my,iz,iv,im)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = vl(iv) * mu(im) * omg(iz) * ff(mx,my,iz,iv,im) * j0(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      call intgrl_v0_moment( wf, qlperp )\n\n!$OMP parallel do\n      do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n              dens(mx,my,iz) = fcs(ranks) / Znum(ranks) * dens(mx,my,iz)\n             upara(mx,my,iz) = fcs(ranks) / Znum(ranks)  &\n                             * sqrt( tau(ranks) / Anum(ranks) ) * upara(mx,my,iz)\n             ppara(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks) * ppara(mx,my,iz)\n             pperp(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks) * pperp(mx,my,iz)\n            qlpara(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks)  &\n                             * sqrt( tau(ranks) / Anum(ranks) ) * qlpara(mx,my,iz)\n            qlperp(mx,my,iz) = fcs(ranks) / Znum(ranks) * tau(ranks)  &\n                             * sqrt( tau(ranks) / Anum(ranks) ) * qlperp(mx,my,iz)\n          end do\n        end do\n      end do\n\n     !fj start 202011\n     !if ( vel_rank == 0 ) then\n       !write( unit=omom ) time, dens, upara, ppara, pperp, qlpara, qlperp\n     !end if\n      call fileio_write_mom( dens, upara, ppara, &\n                             pperp, qlpara, qlperp, time )\n     !fj end 202011\n\n      deallocate( wf )\n      deallocate(   dens )\n      deallocate(  upara )\n      deallocate(  ppara )\n      deallocate(  pperp )\n      deallocate( qlpara )\n      deallocate( qlperp )\n\n  END SUBROUTINE write_moments\n\n\nEND MODULE GKV_out\n", "MODULE GKV_mpienv\n!-------------------------------------------------------------------------------\n!\n!    Header and settings for using MPI\n!\n!    Update history of gkvp_mpienv.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n!--------------------------------------\n!  Variables for MPI parallilization\n!--------------------------------------\n  use GKV_header\n  implicit none\n\n  public\n\n  include \"mpif.h\"\n\n  integer :: rankg, nproc\n  integer :: sizedouble_c, ierr_mpi\n  integer, dimension(MPI_STATUS_SIZE)  :: status\n\n!fj> add\n  integer :: rankw\n!fj<\n  integer :: rankz, rankv, rankm, ranks\n  integer :: izup, izdn, ivup, ivdn, imup, imdn\n\n  integer ::  sendzdn, sendzup, recvzdn, recvzup\n  integer ::  sendvdn, sendvup, recvvdn, recvvup\n  integer ::  sendmdn, sendmup, recvmdn, recvmup\n\n  integer ::  vel_comm_world, zsp_comm_world, vcolor, zcolor\n  integer ::  spc_comm_world, sub_comm_world, scolor\n  integer ::  col_comm_world, ccolor\n  integer ::  vel_rank, vel_nproc\n  integer ::  zsp_rank, zsp_nproc\n  integer ::  spc_rank, spc_nproc\n  integer ::  col_rank, col_nproc\n  integer ::      rank, sub_nproc\n!fj> add\n  integer ::  fft_comm_world, wcolor\n  integer ::  fft_rank, fft_nproc\n!fj<\n  \n  integer :: ornk \n\nCONTAINS\n\n!--------------------------------------\n!fj>\n!cc  SUBROUTINE mpienv_init( nprocz, nprocv, nprocm )\n  SUBROUTINE mpienv_init( nprocw, nprocz, nprocv, nprocm, nprocs )\n!fj<\n!--------------------------------------\n\n!fj>\n!cc  integer, intent(in) :: nprocz, nprocv, nprocm\n  integer, intent(in) :: nprocw, nprocz, nprocv, nprocm, nprocs\n!fj<\n\n  integer :: ny_size, nxw_sz, nwk\n\n\n!--- begin MPI settings\n\n    call MPI_Init ( ierr_mpi )\n\n    call MPI_Comm_rank ( MPI_COMM_WORLD, rankg, ierr_mpi )\n\n    call MPI_Comm_size ( MPI_COMM_WORLD, nproc, ierr_mpi )\n\n    call MPI_Type_size ( MPI_DOUBLE_COMPLEX, sizedouble_c, ierr_mpi )\n\n! --- for multispecies \n    ranks  = rankg / ( nprocz * nprocv * nprocm * nprocw ) \n\n    call MPI_Comm_split ( MPI_COMM_WORLD, ranks, rankg, sub_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( sub_comm_world, rank, ierr_mpi )\n    call MPI_Comm_size ( sub_comm_world, sub_nproc, ierr_mpi )\n\n! --- additional comunicator for integration over species\n    scolor  = mod(rankg, nprocz*nprocw)\n    call MPI_Comm_split ( MPI_COMM_WORLD, scolor, rankg, spc_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( spc_comm_world, spc_rank, ierr_mpi )\n    call MPI_Comm_size ( spc_comm_world, spc_nproc, ierr_mpi )\n\n\n! --- process allocation to domain\n!fj> mod\n!cc    rankz = mod( rank,          nprocz )\n!cc    rankv = mod( rank / nprocz, nprocv )\n!cc    rankm = rank / ( nprocz * nprocv )\n    rankw = mod( rank,                      nprocw )\n    rankz = mod( rank / nprocw,             nprocz )\n    rankv = mod( rank / ( nprocw * nprocz), nprocv )\n    rankm = rank / ( nprocw * nprocz * nprocv )\n\n\n                            ! rank of the targets\n!cc    izup  = rank + 1\n!cc    izdn  = rank - 1\n!cc    ivup  = rank + nprocz\n!cc    ivdn  = rank - nprocz\n!cc    imup  = rank + nprocz * nprocv\n!cc    imdn  = rank - nprocz * nprocv\n    izup  = rank + nprocw\n    izdn  = rank - nprocw\n    ivup  = rank + nprocw * nprocz\n    ivdn  = rank - nprocw * nprocz\n    imup  = rank + nprocw * nprocz * nprocv\n    imdn  = rank - nprocw * nprocz * nprocv\n\n!cc    if ( rankz == nprocz-1 ) izup  = rank - nprocz + 1\n!cc    if ( rankz == 0        ) izdn  = rank + nprocz - 1\n    if ( rankz == nprocz-1 ) izup  = rank - nprocw * (nprocz - 1)\n    if ( rankz == 0        ) izdn  = rank + nprocw * (nprocz - 1)\n!fj<\n    if ( rankv == nprocv-1 ) ivup  = MPI_PROC_NULL\n    if ( rankv == 0        ) ivdn  = MPI_PROC_NULL\n    if ( rankm == nprocm-1 ) imup  = MPI_PROC_NULL\n    if ( rankm == 0        ) imdn  = MPI_PROC_NULL\n\n! --- generating sub-worlds\n\n!fj> mod\n!cc    vcolor   = rankz\n!cc    zcolor   = rank / nprocz\n!cc\n!cc    call MPI_Comm_split ( sub_comm_world, vcolor, rank, vel_comm_world, ierr_mpi )\n!cc    call MPI_Comm_rank ( vel_comm_world, vel_rank, ierr_mpi )\n!cc    call MPI_Comm_size ( vel_comm_world, vel_nproc, ierr_mpi )\n!cc\n!cc    call MPI_Comm_split ( sub_comm_world, zcolor, rank, zsp_comm_world, ierr_mpi )\n!cc    call MPI_Comm_rank ( zsp_comm_world, zsp_rank, ierr_mpi )\n!cc    call MPI_Comm_size ( zsp_comm_world, zsp_nproc, ierr_mpi )\n!cc\n!cc\n!cc      if ( nproc /= nprocz * nprocv * nprocm ) then\n\n    wcolor   = rank / nprocw\n    zcolor   = ( rank / (nprocw*nprocz) ) * nprocw + rankw\n    vcolor   = rankz*nprocw  +  rankw\n\n    call MPI_Comm_split ( sub_comm_world, wcolor, rankw, fft_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( fft_comm_world, fft_rank, ierr_mpi )\n    call MPI_Comm_size ( fft_comm_world, fft_nproc, ierr_mpi )\n\n    call MPI_Comm_split ( sub_comm_world, zcolor, rankz, zsp_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( zsp_comm_world, zsp_rank, ierr_mpi )\n    call MPI_Comm_size ( zsp_comm_world, zsp_nproc, ierr_mpi )\n\n    call MPI_Comm_split ( sub_comm_world, vcolor, (rankv+nprocv*rankm), vel_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( vel_comm_world, vel_rank, ierr_mpi )\n    call MPI_Comm_size ( vel_comm_world, vel_nproc, ierr_mpi )\n\n! --- additional communicator for inter-species comm. for field particle part collision\n    if ( rank == scolor ) then\n      ccolor = mod(rankg, sub_nproc)\n    else\n      ccolor = 99  ! dummy color\n    end if\n\n    call MPI_Comm_split ( MPI_COMM_WORLD, ccolor, rankg, col_comm_world, ierr_mpi )\n    call MPI_Comm_rank ( col_comm_world, col_rank, ierr_mpi )\n    call MPI_Comm_size ( col_comm_world, col_nproc, ierr_mpi )\n\n    if ( vel_rank > 0 ) then \n      col_rank = MPI_PROC_NULL\n    end if\n! ---\n\n\n!cc    write( 6, * ) '##### Debug rank=',rank, &\n!cc          'wcolor,rankw=',wcolor,rankw,'zcolor, rankz=',zcolor, rankz, &\n!cc          'vcolor,(rankv+nprocv*rankm)=',vcolor,(rankv+nprocv*rankm)\n\n      if ( nproc /= nprocw * nprocz * nprocv * nprocm * nprocs ) then\n!fj<\n        write( 6, * ) &\n           \" # proccesor assigment is invalid, nproc = \", nproc\n        call MPI_Finalize ( ierr_mpi )\n        stop\n      end if\n\n!! --- for debug\n!      ornk = 1000+rankg\n!      write( ornk, \"(A25)\" ) \"# rank config., nproc = \", nproc\n!      write( ornk, \"(A3)\" ) \"#  \"\n!      write( ornk, \"(A3)\" ) \"#  \"\n!      write( ornk, \"(A9,I3)\" ) \"rankg\", rankg\n!      write( ornk, \"(A9,I3)\" ) \"ranks\", ranks\n!      write( ornk, \"(A9,I3)\" ) \"rank\", rank\n!      write( ornk, \"(A9,I3)\" ) \"rankw\", rankm\n!      write( ornk, \"(A9,I3)\" ) \"rankz\", rankz\n!      write( ornk, \"(A9,I3)\" ) \"rankv\", rankv\n!      write( ornk, \"(A9,I3)\" ) \"rankm\", rankm\n!      write( ornk, \"(A9,I3)\" ) \"vel_rank\", vel_rank\n!      write( ornk, \"(A9,I3)\" ) \"zsp_rank\", zsp_rank\n!      write( ornk, \"(A9,I3)\" ) \"spc_rank\", spc_rank\n!      write( ornk, \"(A9,I3)\" ) \"fft_rank\", fft_rank\n!      write( ornk, \"(A9,I3)\" ) \"col_rank\", col_rank\n!      write( ornk, \"(A9,I3)\" ) \"zcolor\", zcolor\n!      write( ornk, \"(A9,I3)\" ) \"vcolor\", vcolor\n!      write( ornk, \"(A9,I3)\" ) \"scolor\", scolor\n!      write( ornk, \"(A9,I3)\" ) \"ccolor\", ccolor\n\n\n! ---- set y range --------------------------\n    ny_size = global_ny + 1 \n    if( mod(ny_size,nprocw) == 0 )  then\n      nwk    = ny_size / nprocw\n    else\n      nwk    = ny_size / nprocw + 1\n    endif\n   !--- global index range ---------------- \n    ist_y_g  = nwk*rankw\n    iend_y_g = min( nwk*(rankw+1)-1, (ny_size-1) )\n    nsize_y  = iend_y_g - ist_y_g + 1\n   !--- local index range ---------------- \n    ist_y    = 0\n    iend_y   = iend_y_g - ist_y_g\n\n    if( rankw == 0 )   then\n       ist1_y    = 1\n    else \n       ist1_y    = 0\n    endif\n\n! ---- set xw range ---------------------\n    nxw_sz = 2*nxw\n    if( mod(nxw_sz,nprocw) == 0 )  then\n      nwk    = nxw_sz / nprocw\n    else\n      nwk    = nxw_sz / nprocw + 1\n    endif\n   !--- global index range ----------------\n    ist_xw_g  = nwk*rankw\n    iend_xw_g = min( nwk*(rankw+1)-1, (nxw_sz-1) )\n    nsize_xw  = iend_xw_g - ist_xw_g + 1\n   !--- local index range ----------------\n    ist_xw    = 0\n    iend_xw   = iend_xw_g - ist_xw_g\n\n\n  END SUBROUTINE mpienv_init\n\n\nEND MODULE GKV_mpienv\n", "MODULE GKV_tips\n!-------------------------------------------------------------------------------\n!\n!    Some useful tools and tips\n!\n!    Update history of gkvp_tips.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - flush for binary is removed, for the usage of NetCDF.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public   tips_reality, tips_flush, tips_rescale_for_linear_runs\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE tips_reality( wrk )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wrk\n\n    integer :: mx\n\n      if( rankw == 0 )  then\n        do mx = 0, nx\n          wrk(-mx,0,:,:,:) = conjg( wrk(mx,0,:,:,:) )\n        end do\n      endif\n\n\n  END SUBROUTINE tips_reality\n\n\n!--------------------------------------\n  SUBROUTINE tips_flush\n!--------------------------------------\n\n        call flush(olog)\n       !fj start 202010\n       !call flush(ocnt)\n       !call flush(ofxv)\n       !if ( vel_rank == 0 ) then\n       !  call flush(omom)\n       !end if\n       !if ( ranks == 0.AND. vel_rank == 0 ) then\n       !  call flush(ophi)\n       !  call flush(oAl)\n       !end if\n       !if ( zsp_rank == 0.AND. vel_rank == 0 ) then\n       !  call flush(otrn)\n       !end if\n       !fj end 202010\n        if( rankg == 0 ) then\n          call flush(odtc)\n          call flush(oeng)\n          call flush(omen)\n          call flush(owes)\n          call flush(owem)\n          if ( trim(calc_type) == \"lin_freq\" ) then\n            call flush(ofrq)\n          end if\n        end if\n        if( rank == 0 ) then\n          call flush(obln)\n          call flush(oges)\n          call flush(ogem)\n          call flush(oqes)\n          call flush(oqem)\n        end if\n\n  END SUBROUTINE tips_flush\n\n\n!--------------------------------------\n  SUBROUTINE tips_rescale_for_linear_runs(ff, phi, Al, hh, time)\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: rescale_max_num = 10\n    real(kind=DP) :: ff_max_l, ff_max, wr1\n    real(kind=DP), dimension(-nx:nx,0:ny) :: phi_max_l, phi_max, scale_factor\n    integer :: mx, my, mxw\n    integer, save :: iflg\n    data iflg / 0 /\n\n\n    ff_max_l = maxval(abs(ff))\n    call MPI_Allreduce(ff_max_l, ff_max, 1, MPI_DOUBLE_PRECISION, &\n                       MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n\n    if (ff_max > 1.d50) then! If ff is too large, rescale ff, phi, Al, hh\n\n      write( olog, * ) \" # Rescale linear run at time = \", time\n      call tips_flush\n\n     !== Determine rescale factor for each linear mode ==\n      phi_max_l(:,:) = 0._DP\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          phi_max_l(mx,my) = maxval(abs(phi(mx,my,:)))\n        end do\n      end do\n      call MPI_Allreduce(phi_max_l, phi_max, (2*nx+1)*(ny+1), MPI_DOUBLE_PRECISION, &\n                         MPI_MAX, zsp_comm_world, ierr_mpi )\n\n      scale_factor(:,:) = 1._DP\n      do my = ist_y, iend_y\n\n        if (dj(my) == 0) then ! dj==0, no mode connection in mx\n\n          do mx = -nx, nx\n            if (phi_max(mx,my).ne. 0.d0) then\n              scale_factor(mx,my) = 1.d-10 / phi_max(mx,my)\n            end if\n          end do\n\n        else                  ! dj/=0, mode connection in mxw=mx+-dj\n\n          do mx = -nx, -nx+abs(dj(my))-1\n            wr1 = 0.d0\n            do mxw = mx, nx, abs(dj(my))\n              if (wr1 < phi_max(mxw,my)) wr1 = phi_max(mxw,my)\n            end do\n            if (wr1.ne. 0.d0) then\n              do mxw = mx, nx, abs(dj(my))\n                scale_factor(mxw,my) = 1.d-10 / wr1\n              end do\n            end if\n          end do\n\n        end if\n\n      end do\n\n     !== Rescale ==\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          ff(mx,my,:,:,:) = scale_factor(mx,my) * ff(mx,my,:,:,:)\n          hh(mx,my,:,:,:) = scale_factor(mx,my) * hh(mx,my,:,:,:)\n          phi(mx,my,:) = scale_factor(mx,my) * phi(mx,my,:)\n          Al(mx,my,:) = scale_factor(mx,my) * Al(mx,my,:)\n        end do\n      end do\n\n      iflg = iflg + 1\n\n    end if\n\n    if (iflg > rescale_max_num) then\n      write( olog, * ) \" # Reach max number of rescale:\", iflg\n      call tips_flush\n      call MPI_Finalize(ierr_mpi)\n      stop\n    end if\n\n  END SUBROUTINE tips_rescale_for_linear_runs\n\n\nEND MODULE GKV_tips\n", "MODULE GKV_fileio\n!-------------------------------------------------------------------------------\n!\n!    File I/O interface for Fortran binary output\n!\n!    Update history of gkvp_fileio_fortran.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Fortran binary I/O interface by Fujitsu.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit  none\n\n  private\n\n  public    fileio_open_icnt,fileio_close_icnt, &\n            fileio_open_cnt, fileio_close_cnt, &\n            fileio_open_fxv, fileio_close_fxv, &\n            fileio_open_phi, fileio_close_phi, &\n            fileio_open_Al,  fileio_close_Al, &\n            fileio_open_mom, fileio_close_mom, &\n            fileio_open_trn, fileio_close_trn, &\n            fileio_open_tri, fileio_close_tri, &\n            \n            fileio_read_cnt,  fileio_write_cnt, &\n            fileio_write_fxv, fileio_write_phi, fileio_write_Al, &\n            fileio_write_mom, fileio_write_trn, fileio_write_tri\n\nCONTAINS\n\n!--------------------------------------\n  SUBROUTINE fileio_open_icnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(3)   :: cold\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( cold,  fmt=\"(i3.3)\" ) inum-1\n\n    open( icnt, file=path//crank//\".cnt.\"//cold, &\n          form=\"unformatted\", status=\"old\", action=\"read\" )\n\n  END SUBROUTINE fileio_open_icnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_icnt\n!--------------------------------------\n\n     close( icnt )\n\n  END SUBROUTINE fileio_close_icnt\n\n \n!--------------------------------------\n  SUBROUTINE fileio_open_cnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(3)   :: cnew\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( ocnt, file=path//crank//\".cnt.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_cnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_cnt\n!--------------------------------------\n\n     close( ocnt )\n\n  END SUBROUTINE fileio_close_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_fxv ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( ofxv, file=path//crank//\".\"//srank//\".fxv.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_fxv\n\n!--------------------------------------\n  SUBROUTINE fileio_close_fxv\n!--------------------------------------\n\n     close( ofxv )\n\n  END SUBROUTINE fileio_close_fxv\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_phi ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( ophi, file=path//crank//\".\"//srank//\".phi.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_phi\n\n!--------------------------------------\n  SUBROUTINE fileio_close_phi\n!--------------------------------------\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    close( ophi )\n\n  END SUBROUTINE fileio_close_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_Al ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( oAl, file=path//crank//\".\"//srank//\".Al.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_Al\n\n!--------------------------------------\n  SUBROUTINE fileio_close_Al\n!--------------------------------------\n\n    if ( (ranks /= 0).OR. (vel_rank /= 0) ) return\n\n    close( oAl )\n\n  END SUBROUTINE fileio_close_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_mom ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( vel_rank /= 0 ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( omom, file=path//crank//\".\"//srank//\".mom.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_mom\n\n!--------------------------------------\n  SUBROUTINE fileio_close_mom\n!--------------------------------------\n\n    if ( vel_rank /= 0 ) return\n\n    close( omom )\n\n  END SUBROUTINE fileio_close_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_trn ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( (zsp_rank /= 0).OR. (vel_rank /= 0) ) return\n\n    write( crank, fmt=\"(i6.6)\" ) rankg\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    open( otrn, file=path//crank//\".\"//srank//\".trn.\"//cnew, &\n          form=\"unformatted\" )\n\n  END SUBROUTINE fileio_open_trn\n\n!--------------------------------------\n  SUBROUTINE fileio_close_trn\n!--------------------------------------\n\n    if ( (zsp_rank /= 0).OR. (vel_rank /= 0) ) return\n\n    close( otrn )\n\n  END SUBROUTINE fileio_close_trn\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_tri ( path, cmx, cmy, replace )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n    character(*), intent(in) :: cmx, cmy\n    logical, intent(in) :: replace\n\n    character(1)   :: srank\n    character(3)   :: cnew\n\n    if ( rank /= 0 ) return\n\n    write( srank, fmt=\"(i1.1)\" ) ranks\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( replace ) then\n       open( otri, file=path//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, &\n             form=\"unformatted\", status=\"replace\" )\n    else\n       open( otri, file=path//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, &\n             form=\"unformatted\", status=\"unknown\", position=\"append\" )\n    end if\n\n  END SUBROUTINE fileio_open_tri\n\n!--------------------------------------\n  SUBROUTINE fileio_close_tri\n!--------------------------------------\n\n    if ( rank /= 0 ) return\n\n    close( otri )\n\n  END SUBROUTINE fileio_close_tri\n\n\n\n!--------------------------------------\n  SUBROUTINE fileio_read_cnt ( wf, time, istatus )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(out) :: time\n    integer, optional, intent(out) :: istatus\n\n    integer :: input_status\n\n    read( unit=icnt, iostat=input_status ) time, wf\n    if ( present(istatus) ) then\n       istatus = input_status\n    endif\n\n  END SUBROUTINE fileio_read_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_cnt ( wf, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(in) :: time\n\n    rewind ocnt\n    write( unit=ocnt ) time, wf\n\n    call flush(ocnt)\n\n  END SUBROUTINE fileio_write_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_fxv ( fout, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,1:2*nv,0:nm) :: fout\n    real(kind=DP), intent(in) :: time\n\n    write( unit=ofxv ) time, fout\n\n    call flush(ofxv)\n\n  END SUBROUTINE fileio_write_fxv\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_phi ( phi, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    real(kind=DP), intent(in) :: time\n\n   !- OUTPUT binary data phi/\"*.phi.*\"\n    if ( ranks == 0.AND. vel_rank == 0 ) then\n       write( unit=ophi ) time, phi\n\n       call flush(ophi)\n    end if\n\n\n  END SUBROUTINE fileio_write_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_Al ( Al, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n    real(kind=DP), intent(in) :: time\n\n   !- OUTPUT binary data phi/\"*.Al.*\"\n    if ( ranks == 0.AND. vel_rank == 0 ) then\n       write( unit=oAl  ) time, Al\n\n       call flush(oAl)\n    end if\n\n  END SUBROUTINE fileio_write_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_mom ( dens, upara, ppara, pperp, qlpara, qlperp, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) ::  dens, upara, ppara, pperp, qlpara, qlperp\n    real(kind=DP), intent(in) :: time\n\n    if ( vel_rank /= 0 ) return\n\n    write( unit=omom ) time, dens, upara, ppara, pperp, qlpara, qlperp\n\n    call flush(omom)\n\n  END SUBROUTINE fileio_write_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_trn ( entrpy, fenegy, menegy, peint, pmint, &\n                                neint, nmint, dcd, pflux_es, pflux_em, &\n                                eflux_es, eflux_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy, peint, pmint, neint, nmint, dcd, &\n         pflux_es, pflux_em, eflux_es, eflux_em\n    real(kind=DP), intent(in) :: time\n\n    if ( (zsp_rank /= 0).OR. (vel_rank /= 0) ) return\n\n    write( unit=otrn ) time, entrpy, fenegy, menegy,    &\n         peint, pmint, neint, nmint, dcd, &\n         pflux_es, pflux_em, eflux_es, eflux_em\n\n    call flush(otrn)\n\n  END SUBROUTINE fileio_write_trn\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_tri ( jkpq_es, jpqk_es, jqkp_es, &\n                                jkpq_em, jpqk_em, jqkp_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,-global_ny:global_ny) :: jkpq_es, jpqk_es, jqkp_es, &\n         jkpq_em, jpqk_em, jqkp_em\n    real(kind=DP), intent(in) :: time\n\n    if ( rank /= 0 ) return\n\n    write( unit=otri ) time, jkpq_es, jpqk_es, jqkp_es, jkpq_em, jpqk_em, jqkp_em\n\n  END SUBROUTINE fileio_write_tri\n\nEND MODULE GKV_fileio\n", "MODULE GKV_intgrl\n!-------------------------------------------------------------------------------\n!\n!    Flux-surface and field-line averages, velocity-space integrals\n!\n!    Update history of gkvp_intgrl.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - real(ww)=complex(0,0) is modified to real(ww)=real(0).\n!        - Initialization at padding iend_y<my is added.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public   intgrl_fsrf, intgrl_thet, intgrl_v0_moment, intgrl_v1_moment, intgrl_v2_moment, &\n           intgrl_v0_moment_ms\n\n\n    INTERFACE intgrl_fsrf\n      module procedure  intgrl_fsrf_r, intgrl_fsrf_z\n    END INTERFACE\n\n    INTERFACE intgrl_thet\n      module procedure  intgrl_thet_r, intgrl_thet_z\n    END INTERFACE\n\n\nCONTAINS\n\n\n!note(fsrf does not require my dependence.)\n!--------------------------------------\n  SUBROUTINE intgrl_fsrf_r ( wn, wa )\n!--------------------------------------\n!     Flux-surface average of a real variable wn\n\n    real(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: wn\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx)                 :: wa\n\n    real(kind=DP), dimension(-nx:nx)    :: ww\n    integer  ::  mx, my, iz\n\n          do mx = -nx, nx\n            ww(mx)   = 0._DP\n          end do\n\n      if ( rankw == 0 ) then\n\n\n        my = 0\n!$OMP parallel do reduction(+:ww)\n          do iz = -nz, nz-1\n            do mx = 0, nx\n!              ww(mx)   = ww(mx) + wn(mx,my,iz) / omg(iz)\n              ww(mx)   = ww(mx) + wn(mx,my,iz) * rootg(iz)\n            end do\n          end do\n\n\n        call MPI_Allreduce( ww, wa, 2*nx+1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n\n!note(This procedure can be merged into upper one, \n!     since cfsrf does not have process dependence.)\n        do mx = 0, nx\n          wa(mx)   = wa(mx) / cfsrf\n        end do\n\n! --- reality condition\n        do mx = 0, nx\n          wa(-mx) = wa(mx)\n        end do\n\n      end if\n\n\n  END SUBROUTINE intgrl_fsrf_r\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_fsrf_z ( wn, wa )\n!--------------------------------------\n!     Flux-surface average of a complex variable wn\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: wn\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx)                 :: wa\n\n    complex(kind=DP), dimension(-nx:nx) :: ww\n    integer  ::  mx, my, iz\n\n\n          do mx = -nx, nx\n            ww(mx)   = ( 0._DP, 0._DP )\n          end do\n\n      if ( rankw == 0 ) then\n\n        my = 0\n!$OMP parallel do reduction(+:ww)\n          do iz = -nz, nz-1\n            do mx = 0, nx\n!              ww(mx)   = ww(mx) + wn(mx,my,iz) / omg(iz)\n              ww(mx)   = ww(mx) + wn(mx,my,iz) * rootg(iz)\n            end do\n          end do\n\n\n        call MPI_Allreduce( ww, wa, 2*nx+1, MPI_DOUBLE_COMPLEX, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n\n        do mx = 0, nx\n          wa(mx)   = wa(mx) / cfsrf\n        end do\n\n! --- reality condition\n        do mx = 0, nx\n          wa(-mx) = conjg( wa(mx) )\n        end do\n\n      end if\n\n\n  END SUBROUTINE intgrl_fsrf_z\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_thet_r ( wn, wa )\n!--------------------------------------\n!     average of a real variable wn in the theta space\n\n    real(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1)     :: wn\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny)              :: wa\n\n    real(kind=DP), dimension(-nx:nx,0:ny) :: ww\n    integer  ::  mx, my, iz\n\n      ww(:,:) = 0._DP\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n\n        do iz = -nz, nz-1\n          do mx = -nx, nx\n!            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) / omg(iz)\n            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) * rootg(iz)\n          end do\n        end do\n\n      end do\n\n      call MPI_Allreduce( ww, wa, nxy, MPI_DOUBLE_PRECISION, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          wa(mx,my)   = wa(mx,my) / cfsrf\n        end do\n      end do\n\n! --- reality condition\n      if ( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            wa(-mx,my) = wa(mx,my)\n          end do\n      end if\n\n\n  END SUBROUTINE intgrl_thet_r\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_thet_z ( wn, wa )\n!--------------------------------------\n!     average of a complex variable wn in the theta space\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1)        :: wn\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny)                 :: wa\n\n    complex(kind=DP), dimension(-nx:nx,0:ny) :: ww\n    integer  ::  mx, my, iz\n\n      ww(:,:) = ( 0._DP, 0._DP )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n\n        do iz = -nz, nz-1\n          do mx = -nx, nx\n!            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) / omg(iz)\n            ww(mx,my)   = ww(mx,my) + wn(mx,my,iz) * rootg(iz)\n          end do\n        end do\n\n      end do\n\n      call MPI_Allreduce( ww, wa, nxy, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, zsp_comm_world, ierr_mpi )\n\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          wa(mx,my)   = wa(mx,my) / cfsrf\n        end do\n      end do\n\n! --- reality condition\n      if ( rankw == 0 ) then\n        my = 0\n          do mx = 0, nx\n            wa(-mx,my) = conjg( wa(mx,my) )\n          end do\n      end if\n\n\n  END SUBROUTINE intgrl_thet_z\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_v0_moment ( wf, wn )\n!--------------------------------------\n!     Calculate the zeroth order velocity moment of wf\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz) = ww(mx,my,iz)                         &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n          ! for edge compensation\n            im = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz) = ww(mx,my,iz)                             &\n                        - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                          + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                            - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                            ) * 11._DP / 720._DP                          &\n                          ) * cef * dvp(iz)\n                end do\n              end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz) = ww(mx,my,iz)                         &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, vel_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n\n  END SUBROUTINE intgrl_v0_moment\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_v2_moment ( wf, wn )\n!--------------------------------------\n!     Calculate the second order velocity moment of wf\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    real(kind=DP) :: v2a, v2b\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im,v2a,v2b)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * ( vl(iv)**2 + vp(iz,im)**2 ) * 0.5_DP\n                end do\n              end do\n            end do\n\n          ! for edge compensation\n            im   = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  v2a   = ( vl(iv)**2 + vp(iz,im  )**2 ) * 0.5_DP\n                  v2b   = ( vl(iv)**2 + vp(iz,im+1)**2 ) * 0.5_DP\n                  ww(mx,my,iz)   = ww(mx,my,iz)                           &\n                        - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                                * v2a                                     &\n                          + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                                * v2b                                     &\n                            - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                                * v2a                                     &\n                            ) * 11._DP / 720._DP                          &\n                          ) * cef * dvp(iz)\n                end do\n              end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * ( vl(iv)**2 + vp(iz,im)**2 ) * 0.5_DP\n                end do\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, vel_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n  END SUBROUTINE intgrl_v2_moment\n\n\n!--------------------------------------\n  SUBROUTINE intgrl_v1_moment ( wf, wn )\n!--------------------------------------\n!     Calculate the second order velocity moment of wf\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * vl(iv)\n                end do\n              end do\n            end do\n\n          ! for edge compensation\n            im   = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                           &\n                        - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                                * vl(iv)                                  &\n                          + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                                * vl(iv)                                  &\n                            - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                                * vl(iv)                                  &\n                            ) * 11._DP / 720._DP                          &\n                          ) * cef * dvp(iz)\n                end do\n              end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(cef,ww,wf,vl,vp,dv,dvp,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                  ww(mx,my,iz)   = ww(mx,my,iz)                          &\n                        + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef &\n                          * vl(iv)\n                end do\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, vel_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n  END SUBROUTINE intgrl_v1_moment\n\n\n!--------------------------------------\n  ", "SUBROUTINE intgrl_v0_moment_ms ( wf, wn )\n!--------------------------------------\n!     Calculate the zeroth order velocity moment of wf over species\n\n    complex(kind=DP), intent(in),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)   :: wf\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)               :: wn\n\n    complex(kind=DP), dimension(:,:,:), allocatable :: ww\n    real(kind=DP) :: cef\n    integer :: mx, my, iz, iv, im\n\n      cef   = dv * twopi\n\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n      if( rankm == 0 ) then\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 1, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                    ww(mx,my,iz) = ww(mx,my,iz)                         &\n                          + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n         ! for edge compensation\n            im = 1\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                    ww(mx,my,iz) = ww(mx,my,iz)                             &\n                          - ( - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) / 12._DP &\n                            + ( wf(mx,my,iz,iv,im+1) * vp(iz,im+1)          &\n                              - wf(mx,my,iz,iv,im  ) * vp(iz,im  ) * 2._DP  &\n                              ) * 11._DP / 720._DP                          &\n                            ) * cef * dvp(iz)\n                end do\n              end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      else\n\n!$OMP parallel default(none) &\n!$OMP shared(ww,wf,vp,dvp,cef,ist_y,iend_y) &\n!$OMP private(mx,my,iz,iv,im)\n!$OMP workshare\n      ww(:,:,:) = ( 0._DP, 0._DP )\n!$OMP end workshare\n\n!$OMP do collapse(2)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n  \n            do im = 0, nm\n              do iv = 1, 2*nv\n                do mx = -nx, nx\n                    ww(mx,my,iz) = ww(mx,my,iz)                         &\n                          + wf(mx,my,iz,iv,im) * vp(iz,im) * dvp(iz) * cef\n                end do\n              end do\n            end do\n  \n          end do\n        end do\n!$OMP end do\n!$OMP end parallel\n\n      end if\n\n      call MPI_Allreduce( ww, wn, nxyz, MPI_DOUBLE_COMPLEX, &\n                          MPI_SUM, spc_comm_world, ierr_mpi )\n\n      deallocate( ww )\n\n  END SUBROUTINE intgrl_v0_moment_ms\n\n\nEND MODULE GKV_intgrl\n", "MODULE GKV_advnc\n!-------------------------------------------------------------------------------\n!\n!    Flux surface and field line averages\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fld,   only: fld_esfield, fld_emfield_hh, fld_hh2ff\n  use GKV_exb,   only: exb_NL_term\n  use GKV_colli, only: colli_LB!, colli_full\n  use GKV_colliimp, only: colliimp_calc_colli_full\n  use GKV_bndry, only: bndry_bound_e,  &\n                       bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout, &\n                       bndry_zv_buffin_v2, bndry_zv_sendrecv_v2, bndry_zv_buffout_v2\n  use GKV_clock, only: clock_sta, clock_end\n  use GKV_zfilter, only: zfilter\n  use GKV_tips,  only: tips_reality\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_zv = 1, nchunk_yzv = 1, nchunk_yz = 1\n\n  public   advnc_rkgsteps_rev, caldlt_rev\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n!--------------------------------------\n!     time integration of GK equation using RKG method\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    complex(kind=DP), save,  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: qh\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dh, cf, ef\n    integer :: mx, my, iz, iv, im, istep\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  qh(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zv = ((2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yzv = ((iend_y-ist_y+1)*(2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yz = ((iend_y-ist_y+1)*(2*nz)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      do istep = 1, 4\n\n        call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n                                           call clock_sta(11)\n                                         ! call fapp_start(\"rkg\",11,1)\n        call rkg( hh, dh, qh, istep )\n                                         ! call fapp_stop(\"rkg\",11,1)\n                                           call clock_end(11)\n\n        call tips_reality ( hh )\n\n                                           call clock_sta(12)\n                                         ! call fapp_start(\"esfield\",12,1)\n        if ( beta > 0._DP ) then\n          call fld_emfield_hh( hh, Al )\n        end if\n        call fld_hh2ff( hh, Al, ff )\n        call fld_esfield( ff, phi )\n                                         ! call fapp_stop(\"esfield\",12,1)\n                                           call clock_end(12)\n      end do\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n\n  END SUBROUTINE advnc_rkgsteps_rev\n\n\n!--------------------------------------\n  SUBROUTINE rkg( hh, dh, qh, istep )\n!--------------------------------------\n!     Runge-Kutta-Gill\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh, qh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n    integer, intent(in) :: istep\n\n    real(kind=DP) :: c1, c2, cq, c0\n    integer :: mx, my, iz, iv, im\n\n\n      if      ( istep == 1 ) then\n        c1   =  0.5_DP\n        c2   = -1._DP\n        cq   = -2._DP\n        c0   =  1._DP\n      else if ( istep == 2 ) then\n        c1   =  1._DP - sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 3 ) then\n        c1   =  1._DP + sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 4 ) then\n        c1   =  1._DP / 6._DP\n        c2   = -1._DP / 3._DP\n        cq   =  0._DP\n        c0   =  0._DP\n      end if\n\n!$OMP parallel do collapse(3)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                hh(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im)           &\n                                   + c1 * dt * dh(mx,my,iz,iv,im) &\n                                   + c2 * qh(mx,my,iz,iv,im)\n                qh(mx,my,iz,iv,im) = cq * qh(mx,my,iz,iv,im) &\n                                   + c0 * dt * dh(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n\n  END SUBROUTINE rkg\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: dh, cf, ef\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi\n    integer :: mx, my, iz, iv, im\n\n      allocate( psi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n\n!$OMP parallel do collapse(2)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n              chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n            end do\n          end do\n        end do\n      end do\n\n                                           call clock_sta(13)\n                                         ! call fapp_start(\"literm\",13,1)\n     !%%% Linear collisionless term %%%\n      call caldlt_linear( ff, psi, chi, dh )\n\n     !%%% Collision term %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n\n        if ( trim(col_type) == \"LB\" ) then\n          call colli_LB( ff, phi, cf )\n        else if ( trim(col_type) == \"full\" .or. &\n                  trim(col_type) == \"lorentz\" ) then\n          !call colli_full( ff, phi, cf )\n          call colliimp_calc_colli_full( ff, phi, cf )\n        else \n          write(olog,*) \"## Illegal choice for col_type!! ---> stop\"\n          call flush(olog)\n          call MPI_Finalize(ierr_mpi)\n          stop\n        end if\n\n      else if ( trim(colliflag) == \"collisionless\" ) then\n\n!!$OMP parallel workshare\n!        cf(:,:,:,:,:) = (0._DP, 0._DP)\n!!$OMP end parallel workshare\n\n      else \n\n        write(olog,*) \"## Illegal choice for colliflag:\", colliflag\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n                                         ! call fapp_stop(\"literm\",13,1)\n                                           call clock_end(13)\n\n                                           call clock_sta(14)\n                                         ! call fapp_start(\"nlterm\",14,1)\n     !%%% Nonlinear term %%%\n      call exb_NL_term( hh, psi, chi, ef )\n                                         ! call fapp_stop(\"nlterm\",14,1)\n                                           call clock_end(14)\n\n     !%%% dh/dt = (Linear collisionless) + (Collision) - (Nonlinear) %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     + cf(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      else if ( trim(colliflag) == \"collisionless\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      end if\n                                           call clock_sta(15)\n                                         ! call fapp_start(\"zfilter\",15,1)\n      if ( trim(z_filt) == \"on\" ) then\n        call zfilter( dh )\n      end if                                \n                                         ! call fapp_stop(\"zfilter\",15,1)\n                                           call clock_end(15)\n\n      deallocate( psi )\n      deallocate( chi )\n\n  END SUBROUTINE caldlt_rev\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_linear( ff, psi, chi, dh )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: &\n                         zb1be, zb1te, zb2be, zb2te, zb1bo, zb1to, zb2bo, zb2to\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    integer :: im\n\n\n      allocate( zb1be(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb1te(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2be(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2te(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n!     allocate( zb1bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n!     allocate( zb1to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n!     allocate( zb2bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n!     allocate( zb2to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( vb1e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n!     allocate( vb1o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n!     allocate( vb2o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n\n      call bndry_bound_e( psi )\n\n      call literm_k_rev( ff, psi, chi, dh )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,psi,chi,dh) &\n!$OMP shared(zb1be,zb1te,zb2be,zb2te,zb1bo,zb1to,zb2bo,zb2to,vb1e,vb2e,vb1o,vb2o) &\n!$OMP private(im)\n\n!!%%% Without overlap %%%\n      call bndry_zv_buffin_v2( ff, zb1be, zb1te, vb1e )\n      call bndry_zv_sendrecv_v2( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n      call bndry_zv_buffout_v2( zb2be, zb2te, vb2e, ff )\n      call literm_zv_v2( ff, psi, dh )\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!!%%% With overlap %%%\n!      do im = 0, nm+3\n!        if (mod(im,2) == 0) then ! even\n!!$OMP master\n!          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1bo, zb1to, zb2bo, zb2to, vb1o, vb2o )\n!!$OMP end master\n!          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1be, zb1te, vb1e )\n!          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2be, zb2te, vb2e, ff(:,:,:,:,im-2) )\n!          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n!        else                     ! odd\n!!$OMP master\n!          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n!!$OMP end master\n!          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1bo, zb1to, vb1o )\n!          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2bo, zb2to, vb2o, ff(:,:,:,:,im-2) )\n!          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n!        end if\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( zb1be )\n      deallocate( zb1te )\n      deallocate( zb2be )\n      deallocate( zb2te )\n!     deallocate( zb1bo )\n!     deallocate( zb1to )\n!     deallocate( zb2bo )\n!     deallocate( zb2to )\n      deallocate( vb1e )\n      deallocate( vb2e )\n!     deallocate( vb1o )\n!     deallocate( vb2o )\n\n\n  END SUBROUTINE caldlt_linear\n\n\n!--------------------------------------\n  SUBROUTINE literm_k_rev ( ff, psi, chi, lf )\n!--------------------------------------\n!     z-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: lf\n\n    real(kind=DP) :: cs1, cs2, kvd, kvs\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1320)\n                                         ! call fapp_start(\"literm_perp\",1320,1)\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      cs2    = sqrt( tau(ranks) / Anum(ranks) )\n\n!$OMP parallel do collapse(3) private(kvd,kvs)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im)\n                kvs = ky(my) * vsy(iz,iv,im)\n                lf(mx,my,iz,iv,im) =                  &\n                   - ui * kvd * ff(mx,my,iz,iv,im)    &\n                   - cs1 * fmx(iz,iv,im) * (          &\n                       + ui * kvd * psi(mx,my,iz,im)  &\n                       - ui * kvs                     &\n                            * ( psi(mx,my,iz,im) - cs2 * vl(iv) * chi(mx,my,iz,im) ) )\n              end do\n            end do\n          end do\n        end do\n      end do\n                                         ! call fapp_stop(\"literm_perp\",1320,1)\n                                           call clock_end(1320)\n\n\n  END SUBROUTINE literm_k_rev\n\n\n!--------------------------------------\n  ", "SUBROUTINE literm_zv ( ff, psi, im, lf )\n!--------------------------------------\n!     (z,v)-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb)            :: psi\n    integer, intent(in) :: im\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)             :: lf\n\n    real(kind=DP), dimension(-nz:nz-1) :: cefz, cefz2\n    real(kind=DP) :: cefv, cs1\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1330)\n                                        ! call fapp_start(\"literm_para\",1330,1)\n!$OMP end master\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      do iz = -nz, nz-1\n        cefz(iz)   = 1._DP / ( 12._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n        cefz2(iz)  = 1._DP / ( 60._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n      end do\n      cefv   = 1._DP / ( 12._DP * dv ) * sqrt( tau(ranks) / Anum(ranks) )\n\n      if (trim(z_calc) == \"cf4\") then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_zv)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                 - vl(iv) * cefz(iz) * (              &\n                     -         ff(mx,my,iz+2,iv)      &\n                     + 8._DP * ff(mx,my,iz+1,iv)      &\n                     - 8._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )    &\n                 + mir(iz,im) * cefv * (              &\n                     -         ff(mx,my,iz,iv+2)      &\n                     + 8._DP * ff(mx,my,iz,iv+1)      &\n                     - 8._DP * ff(mx,my,iz,iv-1)      &\n                     +         ff(mx,my,iz,iv-2) )    &\n                 - cs1 * fmx(iz,iv,im) * (            &\n                       vl(iv) * cefz(iz) * (          &\n                         -         psi(mx,my,iz+2)    &\n                         + 8._DP * psi(mx,my,iz+1)    &\n                         - 8._DP * psi(mx,my,iz-1)    &\n                         +         psi(mx,my,iz-2) ) )&\n                 - art_diff * (                       &\n                     +         ff(mx,my,iz+2,iv)      &\n                     - 4._DP * ff(mx,my,iz+1,iv)      &\n                     + 6._DP * ff(mx,my,iz ,iv)      &\n                     - 4._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      else if (trim(z_calc) == \"up5\") then\n\n        do iv = 1, 2*nv\n          if ( vl(iv) > 0._DP ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         - 3._DP * ff(mx,my,iz+2,iv)      &\n                         +30._DP * ff(mx,my,iz+1,iv)      &\n                         +20._DP * ff(mx,my,iz ,iv)      &\n                         -60._DP * ff(mx,my,iz-1,iv)      &\n                         +15._DP * ff(mx,my,iz-2,iv)      &\n                         - 2._DP * ff(mx,my,iz-3,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          else\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         + 2._DP * ff(mx,my,iz+3,iv)      &\n                         -15._DP * ff(mx,my,iz+2,iv)      &\n                         +60._DP * ff(mx,my,iz+1,iv)      &\n                         -20._DP * ff(mx,my,iz ,iv)      &\n                         -30._DP * ff(mx,my,iz-1,iv)      &\n                         + 3._DP * ff(mx,my,iz-2,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          end if\n        end do\n\n      else\n\n        write(olog,*) \"## Illegal choice for z_calc!! ---> stop\"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_para\",1330,1)\n                                           call clock_end(1330)\n!$OMP end master\n\n\n  END SUBROUTINE literm_zv\n\n\n!--------------------------------------\n  SUBROUTINE literm_zv_v2 ( ff, psi, lf )\n!--------------------------------------\n!     (z,v)-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)            :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)             :: lf\n\n    real(kind=DP), dimension(-nz:nz-1) :: cefz, cefz2\n    real(kind=DP) :: cefv, cs1\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1330)\n                                        ! call fapp_start(\"literm_para\",1330,1)\n!$OMP end master\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      do iz = -nz, nz-1\n        cefz(iz)   = 1._DP / ( 12._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n        cefz2(iz)  = 1._DP / ( 60._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n      end do\n      cefv   = 1._DP / ( 12._DP * dv ) * sqrt( tau(ranks) / Anum(ranks) )\n\n      if (trim(z_calc) == \"cf4\") then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zv)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              lf(mx,my,iz,iv,im) = lf(mx,my,iz,iv,im)       &\n                 - vl(iv) * cefz(iz) * (              &\n                     -         ff(mx,my,iz+2,iv,im)      &\n                     + 8._DP * ff(mx,my,iz+1,iv,im)      &\n                     - 8._DP * ff(mx,my,iz-1,iv,im)      &\n                     +         ff(mx,my,iz-2,iv,im) )    &\n                 + mir(iz,im) * cefv * (              &\n                     -         ff(mx,my,iz,iv+2,im)      &\n                     + 8._DP * ff(mx,my,iz,iv+1,im)      &\n                     - 8._DP * ff(mx,my,iz,iv-1,im)      &\n                     +         ff(mx,my,iz,iv-2,im) )    &\n                 - cs1 * fmx(iz,iv,im) * (            &\n                       vl(iv) * cefz(iz) * (          &\n                         -         psi(mx,my,iz+2,im)    &\n                         + 8._DP * psi(mx,my,iz+1,im)    &\n                         - 8._DP * psi(mx,my,iz-1,im)    &\n                         +         psi(mx,my,iz-2,im) ) )&\n                 - art_diff * (                       &\n                     +         ff(mx,my,iz+2,iv,im)      &\n                     - 4._DP * ff(mx,my,iz+1,iv,im)      &\n                     + 6._DP * ff(mx,my,iz ,iv,im)      &\n                     - 4._DP * ff(mx,my,iz-1,iv,im)      &\n                     +         ff(mx,my,iz-2,iv,im) )\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!!!$OMP end do nowait\n\n      else if (trim(z_calc) == \"up5\") then\n\n        do im = 0, nm\n        do iv = 1, 2*nv\n          if ( vl(iv) > 0._DP ) then\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv,im) = lf(mx,my,iz,iv,im)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         - 3._DP * ff(mx,my,iz+2,iv,im)      &\n                         +30._DP * ff(mx,my,iz+1,iv,im)      &\n                         +20._DP * ff(mx,my,iz ,iv,im)      &\n                         -60._DP * ff(mx,my,iz-1,iv,im)      &\n                         +15._DP * ff(mx,my,iz-2,iv,im)      &\n                         - 2._DP * ff(mx,my,iz-3,iv,im) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2,im)      &\n                         + 8._DP * ff(mx,my,iz,iv+1,im)      &\n                         - 8._DP * ff(mx,my,iz,iv-1,im)      &\n                         +         ff(mx,my,iz,iv-2,im) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2,im)    &\n                             + 8._DP * psi(mx,my,iz+1,im)    &\n                             - 8._DP * psi(mx,my,iz-1,im)    &\n                             +         psi(mx,my,iz-2,im) ) )\n                end do\n              end do\n            end do\n!!TBI!!!$OMP end do nowait\n          else\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv,im) = lf(mx,my,iz,iv,im)       &\n                     - vl(iv) * cefz2(iz) * (             &\n                         + 2._DP * ff(mx,my,iz+3,iv,im)      &\n                         -15._DP * ff(mx,my,iz+2,iv,im)      &\n                         +60._DP * ff(mx,my,iz+1,iv,im)      &\n                         -20._DP * ff(mx,my,iz ,iv,im)      &\n                         -30._DP * ff(mx,my,iz-1,iv,im)      &\n                         + 3._DP * ff(mx,my,iz-2,iv,im) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2,im)      &\n                         + 8._DP * ff(mx,my,iz,iv+1,im)      &\n                         - 8._DP * ff(mx,my,iz,iv-1,im)      &\n                         +         ff(mx,my,iz,iv-2,im) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2,im)    &\n                             + 8._DP * psi(mx,my,iz+1,im)    &\n                             - 8._DP * psi(mx,my,iz-1,im)    &\n                             +         psi(mx,my,iz-2,im) ) )\n                end do\n              end do\n            end do\n!!TBI!!!$OMP end do nowait\n          end if\n        end do\n        end do\n\n      else\n\n        write(olog,*) \"## Illegal choice for z_calc!! ---> stop\"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_para\",1330,1)\n                                           call clock_end(1330)\n!$OMP end master\n\n\n  END SUBROUTINE literm_zv_v2\n\n\nEND MODULE GKV_advnc\n", "MODULE GKV_colli\n!-------------------------------------------------------------------------------\n!\n!    Collision term\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only : clock_sta, clock_end\n  use GKV_bndry, only : bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n           bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout, &\n           bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout, &\n           bndry_vm_sendrecv_v2\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_xy = 1, nchunk_yvb = 1, nchunk_ymb = 1\n\n  public   colli_set_param, colli_LB!, colli_full\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE colli_set_param (q0, eps_r, nust)\n!-------------------------------------------------------------------------------\n!\n!    Set parameters for GK collision term\n!\n!    by M. Nakata and M. Nunami, April 2014\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), parameter :: mp      = 1.67262178d-24, & ! proton mass in g\n                                ee      = 4.80320425d-10, & ! elementary charge in esu\n                                ev2erg  = 1.60217657d-12    ! erg/eV  (cf. 1J = 10^7 erg)\n    \n    real(kind=DP),                    intent(in)  :: q0, eps_r\n    real(kind=DP), dimension(0:ns-1,0:ns-1), intent(out) :: nust\n\n    real(kind=DP), dimension(0:ns-1)        :: tmpr, dens, freq_factor\n    real(kind=DP), dimension(0:ns-1,0:ns-1) :: log_lambda\n!    real(kind=DP)                           :: cph, dph, cgg\n\n    integer :: is, is1, is2\n  \n! --- temperature [in eV] and density [in cm^(-3)]\n    do is = 0, ns-1\n      tmpr(is) = tau(is) * Tref*1.d3\n      dens(is) = Nref*1.d-6 * fcs(is)/Znum(is)\n    end do\n\n! --- factor for collision frequencies\n    do is = 0, ns-1\n      freq_factor(is)  = (dens(is) * ee**4 * Lref*1.d2) / (Tref*1.d3*ev2erg)**2 \n    end do\n\n\n! --- Coulomb logarithm in cm^(-3) and eV units (see NRL plasma Formulary)  \n    do is1 = 0, ns-1\n      if (sgn(is1) < 0.d0) then  !! For is1 = electron\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! e-e case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23.5_DP - dlog( dsqrt( dens(is1) ) * tmpr(is1)**(-1.25_DP) )  &\n                                            - dsqrt( 1.d-5 + (( dlog(tmpr(is1)) - 2._DP )**2 )/16._DP )\n            end if\n          else                        !! e-i case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is1) ) / tmpr(is1) )\n            end if\n          end if\n        end do\n\n      else                     !! For is1 = ions\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! i-e case\n            if (dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is2) ) / tmpr(is2) )\n            end if\n          else                       !! i-i case\n            if (dens(is1) == 0.d0 .and. dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23._DP &\n                - dlog( Znum(is1)*Znum(is2)*(Anum(is1)+Anum(is2))/(Anum(is1)*tmpr(is2)+Anum(is2)*tmpr(is1)) &\n                        * dsqrt( (dens(is1) * Znum(is1)**2)/tmpr(is1)                                       &\n                               + (dens(is2) * Znum(is2)**2)/tmpr(is2) ) )\n            end if\n          end if\n        end do\n\n      end if\n    end do\n\n! --- Constant parameters\n    do is1 = 0, ns-1\n      do is2 = 0, ns-1 \n\n         ctauiv(is1,is2) = freq_factor(is2) * (8._DP*dsqrt(pi)/3._DP/dsqrt(2._DP))*log_lambda(is1,is2)  & \n                                   * ( Znum(is1)**2*Znum(is2)**2/dsqrt(Anum(is1))/tau(is1)**1.5 )\n\n         calpha(is1,is2) = dsqrt( tau(is1) * Anum(is2) / ( tau(is2) * Anum(is1) ) )\n         ctheta(is1,is2) = dsqrt( tau(is1) * ( Anum(is1) + Anum(is2) ) / ( tau(is1) * Anum(is2) + tau(is2) * Anum(is1) ) )\n\n         cgamma(is1,is2) = - Anum(is1) * calpha(is1,is2)                                      &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**1.5_DP \n\n         ceta(is1,is2)   = - tau(is1) * 3._DP * calpha(is1,is2)                               &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**2.5_DP\n\n          cxi(is1,is2)   =  calpha(is1,is2) * ( ctheta(is1,is2) - 1._DP ) * ctauiv(is1,is2)   &\n                             / dsqrt(1._DP + calpha(is1,is2)**2) \n\n         nust(is1,is2)   = q0*(ctauiv(is1,is2)/dsqrt(2._DP))/(eps_r**1.5*dsqrt(tau(is1)/Anum(is1)))\n\n      end do\n    end do\n\n!!!%%% Parameters for colli_full %%%\n!!!! --- xxa = v/vta/sqrt(2), where vta = sqrt(Ta/ma)\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1\n!!!          xxa(iz,iv,im) = dsqrt(vl(iv)**2 + vp(iz,im)**2)/dsqrt(2._DP) \n!!!        end do \n!!!      end do\n!!!    end do\n!!!\n!!!! --- collision frequencies and v-space functions\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1 \n!!!          do is1 = 0, ns-1\n!!!            do is2 = 0, ns-1 \n!!!\n!!!              cph = derf(calpha(is1,is2)*xxa(iz,iv,im))\n!!!              dph = 2._DP/dsqrt(pi)*dexp(-calpha(is1,is2)**2*xxa(iz,iv,im)**2)\n!!!              cgg = (cph - calpha(is1,is2)*xxa(iz,iv,im)*dph)/(calpha(is1,is2)**2*xxa(iz,iv,im)**2)*0.5_DP\n!!!\n!!!              nu_d(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*(cph-cgg)/xxa(iz,iv,im)**3\n!!!              nu_p(iz,iv,im,is1,is2) = 1.50_DP*dsqrt(pi)*ctauiv(is1,is2)*(  cgg  )/xxa(iz,iv,im)**3\n!!!              nu_h(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*calpha(is1,is2)*dph/xxa(iz,iv,im)**2\n!!!              nu_g(iz,iv,im,is1,is2) = nu_p(iz,iv,im,is1,is2)*xxa(iz,iv,im)**2*(1._DP-calpha(is1,is2)**2)\n!!!\n!!!              c_t0(iz,iv,im,is1,is2,1)  = - (1._DP + calpha(is1,is2)**2)*fmx(iz,iv,im)*nu_p(iz,iv,im,is1,is2)               &\n!!!                                             * xxa(iz,iv,im)**2*vl(iv)\n!!!              c_t0(iz,iv,im,is1,is2,2)  = - 1.5_DP*dsqrt(pi)*ctauiv(is1,is2)*fmx(iz,iv,im)                                  & \n!!!                                             * ( cph - calpha(is1,is2)*xxa(iz,iv,im)*(1._DP + calpha(is1,is2)**2)*dph )     & \n!!!                                             / calpha(is1,is2)**2 / xxa(iz,iv,im)\n!!!\n!!!              x_tst(1,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*fmx(iz,iv,im)*vl(iv)\n!!!              x_tst(2,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv) \n!!!              x_tst(3,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)/vl(iv)\n!!!              x_tst(4,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,1)                              &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)           &\n!!!                                                              * fmx(iz,iv,im)*vl(iv)/dsqrt(1._DP + calpha(is1,is2)**2) )\n!!!              x_tst(5,iz,iv,im,is1,is2) =  x_tst(4,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              x_tst(6,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,2)*2._DP/3._DP                &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)         &\n!!!                                                              * fmx(iz,iv,im)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)*2._DP     &\n!!!                                                               / (1._DP + calpha(is1,is2)**2)**1.5 )\n!!!\n!!!              y_fld(1,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))*calpha(is1,is2)*Anum(is1)             & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/tau(is1)/cgamma(is1,is2)     &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,1) - cxi(is1,is2)*fmx(iz,iv,im)*vl(iv) ) \n!!!              y_fld(2,iz,iv,im,is1,is2) = y_fld(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              y_fld(3,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))                                     & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/ceta(is1,is2)              &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,2)                                          &\n!!!                                                           - cxi(is1,is2)/(1._DP+calpha(is1,is2)**2)*fmx(iz,iv,im)        &\n!!!                                                               *(2._DP*xxa(iz,iv,im)**2 - 3._DP) ) \n!!!              y_fld(4,iz,iv,im,is1,is2) = - y_fld(1,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(5,iz,iv,im,is1,is2) = - y_fld(2,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(6,iz,iv,im,is1,is2) = - y_fld(3,iz,iv,im,is1,is2)*2._DP*cxi(is2,is1)/(1._DP+calpha(is2,is1)**2) \n!!!\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do\n!!!    end do \n!!!\n!!!! --- summation of collision frequencies with respect to is2, and adiabatic term (used in colli_GK_CT)\n!!!    nu_hs = 0._DP \n!!!    nu_gs = 0._DP \n!!!    nu_ds = 0._DP \n!!!    nu_ps = 0._DP \n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1 \n!!!            do is2 = 0, ns-1 \n!!!                nu_hs(iz,iv,im) = nu_hs(iz,iv,im) + nu_h(iz,iv,im,is1,is2)\n!!!                nu_gs(iz,iv,im) = nu_gs(iz,iv,im) + nu_g(iz,iv,im,is1,is2)\n!!!                nu_ds(iz,iv,im) = nu_ds(iz,iv,im) + nu_d(iz,iv,im,is1,is2)\n!!!                nu_ps(iz,iv,im) = nu_ps(iz,iv,im) + nu_p(iz,iv,im,is1,is2)\n!!!            end do \n!!!          end do \n!!!        end do\n!!!      end do \n!!!\n!!!    if (trim(col_type) == \"lorentz\") then\n!!!      nu_hs(:,:,:) = 0._DP\n!!!      nu_ps(:,:,:) = 0._DP\n!!!      x_tst(:,:,:,:,:,:) = 0._DP\n!!!      y_fld(:,:,:,:,:,:) = 0._DP\n!!!      nu_gs(:,:,:) = - nu_ds(:,:,:)\n!!!    end if\n!!!\n!!!! --- adiabatic part (used in colli_GK_CT)\n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!\n!!!        if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                               - ( nu_ds(iz,iv,im)*vl(iv)**2                           &\n!!!                                     * ksq(mx,my,iz)*Anum(is1)/Znum(is1)/omg(iz)**2    &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        else\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                                 ( -( nu_ds(iz,iv,im)*vl(iv)**2                        &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2                     &\n!!!                                     * (j0(mx,my,iz,im) - j2(mx,my,iz,im))             &\n!!!                                   -( nu_hs(iz,iv,im)*vp(iz,im)                        &\n!!!                                       - 0.5_DP*nu_ps(iz,iv,im)*vp(iz,im)              &\n!!!                                               *(1._DP-vl(iv)**2-vp(iz,im)**2)         &\n!!!                                       + 0.5_DP*nu_ds(iz,iv,im)                        &\n!!!                                               *(vl(iv)**2/vp(iz,im)-vp(iz,im)) )      &\n!!!                                     * dsqrt(ksq(mx,my,iz)*Anum(is1)/tau(is1))/omg(iz) &\n!!!                                     * j1(mx,my,iz,im)                                 &\n!!!                                   -( nu_ds(iz,iv,im)                                  &\n!!!                                               *(2._DP*vl(iv)**2+vp(iz,im)**2)         &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2 * j0(mx,my,iz,im)   &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        end if\n!!!\n!!!      end do\n!!!\n!!!\n!!!! --- set v-space functions used in colli_moment\n!!!\n!!!    vfunc(:,:,:,:,:) = 0._DP\n!!!    jfunc(:,:,:,:,:) = 0._DP\n!!!\n!!!    ", "if ( iFLR == 1 ) then\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = & \n!!!      !                              j1(mx,my,iz,im)*vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = j0(mx,my,iz,im)*vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = j1(mx,my,iz,im)*vp(iz,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = j0(mx,my,iz,im)*(xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = vp(iz,im)\n!!!                vfunc(iz,iv,im,is2,6) = xxa(iz,iv,im)**2-1.5_DP\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,2) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,3) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,4) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,5) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,6) = j0(mx,my,iz,im)\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!   \n!!!    else \n!!!\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = 0._DP\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = 0._DP\n!!!                vfunc(iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = 1._DP\n!!!              jfunc(mx,my,iz,im,2) = 0._DP\n!!!              jfunc(mx,my,iz,im,3) = 1._DP\n!!!              jfunc(mx,my,iz,im,4) = 1._DP\n!!!              jfunc(mx,my,iz,im,5) = 0._DP\n!!!              jfunc(mx,my,iz,im,6) = 1._DP\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!\n!!!    end if\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n! -----------------------------------\n! --- Output constants\n    if ( rankg == nprocz/2 ) then\n\n      do is1 = 0, ns-1\n        do is2 = 0, ns-1 \n          write(unit=ocst,fmt=\"(2I3,SP,256ES24.15e3)\") is1, is2, ctheta(is1,is2), calpha(is1,is2), &\n                                                                 fcs(is1)/Znum(is1)*ceta(is1,is2), &\n                                                               fcs(is1)/Znum(is1)*cgamma(is1,is2), & \n                                                                    cxi(is1,is2), ctauiv(is1,is2), &\n                                                                              log_lambda(is1,is2)\n! --- Note that, for ns >=3, cgamma(is1,is2) /= cgamma(is2,is1), but dens(is1)*cgamma(is1,is2) = dense(is2)*cgamma(is2,is1)\n! ---  due to normalizartion with dens(is). \n        end do\n      end do\n\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=4000,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_h(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_g(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_d(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_p(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=4000,fmt=*)\n!        write (unit=4001,fmt=*)\n!        write (unit=4002,fmt=*)\n!        write (unit=4003,fmt=*)\n!        write (unit=4004,fmt=*)\n!        write (unit=4005,fmt=*)\n!      end do\n!\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=5001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=5001,fmt=*)\n!        write (unit=5002,fmt=*)\n!        write (unit=5003,fmt=*)\n!        write (unit=5004,fmt=*)\n!        write (unit=5005,fmt=*)\n!        write (unit=5006,fmt=*)\n!        write (unit=6001,fmt=*)\n!        write (unit=6002,fmt=*)\n!        write (unit=6003,fmt=*)\n!        write (unit=6004,fmt=*)\n!        write (unit=6005,fmt=*)\n!        write (unit=6006,fmt=*)\n!      end do\n\n    end if\n\n    return\n\n   END SUBROUTINE colli_set_param\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB( ff, phi, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: gge, ggo\n    integer :: iz\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_xy = ((2*nx+1)*(ny+1)-1) / (nthreads-1) + 1\n!$      nchunk_yvb = ((ny+1)*(2*nv)*(2*nvb)-1) / (nthreads-1) + 1\n!$      nchunk_ymb = ((ny+1)*(nm+1)*(2*nvb)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( vb1e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) )\n      allocate( mb1e(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      allocate( mb2e(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      !!!allocate( gge(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny,-nz:nz-1) )\n      ! mod by M.Nakata 20200928\n      allocate( gge(-nx:nx,0:ny,-nz:nz-1,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!     allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!     allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!     allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!     allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!     allocate( ggo(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,phi,cf,vb1e,vb2e,mb1e,mb2e,gge) &\n!$OMP shared(vb1o,vb2o,mb1o,mb2o,ggo) &\n!$OMP private(iz)\n\n!$OMP workshare\n      vb1e(:,:,:,:,:) = (0._DP, 0._DP)\n      vb2e(:,:,:,:,:) = (0._DP, 0._DP)\n      mb1e(:,:,:,:,:) = (0._DP, 0._DP)\n      mb2e(:,:,:,:,:) = (0._DP, 0._DP)\n       gge(:,:,:,:,:) = (0._DP, 0._DP)\n!     vb1o(:,:,:,:) = (0._DP, 0._DP)\n!     vb2o(:,:,:,:) = (0._DP, 0._DP)\n!     mb1o(:,:,:,:) = (0._DP, 0._DP)\n!     mb2o(:,:,:,:) = (0._DP, 0._DP)\n!      ggo(:,:,:,:) = (0._DP, 0._DP)\n      cf(:,:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n!!%%% Without overlap %%%\n      call colli_LB_buffin_v2(ff, phi, vb1e, mb1e)\n      call bndry_vm_sendrecv_v2(vb1e, vb2e, mb1e, mb2e)\n      !!!call colli_LB_buffout_v2(ff, phi, vb2e, mb2e, gge)\n      !!!call colli_LB_calc_v2(gge, cf)\n      ! mod by M.Nakata 20200928\n      call colli_LB_buffout_v3_sx(ff, phi, vb2e, mb2e, gge)   \n      call colli_LB_calc_v3_sx(gge, cf)\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n!      do iz = -nz, nz-1+3\n!        if (mod(iz+nz,2) == 0) then ! even\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1e, mb1e)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2e, mb2e, gge)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, ggo, cf)\n!        else                        ! odd\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1o, mb1o)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2o, mb2o, ggo)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, gge, cf)\n!        end if\n!!$OMP barrier\n!      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( vb1e )\n      deallocate( vb2e )\n      deallocate( mb1e )\n      deallocate( mb2e )\n      deallocate( gge )\n!     deallocate( vb1o )\n!     deallocate( vb2o )\n!     deallocate( mb1o )\n!     deallocate( mb2o )\n!     deallocate( ggo )\n\n  END SUBROUTINE colli_LB\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_buffin( iz, ff, phi, vb1, mb1 )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    real(kind=DP) :: cs1\n    integer :: mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_ymb)\n      do iv = 1, nvb\n        do im = 0, nm\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im) &\n                                  + cs1 * fmx(iz,         iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n              vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im) &\n                                  + cs1 * fmx(iz,2*nv-nvb+iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_yvb)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1) &\n                                  + cs1 * fmx(iz,iv,     im-1) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im) &\n                                  + cs1 * fmx(iz,iv,nm-nvb+im) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffin\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout( iz, ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          do im = 0, nm\n            do iv = 1, 2*nv\n              gg(iv,im,mx,my) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = (0._DP, 0._DP)\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = (0._DP, 0._DP)\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc( iz, gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                         ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n      cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n      cef4 = nu_s / ( 12._DP * dvp(iz) )\n      cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                  / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n\n      if ( rankm /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                           ) * cef1                                    &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &      \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankm == 0\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            im = 0\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            -          gg(iv,im+2,mx,my)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            im = 1\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im  ,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im  ,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &   \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            do im = 2, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                    ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc\n\n\n\n!!--------------------------------------\n!  SUBROUTINE colli_LB( ff, phi, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n!    integer :: iz\n!\n!      allocate( vb1e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!\n!!$OMP parallel default(none) &\n!!$OMP shared(ff,cf,vb1e,vb2e,mb1e,mb2e) &\n!!$OMP shared(vb1o,vb2o,mb1o,mb2o) &\n!!$OMP private(iz)\n!\n!!!%%% Without overlap %%%\n!!      do iz = -nz, nz-1\n!!        call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!!!$OMP barrier\n!!!$OMP master\n!!        call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!!$OMP end master\n!!!$OMP barrier\n!!        call bndry_vm_buffout(iz, vb2e, mb2e, ff)\n!!!$OMP barrier\n!!        call colli_LB_model_rev(iz, ff, cf)\n!!!$OMP barrier\n!!      end do\n!!!%%%%%%%%%%%%%%%%%%%%%%%\n!\n!\n!!%%% With overlap %%%\n!      do iz = -nz, nz-1+3\n!        if (mod(iz+nz,2) == 0) then ! even\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2e, mb2e, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        else                        ! odd\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1o, mb1o)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2o, mb2o, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        end if\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%\n!\n!!$OMP end parallel\n!\n!      deallocate( vb1e )\n!      deallocate( vb2e )\n!      deallocate( mb1e )\n!      deallocate( mb2e )\n!      deallocate( vb1o )\n!      deallocate( vb2o )\n!      deallocate( mb1o )\n!      deallocate( mb2o )\n!\n!  END SUBROUTINE colli_LB\n!\n!\n!!--------------------------------------\n!  ", "SUBROUTINE colli_LB_model_rev( iz, ff, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    integer, intent(in) :: iz\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4\n!    integer  ::  mx, my, iv, im\n!\n!\n!!$OMP master\n!                                           call clock_sta(1311)\n!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!$OMP end master\n!\n!! --- Note that nu(ranks) is a bias factor \n!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!      nu_s = 1.d-3\n!\n!      cef1   = nu_s / ( 12._DP * dv * dv )\n!      cef2   = nu_s / ( 12._DP * dv )\n!      cef3   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!      cef4   = nu_s / ( 12._DP * dvp(iz) )\n!\n!      if( rankm /= 0  ) then\n!\n!        do im = 0, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!                              -          ff(mx,my,iz,iv-2,im)                 &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                               * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      else\n!\n!        im = 0\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -          ff(mx,my,iz,iv,im+2)                &\n!                             ) * cef3 * 2._DP                                 &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        im = 1\n!\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        do im = 2, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      end if\n!\n!!$OMP master\n!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!                                      call clock_end(1311)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE colli_LB_model_rev\n\n\n\n\n!!!!%%% Subroutines for colli_LB (old version) %%%\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_LB( ff, phi, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    integer :: im\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(ff,cf,vb1,vb2,mb1,mb2) &\n!!!!$OMP private(im)\n!!!\n!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!$OMP barrier\n!!!\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!      call colli_zeroset( cf )\n!!!!$OMP barrier\n!!!\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_m_buffout ( mb2, ff )\n!!!!$OMP barrier\n!!!\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!      call colli_LB_model( ff, nm-1, cf(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!      call colli_LB_model( ff, nm, cf(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!\n!!!  END SUBROUTINE colli_LB\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_LB_model( ff, im, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    real(kind=DP) :: nu_s, cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3, cef4\n!!!    integer  ::  mx, my, iz, iv\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1311)\n!!!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!! --- Note that nu(ranks) is a bias factor \n!!!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!!!      nu_s = 1.d-3\n!!!\n!!!      cef1   = nu_s / ( 12._DP * dv * dv )\n!!!      cef2   = nu_s / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!        cef4(iz)   = nu_s / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!      if( rankm /= 0  ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                           &\n!!!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!!!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!!!                              -          ff(mx,my,iz,iv-2,im)                 &\n!!!                             ) * cef1                                         &\n!!!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                               +          ff(mx,my,iz,iv-2,im)                &\n!!!                             ) * cef2 * vl(iv)                                &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               -          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef3(iz)                                     &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!!!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!!$OMP end do nowait\n!!!          end do\n!!!\n!!!      else\n!!!\n!!!          if ( im == 0 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -          ff(mx,my,iz,iv,im+2)                &\n!!!                               ) * cef3(iz) * 2._DP                             &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else if ( im == 1 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else  ! 2=<im=<nm\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          end if\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_LB_model\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_zeroset( cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    zero clear for collision terms \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)    :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv,im) = ( 0._DP, 0._DP )     \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_zeroset\n\n\n!!!%%% Subroutines for colli_full %%%\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 4th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 12._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 32._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -  2._DP * ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 31._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[2,nm] nm for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( -          ff(mx,my,iz,iv,im-2)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT6( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 6th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 90._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 60._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 90._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 270._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               -   27_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +   2._DP * ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 135._DP  * ff(mx,my,iz,iv,im-1)                   &\n!!!                               - 258.5_DP * ff(mx,my,iz,iv,im  )                   &\n!!!                               + 136._DP  * ff(mx,my,iz,iv,im+1)                   &\n!!!                               - 13.5_DP  * ff(mx,my,iz,iv,im+2)                   &\n!!!                               +            ff(mx,my,iz,iv,im+3)                   &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 2 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 136._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[3,nm] for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( +           ff(mx,my,iz,iv,im-3)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_DT( moment_ab_wk, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Non-isothermal terms of test particle part and field particle part \n!!!!                                                      in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1312)\n!!!                                    ! call fapp_start(\"literm_colli_dt\",1312,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dt\",1312,1)\n!!!                                      call clock_end(1312)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_GK_CF_DT(moment_ba_wk, moment_ab_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle and non-isothermal parts in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk, moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CF(moment_ba_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle part in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)         \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_calc( hh, phi, ww )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: local velocity moment part \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!\n!!!    !complex(kind=DP), intent(out), &\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!\n!!!    real(kind=DP) :: v2a, v2b, dflg\n!!!    complex(kind=DP) :: wf1, wf2\n!!!    integer :: mx, my, iz, iv, im, is1, is2, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1314)\n!!!                                    ! call fapp_start(\"literm_colli_mom\",1314,1)\n!!!!$OMP end master\n!!!\n!!!      if ( rankm == 0 ) then\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii,v2a,v2b,wf1,wf2)\n!!!      do ii = 1, 6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!\n!!!! for edge compensation\n!!!!         im  = 1\n!!!          do im = 1, 1\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !v2a = vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    !v2b = vfunc(mx,my,iz,iv,im+1,is2,ii)\n!!!                    v2a = jfunc(mx,my,iz,im,ii)  *vfunc(iz,iv,im,is2,ii)\n!!!                    v2b = jfunc(mx,my,iz,im+1,ii)*vfunc(iz,iv,im+1,is2,ii)\n!!!                    wf1 = hh(mx,my,iz,iv,im)   \n!!!                    wf2 = hh(mx,my,iz,iv,im+1)\n!!!                    ww(mx,my,iz,is2,ii)  = ww(mx,my,iz,is2,ii)            &\n!!!                          - ( - wf1/12._DP*v2a + ( wf2*v2b - wf1*2._DP*v2a )*11._DP/720._DP ) \n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      else\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii)\n!!!      do ii=1,6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_mom\",1314,1)\n!!!                                      call clock_end(1314)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_calc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_redc( ww, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: All_reduce_part\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww\n!!! \n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: wn\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1315)\n!!!                                         ! call fapp_start(\"literm_colli_ar\",1315,1)\n!!!!$OMP end master\n!!!\n!!!      call MPI_Allreduce( ww, wn, nxyz*ns*6, MPI_DOUBLE_COMPLEX, &\n!!!                          MPI_SUM, vel_comm_world, ierr_mpi )\n!!!\n!!!!$OMP master\n!!!                                         ! call fapp_stop(\"literm_colli_ar\",1315,1)\n!!!                                           call clock_end(1315)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_redc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_comm_alltoall( wm, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Inter-species communication of moment quantities for field particle part\n!!!!       with MPI_AlltoAll\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wm\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wn\n!!!\n!!!    complex(kind=DP),              & \n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:6,0:ns-1)  :: send_buff, recv_buff\n!!!\n!!!    integer :: mx, my, iz, is, ii\n!!!    integer :: datasize, datasize_ns\n!!!\n!!!\n!!!!$OMP master\n!!!                                       call clock_sta(1316)\n!!!                                     ! call fapp_start(\"literm_colli_com\",1316,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      datasize = (2*nx+1)*(ny+1)*(2*nz)*6\n!!!      datasize_ns = (2*nx+1)*(ny+1)*(2*nz)*6*ns\n!!!\n!!!      if ( vel_rank == 0 ) then\n!!!\n!!!        do ii = 1, 6\n!!!          do is = 0, ns-1\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!!                  send_buff(mx,my,iz,ii,is)  = real(ranks,kind=DP) + ii ! for debug\n!!!                  send_buff(mx,my,iz,ii,is)  = wm(mx,my,iz,is,ii)\n!!!                end do\n!!!              end do \n!!!            end do\n!!!          end do\n!!!        end do\n!!!\n!!!\n!!!          call MPI_Alltoall( send_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  &\n!!!                             recv_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  & \n!!!                             col_comm_world, ierr_mpi  )\n!!! \n!!!!! --- for debug \n!!!!        write(unit=8000+ranks,fmt=\"(I3,SP,6ES24.15e3)\") ranks, real(recv_buff(0,1,1,1,0)), real(recv_buff(0,1,1,6,0)), &\n!!!!                                                           real(recv_buff(0,1,1,1,1)), real(recv_buff(0,1,1,6,1)), &\n!!!!                                                           real(recv_buff(0,1,1,1,2)), real(recv_buff(0,1,1,6,2))\n!!!!        write(unit=8000+ranks,fmt=*)\n!!!\n!!!      end if\n!!!\n!!!\n!!!      call MPI_Bcast( recv_buff(-nx,ist_y,-nz,1,0), datasize_ns, MPI_DOUBLE_COMPLEX, & \n!!!                      0, vel_comm_world, ierr_mpi  ) \n!!!\n!!!\n!!!      do is = 0, ns-1\n!!!        do ii = 1, 6\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wn(mx,my,iz,is,ii) = recv_buff(mx,my,iz,ii,is)\n!!!              end do\n!!!            end do \n!!!          end do\n!!!        end do         \n!!!      end do         \n!!!\n!!!!$OMP master\n!!!                                     ! call fapp_stop(\"literm_colli_com\",1316,1)\n!!!                                       call clock_end(1316)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_comm_alltoall\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_dfdvp( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 4th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im  )                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!        do im = 2, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!\n!!!      else   \n!!!\n!!!        do im = 0, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_dfdvp6( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 6th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 60._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 44._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 2\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 46._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 3, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!\n!!!      else   \n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_hhset(hh,phi,ff)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    real(kind=DP) :: dflg\n!!!    integer :: mx, my, iz, iv, im, is1\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!     !dflg = real(1-icheck,kind=DP)\n!!!      dflg = real(1-icheck,kind=DP) * real(iFLR,kind=DP)\n!!!\n!!!      is1 = ranks\n!!!!$OMP do collapse(2) private(mx,my,iz,iv,im)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                hh(mx,my,iz,iv,im) = ( ff(mx,my,iz,iv,im) + dflg*sgn(is1)*j0(mx,my,iz,im)*phi(mx,my,iz)   &\n!!!                                                                * fmx(iz,iv,im)*Znum(is1)/tau(is1) )      &\n!!!                                    * vp(iz,im) * dvp(iz) * dv * twopi\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_hhset\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_wwset(ww)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!    integer :: mx, my, iz, is1, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,is1,ii)\n!!!    do ii = 1, 6\n!!!      do is1 = 0, ns-1\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx, nx\n!!!              ww(mx,my,iz,is1,ii) = ( 0._DP, 0._DP )\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!    end do \n!!!!$OMP end do\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_wwset\n!!!\n!!!\n!!!!!--------------------------------------\n!!!!  ", "SUBROUTINE colli_full( ff, phi, cf ) ! Analytic derivative of J0*phi\n!!!!!--------------------------------------\n!!!!!   Sugama collision operator\n!!!!\n!!!!    complex(kind=DP), intent(inout), &\n!!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!!    complex(kind=DP), intent(in), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!!    complex(kind=DP), intent(out), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!!\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!!\n!!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff,phi,dfdvp) &\n!!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP private(im,ii) \n!!!!\n!!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!      call colli_hhset(hh2,phi,ff)\n!!!!      call colli_wwset(wrkm)\n!!!!!$OMP barrier\n!!!!\n!!!!!----------------------------------------------------- ovlp1\n!!!!!$OMP master\n!!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!!$OMP end master\n!!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!!      call colli_zeroset( cff )\n!!!!\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      call bndry_shifts_m_buffout ( mb2, ff )\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp2\n!!!!!$OMP master\n!!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!!$OMP end master\n!!!!\n!!!!!!!      call colli_dfdvp6( ff, dfdvp )  ! 6th-order CFD\n!!!!      call colli_dfdvp( ff, dfdvp )  ! 4th-order CFD\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp3\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!! ! --- No calculations appear here in f0.52 (Nakata July2015)\n!!!! !!!      call colli_zeroset( cdt )\n!!!!\n!!!!!$OMP barrier\n!!!!\n!!!!      do im = 1, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!!\n!!!!!-----------------------------------------------------\n!!!!!$OMP end parallel\n!!!!\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP shared(phi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!!\n!!!!!----------------------------------------------------- ovlp4\n!!!!!$OMP master\n!!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!!$OMP end master\n!!!!\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!!do nn = 0, ns-1\n!!!!  do iz = -nz, nz-1\n!!!!    do my = ist_y, iend_y\n!!!!      do mx = -nx, nx\n!!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!!\n!!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!!      enddo\n!!!!    enddo\n!!!!  enddo\n!!!!enddo\n!!!!!$OMP enddo\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp5\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp6\n!!!!      im = 1\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp7\n!!!!      im = 2\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD \n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp8\n!!!!      do im = 3, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD\n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!!----------------------------------------------------- \n!!!!\n!!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!!$OMP barrier\n!!!!\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP end parallel\n!!!!\n!!!!!$OMP parallel workshare\n!!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!!$OMP end parallel workshare\n!!!!\n!!!!      deallocate( vb1 )\n!!!!      deallocate( vb2 )\n!!!!      deallocate( mb1 )\n!!!!      deallocate( mb2 )\n!!!!      deallocate( cft )\n!!!!      deallocate( cff )\n!!!!      deallocate( wrkm )\n!!!!      deallocate( moment_ab )\n!!!!      deallocate( moment_ba )\n!!!!      deallocate( moment_ab_wk )\n!!!!      deallocate( moment_ba_wk )\n!!!!      deallocate( dfdvp )\n!!!!      deallocate( hh2 )\n!!!!\n!!!!  END SUBROUTINE colli_full\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_full( ff, phi, cf ) ! Finite difference of J0*phi\n!!!!--------------------------------------\n!!!!   Sugama collision operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: wff\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: wphi\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!\n!!!!$OMP parallel do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wff(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n!!!                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n!!!                                                                     * real(iFLR, kind=DP)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!      wphi(:,:,:) = (0._DP, 0._DP)\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(ff,wff,phi,dfdvp) &\n!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP private(im,ii) \n!!!\n!!!      call bndry_shifts_m_buffin ( wff, mb1, mb2 )\n!!!      call colli_hhset(hh2,phi,ff)\n!!!      call colli_wwset(wrkm)\n!!!!$OMP barrier\n!!!\n!!!!----------------------------------------------------- ovlp1\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!      call colli_zeroset( cff )\n!!!\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      call bndry_shifts_m_buffout ( mb2, wff )\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp2\n!!!!$OMP master\n!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!$OMP end master\n!!!\n!!!!!!      call colli_dfdvp6( ff, dfdvp )  ! 6th-order CFD\n!!!      call colli_dfdvp( wff, dfdvp )  ! 4th-order CFD\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp3\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!! ! --- No calculations appear here in f0.52 (Nakata July2015)\n!!! !!!      call colli_zeroset( cdt )\n!!!\n!!!!$OMP barrier\n!!!\n!!!      do im = 1, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!\n!!!!-----------------------------------------------------\n!!!!$OMP end parallel\n!!!\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(wff) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP shared(wphi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!\n!!!!----------------------------------------------------- ovlp4\n!!!!$OMP master\n!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!$OMP end master\n!!!\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( wff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!do nn = 0, ns-1\n!!!  do iz = -nz, nz-1\n!!!    do my = ist_y, iend_y\n!!!      do mx = -nx, nx\n!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!\n!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!      enddo\n!!!    enddo\n!!!  enddo\n!!!enddo\n!!!!$OMP enddo\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp5\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp6\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp7\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD \n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp8\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) )  ! 4th-order CFD\n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!!----------------------------------------------------- \n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), wff(:,:,:,:,nm) )\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) )  ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) )  ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!!$OMP parallel workshare\n!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!$OMP end parallel workshare\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!      deallocate( cft )\n!!!      deallocate( cff )\n!!!      deallocate( wrkm )\n!!!      deallocate( moment_ab )\n!!!      deallocate( moment_ba )\n!!!      deallocate( moment_ab_wk )\n!!!      deallocate( moment_ba_wk )\n!!!      deallocate( dfdvp )\n!!!      deallocate( hh2 )\n!!!\n!!!  END SUBROUTINE colli_full\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_buffin_v2( ff, phi, vb1, mb1 )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n\n    real(kind=DP) :: cs1\n    integer :: mx, my, iz, iv, im\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!!TBI!! !$OMP do collapse(3) schedule(dynamic,nchunk_ymb)\n      do iv = 1, nvb\n        do im = 0, nm\n         do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vb1(mx,my,iz,im,iv    ) = ff(mx,my,iz,         iv,im) &\n                                  + cs1 * fmx(iz,         iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n              vb1(mx,my,iz,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im) &\n                                  + cs1 * fmx(iz,2*nv-nvb+iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n         end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n!!TBI!! !$OMP do collapse(3) schedule(dynamic,nchunk_yvb)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n         do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iz,iv,im    ) = ff(mx,my,iz,iv,     im-1) &\n                                  + cs1 * fmx(iz,iv,     im-1) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,     im-1)\n              mb1(mx,my,iz,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im) &\n                                  + cs1 * fmx(iz,iv,nm-nvb+im) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,nm-nvb+im)\n            end do\n          end do\n         end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffin_v2\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout_v2( ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny,-nz:nz-1) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iz, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do iz = -nz, nz-1\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          do im = 0, nm\n            do iv = 1, 2*nv\n              gg(iv,im,mx,my,iz) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my,iz) = (0._DP, 0._DP)\n                gg(2*nv+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv    )\n                gg(2*nv+iv,im,mx,my,iz) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv    )\n                gg(2*nv+iv,im,mx,my,iz) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my,iz) = (0._DP, 0._DP)\n                gg(iv,nm+im    ,mx,my,iz) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my,iz) = mb2(mx,my,iz,iv,im    )\n                gg(iv,nm+im    ,mx,my,iz) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my,iz) = mb2(mx,my,iz,iv,im    )\n                gg(iv,nm+im    ,mx,my,iz) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout_v2\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout_v3_sx( ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n!  This is for SX-Aurora TSUBASA (mod by M. Nakata, 20200928)\n!  DO NOT use overlap with OMP \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iz, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              gg(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!! !$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 0, nm\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,-nvb+iv,im) = (0._DP, 0._DP)\n                gg(mx,my,iz,2*nv+iv,im) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 0, nm\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,-nvb+iv,im) = vb2(mx,my,iz,im,iv    )\n                gg(mx,my,iz,2*nv+iv,im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 0, nm\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,-nvb+iv,im) = vb2(mx,my,iz,im,iv    )\n                gg(mx,my,iz,2*nv+iv,im) = vb2(mx,my,iz,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 1, nvb\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,-nvb-1+im) = (0._DP, 0._DP)\n                gg(mx,my,iz,iv,nm+im) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 1, nvb\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                gg(mx,my,iz,iv,nm+im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      else\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do im = 1, nvb\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                gg(mx,my,iz,iv,nm+im ) = mb2(mx,my,iz,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!! !$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout_v3_sx\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc_v3_sx( gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                         ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n\n\n      if ( rankm /= 0 ) then\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                           ) * cef1                                    &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im-1)               &\n                            -          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef3                                     &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            +  8._DP * gg(mx,my,iz,iv,im+1)               &\n                            -  8._DP * gg(mx,my,iz,iv,im-1)               &\n                            +          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &      \n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n              end do\n            end do\n\n          end do\n        end do\n\n        end do\n!!TBI!! !$OMP end do nowait\n\n      else ! rankm == 0\n\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n          do iv = 1, 2*nv\n\n            im = 0\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef1                                     &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            -          gg(mx,my,iz,iv,im+2)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &\n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n              end do\n            end do\n\n            im = 1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef1                                     &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im-1)               &\n                            -          gg(mx,my,iz,iv,im  )               &\n                          ) * cef3                                     &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            +  8._DP * gg(mx,my,iz,iv,im+1)               &\n                            -  8._DP * gg(mx,my,iz,iv,im-1)               &\n                            +          gg(mx,my,iz,iv,im  )               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &   \n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n              end do\n            end do\n\n            do im = 2, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(mx,my,iz,iv+2,im)               &\n                            + 16._DP * gg(mx,my,iz,iv+1,im)               &\n                            - 30._DP * gg(mx,my,iz,iv  ,im)               &\n                            + 16._DP * gg(mx,my,iz,iv-1,im)               &\n                            -          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef1                                     &\n                        + ( -          gg(mx,my,iz,iv+2,im)               &\n                            +  8._DP * gg(mx,my,iz,iv+1,im)               &\n                            -  8._DP * gg(mx,my,iz,iv-1,im)               &\n                            +          gg(mx,my,iz,iv-2,im)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            + 16._DP * gg(mx,my,iz,iv,im+1)               &\n                            - 30._DP * gg(mx,my,iz,iv,im  )               &\n                            + 16._DP * gg(mx,my,iz,iv,im-1)               &\n                            -          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef3                                     &\n                        + ( -          gg(mx,my,iz,iv,im+2)               &\n                            +  8._DP * gg(mx,my,iz,iv,im+1)               &\n                            -  8._DP * gg(mx,my,iz,iv,im-1)               &\n                            +          gg(mx,my,iz,iv,im-2)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(mx,my,iz,iv,im)               &\n                        - cflr * ksq(mx,my,iz) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n\n          end do\n\n        end do\n!!TBI!! !$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                    ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc_v3_sx\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc_v2( gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny,-nz:nz-1) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                        ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n\n\n      if ( rankm /= 0 ) then\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                           ) * cef1                                    &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im-1,mx,my,iz)               &\n                            -          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            +  8._DP * gg(iv,im+1,mx,my,iz)               &\n                            -  8._DP * gg(iv,im-1,mx,my,iz)               &\n                            +          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &      \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n            end do\n\n          end do\n        end do\n\n        end do\n!!TBI!!!$OMP end do nowait\n\n      else! rankm == 0\n\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do iz = -nz, nz-1\n          cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cef4 = nu_s / ( 12._DP * dvp(iz) )\n          cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                      / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            im = 0\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            -          gg(iv,im+2,mx,my,iz)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n\n            im = 1\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im-1,mx,my,iz)               &\n                            -          gg(iv,im ,mx,my,iz)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            +  8._DP * gg(iv,im+1,mx,my,iz)               &\n                            -  8._DP * gg(iv,im-1,mx,my,iz)               &\n                            +          gg(iv,im ,mx,my,iz)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &   \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n\n            do im = 2, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my,iz)               &\n                            + 16._DP * gg(iv+1,im,mx,my,iz)               &\n                            - 30._DP * gg(iv ,im,mx,my,iz)               &\n                            + 16._DP * gg(iv-1,im,mx,my,iz)               &\n                            -          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my,iz)               &\n                            +  8._DP * gg(iv+1,im,mx,my,iz)               &\n                            -  8._DP * gg(iv-1,im,mx,my,iz)               &\n                            +          gg(iv-2,im,mx,my,iz)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            + 16._DP * gg(iv,im+1,mx,my,iz)               &\n                            - 30._DP * gg(iv,im ,mx,my,iz)               &\n                            + 16._DP * gg(iv,im-1,mx,my,iz)               &\n                            -          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my,iz)               &\n                            +  8._DP * gg(iv,im+1,mx,my,iz)               &\n                            -  8._DP * gg(iv,im-1,mx,my,iz)               &\n                            +          gg(iv,im-2,mx,my,iz)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my,iz)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my,iz)\n              end do\n            end do\n\n          end do\n        end do\n\n        end do\n!!TBI!!!$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                   ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc_v2\n\n\nEND MODULE GKV_colli\n", "MODULE GKV_igs\n!-------------------------------------------------------------------------------\n!\n!    Calculate the magnetic field components and metric coefficients\n!      from the MEUDAS or G-EQDSK equilibrium by using IGS code. \n!\n!    Notes\n!    -----\n!      1D and 2D equilibrium profiles, e.g., q(Psi), Psi(R,Z), \n!        from a free-boundary 2D Grad-shafranov solver MEUDAS or from G-EQDSK \n!          are converted to SFL magnetic coordinates (Axisym/Boozer/Hamada) \n!            by the interface code IGS developed by A. Matsuyama and M. Nakata. \n!\n!    Update history of gkvp_igs.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!      gkvp_r1.3 (M. Nakata, May 2013)\n!        - First implementation.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public :: igs_read, igs_coeff\n\n  real(kind=DP), dimension(:),       allocatable   :: ss_mc, q_mc, shat_mc, eps_mc, bsq_mc\n  real(kind=DP), dimension(:),       allocatable   :: theta_mc\n  real(kind=DP), dimension(:,:,:,:), allocatable   :: ggup_mc, ggdn_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: Bupt_mc, Bupz_mc, Bdns_mc, Bdnt_mc, Bdnz_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: dBdt_mc, dBds_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: B_mc, rootg_mc\n  real(kind=DP), dimension(:,:),     allocatable   :: real2axi_mc, axi2mag_mc\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE igs_read(mc_type, nss, ntheta)\n!--------------------------------------\n\n    implicit none\n\n    integer, intent(in)        :: mc_type, nss, ntheta\n    integer                    :: is, jj, ierr, imds\n    character(512) :: f_igs\n\n    namelist /igsf/ f_igs\n\n    allocate(ss_mc(1:nss),q_mc(1:nss),shat_mc(1:nss),eps_mc(1:nss),bsq_mc(1:nss))\n    allocate(theta_mc(1:ntheta))\n    allocate(ggup_mc(1:ntheta,1:nss,1:3,1:3),ggdn_mc(1:ntheta,1:nss,1:3,1:3))\n    allocate(Bupt_mc(1:ntheta,1:nss),Bupz_mc(1:ntheta,1:nss))\n    allocate(Bdns_mc(1:ntheta,1:nss),Bdnt_mc(1:ntheta,1:nss),Bdnz_mc(1:ntheta,1:nss))\n    allocate(dBdt_mc(1:ntheta,1:nss),dBds_mc(1:ntheta,1:nss))\n    allocate(B_mc(1:ntheta,1:nss),rootg_mc(1:ntheta,1:nss))\n    allocate(real2axi_mc(1:ntheta,1:nss),axi2mag_mc(1:ntheta,1:nss))\n\n      read(inml,nml=igsf)\n      imds = 5000\n    \n      if ( mc_type == 0 ) then\n\n        open( imds, file=trim(f_igs)//\"METRIC_axi.OUT\", status=\"old\", action=\"read\" )\n        write(olog,*) \"# mag.coord.(IGS) input files : \"\n        write(olog,*) trim(f_igs)//\"METRIC_axi.OUT\"\n        write( olog, * ) \n\n      else if ( mc_type == 1 ) then\n\n        open( imds, file=trim(f_igs)//\"METRIC_boz.OUT\", status=\"old\", action=\"read\" )\n        write(olog,*) \" # mag.coord.(IGS) input files : \"\n        write(olog,*) trim(f_igs)//\"METRIC_boz.OUT\"\n        write( olog, * ) \n\n      else if ( mc_type == 2 ) then\n\n        open( imds, file=trim(f_igs)//\"METRIC_ham.OUT\", status=\"old\", action=\"read\" )\n        write(olog,*) \" # mag.coord.(IGS) input files : \"\n        write(olog,*) trim(f_igs)//\"METRIC_ham.OUT\"\n        write( olog, * ) \n\n      else \n\n        write(*,*) \"## Invalid mc_type setting!!\" \n        call MPI_Finalize(ierr)\n        stop \n\n      end if  \n\n! --- read B-field and metric components\n      do is = 1, nss\n        do jj = 1, ntheta\n          read(imds,fmt=\"(2f15.8, SP, 27ES24.15e3)\")   ss_mc(is), theta_mc(jj),   &\n                    q_mc(is),           shat_mc(is),            eps_mc(is),   &\n                 B_mc(jj,is),            bsq_mc(is),       rootg_mc(jj,is),   &\n          ggdn_mc(jj,is,1,1),    ggdn_mc(jj,is,1,2),    ggdn_mc(jj,is,1,3),   &\n          ggdn_mc(jj,is,2,2),    ggdn_mc(jj,is,2,3),    ggdn_mc(jj,is,3,3),   &\n          ggup_mc(jj,is,1,1),    ggup_mc(jj,is,1,2),    ggup_mc(jj,is,1,3),   &\n          ggup_mc(jj,is,2,2),    ggup_mc(jj,is,2,3),    ggup_mc(jj,is,3,3),   &\n              Bupt_mc(jj,is),        Bupz_mc(jj,is),        Bdnt_mc(jj,is),   &  \n              Bdnz_mc(jj,is),        Bdns_mc(jj,is),        dBds_mc(jj,is),   &\n              dBdt_mc(jj,is),    real2axi_mc(jj,is),     axi2mag_mc(jj,is)\n        end do\n        read(imds,fmt=*) \n      end do\n\n      return \n\n  END SUBROUTINE igs_read\n\n\n!----------------------------------------------------------------------------------\n  SUBROUTINE igs_coeff( isw,  mc_type,  nss,  ntheta,  s_input,  zz,  lz_l, & ! input \n                                   s_0,       q_0,    s_hat,   eps_r,   theta,   & ! output\n                                   omg,     rootg,   domgdx,  domgdz,  domgdy,   &\n                                  gg11,      gg12,     gg13,    gg22,            &\n                                  gg23,      gg33  )\n!----------------------------------------------------------------------------------\n\n    integer, intent(in)        :: isw, mc_type, nss, ntheta\n    real(kind=DP), intent(in)  :: s_input, zz, lz_l\n\n    real(kind=DP), intent(inout) :: s_0, q_0, s_hat, eps_r, theta\n    real(kind=DP), intent(out) :: omg, rootg, domgdx, domgdz, domgdy\n    real(kind=DP), intent(out) :: gg11, gg12, gg13, gg22, gg23, gg33\n\n! --- local variables \n    integer                    :: is0, iz0, nz0, jj0\n    real(kind=DP)              :: eps_a\n\n\n    is0 = nint(s_input*(nss-1))+1\n    \n    if (mc_type == 0 ) then \n      axi2mag_mc(:,:) = 0._DP \n    end if\n\n    if ( isw == 0 ) then \n\n      s_0   =   ss_mc(is0)\n      q_0   =    q_mc(is0)\n      s_hat = shat_mc(is0)\n      eps_r =  eps_mc(is0)\n\n    else if ( isw == 1 ) then\n\n      s_0   =   ss_mc(is0)\n\n      iz0 = nint(nz*zz/lz_l) ! get global_iz\n      nz0 = nint(pi*nz/lz_l)       ! get grid number on z=[0,pi)\n\n      if ( mod(iz0,nz0) /= 0.AND. mod(iz0/nz0,2) == 0 ) then \n   \n        jj0 = mod(iz0,nz0) + (nz0+1)\n\n      else if ( mod(iz0,nz0) /= 0.AND. mod(iz0/nz0,2) /= 0 ) then    \n\n        jj0 = mod(iz0,nz0) - (mod(iz0,nz0)/abs(mod(iz0,nz0)))*nz0 + (nz0+1)\n\n      else if ( mod(iz0,nz0) == 0.AND. mod(iz0/nz0,2) == 0 ) then    \n\n        jj0 = 0 + (nz0+1)\n\n      else if ( mod(iz0,nz0) == 0.AND. mod(iz0/nz0,2) /= 0 ) then    \n\n        jj0 = 1\n\n      end if\n              \n! --- for debug\n!      write(2000+rankg,*) iz0, jj0, nz0, zz\n\n      eps_a =  eps_mc(nss)\n     \n      theta  =  zz - real2axi_mc(jj0,is0) - axi2mag_mc(jj0,is0)\n      omg    =  B_mc(jj0,is0)\n      rootg  =  (eps_a**(-2))*q_0/s_0*rootg_mc(jj0,is0)\n      domgdx =  dBds_mc(jj0,is0)/eps_a\n      domgdz =  dBdt_mc(jj0,is0)\n      domgdy =  0._DP\n\n      gg11   =  eps_a**2 * ggup_mc(jj0,is0,1,1)\n\n      gg12   =  eps_a**2 * (  s_hat*zz*ggup_mc(jj0,is0,1,1)   &\n                             +     s_0*ggup_mc(jj0,is0,1,2)   &\n                             - s_0/q_0*ggup_mc(jj0,is0,1,3) )\n\n      gg13   =  eps_a*ggup_mc(jj0,is0,1,2)\n\n      gg22   =  eps_a**2 * (            (s_hat*zz)**2*ggup_mc(jj0,is0,1,1)   &\n                             +                 s_0**2*ggup_mc(jj0,is0,2,2)   &\n                             +           (s_0/q_0)**2*ggup_mc(jj0,is0,3,3)   & \n                             +     2._DP*s_0*s_hat*zz*ggup_mc(jj0,is0,1,2)   & \n                             -       2._DP*s_0**2/q_0*ggup_mc(jj0,is0,2,3)   & \n                             - 2._DP*s_0/q_0*s_hat*zz*ggup_mc(jj0,is0,1,3) )\n\n      gg23   =     eps_a * (  s_hat*zz*ggup_mc(jj0,is0,1,2)   &\n                             +     s_0*ggup_mc(jj0,is0,2,2)   &\n                             - s_0/q_0*ggup_mc(jj0,is0,2,3) )\n\n      gg33   =  ggup_mc(jj0,is0,2,2)\n\n    end if\n\n    return\n    \n  END SUBROUTINE igs_coeff\n\n\nEND MODULE GKV_igs\n", "MODULE GKV_colliimp\n!-------------------------------------------------------------------------------\n!\n!    Collision term by implicit solver\n!\n!    Update history of gkvp_colliimp.f90\n!    --------------\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - Treat tracer particles (fcs=0), that has no field-particle collision.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Bias factor nu is modified.\n!        - Initialization of padding iend_y<my is added.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only : clock_sta, clock_end\n  use GKV_math, only : math_j0, math_j1, math_j2\n  use GKV_fld, only : fld_esfield, fld_emfield_hh, fld_hh2ff\n\n\n  implicit none\n\n  private\n\n  integer, parameter :: nprocvms = nprocv * nprocm * nprocs\n  integer, parameter :: nbuff = ((2*nx+1)*(ny+1) - 1)/nprocvms + 1\n                        !%%% NOTE %%%\n                        ! if (mod((2*nx+1)*(ny+1),nprocvms)==0) then\n                        !   nbuff = ((2*nx+1)*(ny+1))/nprocvms \n                        ! else\n                        !   nbuff = ((2*nx+1)*(ny+1))/nprocvms + 1\n                        ! end if\n                        !%%%%%%%%%%%%\n  real(kind=DP), save :: gvl(1:2*global_nv)\n  real(kind=DP), save :: gmu(0:global_nm)\n  real(kind=DP), save :: gvp(0:global_nm,-nz:nz-1)\n  real(kind=DP), save :: gfmx(1:2*global_nv,0:global_nm,-nz:nz-1)\n  real(kind=DP), save, &\n    dimension(0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) :: gj0, gj1\n  real(kind=DP), save, &\n    dimension(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1) :: gnu_ds, gnu_ps, &\n                                                            gnu_hs, gnu_gs\n  real(kind=DP), save, &\n    dimension(1:6,1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) &\n                                             :: gvfunc, gx_tst, gy_fld\n\n  integer, parameter :: iter_max = 100\n  real(kind=DP), parameter :: res_error_max = 1.d-12\n\n  public   colliimp_set_param, colliimp_colli, colliimp_calc_colli_full, &\n           gvl, gvp, gnu_ds, gnu_ps, gnu_hs, gnu_gs\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE colliimp_set_param\n!--------------------------------------\n!   Set parameters for GK collision term\n\n    real(kind=DP), dimension(:,:,:,:,:), allocatable :: gnu_d, gnu_p, gnu_h, gnu_g\n    real(kind=DP) :: dm, kmo, gxxa, cph, dph, cgg, &\n                     gc_t01, gc_t02, cintgrl\n    integer :: mx, my, iz, iv, im, is, mxy, ibuff, ia, ib\n                                      !%%% For debug %%%\n                                      ! integer :: iproc\n                                      !%%%%%%%%%%%%%%%%%\n                                      call clock_sta(1700)\n\n      allocate( gnu_d(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n      allocate( gnu_p(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n      allocate( gnu_h(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n      allocate( gnu_g(1:2*global_nv,0:global_nm,0:ns-1,0:ns-1,-nz:nz-1) )\n\n      if ( ns == 1 ) then\n        write(olog,*) \"# Adiabatic model (ns==1) is not supported in imp_colli\"\n        call flush(olog)\n        call MPI_finalize(ierr_mpi)\n        stop\n      end if\n\n\n      do iv = 1, 2*global_nv\n        gvl(iv) = dv * ( real( iv - nv * nprocv - 1, kind=DP ) + 0.5_DP )\n      end do\n\n      dm = vmax / real( nprocm * ( nm+1 ) - 1, kind=DP )\n      do im = 0, global_nm\n        gmu(im) = 0.5_DP * ( dm * real( im, kind=DP ) )**2\n      end do\n\n      do iz = -nz, nz-1\n        do im = 0, global_nm\n          gvp(im,iz)  = sqrt( 2._DP * gmu(im) * omg(iz) )\n        end do\n      end do\n\n      do iz = -nz, nz-1\n        do im = 0, global_nm\n          do iv = 1, 2*global_nv\n            gfmx(iv,im,iz) = exp( - 0.5_DP * gvl(iv)**2 - omg(iz) * gmu(im) ) &\n                           / sqrt( twopi**3 )\n          end do\n        end do\n      end do\n\n      do ibuff = 0, nbuff-1\n        mxy = ibuff + nbuff * spc_rank\n        if (mxy <= (2*nx+1)*(ny+1)-1) then\n          mx = mod(mxy,2*nx+1) - nx\n          my = mxy / (2*nx+1)\n          do iz = -nz, nz-1\n            do is = 0, ns-1\n              do im = 0, global_nm\n                kmo = sqrt( 2._DP * ksq(mx,my,iz) * gmu(im) / omg(iz) ) &\n                    * sqrt( tau(is)*Anum(is) ) / Znum(is)\n                call math_j0( kmo, gj0(im,is,iz,ibuff) )\n                call math_j1( kmo, gj1(im,is,iz,ibuff) )\n              end do\n            end do\n          end do\n        else\n          gj0(:,:,:,ibuff) = 0._DP\n          gj1(:,:,:,ibuff) = 0._DP\n        end if\n      end do\n\n      do iz = -nz, nz-1\n        do ib = 0, ns-1\n          do ia = 0, ns-1\n            do im = 0, global_nm\n              do iv = 1, 2*global_nv\n\n                gxxa = dsqrt(gvl(iv)**2 + gvp(im,iz)**2) / dsqrt(2._DP)\n                cph = derf(calpha(ia,ib) * gxxa)\n                dph = 2._DP / dsqrt(pi) * dexp(- calpha(ia,ib)**2 * gxxa**2)\n                cgg = (cph - calpha(ia,ib) * gxxa * dph)/(calpha(ia,ib)**2 * gxxa**2) * 0.5_DP\n\n                gnu_d(iv,im,ia,ib,iz) = 0.75_DP*dsqrt(pi)*ctauiv(ia,ib)*(cph-cgg)/gxxa**3\n                gnu_p(iv,im,ia,ib,iz) = 1.50_DP*dsqrt(pi)*ctauiv(ia,ib)*(  cgg  )/gxxa**3\n               !gnu_h(iv,im,ia,ib,iz) = 0.75_DP*dsqrt(pi)*ctauiv(ia,ib)*calpha(ia,ib)*dph/gxxa**2\n                gnu_h(iv,im,ia,ib,iz) = 0.75_DP*dsqrt(pi)*ctauiv(ia,ib)*calpha(ia,ib)*dph\n                gnu_g(iv,im,ia,ib,iz) = gnu_p(iv,im,ia,ib,iz)*gxxa**2*(1._DP-calpha(ia,ib)**2)\n\n                gc_t01 = - (1._DP + calpha(ia,ib)**2)*gfmx(iv,im,iz)*gnu_p(iv,im,ia,ib,iz) * gxxa**2*gvl(iv)\n                gc_t02 = - 1.5_DP*dsqrt(pi)*ctauiv(ia,ib)*gfmx(iv,im,iz) &\n                       * ( cph - calpha(ia,ib)*gxxa*(1._DP + calpha(ia,ib)**2)*dph ) / calpha(ia,ib)**2 / gxxa\n                cintgrl = 2._DP * pi * gvp(im,iz) * dv * dvp(iz)\n\n                gvfunc(1,iv,im,ia,ib,iz) = gc_t01 / gfmx(iv,im,iz)                          * cintgrl\n                gvfunc(2,iv,im,ia,ib,iz) = gc_t01 / gfmx(iv,im,iz) * (gvp(im,iz) / gvl(iv)) * cintgrl\n                gvfunc(3,iv,im,ia,ib,iz) = gc_t02 / gfmx(iv,im,iz)                          * cintgrl\n                gvfunc(4,iv,im,ia,ib,iz) = gvl(iv)                                          * cintgrl\n                gvfunc(5,iv,im,ia,ib,iz) = gvp(im,iz)                                       * cintgrl\n                gvfunc(6,iv,im,ia,ib,iz) = (gxxa**2 - 1.5_DP)                               * cintgrl \n\n                gx_tst(1,iv,im,ia,ib,iz) = (ctheta(ia,ib) - 1._DP) * gfmx(iv,im,iz) * gvl(iv)\n                gx_tst(2,iv,im,ia,ib,iz) = gx_tst(1,iv,im,ia,ib,iz) * gvp(im,iz) / gvl(iv) \n                gx_tst(3,iv,im,ia,ib,iz) = gx_tst(1,iv,im,ia,ib,iz) * (gxxa**2/1.5_DP - 1._DP) / gvl(iv)\n                gx_tst(4,iv,im,ia,ib,iz) = (ctheta(ia,ib) - 1._DP) * (gc_t01                              &\n                                            - (ctheta(ia,ib) - 1._DP) * calpha(ia,ib) * ctauiv(ia,ib)     &\n                                              * gfmx(iv,im,iz) * gvl(iv) / dsqrt(1._DP + calpha(ia,ib)**2) )\n                gx_tst(5,iv,im,ia,ib,iz) =  gx_tst(4,iv,im,ia,ib,iz) * gvp(im,iz) / gvl(iv)  \n                gx_tst(6,iv,im,ia,ib,iz) = (ctheta(ia,ib) - 1._DP) * (gc_t02 * 2._DP/3._DP            &\n                                            - (ctheta(ia,ib) - 1._DP) * calpha(ia,ib) * ctauiv(ia,ib) &\n                                              * gfmx(iv,im,iz) * (gxxa**2/1.5_DP - 1._DP) * 2._DP     &\n                                                / (1._DP + calpha(ia,ib)**2)**1.5 )\n\n                if (fcs(ia) == 0.d0 .or. fcs(ib) == 0.d0) then !-care for tracer particle(dens=0)-\n                  gy_fld(1:6,iv,im,ia,ib,iz) = 0._DP\n                else\n                  gy_fld(1,iv,im,ia,ib,iz) = - (fcs(ib)/Znum(ib)) / (fcs(ia)/Znum(ia)) * calpha(ia,ib) * Anum(ia)  & \n                                               * tau(ib) * ctheta(ia,ib) * ctheta(ib,ia) / tau(ia) / cgamma(ia,ib) &\n                                                        * ( gc_t01 - cxi(ia,ib) * gfmx(iv,im,iz) * gvl(iv) ) \n                  gy_fld(2,iv,im,ia,ib,iz) = gy_fld(1,iv,im,ia,ib,iz) * gvp(im,iz) / gvl(iv)  \n                  gy_fld(3,iv,im,ia,ib,iz) = - (fcs(ib)/Znum(ib)) / (fcs(ia)/Znum(ia))                          & \n                                                        * tau(ib) * ctheta(ia,ib) * ctheta(ib,ia) / ceta(ia,ib) &\n                                                        * ( gc_t02                                          &\n                                                            - cxi(ia,ib)/(1._DP+calpha(ia,ib)**2)*gfmx(iv,im,iz)&\n                                                              *(2._DP*gxxa**2 - 3._DP) ) \n                  gy_fld(4,iv,im,ia,ib,iz) = - gy_fld(1,iv,im,ia,ib,iz)*cxi(ib,ia) \n                  gy_fld(5,iv,im,ia,ib,iz) = - gy_fld(2,iv,im,ia,ib,iz)*cxi(ib,ia) \n                  gy_fld(6,iv,im,ia,ib,iz) = - gy_fld(3,iv,im,ia,ib,iz)*2._DP*cxi(ib,ia)/(1._DP+calpha(ib,ia)**2) \n                end if\n\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      do iz = -nz, nz-1\n        do ia = 0, ns-1\n          gnu_ds(:,:,ia,iz) = 0._DP\n          gnu_ps(:,:,ia,iz) = 0._DP\n          gnu_hs(:,:,ia,iz) = 0._DP\n          gnu_gs(:,:,ia,iz) = 0._DP\n          do ib = 0, ns-1\n            gnu_ds(:,:,ia,iz) = gnu_ds(:,:,ia,iz) + nu(ia) * gnu_d(:,:,ia,ib,iz)\n            gnu_ps(:,:,ia,iz) = gnu_ps(:,:,ia,iz) + nu(ia) * gnu_p(:,:,ia,ib,iz)\n            gnu_hs(:,:,ia,iz) = gnu_hs(:,:,ia,iz) + nu(ia) * gnu_h(:,:,ia,ib,iz)\n            gnu_gs(:,:,ia,iz) = gnu_gs(:,:,ia,iz) + nu(ia) * gnu_g(:,:,ia,ib,iz)\n          end do              !- nu(ia) is a bias factor given in namelist\n        end do\n      end do\n                                      !%%% For debug %%%\n                                      ! mx = 1; my = 1; iz = 0; is = 0\n                                      ! if (rankw == 0 .and. rankz == 0 .and. &\n                                      !     ranks == is) then\n                                      !   do im = 0, nm\n                                      !   do iv = 1, 2*nv\n                                      !     write(910000+rankg,*)  &\n                                      !         vl(iv), vp(iz,im), &\n                                      !         fmx(iz,iv,im), &\n                                      !         j0(mx,my,iz,im), &\n                                      !         nu_ds(iz,iv,im)\n                                      !   end do\n                                      !   write(910000+rankg,*)\n                                      !   end do\n                                      ! end if\n                                      !\n                                      ! mx = 1; my = 1; iz = 0; is = 0\n                                      ! if (rankw == 0 .and. rankz == 0) then\n                                      ! call mxmy2ibuffiproc(mx,my,ibuff,iproc)\n                                      ! if (spc_rank == iproc) then\n                                      !   do im = 0, global_nm\n                                      !   do iv = 1, 2*global_nv\n                                      !     write(91,*) gvl(iv), gvp(im,iz), &\n                                      !                 gfmx(iv,im,iz),      &\n                                      !                 gj0(im,is,iz,ibuff), &\n                                      !                 gnu_ds(iv,im,is,iz)\n                                      !   end do\n                                      !   write(91,*)\n                                      !   end do\n                                      ! end if\n                                      ! end if\n                                      !%%%%%%%%%%%%%%%%%\n      deallocate( gnu_d )\n      deallocate( gnu_p )\n      deallocate( gnu_h )\n      deallocate( gnu_g )\n                                      call clock_end(1700)\n\n\n  END SUBROUTINE colliimp_set_param\n\n\n  SUBROUTINE ibuffiproc2mxmy(ibuff, iproc, mx, my)\n    integer, intent(in) :: ibuff, iproc\n    integer, intent(out) :: mx, my\n    integer :: mxy\n      mxy = ibuff + nbuff * iproc\n      !if (mxy <= (2*nx+1)*(ny+1)-1) then\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n      !end if\n  END SUBROUTINE ibuffiproc2mxmy\n\n\n  SUBROUTINE mxmy2ibuffiproc(mx, my, ibuff, iproc)\n    integer, intent(in) :: mx, my\n    integer, intent(out) :: ibuff, iproc\n    integer :: mxy\n      mxy = mx + nx + (2*nx+1) * my\n      ibuff = mod(mxy,nbuff)\n      iproc = mxy / nbuff\n  END SUBROUTINE mxmy2ibuffiproc\n\n\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colliimp_colli( ldt, ff, phi, Al, hh )\n!!!!--------------------------------------\n!!!!   Collsion operator calculation interface\n!!!\n!!!    real(kind=DP), intent(in) :: ldt\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi, Al\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: sender, recver\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wh\n!!!    integer :: iz, ibuff\n!!!\n!!!                                      !%%% For debug %%%\n!!!                                      ! complex(kind=DP) :: wphi, wAl\n!!!                                      ! integer :: mx, my, iproc\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!      allocate( sender(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( recver(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( wh(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) )\n!!!\n!!!      call vms2xy_pack(hh, sender)\n!!!      call vms2xy_transpose(sender, recver)\n!!!      call vms2xy_unpack(recver, wh)\n!!!      \n!!!                                      call clock_sta(1720)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(ldt,wh) &\n!!!!$OMP private(iz,ibuff)\n!!!!$OMP do collapse(2)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          call implicit_collision_solver(ldt, wh(:,:,:,iz,ibuff), iz, ibuff)\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1720)\n!!!\n!!!      call xy2vms_pack(wh, sender)\n!!!      call xy2vms_transpose(sender, recver)\n!!!      call xy2vms_unpack(recver, hh)\n!!!\n!!!      if ( beta .ne. 0._DP ) then\n!!!        call fld_emfield_hh( hh, Al )\n!!!      end if\n!!!      call fld_hh2ff( hh, Al, ff )\n!!!      call fld_esfield( ff, phi )\n!!!                                      !%%% For debug %%%\n!!!                                      ! mx = 1; my = 1\n!!!                                      ! call mxmy2ibuffiproc(mx,my,ibuff,iproc)\n!!!                                      ! if (rankw == 0 .and. &\n!!!                                      !     spc_rank == iproc) then\n!!!                                      !   do iz = -nz, nz-1\n!!!                                      !     call emfield_hh(wh(:,:,:,iz,ibuff),&\n!!!                                      !                     wAl, iz, ibuff)\n!!!                                      !     call esfield(wh(:,:,:,iz,ibuff), &\n!!!                                      !                  wphi, iz, ibuff)\n!!!                                      !     write(10000+rankg,*) zz(iz), &\n!!!                                      !            dble(wphi),           &\n!!!                                      !            aimag(wphi),          &\n!!!                                      !            dble(phi(mx,my,iz)),  &\n!!!                                      !            aimag(phi(mx,my,iz)), &\n!!!                                      !            dble(wAl),            &\n!!!                                      !            aimag(wAl),           &\n!!!                                      !            dble(Al(mx,my,iz)),   &\n!!!                                      !            aimag(Al(mx,my,iz))\n!!!                                      !   end do\n!!!                                      ! end if\n!!!                                      ! call MPI_finalize(ierr_mpi)\n!!!                                      ! stop\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!      deallocate( sender )\n!!!      deallocate( recver )\n!!!      deallocate( wh )\n!!!\n!!!  END SUBROUTINE colliimp_colli\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE vms2xy_pack(hh, sender)\n!!!!--------------------------------------\n!!!!   Data pack for transpose from (x,y*,z*,v*,m*,s*) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: sender\n!!!\n!!!    integer :: mx, my, iz, iv, im, ibuff, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1710)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(hh,sender) &\n!!!!$OMP private(mx,my,iz,iv,im,ibuff,iproc)\n!!!!$OMP workshare\n!!!      sender(:,:,:,:,:) = (0._DP, 0._DP)\n!!!!$OMP end workshare\n!!!!$OMP do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = 0, ny\n!!!              do mx = -nx, nx\n!!!                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n!!!                sender(iv,im,iz,ibuff,iproc) = hh(mx,my,iz,iv,im)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1710)\n!!!                                      !%%% For debug %%%\n!!!                                      ! if (rankg == 0) then\n!!!                                      ! do my = 0, ny\n!!!                                      ! do mx = -nx, nx\n!!!                                      !   mxy = mx+nx + (2*nx+1)*my\n!!!                                      !   ibuff = mod(mxy, nbuff)\n!!!                                      !   iproc = mxy / nbuff\n!!!                                      !   write(99,*) mx, my, mxy, ibuff, iproc\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end if\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!\n!!!  END SUBROUTINE vms2xy_pack\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE vms2xy_transpose(sender, recver)\n!!!!--------------------------------------\n!!!!   Transpose from (x,y*,z*,v*,m*,s*) to ((x,y*)***,z*,v,m,s) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: sender\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: recver\n!!!\n!!!\n!!!                                      call clock_sta(1711)\n!!!      call mpi_alltoall( sender,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         recver,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         spc_comm_world,              &\n!!!                         ierr_mpi     )\n!!!                                      call clock_end(1711)\n!!!\n!!!  END SUBROUTINE vms2xy_transpose\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE vms2xy_unpack(recver, wh)\n!!!!--------------------------------------\n!!!!   Data unpack for transpose to ((x,y*)***,z*,v,m,s) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: recver\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) :: wh\n!!!\n!!!    integer :: iz, iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1712)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(recver,wh) &\n!!!!$OMP private(iz,iv,im,ibuff,irs,irm,irv,iproc,gim,giv)\n!!!!$OMP workshare\n!!!      wh(:,:,:,:,:) = (0._DP, 0._DP)\n!!!!$OMP end workshare\n!!!!$OMP do collapse(5)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          do irs = 0, nprocs-1\n!!!            do irm = 0, nprocm-1\n!!!              do irv = 0, nprocv-1\n!!!                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n!!!                do im = 0, nm\n!!!                  gim = im + (nm+1)*irm\n!!!                  do iv = 1, 2*nv\n!!!                    giv = iv + (2*nv)*irv\n!!!                    wh(giv,gim,irs,iz,ibuff) = recver(iv,im,iz,ibuff,iproc)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1712)\n!!!                                      !%%% For debug %%%\n!!!                                      ! if (rankg == 0) then\n!!!                                      ! do irs = 0, nprocs-1\n!!!                                      ! do irm = 0, nprocm-1\n!!!                                      ! do irv = 0, nprocv-1\n!!!                                      !   iproc = irv + nprocv*irm &\n!!!                                      !         + nprocv*nprocm*irs\n!!!                                      ! do im = 0, nm\n!!!                                      !   gim = im + (nm+1)*irm\n!!!                                      ! do iv = 1, 2*nv\n!!!                                      !   giv = iv + (2*nv)*irv\n!!!                                      !   write(97,*) irs, irm, irv, iproc, &\n!!!                                      !               giv, gim\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end do\n!!!                                      ! end if\n!!!                                      !%%%%%%%%%%%%%%%%%\n!!!\n!!!  END SUBROUTINE vms2xy_unpack\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE xy2vms_pack(wh, sender)\n!!!!--------------------------------------\n!!!!   Data pack for transpose from ((x,y*)***,z*,v,m,s) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) :: wh\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: sender\n!!!\n!!!    integer :: iz, iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1730)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(wh,sender) &\n!!!!$OMP private(iz,iv,im,ibuff,irs,irm,irv,iproc,gim,giv)\n!!!!$OMP workshare\n!!!      sender(:,:,:,:,:) = (0._DP, 0._DP)\n!!!!$OMP end workshare\n!!!!$OMP do collapse(5)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          do irs = 0, nprocs-1\n!!!            do irm = 0, nprocm-1\n!!!              do irv = 0, nprocv-1\n!!!                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n!!!                do im = 0, nm\n!!!                  gim = im + (nm+1)*irm\n!!!                  do iv = 1, 2*nv\n!!!                    giv = iv + (2*nv)*irv\n!!!                    sender(iv,im,iz,ibuff,iproc) = wh(giv,gim,irs,iz,ibuff)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1730)\n!!! \n!!!  END SUBROUTINE xy2vms_pack\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE xy2vms_transpose(sender, recver)\n!!!!--------------------------------------\n!!!!   Transpose from ((x,y*)***,z*,v,m,s) to (x,y*,z*,v*,m*,s*) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,0:nbuff-1,-nz:nz-1,0:nprocvms-1) :: sender\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(1:2*nv,0:nm,0:nbuff-1,-nz:nz-1,0:nprocvms-1) :: recver\n!!!\n!!!\n!!!                                      call clock_sta(1731)\n!!!      call mpi_alltoall( sender,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         recver,                      &\n!!!                         (2*nv)*(nm+1)*(2*nz)*nbuff,  &\n!!!                         MPI_DOUBLE_COMPLEX,          &\n!!!                         spc_comm_world,              &\n!!!                         ierr_mpi     )\n!!!                                      call clock_end(1731)\n!!!\n!!!  END SUBROUTINE xy2vms_transpose\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE xy2vms_unpack(recver, hh)\n!!!!--------------------------------------\n!!!!   Data unpack for transpose to (x,y*,z*,v*,m*,s*) decomposition\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) :: recver\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!\n!!!    integer :: mx, my, iz, iv, im, ibuff, iproc\n!!!\n!!!\n!!!                                      call clock_sta(1732)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(recver,hh) &\n!!!!$OMP private(mx,my,iz,iv,im,ibuff,iproc)\n!!!!$OMP do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = 0, ny\n!!!              do mx = -nx, nx\n!!!                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n!!!                hh(mx,my,iz,iv,im) = recver(iv,im,iz,ibuff,iproc)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1732)\n!!!\n!!!  END SUBROUTINE xy2vms_unpack\n\n\n!--------------------------------------\n  ", "SUBROUTINE colliimp_colli( ldt, ff, phi, Al, hh )\n!--------------------------------------\n!   Collsion operator calculation interface\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable ::  &\n           send1e, recv1e, send2e, recv2e, send1o, recv1o, send2o, recv2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: wh1e, wh2e, wh1o, wh2o\n    integer :: iv, im, iz, is, ibuff, iproc\n\n      allocate( send1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( send1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ldt,hh) &\n!$OMP shared(send1e,recv1e,send2e,recv2e,wh1e,wh2e) &\n!$OMP shared(send1o,recv1o,send2o,recv2o,wh1o,wh2o) &\n!$OMP private(iv,im,iz,is,ibuff,iproc)\n      do iproc = 0, nprocvms-1\n!$OMP do\n        do ibuff = 0, nbuff-1\n          do im = 0, nm\n            do iv = 1, 2*nv\n              send1e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send1o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n      do ibuff = 0, nbuff-1\n!$OMP do\n        do is = 0, ns-1\n          do im = 0, global_nm\n            do iv = 1, 2*global_nv\n              wh1e(iv,im,is,ibuff) = (0._DP, 0._DP)\n              wh1o(iv,im,is,ibuff) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP barrier\n\n!!%%% Without overlap %%%\n!      do iz = -nz, nz-1\n!        call vms2xy_pack_iz(iz, hh, send1e)\n!!$OMP barrier\n!!$OMP master\n!        call vms2xy_transpose_iz(send1e, recv1e)\n!!$OMP end master\n!!$OMP barrier\n!        call vms2xy_unpack_iz(recv1e, wh1e)\n!!$OMP barrier\n!        call solver_wrapper_iz(ldt, iz, wh1e, wh2e)\n!!$OMP barrier\n!        call xy2vms_pack_iz(wh2e, send2e)\n!!$OMP barrier\n!!$OMP master\n!        call xy2vms_transpose_iz(send2e, recv2e)\n!!$OMP end master\n!!$OMP barrier\n!        call xy2vms_unpack_iz(iz, recv2e, hh)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n!%%% With overlap %%%\n      do iz = -nz, nz-1+6\n\n        if (mod(iz+nz,2) == 0) then ! even\n\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call vms2xy_transpose_iz(send1o, recv1o)\n          if (-nz+5<=iz .and. iz<=nz-1+5) call xy2vms_transpose_iz(send2o, recv2o)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call vms2xy_pack_iz(iz, hh, send1e)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1e, wh1e)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call solver_wrapper_iz(ldt, iz-3, wh1o, wh2o)\n          if (-nz+4<=iz .and. iz<=nz-1+4) call xy2vms_pack_iz(wh2e, send2e)\n          if (-nz+6<=iz .and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2e, hh)\n\n        else                        ! odd\n\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call vms2xy_transpose_iz(send1e, recv1e)\n          if (-nz+5<=iz .and. iz<=nz-1+5) call xy2vms_transpose_iz(send2e, recv2e)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call vms2xy_pack_iz(iz, hh, send1o)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1o, wh1o)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call solver_wrapper_iz(ldt, iz-3, wh1e, wh2e)\n          if (-nz+4<=iz .and. iz<=nz-1+4) call xy2vms_pack_iz(wh2o, send2o)\n          if (-nz+6<=iz .and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2o, hh)\n\n        end if\n!$OMP barrier\n\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      if ( beta .ne. 0._DP ) then\n        call fld_emfield_hh( hh, Al )\n      end if\n      call fld_hh2ff( hh, Al, ff )\n      call fld_esfield( ff, phi )\n\n      deallocate( send1e )\n      deallocate( recv1e )\n      deallocate( send2e )\n      deallocate( recv2e )\n      deallocate( wh1e )\n      deallocate( wh2e )\n      deallocate( send1o )\n      deallocate( recv1o )\n      deallocate( send2o )\n      deallocate( recv2o )\n      deallocate( wh1o )\n      deallocate( wh2o )\n\n  END SUBROUTINE colliimp_colli\n\n\n!--------------------------------------\n  SUBROUTINE vms2xy_pack_iz(iz, hh, sender)\n!--------------------------------------\n!   Data pack for transpose from (x,y*,z*,v*,m*,s*) decomposition\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n\n    integer :: mx, my, iv, im, ibuff, iproc\n\n!$OMP master\n                                      call clock_sta(1710)\n!$OMP end master\n      do im = 0, nm\n!$OMP do schedule(dynamic)\n        do iv = 1, 2*nv\n            do my = 0, ny\n              do mx = -nx, nx\n                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n                sender(iv,im,ibuff,iproc) = hh(mx,my,iz,iv,im)\n              end do\n            end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP master\n                                      call clock_end(1710)\n!$OMP end master\n\n  END SUBROUTINE vms2xy_pack_iz\n\n\n!--------------------------------------\n  SUBROUTINE vms2xy_transpose_iz(sender, recver)\n!--------------------------------------\n!   Transpose from (x,y*,z*,v*,m*,s*) to ((x,y*)***,z*,v,m,s) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n    complex(kind=DP), intent(out), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n\n                                      call clock_sta(1711)\n      call mpi_alltoall( sender,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         recver,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         spc_comm_world,       &\n                         ierr_mpi     )\n                                      call clock_end(1711)\n\n  END SUBROUTINE vms2xy_transpose_iz\n\n\n!--------------------------------------\n  SUBROUTINE vms2xy_unpack_iz(recver, wh)\n!--------------------------------------\n!   Data unpack for transpose to ((x,y*)***,z*,v,m,s) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wh\n\n    integer :: iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n\n!$OMP master\n                                      call clock_sta(1712)\n!$OMP end master\n!$OMP do collapse(4) schedule(dynamic)\n      do ibuff = 0, nbuff-1\n          do irs = 0, nprocs-1\n            do irm = 0, nprocm-1\n              do irv = 0, nprocv-1\n                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n                do im = 0, nm\n                  gim = im + (nm+1)*irm\n                  do iv = 1, 2*nv\n                    giv = iv + (2*nv)*irv\n                    wh(giv,gim,irs,ibuff) = recver(iv,im,ibuff,iproc)\n                  end do\n                end do\n              end do\n            end do\n          end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1712)\n!$OMP end master\n\n  END SUBROUTINE vms2xy_unpack_iz\n\n\n!--------------------------------------\n  SUBROUTINE xy2vms_pack_iz(wh, sender)\n!--------------------------------------\n!   Data pack for transpose from ((x,y*)***,z*,v,m,s) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wh\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n\n    integer :: iv, im, giv, gim, ibuff, irs, irm, irv, iproc\n\n!$OMP master\n                                      call clock_sta(1730)\n!$OMP end master\n!$OMP do collapse(4) schedule(dynamic)\n      do ibuff = 0, nbuff-1\n          do irs = 0, nprocs-1\n            do irm = 0, nprocm-1\n              do irv = 0, nprocv-1\n                iproc = irv + nprocv*irm + nprocv*nprocm*irs\n                do im = 0, nm\n                  gim = im + (nm+1)*irm\n                  do iv = 1, 2*nv\n                    giv = iv + (2*nv)*irv\n                    sender(iv,im,ibuff,iproc) = wh(giv,gim,irs,ibuff)\n                  end do\n                end do\n              end do\n            end do\n          end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1730)\n!$OMP end master\n \n  END SUBROUTINE xy2vms_pack_iz\n\n\n!--------------------------------------\n  SUBROUTINE xy2vms_transpose_iz(sender, recver)\n!--------------------------------------\n!   Transpose from ((x,y*)***,z*,v,m,s) to (x,y*,z*,v*,m*,s*) decomposition\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: sender\n    complex(kind=DP), intent(out), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n\n                                      call clock_sta(1731)\n      call mpi_alltoall( sender,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         recver,               &\n                         (2*nv)*(nm+1)*nbuff,  &\n                         MPI_DOUBLE_COMPLEX,   &\n                         spc_comm_world,       &\n                         ierr_mpi     )\n                                      call clock_end(1731)\n\n  END SUBROUTINE xy2vms_transpose_iz\n\n\n!--------------------------------------\n  SUBROUTINE xy2vms_unpack_iz(iz, recver, hh)\n!--------------------------------------\n!   Data unpack for transpose to (x,y*,z*,v*,m*,s*) decomposition\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) :: recver\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    integer :: mx, my, iv, im, ibuff, iproc\n\n!$OMP master\n                                      call clock_sta(1732)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic)\n      do im = 0, nm\n        do iv = 1, 2*nv\n            do my = 0, ny\n              do mx = -nx, nx\n                call mxmy2ibuffiproc(mx, my, ibuff, iproc)\n                hh(mx,my,iz,iv,im) = recver(iv,im,ibuff,iproc)\n              end do\n            end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1732)\n!$OMP end master\n\n  END SUBROUTINE xy2vms_unpack_iz\n\n\n!--------------------------------------\n  SUBROUTINE solver_wrapper_iz(ldt, iz, whin, whout)\n!--------------------------------------\n!   Implicit collision solver wrapper for overlap\n\n    real(kind=DP), intent(in) :: ldt\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: whin\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: whout\n\n    complex(kind=DP), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: wc3\n    integer :: ibuff\n\n!$OMP master\n                                      call clock_sta(1720)\n!$OMP end master\n!$OMP do schedule(dynamic)\n      do ibuff = 0, nbuff-1\n        wc3(:,:,:) = whin(:,:,:,ibuff)\n        call implicit_collision_solver(ldt, wc3, iz, ibuff)\n        whout(:,:,:,ibuff) = wc3(:,:,:)\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1720)\n!$OMP end master\n\n  END SUBROUTINE solver_wrapper_iz\n\n\n!--------------------------------------\n  SUBROUTINE implicit_collision_solver(ldt, wh, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    2nd C.N. : 2nd-order Crank-Nicolson method\n!\n!        (h(t+dt) - h(t))/dt = C((g(t+dt) + g(t))/2)\n!      where g is a function of h, i.e., g(t)=g(h(t)).\n!      Since C is a linearized collision operator, it is regard as A*x = b,\n!        A = 1 - dt/2*Cg,\n!        x = h(t+dt),\n!        b = g(h(t)) + dt/2*C(g(h(t))).\n!\n!    1st B.E. : 1st-order backward Euler method\n!\n!        (f(t+dt) - f(t))/dt = C(f(t+dt))\n!      It is regard as A*x = b,\n!        A = 1 - dt*Cg,\n!        x = f(t+dt),\n!        b = g(h(t)).\n!\n!    Difference between 2nd C.N and 1st B.E. appears in \"calc_ap\" and \"calc_b\".\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: wh\n    integer, intent(in) :: iz, ibuff\n  \n    complex(kind=DP), dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b, r\n    real(kind=DP) :: res_error\n    integer :: iter\n  \n      !if (maxval(abs(wh(:,:,:))) < 1.d-100) then\n      if (maxval(abs(wh(:,:,:))) < 1.d-40) then\n        return\n      else\n        res_error = 1._DP\n      end if\n\n      call calc_b(ldt, wh, b, iz, ibuff)\n      do iter = 0, iter_max-1\n        if (res_error < res_error_max) exit\n        call bi_cgstab(ldt, iter, wh, b, r, iz, ibuff)\n       !call gcr      (ldt, iter, wh, b, r, iz, ibuff)\n       !call gcr1     (ldt, iter, wh, b, r, iz, ibuff)\n       !call gcrm     (ldt, iter, wh, b, r, iz, ibuff)\n        call calc_error(r, b, res_error)\n      end do\n      if (iter == iter_max) then\n        write(olog,*) \"# Reach maximum iteration : \", iz, ibuff, iter, res_error\n      end if\n                                      !%%% For debug %%%\n                                      ! write(olog,*) \"#iter= \", iter, iz, ibuff\n                                      !%%%%%%%%%%%%%%%%%\n  \n  END SUBROUTINE implicit_collision_solver\n\n\n!--------------------------------------\n  SUBROUTINE bi_cgstab(ldt, iter, x, b, r, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Bi-conjugate gradient stabilization method (A*x = b for Non-Hermitian A)\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    integer, intent(in) :: iter\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n    integer, intent(in) :: iz, ibuff\n\n    complex(kind=DP), save, &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: p, r0\n!$OMP threadprivate(p,r0)\n    complex(kind=DP), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: s, ap, as\n    complex(kind=DP) :: alpha, beta, omega, sum1, sum2, sum3\n  \n      if (iter == 0) then                           ! r_0 = b - A*x_0, p_0 = r_0\n        call calc_r(ldt, x, b, r, iz, ibuff)\n        p(:,:,:) = r(:,:,:)\n        r0(:,:,:) = r(:,:,:)\n      end if\n  \n      call calc_ap(ldt, p, ap, iz, ibuff)\n      sum1 = sum(r0(:,:,:) * r(:,:,:))\n      sum2 = sum(r0(:,:,:) * ap(:,:,:))\n      alpha = sum1 / sum2                      ! alpha = (r_0,r_k) / (r_0,A*p_k)\n  \n      s(:,:,:) = r(:,:,:) - alpha * ap(:,:,:)          ! s_k = r_k - alpha*A*p_k\n  \n      call calc_ap(ldt, s, as, iz, ibuff)\n      sum2 = sum(s(:,:,:) * as(:,:,:))\n      sum3 = sum(as(:,:,:)**2)\n      omega = sum2 / sum3                  ! omega = (A*s_k,s_k) / (A*s_k,A*s_k)\n  \n      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:) + omega * s(:,:,:)\n                                           ! x_k+1 = x_k * alpha*p_k + omega*s_k\n      r(:,:,:) = s(:,:,:) - omega * as(:,:,:)        ! r_k+1 = s_k - omega*A*s_k\n  \n      sum3 = sum(r0(:,:,:) * r(:,:,:))\n      beta = alpha * sum3 / (omega * sum1)\n                              ! beta = (alpha / omega) * (r_0,r_k+1) / (r_0,r_k)\n  \n      p(:,:,:) = r(:,:,:) + beta * (p(:,:,:) - omega * ap(:,:,:))\n                                    ! p_k+1 = r_k+1 + beta * (p_k - omega*A*p_k)\n  \n  END SUBROUTINE bi_cgstab\n\n\n!!--------------------------------------\n!  ", "SUBROUTINE gcr(ldt, iter, x, b, r, iz, ibuff)\n!!-------------------------------------------------------------------------------\n!!\n!!    Generalized conjugate gradient method (A*x = b for Non-Hermitian A)\n!!\n!!-------------------------------------------------------------------------------\n!\n!    real(kind=DP), intent(in) :: ldt\n!    integer, intent(in) :: iter\n!    complex(kind=DP), intent(inout), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n!    complex(kind=DP), intent(in), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n!    integer, intent(in) :: iz, ibuff\n!\n!    complex(kind=DP), save, &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:iter_max-1) :: p, ap\n!!$OMP threadprivate(p,ap)\n!    complex(kind=DP), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ar\n!    complex(kind=DP) :: alpha, beta, sum1\n!    complex(kind=DP), save, &\n!      dimension(0:iter_max-1) :: sum2\n!!$OMP threadprivate(sum2)\n!    integer :: i\n!  \n!      if (iter == 0) then                           ! r_0 = b - A*x_0, p_0 = r_0\n!        call calc_r(ldt, x, b, r, iz, ibuff)\n!        p(:,:,:,iter) = r(:,:,:)\n!        call calc_ap(ldt, p(:,:,:,iter), ap(:,:,:,iter), iz, ibuff)\n!      end if\n!  \n!      sum1 = sum(ap(:,:,:,iter) * r(:,:,:))\n!      sum2(iter) = sum(ap(:,:,:,iter) * ap(:,:,:,iter))\n!      alpha = sum1 / sum2(iter)            ! alpha = (A*p_k,r_k) / (A*p_k,A*p_k)\n!  \n!      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:,iter)    ! x_k+1 = x_k + alpha*p_k\n!      r(:,:,:) = r(:,:,:) - alpha * ap(:,:,:,iter)   ! r_k+1 = r_k - alpha*A*p_k\n!  \n!      call calc_ap(ldt, r, ar, iz, ibuff)\n!\n!      p(:,:,:,iter+1) = r(:,:,:)\n!      ap(:,:,:,iter+1) = ar(:,:,:)\n!      do i = 0, iter\n!        sum1 = sum(ap(:,:,:,i) * ar(:,:,:))\n!        beta = - sum1 / sum2(i)     ! beta_i = - (A*p_i,A*r_k+1) / (A*p_i,A*p_i)\n!        p(:,:,:,iter+1) = p(:,:,:,iter+1) + beta * p(:,:,:,i)\n!                                            ! p_k+1 = r_k+1 + Sum_i^k beta_i*p_i\n!        ap(:,:,:,iter+1) = ap(:,:,:,iter+1) + beta * ap(:,:,:,i)\n!                                      ! A*p_k+1 = A*r_k+1 + Sum_i^k beta_i*A*p_i\n!      end do\n!  \n!  END SUBROUTINE gcr\n!\n!\n!!--------------------------------------\n!  SUBROUTINE gcr1(ldt, iter, x, b, r, iz, ibuff)\n!!-------------------------------------------------------------------------------\n!!\n!!    Generalized conjugate gradient method (A*x = b for Non-Hermitian A)\n!!\n!!-------------------------------------------------------------------------------\n!\n!    real(kind=DP), intent(in) :: ldt\n!    integer, intent(in) :: iter\n!    complex(kind=DP), intent(inout), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n!    complex(kind=DP), intent(in), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n!    integer, intent(in) :: iz, ibuff\n!\n!    complex(kind=DP), save, &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: p, ap\n!!$OMP threadprivate(p,ap)\n!    complex(kind=DP), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ar\n!    complex(kind=DP) :: alpha, beta, sum1, sum2\n!  \n!      if (iter == 0) then                           ! r_0 = b - A*x_0, p_0 = r_0\n!        call calc_r(ldt, x, b, r, iz, ibuff)\n!        p(:,:,:) = r(:,:,:)\n!        call calc_ap(ldt, p, ap, iz, ibuff)\n!      end if\n!  \n!      sum1 = sum(ap(:,:,:) * r(:,:,:))\n!      sum2 = sum(ap(:,:,:) * ap(:,:,:))\n!      alpha = sum1 / sum2                  ! alpha = (A*p_k,r_k) / (A*p_k,A*p_k)\n!  \n!      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:)         ! x_k+1 = x_k + alpha*p_k\n!      r(:,:,:) = r(:,:,:) - alpha * ap(:,:,:)        ! r_k+1 = r_k - alpha*A*p_k\n!  \n!      call calc_ap(ldt, r, ar, iz, ibuff)\n!      sum1 = sum(ap(:,:,:) * ar(:,:,:))\n!      beta = - sum1 / sum2            ! beta = - (A*p_k,A*r_k+1) / (A*p_k,A*p_k)\n!  \n!      p(:,:,:) = r(:,:,:) + beta * p(:,:,:)           ! p_k+1 = r_k+1 + beta*p_k\n!      ap(:,:,:) = ar(:,:,:) + beta * ap(:,:,:)  ! A*p_k+1 = A*r_k+1 + beta*A*p_k\n!  \n!  END SUBROUTINE gcr1\n!\n!\n!!--------------------------------------\n!  SUBROUTINE gcrm(ldt, iter, x, b, r, iz, ibuff)\n!!-------------------------------------------------------------------------------\n!!\n!!    Generalized conjugate gradient method (A*x = b for Non-Hermitian A)\n!!\n!!-------------------------------------------------------------------------------\n!\n!    real(kind=DP), intent(in) :: ldt\n!    integer, intent(in) :: iter\n!    complex(kind=DP), intent(inout), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, r\n!    complex(kind=DP), intent(in), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n!    integer, intent(in) :: iz, ibuff\n!\n!    integer, parameter :: m = 10\n!    complex(kind=DP), save, &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:m-1) :: p, ap\n!!$OMP threadprivate(p,ap)\n!    complex(kind=DP), &\n!      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ar\n!    complex(kind=DP) :: alpha, beta, sum1\n!    complex(kind=DP), save, &\n!      dimension(0:m-1) :: sum2\n!!$OMP threadprivate(sum2)\n!    integer :: i, k\n!  \n!      k = mod(iter,m)\n!      if (k == 0) then                    ! r_0 = b - A*x_0, p_0 = r_0\n!        call calc_r(ldt, x, b, r, iz, ibuff)\n!        p(:,:,:,k) = r(:,:,:)\n!        call calc_ap(ldt, p(:,:,:,k), ap(:,:,:,k), iz, ibuff)\n!      end if\n!  \n!      sum1 = sum(ap(:,:,:,k) * r(:,:,:))\n!      sum2(k) = sum(ap(:,:,:,k) * ap(:,:,:,k))\n!      alpha = sum1 / sum2(k)            ! alpha = (A*p_k,r_k) / (A*p_k,A*p_k)\n!  \n!      x(:,:,:) = x(:,:,:) + alpha * p(:,:,:,k)    ! x_k+1 = x_k + alpha*p_k\n!      r(:,:,:) = r(:,:,:) - alpha * ap(:,:,:,k)   ! r_k+1 = r_k - alpha*A*p_k\n!  \n!      call calc_ap(ldt, r, ar, iz, ibuff)\n!\n!      p(:,:,:,k+1) = r(:,:,:)\n!      ap(:,:,:,k+1) = ar(:,:,:)\n!      do i = 0, k\n!        sum1 = sum(ap(:,:,:,i) * ar(:,:,:))\n!        beta = - sum1 / sum2(i)     ! beta_i = - (A*p_i,A*r_k+1) / (A*p_i,A*p_i)\n!        p(:,:,:,k+1) = p(:,:,:,k+1) + beta * p(:,:,:,i)\n!                                            ! p_k+1 = r_k+1 + Sum_i^k beta_i*p_i\n!        ap(:,:,:,k+1) = ap(:,:,:,k+1) + beta * ap(:,:,:,i)\n!                                      ! A*p_k+1 = A*r_k+1 + Sum_i^k beta_i*A*p_i\n!      end do\n!  \n!  END SUBROUTINE gcrm\n\n\n!--------------------------------------\n  SUBROUTINE calc_b(ldt, wh, b, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Calculate b\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: wh\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: b\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: ww\n    complex(kind=DP) :: phi, Al\n\n      call emfield_hh(wh, Al, iz, ibuff)\n      call esfield(wh, phi, iz, ibuff)\n\n      if (iFLR == 0) then\n        call setww_ff(wh, Al, ww, iz, ibuff) ! Gyrocenter distribution\n      else\n        call setww_gg(wh, phi, Al, ww, iz, ibuff) ! Non-adiabatic distribution\n      end if\n\n      if (trim(col_type) == \"LB\") then\n        call collision_LB(ww, b, iz, ibuff)\n      else if (trim(col_type) == \"lorentz\") then\n        call collision_lorentz(ww, b, iz, ibuff)\n      else if (trim(col_type) == \"full\") then\n        call collision_full(ww, b, iz, ibuff)\n      else\n        write(olog,*) \"# colliimp module does not support col_type=\", col_type\n        stop\n      end if\n\n      b(:,:,:) = wh(:,:,:) + 0.5_DP * ldt * b(:,:,:) ! 2nd C.N.\n     !b(:,:,:) = wh(:,:,:)                           ! 1st B.E.\n  \n  END SUBROUTINE calc_b\n\n\n!--------------------------------------\n  SUBROUTINE calc_ap(ldt, p, ap, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Calculate A*p^k\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: p\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: ap\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: ww\n    complex(kind=DP) :: phi, Al\n\n      call emfield_hh(p, Al, iz, ibuff)\n      call esfield(p, phi, iz, ibuff)\n\n      if (iFLR == 0) then\n        call setww_ff(p, Al, ww, iz, ibuff) ! Gyrocenter distribution\n      else\n        call setww_gg(p, phi, Al, ww, iz, ibuff) ! Non-adiabatic distribution\n      end if\n\n      if (trim(col_type) == \"LB\") then\n        call collision_LB(ww, ap, iz, ibuff)\n      else if (trim(col_type) == \"lorentz\") then\n        call collision_lorentz(ww, ap, iz, ibuff)\n      else if (trim(col_type) == \"full\") then\n        call collision_full(ww, ap, iz, ibuff)\n      else\n        write(olog,*) \"# colliimp module does not support col_type=\", col_type\n        stop\n      end if\n\n      ap(:,:,:) = p(:,:,:) - 0.5_DP * ldt * ap(:,:,:) ! 2nd C.N.\n     !ap(:,:,:) = p(:,:,:) - ldt * ap(:,:,:)          ! 1st B.E.\n  \n  END SUBROUTINE calc_ap\n\n\n!--------------------------------------\n  SUBROUTINE calc_r(ldt, x, b, r, iz, ibuff)\n!-------------------------------------------------------------------------------\n!\n!    Calculate residual  r^n = b - A*x^n\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), intent(in) :: ldt\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: x, b\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: r\n    integer, intent(in) :: iz, ibuff\n  \n      call calc_ap(ldt, x, r, iz, ibuff)\n      r(:,:,:) = b(:,:,:) - r(:,:,:)\n  \n  END SUBROUTINE calc_r\n  \n  \n!--------------------------------------\n  SUBROUTINE calc_error(r, b, error)\n!-------------------------------------------------------------------------------\n!\n!    Evaluate relative error of A*x^n = b\n!\n!      When analytic solution x^* is known,\n!\n!        Relative error = ||x^n - x^*|| / ||x^*||\n!\n!      When x^* is not available, error is often replaced by followings:\n!\n!        Relative residual error = ||r^n|| / ||b||\n!        Relative iteration error = ||x^n - x^n-1|| / ||x^n||\n!\n!      where residual is  r^n = b - A*x^n.\n!\n!      Several types of norm of the vector ||x|| are available,\n!\n!              1-norm  ||x|| = sum_i |x_i|\n!              2-norm  ||x|| = sum_i |x_i|^2\n!              p-norm  ||x|| = sum_i |x_i|^p\n!        Maximum norm  ||x|| = max(|x_i|)\n!\n!-------------------------------------------------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: r, b\n    real(kind=DP), intent(out) :: error\n\n     !error = sum(abs(r(:,:,:))) / sum(abs(b(:,:,:)))\n     !error = sum(abs(r(:,:,:))**2) / sum(abs(b(:,:,:))**2)\n      error = maxval(abs(r(:,:,:))) / maxval(abs(b(:,:,:)))\n\n  END SUBROUTINE calc_error\n\n\n!--------------------------------------\n  SUBROUTINE emfield_hh(hh, Al, iz, ibuff)\n!--------------------------------------\n!   Magnetic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(out) :: Al\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP) :: jpara, wf, wfvp, wfvp1\n    real(kind=DP) :: cs2, cintgrl\n    integer :: iv, im, is, mx, my\n\n      jpara = (0._DP, 0._DP)\n      do is = 0, ns-1\n        cs2 = sgn(is) * fcs(is) * sqrt(tau(is) / Anum(is))\n\n        do im = 1, global_nm\n          cintgrl = 2._DP * pi * gvp(im,iz) * dv * dvp(iz)\n          do iv = 1, 2*global_nv\n            wf = hh(iv,im,is) * gj0(im,is,iz,ibuff) * cs2 * gvl(iv)\n            jpara = jpara + wf * cintgrl\n          end do\n        end do\n\n       !- edge compensation -\n        im = 1\n          do iv = 1, 2*global_nv\n            wfvp  = gvp(im  ,iz) * hh(iv,im  ,is) * gj0(im  ,is,iz,ibuff) &\n                  * cs2 * gvl(iv)\n            wfvp1 = gvp(im+1,iz) * hh(iv,im+1,is) * gj0(im+1,is,iz,ibuff) &\n                  * cs2 * gvl(iv)\n            jpara = jpara - ( - wfvp / 12._DP       &\n                            + ( wfvp1               &\n                              - wfvp * 2._DP        &\n                              ) * 11._DP / 720._DP  &\n                            ) * (2._DP * pi * dv * dvp(iz))\n          end do\n\n      end do\n\n      call ibuffiproc2mxmy(ibuff, spc_rank, mx, my)\n      Al = jpara * beta * fct_ampere(mx,my,iz)\n\n  END SUBROUTINE emfield_hh\n\n\n!--------------------------------------\n  SUBROUTINE esfield(hh, phi, iz, ibuff)\n!--------------------------------------\n!   Electrostatic field calculation\n\n    implicit none\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(out) :: phi\n    integer, intent(in) :: iz, ibuff\n \n    complex(kind=DP) :: rho, wf, wfvp, wfvp1\n    real(kind=DP) :: cs1, cintgrl\n    integer :: iv, im, is, mx, my\n\n      rho = (0._DP, 0._DP)\n      do is = 0, ns-1\n        cs1 = sgn(is) * fcs(is)\n\n        do im = 1, global_nm\n          cintgrl = 2._DP * pi * gvp(im,iz) * dv * dvp(iz)\n          do iv = 1, 2*global_nv\n            wf = hh(iv,im,is) * gj0(im,is,iz,ibuff) * cs1\n            rho = rho + wf * cintgrl\n          end do\n        end do\n\n       !- edge compensation -\n        im = 1\n          do iv = 1, 2*global_nv\n            wfvp  = gvp(im  ,iz) * hh(iv,im  ,is) * gj0(im  ,is,iz,ibuff) * cs1\n            wfvp1 = gvp(im+1,iz) * hh(iv,im+1,is) * gj0(im+1,is,iz,ibuff) * cs1\n            rho = rho - ( - wfvp / 12._DP       &\n                        + ( wfvp1               &\n                          - wfvp * 2._DP        &\n                          ) * 11._DP / 720._DP  &\n                        ) * (2._DP * pi * dv * dvp(iz))\n          end do\n\n      end do\n\n      call ibuffiproc2mxmy(ibuff, spc_rank, mx, my)\n      phi = rho * fct_poisson(mx,my,iz)\n\n  END SUBROUTINE esfield\n\n\n!--------------------------------------\n  SUBROUTINE setww_ff(hh, Al, ff, iz, ibuff)\n!--------------------------------------\n!   Set gyrocenter distribution ff\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(in) :: Al\n    complex(kind=DP), intent(out), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: ff\n    integer, intent(in) :: iz, ibuff\n \n    real(kind=DP) :: cs2\n    integer :: iv, im, is, ivb\n\n      do is = 0, ns-1\n        cs2 = sgn(is) * Znum(is) / sqrt( Anum(is) * tau(is) )\n        do im = 0, global_nm\n          do iv = 1, 2*global_nv\n            ff(iv,im,is) = hh(iv,im,is) - gfmx(iv,im,iz) * gj0(im,is,iz,ibuff) &\n                                                          * cs2 * gvl(iv) * Al\n          end do\n        end do\n      end do\n\n    !- Boundary condition -\n      do ivb = 1, nvb\n        ff(1-ivb,:,:) = (0._DP, 0._DP)\n        ff(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n        ff(:,global_nm+ivb,:) = (0._DP, 0._DP)\n        ff(:,-ivb,:) = ff(:,ivb,:)\n      end do\n    !-\n\n  END SUBROUTINE setww_ff\n\n\n!--------------------------------------\n  SUBROUTINE setww_gg(hh, phi, Al, gg, iz, ibuff)\n!--------------------------------------\n!   Set non-adiabatic distribution gg\n\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: hh\n    complex(kind=DP), intent(in) :: phi, Al\n    complex(kind=DP), intent(out), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: gg\n    integer, intent(in) :: iz, ibuff\n \n    real(kind=DP) :: cs1, cs2\n    integer :: iv, im, is, ivb\n\n      do is = 0, ns-1\n        cs1 = sgn(is) * Znum(is) / tau(is)\n        cs2 = sgn(is) * Znum(is) / sqrt( Anum(is) * tau(is) )\n        do im = 0, global_nm\n          do iv = 1, 2*global_nv\n            gg(iv,im,is) = hh(iv,im,is) + gfmx(iv,im,iz) * gj0(im,is,iz,ibuff) &\n                                            * (cs1 * phi - cs2 * gvl(iv) * Al)\n          end do\n        end do\n      end do\n\n    !- Boundary condition -\n      do ivb = 1, nvb\n        gg(1-ivb,:,:) = (0._DP, 0._DP)\n        gg(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n        gg(:,global_nm+ivb,:) = (0._DP, 0._DP)\n        gg(:,-ivb,:) = gg(:,ivb,:)\n      end do\n    !-\n\n  END SUBROUTINE setww_gg\n\n\n!--------------------------------------\n  ", "SUBROUTINE collision_LB(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Lenard-Bernstein operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    real(kind=DP) :: nu_s, cv1, cv2, cm1, cm2, cflr\n    integer :: iv, im, is, mxy, mx, my\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n        do is = 0, ns-1\n          nu_s = nu(is) * 3._DP * sqrt(pi) * ctauiv(is,is) / 4._DP\n               !- nu(is) is a bias factor given in namelist\n          cv1 = nu_s / ( 12._DP * dv )\n          cv2 = nu_s / ( 12._DP * dv * dv )\n          cm1 = nu_s / ( 12._DP * dvp(iz) )\n          cm2 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n          cflr = nu_s * ksq(mx,my,iz) * Anum(is) * tau(is)  &\n                 / ( Znum(is) * omg(iz) )**2 * real(iFLR, kind=DP)\n          im = 0 \n            do iv = 1, 2*global_nv\n              cf(iv,im,is) =                                        &\n                         ( -          wf(iv+2,im,is)                &\n                           + 16._DP * wf(iv+1,im,is)                &\n                           - 30._DP * wf(iv  ,im,is)                &\n                           + 16._DP * wf(iv-1,im,is)                &\n                           -          wf(iv-2,im,is)                &\n                         ) * cv2                                    &\n                       + ( -          wf(iv+2,im,is)                &\n                           +  8._DP * wf(iv+1,im,is)                &\n                           -  8._DP * wf(iv-1,im,is)                &\n                           +          wf(iv-2,im,is)                &\n                         ) * cv1 * gvl(iv)                          &\n                       + ( -          wf(iv,im+2,is)                &\n                           + 16._DP * wf(iv,im+1,is)                &\n                           - 30._DP * wf(iv,im  ,is)                &\n                           + 16._DP * wf(iv,im-1,is)                &\n                           -          wf(iv,im-2,is)                &\n                         ) * cm2 * 2._DP                            &\n                       + nu_s * 3._DP * wf(iv,im,is)                &\n                       - cflr * wf(iv,im,is)\n            end do\n          do im = 1, global_nm\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) =                                            &\n                         ( -          wf(iv+2,im,is)                    &\n                           + 16._DP * wf(iv+1,im,is)                    &\n                           - 30._DP * wf(iv  ,im,is)                    &\n                           + 16._DP * wf(iv-1,im,is)                    &\n                           -          wf(iv-2,im,is)                    &\n                         ) * cv2                                        &\n                       + ( -          wf(iv+2,im,is)                    &\n                           +  8._DP * wf(iv+1,im,is)                    &\n                           -  8._DP * wf(iv-1,im,is)                    &\n                           +          wf(iv-2,im,is)                    &\n                         ) * cv1 * gvl(iv)                              &\n                       + ( -          wf(iv,im+2,is)                    &\n                           + 16._DP * wf(iv,im+1,is)                    &\n                           - 30._DP * wf(iv,im  ,is)                    &\n                           + 16._DP * wf(iv,im-1,is)                    &\n                           -          wf(iv,im-2,is)                    &\n                         ) * cm2                                        &\n                       + ( -          wf(iv,im+2,is)                    &\n                           +  8._DP * wf(iv,im+1,is)                    &\n                           -  8._DP * wf(iv,im-1,is)                    &\n                           +          wf(iv,im-2,is)                    &\n                         ) * cm1 * ( gvp(im,iz) + 1._DP / gvp(im,iz) )  &\n                       + nu_s * 3._DP * wf(iv,im,is)                    &   \n                       - cflr * wf(iv,im,is)\n            end do\n          end do\n        end do\n\n      else\n\n        cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_LB\n\n\n!--------------------------------------\n  SUBROUTINE collision_lorentz(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Lorentz operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    real(kind=DP) :: cv1, cv2, cm1, cm2, cvm, cflr\n    integer :: iv, im, is, mxy, mx, my\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n        do is = 0, ns-1\n          cv1 = 1._DP / (12._DP * dv)\n          cv2 = 1._DP / (12._DP * dv**2)\n          cm1 = 1._DP / (12._DP * dvp(iz))\n          cm2 = 1._DP / (12._DP * dvp(iz)**2)\n          cvm = 1._DP / (144._DP * dv * dvp(iz))\n          cflr = ksq(mx,my,iz) * Anum(is) * tau(is)  &\n                 / ( Znum(is) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n          im = 0\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = 0.5_DP * gnu_ds(iv,im,is,iz) * (                  &\n                          - 2._DP * gvl(iv) * cv1 * (-         wf(iv+2,im,is)  &\n                                                     + 8._DP * wf(iv+1,im,is)  &\n                                                     - 8._DP * wf(iv-1,im,is)  &\n                                                     +         wf(iv-2,im,is)) &\n                       + 2._DP * gvl(iv)**2 * cm2 * (-         wf(iv,im+2,is)  &\n                                                     +16._DP * wf(iv,im+1,is)  &\n                                                     -30._DP * wf(iv,im  ,is)  &\n                                                     +16._DP * wf(iv,im-1,is)  &\n                                                     -         wf(iv,im-2,is)) &\n                           )                                                   &\n                           - 0.25_DP * gnu_ds(iv,im,is,iz)                     &\n                             * (2._DP * gvl(iv)**2)                            &\n                             * cflr * wf(iv,im,is)\n            end do\n\n          do im = 1, global_nm\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = 0.5_DP * gnu_ds(iv,im,is,iz) * (                  &\n                              gvp(im,iz)**2 * cv2 * (-         wf(iv+2,im,is)  &\n                                                     +16._DP * wf(iv+1,im,is)  &\n                                                     -30._DP * wf(iv  ,im,is)  &\n                                                     +16._DP * wf(iv-1,im,is)  &\n                                                     -         wf(iv-2,im,is)) &\n                          - 2._DP * gvl(iv) * cv1 * (-         wf(iv+2,im,is)  &\n                                                     + 8._DP * wf(iv+1,im,is)  &\n                                                     - 8._DP * wf(iv-1,im,is)  &\n                                                     +         wf(iv-2,im,is)) &\n                           - 2._DP * gvl(iv) * gvp(im,iz) &\n                                          * cvm * (+         wf(iv+2,im+2,is)  &\n                                                   - 8._DP * wf(iv+2,im+1,is)  &\n                                                   + 8._DP * wf(iv+2,im-1,is)  &\n                                                   -         wf(iv+2,im-2,is)  &\n                                                   - 8._DP * wf(iv+1,im+2,is)  &\n                                                   +64._DP * wf(iv+1,im+1,is)  &\n                                                   -64._DP * wf(iv+1,im-1,is)  &\n                                                   + 8._DP * wf(iv+1,im-2,is)  &\n                                                   + 8._DP * wf(iv-1,im+2,is)  &\n                                                   -64._DP * wf(iv-1,im+1,is)  &\n                                                   +64._DP * wf(iv-1,im-1,is)  &\n                                                   - 8._DP * wf(iv-1,im-2,is)  &\n                                                   -         wf(iv-2,im+2,is)  &\n                                                   + 8._DP * wf(iv-2,im+1,is)  &\n                                                   - 8._DP * wf(iv-2,im-1,is)  &\n                                                   +         wf(iv-2,im-2,is)) &\n                           + ((gvl(iv)**2 - gvp(im,iz)**2) / gvp(im,iz)) &\n                                            * cm1 * (-         wf(iv,im+2,is)  &\n                                                     + 8._DP * wf(iv,im+1,is)  &\n                                                     - 8._DP * wf(iv,im-1,is)  &\n                                                     +         wf(iv,im-2,is)) &\n                               + gvl(iv)**2 * cm2 * (-         wf(iv,im+2,is)  &\n                                                     +16._DP * wf(iv,im+1,is)  &\n                                                     -30._DP * wf(iv,im  ,is)  &\n                                                     +16._DP * wf(iv,im-1,is)  &\n                                                     -         wf(iv,im-2,is)) &\n                           )                                                   &\n                           - 0.25_DP * gnu_ds(iv,im,is,iz)                     &\n                             * (2._DP * gvl(iv)**2 + gvp(im,iz)**2)            &\n                             * cflr * wf(iv,im,is)\n            end do\n          end do\n        end do\n\n      else\n\n        cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_lorentz\n\n\n!--------------------------------------\n  SUBROUTINE collision_full(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n\n    complex(kind=DP), dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n\n                             !%%% For debug %%%\n                             ! complex(kind=DP), &\n                             ! dimension(1:2*global_nv,0:global_nm,0:ns-1) &\n                             !                              :: cft, cfd, cff\n                             ! integer :: mx, my, iv, im\n                             ! integer, save :: iflg_dbg\n                             ! data iflg_dbg / 0 /\n                             !%%%%%%%%%%%%%%%%%\n\n      call collision_full_CT(wf, cf, iz, ibuff)\n\n      call collision_full_calc_moment(wf, moment_ab, iz, ibuff)\n      call collision_full_DT(moment_ab, cf, iz, ibuff)\n      call collision_full_CF(moment_ab, cf, iz, ibuff)\n\n                             !%%% For debug %%%\n                             ! call ibuffiproc2mxmy&\n                             !                   (ibuff,spc_rank,mx,my)\n                             ! if (rankw == 0 .and. rankz == 0 .and. &\n                             !     mx == 1 .and. my == 1 .and.       &\n                             !     iz == 0 .and. iflg_dbg == 0) then\n                             ! iflg_dbg = 1\n                             ! call collision_full_ct(wf,cft,iz,ibuff)\n                             ! call collision_full_dt(moment_ab,cfd,iz,ibuff)\n                             ! call collision_full_cf(moment_ab,cff,iz,ibuff)\n                             ! do im = 0, global_nm\n                             ! do iv = 1, 2*global_nv\n                             !   write(97,*) gvl(iv), gvp(im,iz), &\n                             !              dble(wf(iv,im,0)),    &\n                             !              aimag(wf(iv,im,0)),   &\n                             !              dble(cft(iv,im,0)),   &\n                             !              aimag(cft(iv,im,0)),  &\n                             !              dble(cfd(iv,im,0)),   &\n                             !              aimag(cfd(iv,im,0)),  &\n                             !              dble(cff(iv,im,0)),   &\n                             !              aimag(cff(iv,im,0))\n                             ! end do\n                             !   write(97,*)\n                             ! end do\n                             ! end if\n                             !%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE collision_full\n\n\n!--------------------------------------\n  ", "SUBROUTINE collision_full_CT(wf, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, test particle part (scattering+slowing down+diffusion)\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    real(kind=DP) :: cv1, cv2, cm1, cm2, cvm, cflr\n    integer :: iv, im, is, mxy, mx, my\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        mx = mod(mxy,2*nx+1) - nx\n        my = mxy / (2*nx+1)\n        do is = 0, ns-1\n\n          cv1 = 1._DP / (12._DP * dv)\n          cv2 = 1._DP / (12._DP * dv**2)\n          cm1 = 1._DP / (12._DP * dvp(iz))\n          cm2 = 1._DP / (12._DP * dvp(iz)**2)\n          cvm = 1._DP / (144._DP * dv * dvp(iz))\n          cflr = ksq(mx,my,iz) * Anum(is) * tau(is)  &\n                 / ( Znum(is) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n          im = 0\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = ( -          wf(iv+2,im,is)                       &\n                               + 16._DP * wf(iv+1,im,is)                       &\n                               - 30._DP * wf(iv  ,im,is)                       &\n                               + 16._DP * wf(iv-1,im,is)                       &\n                               -          wf(iv-2,im,is)                       &\n                             ) * cv2                                           &\n                               * (   gnu_ps(iv,im,is,iz) * gvl(iv)**2          &\n                                 ) * 0.5_DP                                    &\n                           + ( -          wf(iv,im+2,is)                       &\n                               + 16._DP * wf(iv,im+1,is)                       &\n                               - 30._DP * wf(iv,im  ,is)                       &\n                               + 16._DP * wf(iv,im-1,is)                       &\n                               -          wf(iv,im-2,is)                       &\n                             ) * cm2                                           &\n                               * (   gnu_ds(iv,im,is,iz) * gvl(iv)**2          &\n                                 )                                             &\n                           + ( -          wf(iv+2,im,is)                       &\n                               +  8._DP * wf(iv+1,im,is)                       &\n                               -  8._DP * wf(iv-1,im,is)                       &\n                               +          wf(iv-2,im,is)                       &\n                             ) * cv1                                           &\n                               * gnu_gs(iv,im,is,iz) * gvl(iv)                 &\n                          !+ ( gnu_hs(iv,im,is,iz) * gxxa**2 * 2._DP           &\n                           + ( gnu_hs(iv,im,is,iz) * 2._DP                     &\n                                - 0.25_DP * cflr                               &\n                                 * gnu_ds(iv,im,is,iz) * 2._DP * gvl(iv)**2    &\n                             ) * wf(iv,im,is)\n            end do\n\n          do im = 1, global_nm\n            do iv = 1, 2*global_nv\n              cf(iv,im,is) = ( -          wf(iv+2,im,is)                       &\n                               + 16._DP * wf(iv+1,im,is)                       &\n                               - 30._DP * wf(iv  ,im,is)                       &\n                               + 16._DP * wf(iv-1,im,is)                       &\n                               -          wf(iv-2,im,is)                       &\n                             ) * cv2                                           &\n                               * (   gnu_ps(iv,im,is,iz) * gvl(iv)**2          &\n                                   + gnu_ds(iv,im,is,iz) * gvp(im,iz)**2       &\n                                 ) * 0.5_DP                                    &\n                           + ( -          wf(iv,im+2,is)                       &\n                               + 16._DP * wf(iv,im+1,is)                       &\n                               - 30._DP * wf(iv,im  ,is)                       &\n                               + 16._DP * wf(iv,im-1,is)                       &\n                               -          wf(iv,im-2,is)                       &\n                             ) * cm2                                           &\n                               * (   gnu_ds(iv,im,is,iz) * gvl(iv)**2          &\n                                   + gnu_ps(iv,im,is,iz) * gvp(im,iz)**2       &\n                                 ) * 0.5_DP                                    &\n                           + ( +          wf(iv+2,im+2,is)                     &\n                               -  8._DP * wf(iv+2,im+1,is)                     &\n                               +  8._DP * wf(iv+2,im-1,is)                     &\n                               -          wf(iv+2,im-2,is)                     &\n                               -  8._DP * wf(iv+1,im+2,is)                     &\n                               + 64._DP * wf(iv+1,im+1,is)                     &\n                               - 64._DP * wf(iv+1,im-1,is)                     &\n                               +  8._DP * wf(iv+1,im-2,is)                     &\n                               +  8._DP * wf(iv-1,im+2,is)                     &\n                               - 64._DP * wf(iv-1,im+1,is)                     &\n                               + 64._DP * wf(iv-1,im-1,is)                     &\n                               -  8._DP * wf(iv-1,im-2,is)                     &\n                               -          wf(iv-2,im+2,is)                     &\n                               +  8._DP * wf(iv-2,im+1,is)                     &\n                               -  8._DP * wf(iv-2,im-1,is)                     &\n                               +          wf(iv-2,im-2,is)                     &\n                             ) * cvm                                           &\n                               * gvl(iv) * gvp(im,iz)                          &\n                               * (   gnu_ps(iv,im,is,iz)                       &\n                                   - gnu_ds(iv,im,is,iz) )                     &\n                           + ( -          wf(iv+2,im,is)                       &\n                               +  8._DP * wf(iv+1,im,is)                       &\n                               -  8._DP * wf(iv-1,im,is)                       &\n                               +          wf(iv-2,im,is)                       &\n                             ) * cv1                                           &\n                               * gnu_gs(iv,im,is,iz) * gvl(iv)                 &\n                           + ( -          wf(iv,im+2,is)                       &\n                               +  8._DP * wf(iv,im+1,is)                       &\n                               -  8._DP * wf(iv,im-1,is)                       &\n                               +          wf(iv,im-2,is)                       &\n                             ) * cm1                                           &\n                               * (   gnu_gs(iv,im,is,iz) * gvp(im,iz)          &\n                                   + gnu_ds(iv,im,is,iz) * 0.5_DP              &\n                                     * (gvl(iv)**2 / gvp(im,iz) + gvp(im,iz)) )&\n                          !+ ( gnu_hs(iv,im,is,iz) * gxxa**2 * 2._DP           &\n                           + ( gnu_hs(iv,im,is,iz) * 2._DP                     &\n                                - 0.25_DP * cflr                               &\n                                 * (  gnu_ds(iv,im,is,iz)                      &\n                                       * (2._DP * gvl(iv)**2 + gvp(im,iz)**2)  &\n                                     + gnu_ps(iv,im,is,iz) * gvp(im,iz)**2 )   &\n                             ) * wf(iv,im,is)\n            end do\n          end do\n        end do\n\n      else\n\n        cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_full_CT\n\n\n!--------------------------------------\n  ", "SUBROUTINE collision_full_calc_moment(wf, moment_ab, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, calculate velocity moments\n\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: wf\n    complex(kind=DP), intent(out), &\n      dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n    integer, intent(in) :: iz, ibuff\n\n    complex(kind=DP) :: wfvp, wfvp1\n    integer :: iv, im, ia, ib\n             \n      moment_ab(:,:,:) = (0._DP, 0._DP)\n\n      if ( iFLR == 1 ) then  ! full-GK\n\n        do ib = 0, ns-1\n          do ia = 0, ns-1\n  \n            do im = 1, global_nm\n              do iv = 1, 2*global_nv\n                  moment_ab(1,ia,ib) = moment_ab(1,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(1,iv,im,ia,ib,iz)\n                  moment_ab(2,ia,ib) = moment_ab(2,ia,ib) + wf(iv,im,ia) * gj1(im,ia,iz,ibuff) * gvfunc(2,iv,im,ia,ib,iz)\n                  moment_ab(3,ia,ib) = moment_ab(3,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(3,iv,im,ia,ib,iz)\n                  moment_ab(4,ia,ib) = moment_ab(4,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(4,iv,im,ia,ib,iz)\n                  moment_ab(5,ia,ib) = moment_ab(5,ia,ib) + wf(iv,im,ia) * gj1(im,ia,iz,ibuff) * gvfunc(5,iv,im,ia,ib,iz)\n                  moment_ab(6,ia,ib) = moment_ab(6,ia,ib) + wf(iv,im,ia) * gj0(im,ia,iz,ibuff) * gvfunc(6,iv,im,ia,ib,iz)\n              end do\n            end do\n  \n           !- edge compensation -\n            im = 1\n              do iv = 1, 2*global_nv\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(1,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(1,iv,im+1,ia,ib,iz)\n                moment_ab(1,ia,ib) = moment_ab(1,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj1(im  ,ia,iz,ibuff) * gvfunc(2,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj1(im+1,ia,iz,ibuff) * gvfunc(2,iv,im+1,ia,ib,iz)\n                moment_ab(2,ia,ib) = moment_ab(2,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(3,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(3,iv,im+1,ia,ib,iz)\n                moment_ab(3,ia,ib) = moment_ab(3,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(4,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(4,iv,im+1,ia,ib,iz)\n                moment_ab(4,ia,ib) = moment_ab(4,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj1(im  ,ia,iz,ibuff) * gvfunc(5,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj1(im+1,ia,iz,ibuff) * gvfunc(5,iv,im+1,ia,ib,iz)\n                moment_ab(5,ia,ib) = moment_ab(5,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gj0(im  ,ia,iz,ibuff) * gvfunc(6,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gj0(im+1,ia,iz,ibuff) * gvfunc(6,iv,im+1,ia,ib,iz)\n                moment_ab(6,ia,ib) = moment_ab(6,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n              end do\n          \n          end do\n        end do\n\n      else if ( iFLR == 0 ) then ! DK-limit\n\n        do ib = 0, ns-1\n          do ia = 0, ns-1\n  \n            do im = 1, global_nm\n              do iv = 1, 2*global_nv\n                  moment_ab(1,ia,ib) = moment_ab(1,ia,ib) + wf(iv,im,ia) * gvfunc(1,iv,im,ia,ib,iz)\n                  moment_ab(3,ia,ib) = moment_ab(3,ia,ib) + wf(iv,im,ia) * gvfunc(3,iv,im,ia,ib,iz)\n                  moment_ab(4,ia,ib) = moment_ab(4,ia,ib) + wf(iv,im,ia) * gvfunc(4,iv,im,ia,ib,iz)\n                  moment_ab(6,ia,ib) = moment_ab(6,ia,ib) + wf(iv,im,ia) * gvfunc(6,iv,im,ia,ib,iz)\n              end do\n            end do\n  \n           !- edge compensation -\n            im = 1\n              do iv = 1, 2*global_nv\n                wfvp  = wf(iv,im  ,ia) * gvfunc(1,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(1,iv,im+1,ia,ib,iz)\n                moment_ab(1,ia,ib) = moment_ab(1,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gvfunc(3,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(3,iv,im+1,ia,ib,iz)\n                moment_ab(3,ia,ib) = moment_ab(3,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gvfunc(4,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(4,iv,im+1,ia,ib,iz)\n                moment_ab(4,ia,ib) = moment_ab(4,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n                wfvp  = wf(iv,im  ,ia) * gvfunc(6,iv,im  ,ia,ib,iz)\n                wfvp1 = wf(iv,im+1,ia) * gvfunc(6,iv,im+1,ia,ib,iz)\n                moment_ab(6,ia,ib) = moment_ab(6,ia,ib)        &\n                                   - ( - wfvp / 12._DP         &\n                                       + ( wfvp1               &\n                                         - wfvp * 2._DP        &\n                                         ) * 11._DP / 720._DP )\n              end do\n          \n          end do\n        end do\n\n      end if\n\n  END SUBROUTINE collision_full_calc_moment\n\n\n!--------------------------------------\n  SUBROUTINE collision_full_DT(moment_ab, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, test particle part (non-isothermal terms)\n\n    complex(kind=DP), intent(in), &\n      dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    integer :: iv, im, ia, ib, mxy\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        if ( iFLR == 1 ) then  ! full-GK\n   \n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gx_tst(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gx_tst(2,iv,im,ia,ib,iz) &\n                                * moment_ab(2,ia,ib)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gx_tst(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gx_tst(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gx_tst(5,iv,im,ia,ib,iz) &\n                                * moment_ab(5,ia,ib)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gx_tst(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ia,ib)      &\n                                 * gj0(im,ia,iz,ibuff)                  \n                end do\n              end do\n            end do\n          end do\n   \n        else if ( iFLR == 0 ) then ! DK-limit\n   \n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gx_tst(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ia,ib)      &\n                               + gx_tst(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ia,ib)      &\n                               + gx_tst(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ia,ib)      &\n                               + gx_tst(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ia,ib)\n                end do\n              end do\n            end do\n          end do\n   \n        end if\n\n      else\n\n        !cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_full_DT\n\n\n!--------------------------------------\n  SUBROUTINE collision_full_CF(moment_ab, cf, iz, ibuff)\n!--------------------------------------\n!   Sugama operator, field particle part\n\n    complex(kind=DP), intent(in), &\n      dimension(1:6,0:ns-1,0:ns-1) :: moment_ab\n    complex(kind=DP), intent(inout), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: cf\n    integer, intent(in) :: iz, ibuff\n  \n    integer :: iv, im, ia, ib, mxy\n\n      mxy = ibuff + nbuff * spc_rank\n      if (mxy <= (2*nx+1)*(ny+1)-1) then\n\n        if ( iFLR == 1 ) then  ! full-GK\n\n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gy_fld(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gy_fld(2,iv,im,ia,ib,iz) &\n                                * moment_ab(2,ib,ia)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gy_fld(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gy_fld(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)    & \n                               + gy_fld(5,iv,im,ia,ib,iz) &\n                                * moment_ab(5,ib,ia)      &\n                                 * gj1(im,ia,iz,ibuff)    & \n                               + gy_fld(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ib,ia)      &\n                                 * gj0(im,ia,iz,ibuff)                  \n                end do\n              end do\n            end do\n          end do\n\n        else if ( iFLR == 0 ) then ! DK-limit\n   \n          do ib = 0, ns-1\n            do ia = 0, ns-1\n              do im = 0, global_nm\n                do iv = 1, 2*global_nv\n                  cf(iv,im,ia) = cf(iv,im,ia)             &\n                               + gy_fld(1,iv,im,ia,ib,iz) &\n                                * moment_ab(1,ib,ia)      &\n                               + gy_fld(3,iv,im,ia,ib,iz) &\n                                * moment_ab(3,ib,ia)      &\n                               + gy_fld(4,iv,im,ia,ib,iz) &\n                                * moment_ab(4,ib,ia)      &\n                               + gy_fld(6,iv,im,ia,ib,iz) &\n                                * moment_ab(6,ib,ia)\n                end do\n              end do\n            end do\n          end do\n   \n        end if\n\n      else\n\n        !cf(:,:,:) = (0._DP, 0._DP)\n\n      end if\n\n  END SUBROUTINE collision_full_CF\n\n\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colliimp_calc_colli_full( ff, phi, cf )\n!!!!--------------------------------------\n!!!!   Collsion operator calculation interface\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: sender, recver\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n!!!    complex(kind=DP), dimension(:,:,:), allocatable :: w1, w2\n!!!    integer :: mx, my, iz, iv, im, ibuff, ivb\n!!!\n!!!      allocate( sender(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( recver(1:2*nv,0:nm,-nz:nz-1,0:nbuff-1,0:nprocvms-1) )\n!!!      allocate( wf(1:2*global_nv,0:global_nm,0:ns-1,-nz:nz-1,0:nbuff-1) )\n!!!      allocate( w1(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) )\n!!!      allocate( w2(1:2*global_nv,0:global_nm,0:ns-1) )\n!!!\n!!!!$OMP parallel do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                cf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n!!!                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n!!!                                                                     * real(iFLR, kind=DP)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!\n!!!      call vms2xy_pack(cf, sender)\n!!!      call vms2xy_transpose(sender, recver)\n!!!      call vms2xy_unpack(recver, wf)\n!!!      \n!!!                                      call clock_sta(1720)\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(wf) &\n!!!!$OMP private(w1,w2,iz,ibuff)\n!!!      w1(:,:,:) = (0._DP, 0._DP)\n!!!!$OMP do collapse(2)\n!!!      do ibuff = 0, nbuff-1\n!!!        do iz = -nz, nz-1\n!!!          w1(1:2*global_nv,0:global_nm,0:ns-1) = wf(:,:,:,iz,ibuff)\n!!!        !- Boundary condition -\n!!!          do ivb = 1, nvb\n!!!          !w1(1-ivb,:,:) = (0._DP, 0._DP)\n!!!          !w1(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n!!!          !w1(:,global_nm+ivb,:) = (0._DP, 0._DP)\n!!!            w1(:,-ivb,:) = w1(:,ivb,:)\n!!!          end do\n!!!        !-\n!!!          call collision_full(w1, w2, iz, ibuff)\n!!!          wf(:,:,:,iz,ibuff) = w2(:,:,:)\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!!$OMP end parallel\n!!!                                      call clock_end(1720)\n!!!\n!!!      call xy2vms_pack(wf, sender)\n!!!      call xy2vms_transpose(sender, recver)\n!!!      call xy2vms_unpack(recver, cf)\n!!!\n!!!      deallocate( sender )\n!!!      deallocate( recver )\n!!!      deallocate( wf )\n!!!      deallocate( w1 )\n!!!      deallocate( w2 )\n!!!\n!!!  END SUBROUTINE colliimp_calc_colli_full\n\n\n!--------------------------------------\n  SUBROUTINE colliimp_calc_colli_full( ff, phi, cf )\n!--------------------------------------\n!   Collsion operator calculation interface\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)             :: phi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable ::  &\n           send1e, recv1e, send2e, recv2e, send1o, recv1o, send2o, recv2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: wh1e, wh2e, wh1o, wh2o\n    integer :: mx, my, iz, iv, im, is, ibuff, iproc\n\n      allocate( send1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2e(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2e(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( send1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv1o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( send2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( recv2o(1:2*nv,0:nm,0:nbuff-1,0:nprocvms-1) )\n      allocate( wh1o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n      allocate( wh2o(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,phi,cf,ist_y,iend_y,sgn,Znum,fmx,tau,j0,iFLR,ranks) &\n!$OMP shared(send1e,recv1e,send2e,recv2e,wh1e,wh2e) &\n!$OMP shared(send1o,recv1o,send2o,recv2o,wh1o,wh2o) &\n!$OMP private(mx,my,iz,iv,im,is,ibuff,iproc)\n      do iproc = 0, nprocvms-1\n!$OMP do\n        do ibuff = 0, nbuff-1\n          do im = 0, nm\n            do iv = 1, 2*nv\n              send1e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2e(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send1o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n              send2o(iv,im,ibuff,iproc) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n      do ibuff = 0, nbuff-1\n!$OMP do\n        do is = 0, ns-1\n          do im = 0, global_nm\n            do iv = 1, 2*global_nv\n              wh1e(iv,im,is,ibuff) = (0._DP, 0._DP)\n              wh1o(iv,im,is,ibuff) = (0._DP, 0._DP)\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = iend_y, ny\n              cf(:,my,iz,iv,im) = (0._DP, 0._DP)\n            end do\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                cf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n                                                                     * real(iFLR, kind=DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP barrier\n\n!!%%% Without overlap %%%\n!      do iz = -nz, nz-1\n!        call vms2xy_pack_iz(iz, cf, send1e)\n!!$OMP barrier\n!!$OMP master\n!        call vms2xy_transpose_iz(send1e, recv1e)\n!!$OMP end master\n!!$OMP barrier\n!        call vms2xy_unpack_iz(recv1e, wh1e)\n!!$OMP barrier\n!        call collision_full_wrapper_iz(iz, wh1e, wh2e)\n!!$OMP barrier\n!        call xy2vms_pack_iz(wh2e, send2e)\n!!$OMP barrier\n!!$OMP master\n!        call xy2vms_transpose_iz(send2e, recv2e)\n!!$OMP end master\n!!$OMP barrier\n!        call xy2vms_unpack_iz(iz, recv2e, cf)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n!%%% With overlap %%%\n      do iz = -nz, nz-1+6\n\n        if (mod(iz+nz,2) == 0) then! even\n\n!$OMP master\n          if (-nz+1<=iz.and. iz<=nz-1+1) call vms2xy_transpose_iz(send1o, recv1o)\n          if (-nz+5<=iz.and. iz<=nz-1+5) call xy2vms_transpose_iz(send2o, recv2o)\n!$OMP end master\n          if (-nz  <=iz.and. iz<=nz-1  ) call vms2xy_pack_iz(iz, cf, send1e)\n          if (-nz+2<=iz.and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1e, wh1e)\n          if (-nz+3<=iz.and. iz<=nz-1+3) call collision_full_wrapper_iz(iz-3, wh1o, wh2o)\n          if (-nz+4<=iz.and. iz<=nz-1+4) call xy2vms_pack_iz(wh2e, send2e)\n          if (-nz+6<=iz.and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2e, cf)\n\n        else                       ! odd\n\n!$OMP master\n          if (-nz+1<=iz.and. iz<=nz-1+1) call vms2xy_transpose_iz(send1e, recv1e)\n          if (-nz+5<=iz.and. iz<=nz-1+5) call xy2vms_transpose_iz(send2e, recv2e)\n!$OMP end master\n          if (-nz  <=iz.and. iz<=nz-1  ) call vms2xy_pack_iz(iz, cf, send1o)\n          if (-nz+2<=iz.and. iz<=nz-1+2) call vms2xy_unpack_iz(recv1o, wh1o)\n          if (-nz+3<=iz.and. iz<=nz-1+3) call collision_full_wrapper_iz(iz-3, wh1e, wh2e)\n          if (-nz+4<=iz.and. iz<=nz-1+4) call xy2vms_pack_iz(wh2o, send2o)\n          if (-nz+6<=iz.and. iz<=nz-1+6) call xy2vms_unpack_iz(iz-6, recv2o, cf)\n\n        end if\n!$OMP barrier\n\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( send1e )\n      deallocate( recv1e )\n      deallocate( send2e )\n      deallocate( recv2e )\n      deallocate( wh1e )\n      deallocate( wh2e )\n      deallocate( send1o )\n      deallocate( recv1o )\n      deallocate( send2o )\n      deallocate( recv2o )\n      deallocate( wh1o )\n      deallocate( wh2o )\n\n  END SUBROUTINE colliimp_calc_colli_full\n\n\n!--------------------------------------\n  SUBROUTINE collision_full_wrapper_iz( iz, wfin, wfout )\n!--------------------------------------\n!   Collsion operator calculation interface\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wfin\n    complex(kind=DP), intent(out), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1,0:nbuff-1) :: wfout\n\n    complex(kind=DP), &\n      dimension(1-nvb:2*global_nv+nvb,0-nvb:global_nm+nvb,0:ns-1) :: w1\n    complex(kind=DP), &\n      dimension(1:2*global_nv,0:global_nm,0:ns-1) :: w2\n    integer :: ibuff, ivb\n\n!$OMP master\n                                      call clock_sta(1720)\n!$OMP end master\n      w1(:,:,:) = (0._DP, 0._DP)\n!$OMP do schedule(dynamic)\n      do ibuff = 0, nbuff-1\n          w1(1:2*global_nv,0:global_nm,0:ns-1) = wfin(:,:,:,ibuff)\n        !- Boundary condition -\n          do ivb = 1, nvb\n          !w1(1-ivb,:,:) = (0._DP, 0._DP)\n          !w1(2*global_nv+ivb,:,:) = (0._DP, 0._DP)\n          !w1(:,global_nm+ivb,:) = (0._DP, 0._DP)\n            w1(:,-ivb,:) = w1(:,ivb,:)\n          end do\n        !-\n          call collision_full(w1, w2, iz, ibuff)\n          wfout(:,:,:,ibuff) = w2(:,:,:)\n      end do\n!$OMP end do nowait\n!$OMP master\n                                      call clock_end(1720)\n!$OMP end master\n\n  END SUBROUTINE collision_full_wrapper_iz\n\n\nEND MODULE GKV_colliimp\n", "MODULE GKV_fft\n!-------------------------------------------------------------------------------\n!\n!    FFT module for E x B term calculation using SSL2\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n#ifdef __NEC__\n  include \"aslfftw3.f\"\n#else\n  include \"fftw3.f\"\n#endif\n\n  private\n\n  integer, parameter :: mthds = 8   ! Max OpenMP threads\n  integer(kind=DP), save      :: plan_x_forward(0:mthds-1), plan_x_backward(0:mthds-1)\n  integer(kind=DP), save      :: plan_y_forward(0:mthds-1), plan_y_backward(0:mthds-1)\n  integer(kind=DP), save      :: plan_xf_y2zm(0:mthds-1), plan_xf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: plan_xb_y2zm(0:mthds-1), plan_xb_y2x(0:mthds-1)\n  integer(kind=DP), save      :: plan_yf_y2zm(0:mthds-1), plan_yf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: plan_yb_y2zm(0:mthds-1), plan_yb_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_xf_y2zm(0:mthds-1), planr_xf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_xb_y2zm(0:mthds-1), planr_xb_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_yf_y2zm(0:mthds-1), planr_yf_y2x(0:mthds-1)\n  integer(kind=DP), save      :: planr_yb_y2zm(0:mthds-1), planr_yb_y2x(0:mthds-1)\n\n  public   fft_pre,  &\n           !fft_backward_Xfft, fft_backward_chXY, fft_backward_Yfft, &\n           !fft_forward_Yfft, fft_forward_chYX, fft_forward_Xfft,    &\n           plan_xf_y2zm, plan_xf_y2x, &\n           plan_xb_y2zm, plan_xb_y2x, &\n           plan_yf_y2zm, plan_yf_y2x, &\n           plan_yb_y2zm, plan_yb_y2x, &\n           planr_xf_y2zm, planr_xf_y2x, &\n           planr_xb_y2zm, planr_xb_y2x, &\n           planr_yf_y2zm, planr_yf_y2x, &\n           planr_yb_y2zm, planr_yb_y2x, &\n           plan_x_forward, plan_x_backward, &\n           plan_y_forward, plan_y_backward\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE fft_pre( )\n!--------------------------------------\n!  Initialization of FFT\n\n    complex(kind=DP) :: wk1_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk2_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk1_y_z(0:nyw)\n    real(kind=DP)    :: wk2_y_r(0:2*nyw-1)\n\n    integer :: nfft(1),mfft,lfft(1),lfftr(1),lfftc(1),iostr\n    integer :: nbuf\n    integer :: nthds,nplan,i,ierr\n!$  integer :: omp_get_max_threads\n\n     wk1_x_z(:) = (0._DP, 0._DP)\n     wk2_x_z(:) = (0._DP, 0._DP)\n     wk1_y_z(:) = (0._DP, 0._DP)\n     wk2_y_r(:) = 0._DP\n\n     nplan = 1\n#ifdef OMP_INSIDE_FFTW\n!$   nthds = omp_get_max_threads()\n!$   call dfftw_init_threads(ierr)\n!$   call dfftw_plan_with_nthreads(nthds)\n#else\n!$   nplan = omp_get_max_threads()\n#endif\n\n    do i=0, nplan-1\n     call dfftw_plan_dft_1d( plan_x_backward(i),     &\n                             (2*nxw),             &\n                             wk1_x_z,             &   ! complex in\n                             wk2_x_z,             &   ! complex out\n                             FFTW_BACKWARD,       &\n                             FFTW_MEASURE )\n\n     call dfftw_plan_dft_c2r_1d( plan_y_backward(i), &\n                                 (2*nyw),         &\n                                 wk1_y_z,         &   ! complex in\n                                 wk2_y_r,         &   ! real    out\n                                 FFTW_MEASURE )\n\n     call dfftw_plan_dft_r2c_1d( plan_y_forward(i),  &\n                                 (2*nyw),         &\n                                 wk2_y_r,         &   ! real    in\n                                 wk1_y_z,         &   ! complex out\n                                 FFTW_MEASURE )\n\n     call dfftw_plan_dft_1d( plan_x_forward(i),      &\n                             (2*nxw),             &\n                             wk2_x_z,             &   ! complex in\n                             wk1_x_z,             &   ! complex out\n                             FFTW_FORWARD,        &\n                             FFTW_MEASURE )\n    end do\n\n\n!tune2\n#ifdef USE_TERM_Y2ZM\n    nbuf = ((2*nz)*(nm+1)-1)/nprocw + 1\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(plan_xb_y2zm(i),1,nfft,mfft,wk1_x_z,lfft,1,2*nxw,wk2_x_z,lfft,1,2*nxw,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     call dfftw_plan_many_dft_c2r(plan_yb_y2zm(i),1,nfft,mfft,wk1_y_z,lfftc,1,nyw+1,wk2_y_r,lfftr,1,2*nyw,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     call dfftw_plan_many_dft_r2c(plan_yf_y2zm(i),1,nfft,mfft,wk2_y_r,lfftr,1,2*nyw,wk1_y_z,lfftc,1,nyw+1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(plan_xf_y2zm(i),1,nfft,mfft,wk2_x_z,lfft,1,2*nxw,wk1_x_z,lfft,1,2*nxw,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#else\n    nbuf = 2*nz*(nm+1)\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(plan_xb_y2x(i),1,nfft,mfft,wk1_x_z,lfft,1,2*nxw,wk2_x_z,lfft,1,2*nxw,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_c2r(plan_yb_y2x(i),1,nfft,mfft,wk1_y_z,lfftc,1,nyw+1,wk2_y_r,lfftr,1,2*nyw,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_r2c(plan_yf_y2x(i),1,nfft,mfft,wk2_y_r,lfftr,1,2*nyw,wk1_y_z,lfftc,1,nyw+1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(plan_xf_y2x(i),1,nfft,mfft,wk2_x_z,lfft,1,2*nxw,wk1_x_z,lfft,1,2*nxw,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#endif\n\n\n!tune2r\n#ifdef USE_TERM_Y2ZM\n    nbuf = ((2*nz)*(nm+1)-1)/nprocw + 1\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     iostr= (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(planr_xb_y2zm(i),1,nfft,mfft,wk1_x_z,lfft,iostr,1,wk2_x_z,lfft,iostr,1,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     iostr= 2*nxw*nbuf\n     call dfftw_plan_many_dft_c2r(planr_yb_y2zm(i),1,nfft,mfft,wk1_y_z,lfftc,iostr,1,wk2_y_r,lfftr,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = 2*nxw*nbuf\n     iostr= 2*nxw*nbuf\n     call dfftw_plan_many_dft_r2c(planr_yf_y2zm(i),1,nfft,mfft,wk2_y_r,lfftr,iostr,1,wk1_y_z,lfftc,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (global_ny+1)*nbuf\n     iostr= (global_ny+1)*nbuf\n     call dfftw_plan_many_dft(planr_xf_y2zm(i),1,nfft,mfft,wk2_x_z,lfft,iostr,1,wk1_x_z,lfft,iostr,1,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#else\n    nbuf = 2*nz*(nm+1)\n    do i=0, nplan-1\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     iostr= (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(planr_xb_y2x(i),1,nfft,mfft,wk1_x_z,lfft,iostr,1,wk2_x_z,lfft,iostr,1,FFTW_BACKWARD,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     iostr= (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_c2r(planr_yb_y2x(i),1,nfft,mfft,wk1_y_z,lfftc,iostr,1,wk2_y_r,lfftr,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nyw\n     lfftr(1)=2*nyw\n     lfftc(1)=nyw+1\n     mfft = (iend_xw-ist_xw+1)*nbuf\n     iostr= (iend_xw-ist_xw+1)*nbuf\n     call dfftw_plan_many_dft_r2c(planr_yf_y2x(i),1,nfft,mfft,wk2_y_r,lfftr,iostr,1,wk1_y_z,lfftc,iostr,1,FFTW_MEASURE)\n\n     nfft(1)=2*nxw\n     lfft(1)=2*nxw\n     mfft = (iend_y-ist_y+1)*nbuf\n     iostr= (iend_y-ist_y+1)*nbuf\n     call dfftw_plan_many_dft(planr_xf_y2x(i),1,nfft,mfft,wk2_x_z,lfft,iostr,1,wk1_x_z,lfft,iostr,1,FFTW_FORWARD,FFTW_MEASURE)\n    end do\n\n#endif\n\n\n  END SUBROUTINE fft_pre\n\n\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Xfft ( exbdf, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_out ! for outplace\n!    integer :: ist_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1421)\n!                                         ! call fapp_start(\"nlterm_backward_Xfft\",1421,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_backward,  &\n!                          exbdf(0,my,i),    &     ! complex in\n!                        !  exbdf(0,my,i)        )  ! complex out\n!                          wk_x_out             )  ! complex out ! for outplace\n!\n!        ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            do mx = ist_xw, iend_xw\n!             !  send_buff(my,mx,i,irank) = exbdf(mx+ist_xw_g_rank,my,i)\n!               send_buff(my,mx,i,irank) = wk_x_out(mx+ist_xw_g_rank) ! for outplace\n!            enddo\n!          enddo\n!\n!        enddo\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_backward_Xfft\",1421,1)\n!                                           call clock_end(1421)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Xfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_chXY ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         Y divide -> X divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1422)\n!                                         ! call fapp_start(\"nlterm_backward_shiftXY\",1422,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                         ! call fapp_stop(\"nlterm_backward_shiftXY\",1422,1)\n!                                           call clock_end(1422)\n!    \n!\n!  END SUBROUTINE fft_backward_chXY\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Yfft ( recv_buff, exbdf_xw, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_in(0:nyw) ! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1423)\n!                                         ! call fapp_start(\"nlterm_backward_Yfft\",1423,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!        ! --- restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!            !  exbdf_xw(my,mx,i) = recv_buff(my-ist_y_g_rank,mx,i,irank)\n!              wk_y_in(my) = recv_buff(my-ist_y_g_rank,mx,i,irank) ! for outplace\n!            end do\n!          end do\n!        ! --- set filler ---\n!          do my = global_ny+1, nyw\n!          !  exbdf_xw(my,mx,i) = ( 0._DP, 0._DP )\n!            wk_y_in(my) = ( 0._DP, 0._DP ) ! for outplace\n!          end do\n!\n!          call dfftw_execute_dft_c2r( &\n!                          plan_y_backward,   &\n!                        !  exbdf_xw(0,mx,i),  &    ! complex in\n!                          wk_y_in,            &    ! complex in ! for outplace\n!                          exbdf_xw(0,mx,i)     )  ! real    out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_backward_Yfft\",1423,1)\n!                                           call clock_end(1423)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Yfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Yfft ( exbdf_xw, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_out(0:nyw) ! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1441)\n!                                         ! call fapp_start(\"nlterm_forward_Yfft\",1441,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!          call dfftw_execute_dft_r2c( &\n!                          plan_y_forward,    &\n!                          exbdf_xw(0,mx,i),  &    ! real in\n!                        !  exbdf_xw(0,mx,i)     )  ! complex out\n!                          wk_y_out             )  ! complex out ! for outplace\n!\n!        ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!            !  send_buff(my-ist_y_g_rank,mx,i,irank) = exbdf_xw(my,mx,i)\n!              send_buff(my-ist_y_g_rank,mx,i,irank) = wk_y_out(my) ! for outplace\n!            end do\n!          end do\n!\n!      end do\n!    end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_forward_Yfft\",1441,1)\n!                                           call clock_end(1441)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Yfft\n!\n!\n!!--------------------------------------\n!  ", "SUBROUTINE fft_forward_chYX ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         X divide -> Y divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1442)\n!                                        ! call fapp_start(\"nlterm_forward_shiftYX\",1442,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                        ! call fapp_stop(\"nlterm_forward_shiftYX\",1442,1)\n!                                           call clock_end(1442)\n!\n!\n!  END SUBROUTINE fft_forward_chYX\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Xfft ( recv_buff, exbdf, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_in! for outplace\n!    integer :: ist_xw_g_rank, iend_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1443)\n!                                        ! call fapp_start(\"nlterm_forward_Xfft\",1443,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!       ! ---  restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            iend_xw_g_rank = min ( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!            do mx = ist_xw_g_rank, iend_xw_g_rank\n!           !  exbdf(mx,my,i) = recv_buff(my,mx-ist_xw_g_rank,i,irank)\n!              wk_x_in(mx) = recv_buff(my,mx-ist_xw_g_rank,i,irank)! for outplace\n!            enddo\n!          enddo\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_forward,   &\n!                       !  exbdf(0,my,i),    &   ! complex in\n!                          wk_x_in,          &   ! complex in! for outplace\n!                          exbdf(0,my,i)       ) ! complex out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_forward_Xfft\",1443,1)\n!                                           call clock_end(1443)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Xfft\n\n\nEND MODULE GKV_fft\n", "MODULE ring_header\n\n  implicit none\n\n  integer, parameter :: DP = selected_real_kind(14)\n!\n!  integer :: olog = 10\n!\n!  real(kind=DP) :: ring_a = 0.5_DP\n\n  real(kind=DP) :: ring_a\n\n  public  ring_a\n\n\nEND MODULE ring_header\n\n\nMODULE ring_func\n\n  use ring_header\n  use GKV_math,   only: math_eli1, math_eli2\n\n  implicit none\n\n  private\n\n  public func_k, func_g, func_psi, func_x, func_eli1, func_eli2\n\n\nCONTAINS\n\n\n  FUNCTION func_k( r, z )\n\n    real(kind=DP)             :: func_k\n    real(kind=DP), intent(in) :: r, z\n\n      func_k = sqrt( ( 4._DP * ring_a * abs(r) ) / ( ( ring_a + r )**2 + z**2 ) )\n\n  END FUNCTION func_k\n\n\n  FUNCTION func_g( r, z )\n\n    real(kind=DP)             :: func_g\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: eli1, eli2, kk\n\n      kk = func_k( r, z )**2\n\n      call math_eli1( kk, eli1 ) \n!!!        if( icon /= 0 ) print *, \"# icon in celi1 = \", icon\n      call math_eli2( kk, eli2 ) \n!!!        if( icon /= 0 ) print *, \"# icon in celi2 = \", icon\n\n      func_g = ( ( 1._DP - 0.5_DP * kk ) * eli1 - eli2 ) &\n             * sqrt( ( ring_a + r )**2 + z**2 ) * 0.5_DP\n\n  END FUNCTION func_g\n\n\n  FUNCTION func_psi( r, z )\n\n    real(kind=DP)             :: func_psi\n    real(kind=DP), intent(in) :: r, z\n\n      func_psi = func_g( r, z ) / func_g( 1._DP, 0._DP )\n\n  END FUNCTION func_psi\n\n\n  FUNCTION func_x( r, z, psi0 )\n\n    real(kind=DP)             :: func_x\n    real(kind=DP), intent(in) :: r, z, psi0\n\n      func_x =  (func_psi( 1._DP, 0._DP ) - func_psi( r, z ) ) / psi0\n\n  END FUNCTION func_x\n\n\n  FUNCTION func_eli1( r, z )\n\n    real(kind=DP)             :: func_eli1\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: eli1, kk\n\n      kk = func_k( r, z )**2\n\n      call math_eli1( kk, eli1 ) \n\n      func_eli1 = eli1\n\n  END FUNCTION func_eli1\n\n\n  FUNCTION func_eli2( r, z )\n\n    real(kind=DP)             :: func_eli2\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: eli2, kk\n\n      kk = func_k( r, z )**2\n\n      call math_eli2( kk, eli2 ) \n\n      func_eli2 = eli2\n\n  END FUNCTION func_eli2\n\n\nEND MODULE ring_func\n\n\nMODULE ring_diff\n\n  use ring_header\n\n  implicit none\n\n  private\n\n  public diff_r, diff_z, diff_rho\n\n\nCONTAINS\n\n\n  FUNCTION diff_r( fun, rin, zin )\n\n    real(kind=DP), external :: fun\n    real(kind=DP), intent(in)  :: rin, zin\n\n    real(kind=DP) :: diff_r\n\n    real(kind=DP) :: dr1, dr2\n\n\n      dr1   = abs( rin ) * 1.d-4\n      dr2   = dr1 * 2._DP\n\n      if( rin == 0._DP ) then\n        diff_r = 0._DP\n\n      else\n        diff_r = ( - fun(rin+dr2,zin) + 8._DP*fun(rin+dr1,zin)   &\n                   - 8._DP*fun(rin-dr1,zin) + fun(rin-dr2,zin) ) &\n               / ( 12._DP * dr1 )\n\n      end if\n\n\n  END FUNCTION diff_r\n\n\n  FUNCTION diff_z( fun, rin, zin )\n\n    real(kind=DP), external :: fun\n    real(kind=DP), intent(in)  :: rin, zin\n\n    real(kind=DP) :: diff_z\n\n    real(kind=DP) :: dz1, dz2\n\n\n      dz1   = abs( zin ) * 1.d-4\n      dz2   = dz1 * 2._DP\n\n!      if( zin == 0._DP ) then\n       if( abs(zin) < 1.d-12) then\n        diff_z = 0._DP\n\n      else\n        diff_z = ( - fun(rin,zin+dz2) + 8._DP*fun(rin,zin+dz1)   &\n                   - 8._DP*fun(rin,zin-dz1) + fun(rin,zin-dz2) ) &\n               / ( 12._DP * dz1 )\n\n      end if\n\n\n  END FUNCTION diff_z\n\n\n  FUNCTION diff_rho( fun, rin, zin )\n\n    real(kind=DP), external :: fun\n    real(kind=DP), intent(in)  :: rin, zin\n\n    real(kind=DP) :: diff_rho\n\n!    real(kind=DP) :: rho, tht\n    real(kind=DP) :: tht\n\n\n!      rho = sqrt( ( rin - ring_a )**2 + zin**2 )\n      tht = atan2( zin, rin - ring_a ) \n\n      diff_rho = diff_r( fun, rin, zin ) * cos( tht ) &\n               + diff_z( fun, rin, zin ) * sin( tht )\n\n\n  END FUNCTION diff_rho\n\n\nEND MODULE ring_diff\n\n\nMODULE ring_bfld\n\n  use ring_header\n  use ring_func\n  use ring_diff\n\n  implicit none\n\n  private\n\n  public bfld_br, bfld_bz, bfld_magb, bfld_gradbr, bfld_gradbz\n\n\nCONTAINS\n\n\n  FUNCTION bfld_br( r, z )\n\n    real(kind=DP)             :: bfld_br\n    real(kind=DP), intent(in) :: r, z\n\n!      bfld_br = diff_z( func_psi, r, z) / r\n\n      bfld_br = diff_z( func_psi, r, z ) / r\n\n  END FUNCTION bfld_br\n\n\n  FUNCTION bfld_bz( r, z )\n\n    real(kind=DP)             :: bfld_bz\n    real(kind=DP), intent(in) :: r, z\n\n!      bfld_bz = diff_r( func_psi, r, z ) / r\n\n      bfld_bz = - diff_r( func_psi, r, z ) / r\n\n  END FUNCTION bfld_bz\n\n\n  FUNCTION bfld_magb( r, z )\n\n    real(kind=DP)             :: bfld_magb\n    real(kind=DP), intent(in) :: r, z\n\n    real(kind=DP) :: br, bz\n\n      br = bfld_br( r, z )\n      bz = bfld_bz( r, z )\n\n      bfld_magb = sqrt( br**2 + bz**2 )\n\n!!!      print *, br, bz\n\n  END FUNCTION bfld_magb\n\n\n  FUNCTION bfld_gradbr( r, z )\n\n    real(kind=DP)             :: bfld_gradbr\n    real(kind=DP), intent(in) :: r, z\n\n      bfld_gradbr = diff_r( bfld_magb,  r, z )\n\n  END FUNCTION bfld_gradbr\n\n\n  FUNCTION bfld_gradbz( r, z )\n\n    real(kind=DP)             :: bfld_gradbz\n    real(kind=DP), intent(in) :: r, z\n\n      bfld_gradbz = diff_z( bfld_magb,  r, z )\n\n  END FUNCTION bfld_gradbz\n\n\nEND MODULE ring_bfld\n\n\nMODULE GKV_ring\n!-----------------------------------------------------------------\n!\n!   Flux tube coordinates in the ring dipole geometry\n!\n!   Definition of the flux tube coordinates\n!   in the ring dipole geometry\n!\n!     x = (Psi_0 - Psi) / (R_0*B'_0)\n!     y = R_0 * phi\n!     z = Theta (= arctan(Z/(R-a)) \n!     where (R, phi, Z ) are the cylindorical coordinates\n!\n!     B'_0 = 1/R * (dPsi/dr - dPsi/dz) | r=1,z=0\n!     B_0 = B / B'_0                   | r=1,z=0\n!   We also use the normalization of Psi_0*(gradx crs grady) = B_0*R_0^2 \n!     with R_0 = 1 and B_0 = 1 as the units\n!\n!-----------------------------------------------------------------\n\n  use ring_header\n!  use gkv_header\n  use ring_func\n  use ring_diff\n  use ring_bfld\n\n  implicit none\n\n  private\n\n  public ring_coordinates\n\n\nCONTAINS\n\n  SUBROUTINE ring_coordinates( a, tht, bb, ub_dot_grdb, ub_crs_grdb, &\n                               gxx, gxy, gxz, gyy, gyz, gzz, rootg, dbdx, dbdz)\n\n  real(kind=DP), intent(in)  :: a, tht\n  real(kind=DP), intent(out) :: bb, ub_dot_grdb, ub_crs_grdb\n  real(kind=DP), intent(out) :: gxx, gxy, gxz, gyy, gyz, gzz, rootg\n!>>\n  real(kind=DP), intent(out) :: dbdx, dbdz\n  real(kind=DP) :: R0, psi0\n  real(kind=DP) :: eps_x, rho_p, rho_m, r_p, r_m, z_p, z_m\n!<<\n  real(kind=DP) :: r, z, rho, rho1, hh, dh\n\n  real(kind=DP) :: b0\n  real(kind=DP) :: gbr, gbz, ubr, ubz!, psi_n, b_rootg_i, ub_dot_grdh\n\n!  real(kind=DP) :: rootg2\n\n  real(kind=DP) :: eps, eps0 = 0.00000001_DP\n  integer       :: ic, nc = 20\n\n\n    ring_a = a\n\n    rho  = 1._DP - ring_a\n\n      hh  = 0._DP\n      dh  = acos(-1._DP) * 0.01_DP\n\n\n\n! compute for hh\n!!!      do while ( hh < abs(tht)-dh*0.5 )\n      do while ( hh < abs(tht)-dh )\n        hh = hh + dh\n\n        eps = 1._DP\n        ic  = 0\n\n        r = rho * cos(hh) + ring_a\n        z = rho * sin(hh)\n\n      do while ( eps > eps0 .AND.  ic < nc )\n\n        ic = ic + 1\n\n        rho1 = rho - ( func_psi( r, z ) - 1._DP ) / diff_rho( func_psi, r, z )\n        eps  = abs( rho1 - rho ) / abs( rho )\n        rho  = rho1\n\n        r = rho * cos(hh) + ring_a\n        z = rho * sin(hh)\n        if( abs(z) < 1.d-14 ) z = 0._DP\n\n      end do\n!!!           print *, \"# ic, tht, rho1, psi = \", ic, tht, rho, func_psi( r, z )\n\n      end do\n\n! compute for tht\n        eps = 1._DP\n        ic  = 0\n\n        r = rho * cos(tht) + ring_a\n        z = rho * sin(tht)\n\n      do while ( eps > eps0 .AND.  ic < nc )\n\n        ic = ic + 1\n\n        rho1 = rho - ( func_psi( r, z ) - 1._DP ) / diff_rho( func_psi, r, z )\n        eps  = abs( rho1 - rho ) / abs( rho )\n        rho  = rho1\n\n        r = rho * cos(tht) + ring_a\n        z = rho * sin(tht)\n        if( abs(z) < 1.d-14 ) z = 0._DP\n\n      end do\n\n        if( ic == nc ) then\n           print *, \"# ic, tht, rho1, psi = \", ic, tht, rho, func_psi( r, z )\n        end if\n\n!>>\n        R0 = 1._DP\n        eps_x = 0.0000001_DP\n        rho_p = rho + eps_x\n        r_p = rho_p * cos(tht) + ring_a\n        z_p = rho_p * sin(tht)\n        rho_m = rho - eps_x\n        r_m = rho_m * cos(tht) + ring_a\n        z_m = rho_m * sin(tht)\n!<<\n\n        b0 = bfld_magb( 1._DP, 0._DP )\n\n        bb  = bfld_magb  ( r, z )/b0\n\n!>>\n        psi0 = b0*R0**2\n        dbdx = ( bfld_magb( r_p, z_p ) - bfld_magb( r_m, z_m ) )/b0/( func_x(r_p, z_p, psi0) - func_x(r_m, z_m, psi0) )\n!<<\n\n        ubr = bfld_br( r, z )/b0 / bb\n        ubz = bfld_bz( r, z )/b0 / bb\n\n        gbr = bfld_gradbr( r, z )/b0\n        gbz = bfld_gradbz( r, z )/b0\n\n        ub_dot_grdb = ubr * gbr + ubz * gbz\n        ub_crs_grdb = ubz * gbr - ubr * gbz\n\n!        ub_dot_grdh = - ubr * sin( tht ) + ubz * cos( tht )\n\n!        psi_n = func_psi( r, z ) / func_psi( 1._DP, 0._DP )\n\n        gxx   = ( r * bb )**2\n        gxy   = 0._DP\n        gxz   = - r * bb * ( ubz*sin(tht) + ubr*cos(tht) ) / rho\n        gyy   = 1._DP / r**2\n        gyz   = 0._DP\n        gzz   = 1._DP / rho**2\n        rootg = 1._DP / sqrt( gyy*( gxx*gzz - gxz**2 ) )\n\n!>>\n        dbdz = ub_dot_grdb * bb * rootg\n!<<\n\n!        b_rootg_i = 1._DP / ( bb * rootg )\n\n!        rootg2= r * rho * b0 / ( diff_r( func_psi, r, z )*cos(tht)   &\n!                                 + diff_z( func_psi, r, z )*sin(tht) )\n!        rootg2= 1._DP / ( ubz * bb * cos(tht)   &\n!                        - ubr * bb * sin(tht) )\n\n!! debug\n!        write(unit=6, fmt=\"(1p, 32e15.7)\" ) tht, rho, r, z, func_psi(r,z), &\n!              bb, ubr, ubz, gbr, gbz, ub_dot_grdb, ub_crs_grdb, ub_dot_grdh,  &\n!              psi_n, gxx, gxy, gxz, gyy, gyz, gzz, rootg, b_rootg_i, rootg2\n!! debug\n\n\n\n  END SUBROUTINE ring_coordinates\n\n\nEND MODULE GKV_ring\n", "MODULE GKV_advnc\n!-------------------------------------------------------------------------------\n!\n!    Calculate df/dt and time advance by Runge-Kutta-Gill method\n!\n!    Update history of gkvp_advnc.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Time-dependent metrics for rotating flux-tube model is implemented.\n!          See lines at \"!%%% For shearflow rotating flux tube model %%%\".\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Unitialized access for padding iend_y<my is removed.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fld,   only: fld_esfield, fld_emfield_hh, fld_hh2ff\n  use GKV_exb,   only: exb_NL_term\n  use GKV_colli, only: colli_LB!, colli_full\n  use GKV_colliimp, only: colliimp_calc_colli_full, colliimp_set_param\n  use GKV_bndry, only: bndry_bound_e,  &\n                       bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout\n  use GKV_clock, only: clock_sta, clock_end\n  use GKV_zfilter, only: zfilter\n  use GKV_tips,  only: tips_reality\n  use GKV_geom, only: geom_increment_time\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_zv = 1, nchunk_yzv = 1, nchunk_yz = 1\n\n  public   advnc_rkgsteps_rev, caldlt_rev\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n!--------------------------------------\n!     time integration of GK equation using RKG method\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n    complex(kind=DP), save,  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: qh\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dh, cf, ef\n    integer :: mx, my, iz, iv, im, istep\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = 0, ny\n                do mx = -nx, nx\n                  qh(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zv = ((2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yzv = ((iend_y-ist_y+1)*(2*nz)*(2*nv)-1) / (nthreads-1) + 1\n!$      nchunk_yz = ((iend_y-ist_y+1)*(2*nz)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      do istep = 1, 4\n\n       !%%% For shearflow rotating flux tube model %%%\n        if (gamma_e /= 0._DP .and. trim(flag_shearflow) == \"rotating\") then\n          if (istep == 2 .or. istep == 4) then\n            call geom_increment_time(0.5_DP * dt)\n            if (trim(col_type) == \"full\" .or. trim(col_type) == \"lorentz\" .or. trim(time_advnc) == \"imp_colli\") then\n              call colliimp_set_param\n            end if\n          end if\n        end if\n       !%%%\n\n        call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n                                           call clock_sta(11)\n                                         ! call fapp_start(\"rkg\",11,1)\n        call rkg( hh, dh, qh, istep )\n                                         ! call fapp_stop(\"rkg\",11,1)\n                                           call clock_end(11)\n\n        call tips_reality ( hh )\n\n                                           call clock_sta(12)\n                                         ! call fapp_start(\"esfield\",12,1)\n        if ( beta > 0._DP ) then\n          call fld_emfield_hh( hh, Al )\n        end if\n        call fld_hh2ff( hh, Al, ff )\n        call fld_esfield( ff, phi )\n                                         ! call fapp_stop(\"esfield\",12,1)\n                                           call clock_end(12)\n      end do\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n\n  END SUBROUTINE advnc_rkgsteps_rev\n\n\n!--------------------------------------\n  SUBROUTINE rkg( hh, dh, qh, istep )\n!--------------------------------------\n!     Runge-Kutta-Gill\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh, qh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n    integer, intent(in) :: istep\n\n    real(kind=DP) :: c1, c2, cq, c0\n    integer :: mx, my, iz, iv, im\n\n\n      if      ( istep == 1 ) then\n        c1   =  0.5_DP\n        c2   = -1._DP\n        cq   = -2._DP\n        c0   =  1._DP\n      else if ( istep == 2 ) then\n        c1   =  1._DP - sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 3 ) then\n        c1   =  1._DP + sqrt( 0.5_DP )\n        c2   = -c1\n        cq   =  1._DP - 3._DP * c1\n        c0   =  2._DP * c1\n      else if ( istep == 4 ) then\n        c1   =  1._DP / 6._DP\n        c2   = -1._DP / 3._DP\n        cq   =  0._DP\n        c0   =  0._DP\n      end if\n\n!$OMP parallel do collapse(3)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                hh(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im)           &\n                                   + c1 * dt * dh(mx,my,iz,iv,im) &\n                                   + c2 * qh(mx,my,iz,iv,im)\n                qh(mx,my,iz,iv,im) = cq * qh(mx,my,iz,iv,im) &\n                                   + c0 * dt * dh(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n\n  END SUBROUTINE rkg\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    character(15), intent(in) :: colliflag ! = \"collisional\"\n                                           ! = \"collisionless\"\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: dh, cf, ef\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi\n    integer :: mx, my, iz, iv, im\n\n      allocate( psi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n\n!$OMP parallel default(none) &\n!$OMP shared(psi,chi,phi,Al,j0,ist_y,iend_y) &\n!$OMP private(mx,my,iz,im)\n!$OMP do collapse(2)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = iend_y, ny\n            psi(:,my,iz,im) = (0._DP, 0._DP)\n            chi(:,my,iz,im) = (0._DP, 0._DP)\n          end do\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n              chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do\n!$OMP end parallel\n\n                                           call clock_sta(13)\n                                         ! call fapp_start(\"literm\",13,1)\n     !%%% Linear collisionless term %%%\n      call caldlt_linear( ff, psi, chi, dh )\n\n     !%%% Collision term %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n\n        if ( trim(col_type) == \"LB\" ) then\n          call colli_LB( ff, phi, cf )\n        else if ( trim(col_type) == \"full\" .or. &\n                  trim(col_type) == \"lorentz\" ) then\n          !call colli_full( ff, phi, cf )\n          call colliimp_calc_colli_full( ff, phi, cf )\n        else \n          write(olog,*) \"## Illegal choice for col_type!! ---> stop\"\n          call flush(olog)\n          call MPI_Finalize(ierr_mpi)\n          stop\n        end if\n\n      else if ( trim(colliflag) == \"collisionless\" ) then\n\n!!$OMP parallel workshare\n!        cf(:,:,:,:,:) = (0._DP, 0._DP)\n!!$OMP end parallel workshare\n\n      else \n\n        write(olog,*) \"## Illegal choice for colliflag:\", colliflag\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n                                         ! call fapp_stop(\"literm\",13,1)\n                                           call clock_end(13)\n\n                                           call clock_sta(14)\n                                         ! call fapp_start(\"nlterm\",14,1)\n     !%%% Nonlinear term %%%\n      call exb_NL_term( hh, psi, chi, ef )\n                                         ! call fapp_stop(\"nlterm\",14,1)\n                                           call clock_end(14)\n\n     !%%% dh/dt = (Linear collisionless) + (Collision) - (Nonlinear) %%%\n      if ( trim(colliflag) == \"collisional\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              !do my = 0, ny\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     + cf(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      else if ( trim(colliflag) == \"collisionless\" ) then\n!$OMP parallel\n        do im = 0, nm\n!$OMP do\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              !do my = 0, ny\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  dh(mx,my,iz,iv,im) = dh(mx,my,iz,iv,im) &\n                                     - ef(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n        end do\n!$OMP end parallel\n      end if\n                                           call clock_sta(15)\n                                         ! call fapp_start(\"zfilter\",15,1)\n      if ( trim(z_filt) == \"on\" ) then\n        call zfilter( dh )\n      end if                                \n                                         ! call fapp_stop(\"zfilter\",15,1)\n                                           call clock_end(15)\n\n      deallocate( psi )\n      deallocate( chi )\n\n  END SUBROUTINE caldlt_rev\n\n\n!--------------------------------------\n  SUBROUTINE caldlt_linear( ff, psi, chi, dh )\n!--------------------------------------\n!     increment of delta-f within a time step\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: dh\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: &\n                         zb1be, zb1te, zb2be, zb2te, zb1bo, zb1to, zb2bo, zb2to\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    integer :: im\n\n\n      allocate( zb1be(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb1te(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2be(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2te(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb1bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb1to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2bo(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( zb2to(-nx:nx,0:ny,0:nzb-1,1:2*nv) )\n      allocate( vb1e(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n      allocate( vb1o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n      allocate( vb2o(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) )\n\n      call bndry_bound_e( psi )\n\n      call literm_k_rev( ff, psi, chi, dh )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,psi,chi,dh) &\n!$OMP shared(zb1be,zb1te,zb2be,zb2te,zb1bo,zb1to,zb2bo,zb2to,vb1e,vb2e,vb1o,vb2o) &\n!$OMP private(im)\n\n!!%%% Without overlap %%%\n!      do im = 0, nm\n!        call bndry_zv_buffin( ff(:,:,:,:,im), zb1be, zb1te, vb1e )\n!!$OMP barrier\n!!$OMP master\n!        call bndry_zv_sendrecv( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n!!$OMP end master\n!!$OMP barrier\n!        call bndry_zv_buffout( zb2be, zb2te, vb2e, ff(:,:,:,:,im) )\n!!$OMP barrier\n!        call literm_zv( ff(:,:,:,:,im), psi(:,:,:,im), im, dh(:,:,:,:,im) )\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!!%%% With overlap %%%\n      do im = 0, nm+3\n        if (mod(im,2) == 0) then ! even\n!$OMP master\n          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1bo, zb1to, zb2bo, zb2to, vb1o, vb2o )\n!$OMP end master\n          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1be, zb1te, vb1e )\n          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2be, zb2te, vb2e, ff(:,:,:,:,im-2) )\n          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n        else                     ! odd\n!$OMP master\n          if (0+1<=im .and. im<=nm+1) call bndry_zv_sendrecv( zb1be, zb1te, zb2be, zb2te, vb1e, vb2e )\n!$OMP end master\n          if (0  <=im .and. im<=nm  ) call bndry_zv_buffin( ff(:,:,:,:,im), zb1bo, zb1to, vb1o )\n          if (0+2<=im .and. im<=nm+2) call bndry_zv_buffout( zb2bo, zb2to, vb2o, ff(:,:,:,:,im-2) )\n          if (0+3<=im .and. im<=nm+3) call literm_zv( ff(:,:,:,:,im-3), psi(:,:,:,im-3), im-3, dh(:,:,:,:,im-3) )\n        end if\n!$OMP barrier\n      end do\n!!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( zb1be )\n      deallocate( zb1te )\n      deallocate( zb2be )\n      deallocate( zb2te )\n      deallocate( zb1bo )\n      deallocate( zb1to )\n      deallocate( zb2bo )\n      deallocate( zb2to )\n      deallocate( vb1e )\n      deallocate( vb2e )\n      deallocate( vb1o )\n      deallocate( vb2o )\n\n\n  END SUBROUTINE caldlt_linear\n\n\n!--------------------------------------\n  SUBROUTINE literm_k_rev ( ff, psi, chi, lf )\n!--------------------------------------\n!     z-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: lf\n\n    real(kind=DP) :: cs1, cs2, kvd, kvs\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1320)\n                                         ! call fapp_start(\"literm_perp\",1320,1)\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      cs2    = sqrt( tau(ranks) / Anum(ranks) )\n\n!$OMP parallel do collapse(3) private(kvd,kvs)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im)\n                kvs = ky(my) * vsy(iz,iv,im)\n                lf(mx,my,iz,iv,im) =                  &\n                   - ui * kvd * ff(mx,my,iz,iv,im)    &\n                   - cs1 * fmx(iz,iv,im) * (          &\n                       + ui * kvd * psi(mx,my,iz,im)  &\n                       - ui * kvs                     &\n                            * ( psi(mx,my,iz,im) - cs2 * vl(iv) * chi(mx,my,iz,im) ) )\n              end do\n            end do\n          end do\n        end do\n      end do\n                                         ! call fapp_stop(\"literm_perp\",1320,1)\n                                           call clock_end(1320)\n\n\n  END SUBROUTINE literm_k_rev\n\n\n!--------------------------------------\n  ", "SUBROUTINE literm_zv ( ff, psi, im, lf )\n!--------------------------------------\n!     (z,v)-derivative of ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb)            :: psi\n    integer, intent(in) :: im\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)             :: lf\n\n    real(kind=DP), dimension(-nz:nz-1) :: cefz, cefz2\n    real(kind=DP) :: cefv, cs1, rotating_cf4, rotating_up5\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1330)\n                                        ! call fapp_start(\"literm_para\",1330,1)\n!$OMP end master\n\n      cs1    = sgn(ranks) * Znum(ranks) / tau(ranks)\n      do iz = -nz, nz-1\n        cefz(iz)   = 1._DP / ( 12._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n        cefz2(iz)  = 1._DP / ( 60._DP * dpara(iz) ) * sqrt( tau(ranks) / Anum(ranks) )\n      end do\n      cefv   = 1._DP / ( 12._DP * dv ) * sqrt( tau(ranks) / Anum(ranks) )\n    !%%% For shearflow rotating flux tube model %%%\n      if (gamma_e /= 0._DP.and. trim(flag_shearflow) == \"rotating\") then\n        rotating_cf4 = - gamma_e / (s_hat_g * 12._DP * (zz(0)-zz(-1)))\n        rotating_up5 = - gamma_e / (s_hat_g * 60._DP * (zz(0)-zz(-1)))\n      else\n        rotating_cf4 = 0._DP\n        rotating_up5 = 0._DP\n      end if\n    !%%%\n\n      if (trim(z_calc) == \"cf4\") then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_zv)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n             !%%% For shearflow rotating flux tube model %%%\n             !!!- vl(iv) * cefz(iz) * (              &\n                 - (vl(iv) * cefz(iz) + rotating_cf4) * ( &\n             !%%%\n                     -         ff(mx,my,iz+2,iv)      &\n                     + 8._DP * ff(mx,my,iz+1,iv)      &\n                     - 8._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )    &\n                 + mir(iz,im) * cefv * (              &\n                     -         ff(mx,my,iz,iv+2)      &\n                     + 8._DP * ff(mx,my,iz,iv+1)      &\n                     - 8._DP * ff(mx,my,iz,iv-1)      &\n                     +         ff(mx,my,iz,iv-2) )    &\n                 - cs1 * fmx(iz,iv,im) * (            &\n                       vl(iv) * cefz(iz) * (          &\n                         -         psi(mx,my,iz+2)    &\n                         + 8._DP * psi(mx,my,iz+1)    &\n                         - 8._DP * psi(mx,my,iz-1)    &\n                         +         psi(mx,my,iz-2) ) )&\n                 - art_diff * (                       &\n                     +         ff(mx,my,iz+2,iv)      &\n                     - 4._DP * ff(mx,my,iz+1,iv)      &\n                     + 6._DP * ff(mx,my,iz ,iv)      &\n                     - 4._DP * ff(mx,my,iz-1,iv)      &\n                     +         ff(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      else if (trim(z_calc) == \"up5\") then\n\n        do iv = 1, 2*nv\n          if ( vl(iv) > 0._DP ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                   !%%% For shearflow rotating flux tube model %%%\n                     - rotating_cf4 * (                   &\n                         -         ff(mx,my,iz+2,iv)      &\n                         + 8._DP * ff(mx,my,iz+1,iv)      &\n                         - 8._DP * ff(mx,my,iz-1,iv)      &\n                         +         ff(mx,my,iz-2,iv) )    &\n                   !%%%\n                     - vl(iv) * cefz2(iz) * (             &\n                         - 3._DP * ff(mx,my,iz+2,iv)      &\n                         +30._DP * ff(mx,my,iz+1,iv)      &\n                         +20._DP * ff(mx,my,iz ,iv)      &\n                         -60._DP * ff(mx,my,iz-1,iv)      &\n                         +15._DP * ff(mx,my,iz-2,iv)      &\n                         - 2._DP * ff(mx,my,iz-3,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          else\n!$OMP do collapse(2) schedule(dynamic,nchunk_yz)\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  lf(mx,my,iz,iv) = lf(mx,my,iz,iv)       &\n                   !%%% For shearflow rotating flux tube model %%%\n                     - rotating_cf4 * (                   &\n                         -         ff(mx,my,iz+2,iv)      &\n                         + 8._DP * ff(mx,my,iz+1,iv)      &\n                         - 8._DP * ff(mx,my,iz-1,iv)      &\n                         +         ff(mx,my,iz-2,iv) )    &\n                   !%%%\n                     - vl(iv) * cefz2(iz) * (             &\n                         + 2._DP * ff(mx,my,iz+3,iv)      &\n                         -15._DP * ff(mx,my,iz+2,iv)      &\n                         +60._DP * ff(mx,my,iz+1,iv)      &\n                         -20._DP * ff(mx,my,iz ,iv)      &\n                         -30._DP * ff(mx,my,iz-1,iv)      &\n                         + 3._DP * ff(mx,my,iz-2,iv) )    &\n                     + mir(iz,im) * cefv * (              &\n                         -         ff(mx,my,iz,iv+2)      &\n                         + 8._DP * ff(mx,my,iz,iv+1)      &\n                         - 8._DP * ff(mx,my,iz,iv-1)      &\n                         +         ff(mx,my,iz,iv-2) )    &\n                     - cs1 * fmx(iz,iv,im) * (            &\n                           vl(iv) * cefz(iz) * (          &\n                             -         psi(mx,my,iz+2)    &\n                             + 8._DP * psi(mx,my,iz+1)    &\n                             - 8._DP * psi(mx,my,iz-1)    &\n                             +         psi(mx,my,iz-2) ) )\n                end do\n              end do\n            end do\n!$OMP end do nowait\n          end if\n        end do\n\n      else\n\n        write(olog,*) \"## Illegal choice for z_calc!! ---> stop\"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_para\",1330,1)\n                                           call clock_end(1330)\n!$OMP end master\n\n\n  END SUBROUTINE literm_zv\n\n\nEND MODULE GKV_advnc\n", "MODULE GKV_vmecbzx\n!-------------------------------------------------------------------------------\n!\n!    Calculate the magnetic field components and metric coefficients\n!      from the VMEC equilibrium by using BZX code. \n!\n!    Update history of gkvp_vmecbxz.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Input of vmecbzx_boozxcoef is modified from local iz for each rankz\n!          to global index giz.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public :: vmecbzx_boozx_read, vmecbzx_boozx_coeff\n\n  real(kind=DP), dimension(:),         allocatable   :: ss_bz, q_bz, shat_bz, eps_bz\n  real(kind=DP), dimension(:),         allocatable   :: theta_bz, zeta_bz\n  real(kind=DP), dimension(:,:,:,:,:), allocatable   :: ggup_bz\n  real(kind=DP), dimension(:,:,:),     allocatable   :: B_bz, rootg_bz, rootg_bz0\n  real(kind=DP), dimension(:,:,:),     allocatable   :: dBds_bz, dBdt_bz, dBdz_bz\n  real(kind=DP), dimension(:,:),       allocatable   :: bbozc_bz, bbozs_bz\n  real(kind=DP), dimension(:,:,:),     allocatable   :: rr_bz, zz_bz, ph_bz\n  integer,       dimension(:),         allocatable   :: ixn_bz, ixm_bz\n\n  integer        :: nss_bz, ntheta_bz, nzeta_bz\n  integer        :: nfp_bz, mnboz_bz, mboz_bz, nboz_bz, asym_flg\n  real(kind=DP)  :: Rax_bz, Bax_bz, aa_bz, volume_bz, alpha_fix\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE vmecbzx_boozx_read( nss, ntheta, nzeta )\n!--------------------------------------\n\n    implicit none\n\n    integer, intent(in)        :: nss, ntheta, nzeta\n    integer                    :: ibzx\n    character(512) :: f_bozx\n!   character(512) :: env_string      !fj\n\n    namelist /bozxf/ f_bozx\n\n    allocate(q_bz(1:nss),shat_bz(1:nss),eps_bz(1:nss))\n    allocate(ss_bz(1:nss),theta_bz(0:ntheta),zeta_bz(0:nzeta))\n    allocate(ggup_bz(1:nss,0:ntheta,0:nzeta,1:3,1:3))\n    allocate(B_bz(1:nss,0:ntheta,0:nzeta),rootg_bz(1:nss,0:ntheta,0:nzeta),rootg_bz0(1:nss,0:ntheta,0:nzeta))\n    allocate(dBds_bz(1:nss,0:ntheta,0:nzeta),dBdt_bz(1:nss,0:ntheta,0:nzeta),dBdz_bz(1:nss,0:ntheta,0:nzeta))\n\n      read(inml,nml=bozxf)\n      ibzx = 5000\n\n!      call getenv ( 'fu09',env_string ) !fj\n!      open(ibzx, file=env_string, status=\"old\", action=\"read\", form=\"unformatted\", CONVERT='LITTLE_ENDIAN' )         !fj\n\n\n      open( ibzx, file=trim(f_bozx)//\"metric_boozer.bin.dat\", status=\"old\", &\n                  action=\"read\", form=\"unformatted\", CONVERT='LITTLE_ENDIAN' )\n      write(olog,*) \"# mag.coord.(Booz_xform) input file : \"\n      write(olog,*) trim(f_bozx)//\"metric_boozer.bin.dat\"\n\n! --- read B-field and metric components\n     ! binary\n      read(unit=ibzx) nfp_bz, nss_bz, ntheta_bz, nzeta_bz, mnboz_bz, mboz_bz, nboz_bz, & \n                      Rax_bz, Bax_bz, aa_bz, volume_bz, asym_flg, alpha_fix\n      if (nss_bz /= nss.OR. ntheta_bz /= ntheta.OR. nzeta_bz /= nzeta ) then \n        print*, \"nss_bz, ntheta_bz, nzeta_bz = \", nss_bz, ntheta_bz, nzeta_bz\n        call MPI_Finalize\n        stop \"# nss or ntheta or nzeta is inconsistent between gkv_namelist and metric_boozer.dat! --> stop\"\n      end if \n\n      read(unit=ibzx) ss_bz, theta_bz, zeta_bz, q_bz, shat_bz, eps_bz, B_bz, rootg_bz, rootg_bz0, & \n                      ggup_bz, dBds_bz, dBdt_bz, dBdz_bz\n\n      allocate(rr_bz(1:nss,0:ntheta,0:nzeta),zz_bz(1:nss,0:ntheta,0:nzeta),ph_bz(1:nss,0:ntheta,0:nzeta))\n      allocate(bbozc_bz(1:mnboz_bz,1:nss),bbozs_bz(1:mnboz_bz,1:nss))\n      allocate(ixn_bz(1:mnboz_bz),ixm_bz(1:mnboz_bz))\n\n      read(unit=ibzx) rr_bz, zz_bz, ph_bz, bbozc_bz, ixn_bz, ixm_bz\n\n\n                 !!!! ascii for debug: NOT Used usually\n                 !!! read(unit=ibzx, fmt=\"(7I5,4ES24.15e3)\") nfp_bz, nss, ntheta, nzeta, mnboz_bz, mboz_bz, nboz_bz, &\n                 !!!                                         Rax_bz, Bax_bz, aa_bz, volume_bz\n                 !!! do js = 1, nss\n                 !!!   do iz = 0, nzeta\n                 !!!     do it = 0, ntheta\n                 !!!       write(unit=ibzx, fmt=\"(256ES24.15e3)\")                       &\n                 !!!               ss_bz(js),            theta_bz(it),    zeta_bz(iz),  &\n                 !!!                q_bz(js),             shat_bz(js),     eps_bz(js),  &\n                 !!!          B_bz(js,it,iz),      rootg_bz(js,it,iz),                  &\n                 !!!         ggup_bz(js,it,iz,1,1), ggup_bz(js,it,iz,1,2), ggup_bz(js,it,iz,1,3),    &\n                 !!!         ggup_bz(js,it,iz,2,2), ggup_bz(js,it,iz,2,3), ggup_bz(js,it,iz,3,3),    & \n                 !!!         Rax_bz, Bax_bz, aa_bz, volume_bz, nss, ntheta, nzeta, nfp_bz\n                 !!!     end do\n                 !!!     write(unit=ibzx, fmt=*)\n                 !!!   end do\n                 !!!     write(unit=ibzx, fmt=*)\n                 !!!     write(unit=ibzx, fmt=*)\n                 !!! end do\n\n      write(olog,*) \"# Rax_bz[m], Bax_bz[T], aa_bz[m], volume_bz[m3] = \", Rax_bz, Bax_bz, aa_bz, volume_bz\n      write(olog,*) \"# nss(=ns_b), ntheta(=ntht), nzeta, asym_flg    = \", nss, ntheta, nzeta, asym_flg\n      write(olog,*) \"# nfp_bz, mboz_bz, nboz_bz, mnboz_bz            = \", nfp_bz, mboz_bz, nboz_bz, mnboz_bz\n      if(nzeta == 0) write(olog,*) \"# fixed alpha (= zeta - q*theta) = \", alpha_fix\n      write(olog,*) \n\n\n! --- normalizartion with Bax, Rax \n      \n      B_bz       =  B_bz/Bax_bz\n      rootg_bz   =  rootg_bz/Rax_bz**3\n      ggup_bz    =  ggup_bz*Rax_bz**2\n      dBds_bz    =  dBds_bz/Bax_bz\n      dBdt_bz    =  dBdt_bz/Bax_bz\n      dBdz_bz    =  dBdz_bz/Bax_bz\n      bbozc_bz   =  bbozc_bz/Bax_bz\n\n\n      return \n\n  END SUBROUTINE vmecbzx_boozx_read\n\n\n\n!----------------------------------------------------------------------------------\n!smae start 202303\n!  SUBROUTINE vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input,  iz, zz,  lz_l,    & ! input \n  SUBROUTINE vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input,  giz, zz,  lz_l,    & ! input \n!smae end 202303\n                                   s_0,       q_0,    s_hat,   eps_r,   phi_ax,           & ! output\n                                   omg,     rootg,   domgdx,  domgdz,  domgdy,            &\n                                  gg11,      gg12,     gg13,    gg22,                     &\n                                  gg23,      gg33  )\n!----------------------------------------------------------------------------------\n\n!smae start 202303\n!    integer, intent(in)        :: isw, nss, ntheta, nzeta, iz\n    integer, intent(in)        :: isw, nss, ntheta, nzeta, giz\n!smae end 202303\n    real(kind=DP), intent(in)  :: s_input, zz, lz_l\n\n    real(kind=DP), intent(inout) :: s_0, q_0, s_hat, eps_r, phi_ax\n    real(kind=DP), intent(out) :: omg, rootg, domgdx, domgdz, domgdy\n    real(kind=DP), intent(out) :: gg11, gg12, gg13, gg22, gg23, gg33\n\n! --- local variables \n    integer                    :: is0, jj0, zt0\n    real(kind=DP)              :: eps_a\n\n\n  ! is0 = nint(s_input*(nss+1))\n    is0 = nint(s_input*(nss-1))+1\n    \n    if ( isw == 0 ) then \n\n      s_0   =   ss_bz(is0)\n      q_0   =    q_bz(is0)\n      s_hat = shat_bz(is0)\n      eps_r =  eps_bz(is0)\n\n    else if ( isw == 1 ) then\n\n      s_0   =   ss_bz(is0)\n!smae start 202303\n!      giz = (-global_nz + 2*nz*rankz + iz + nz )          \n!smae end 202303\n      jj0 = giz + ntheta/2\n  \n     \n! --- for debug\n!      write(2000+rankg,*) giz, jj0\n\n      eps_a =  eps_bz(nss)\n\n      zt0    =  0 ! for fixed alpha (i.e., single fluxtube)\n      phi_ax =  ph_bz(is0,jj0,zt0)\n      omg    =  B_bz(is0,jj0,zt0)\n      rootg  =  (eps_a**(-2))*q_0/s_0*rootg_bz(is0,jj0,zt0)\n      domgdx =  ( dBds_bz(is0,jj0,zt0) + q_0*s_hat*zz/s_0*dBdz_bz(is0,jj0,zt0) )/eps_a\n      domgdz =    dBdt_bz(is0,jj0,zt0) + q_0*dBdz_bz(is0,jj0,zt0)\n      domgdy =  - q_0/s_0*dBdz_bz(is0,jj0,zt0)/eps_a\n\n      gg11   =  eps_a**2 * ggup_bz(is0,jj0,zt0,1,1)\n\n      gg12   =  eps_a**2 * (  s_hat*zz*ggup_bz(is0,jj0,zt0,1,1)   &\n                             +     s_0*ggup_bz(is0,jj0,zt0,1,2)   &\n                             - s_0/q_0*ggup_bz(is0,jj0,zt0,1,3) )\n\n      gg13   =  eps_a*ggup_bz(is0,jj0,zt0,1,2)\n\n      gg22   =  eps_a**2 * (            (s_hat*zz)**2*ggup_bz(is0,jj0,zt0,1,1)   &\n                             +                 s_0**2*ggup_bz(is0,jj0,zt0,2,2)   &\n                             +           (s_0/q_0)**2*ggup_bz(is0,jj0,zt0,3,3)   & \n                             +     2._DP*s_0*s_hat*zz*ggup_bz(is0,jj0,zt0,1,2)   & \n                             -       2._DP*s_0**2/q_0*ggup_bz(is0,jj0,zt0,2,3)   & \n                             - 2._DP*s_0/q_0*s_hat*zz*ggup_bz(is0,jj0,zt0,1,3) )\n\n      gg23   =     eps_a * (  s_hat*zz*ggup_bz(is0,jj0,zt0,1,2)   &\n                             +     s_0*ggup_bz(is0,jj0,zt0,2,2)   &\n                             - s_0/q_0*ggup_bz(is0,jj0,zt0,2,3) )\n\n      gg33   =  ggup_bz(is0,jj0,zt0,2,2)\n\n    end if\n\n    return\n    \n  END SUBROUTINE vmecbzx_boozx_coeff\n\n\nEND MODULE GKV_vmecbzx\n", "MODULE GKV_dtc\n!-------------------------------------------------------------------------------\n!\n!    Time step size control\n!\n!    Update history of gkvp_dtc.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Minimum value of time step size is set to avoid zero-division\n!          e.g., nu_max2=max(nu_max2,1.d-20) for nu=0.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_exb, only: exb_maxvx_eachrank, exb_maxvy_eachrank\n  use GKV_colliimp, only: colliimp_colli, gvl, gvp, gnu_ds, gnu_ps, gnu_hs, gnu_gs\n\n  implicit none\n\n  private\n\n  real(kind=DP), save :: dt_linear, dt_nl, dt_limit, dt_col\n\n  real(kind=DP), save :: dx_inv, dy_inv\n\n  integer, save :: flag_time_advnc! 0: rkg4\n                                  ! 1: imp_colli\n  integer, save :: flag_time_split! 0: colli(dt/2)->RK(dt)! for imp_colli\n                                  ! 1: colli(dt  )->RK(dt)! for imp_colli\n\n  public   dtc_init, dtc_cntrl, flag_time_advnc, flag_time_split\n\n\n CONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE dtc_init( lx, ly, vmax )\n!--------------------------------------\n\n    real(kind=DP), intent(in) :: lx, ly, vmax\n\n    real(kind=DP) :: dt_perp, dt_zz, dt_vl\n    real(kind=DP) :: kvd_max, kvd_max2, vl_max, vl_max2, mir_max, mir_max2\n    real(kind=DP) :: ksq_max0, ksq_max, nu_max, nu_max2, nu_temp\n    real(kind=DP) :: cs, dx, dy, kvd\n    integer :: mx, my, iz, iv, im, is\n\n\n      ksq_max0 = 0._DP\n      ksq_max  = 0._DP\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n!              do mx = 0, nx\n                if ( ksq_max0 < ksq(mx,my,iz) ) ksq_max0 = ksq(mx,my,iz)\n              end do\n            end do\n          end do\n      call MPI_Allreduce( ksq_max0, ksq_max, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n\n      kvd_max = 0._DP\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n!              do mx = 0, nx\n                kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im)\n                if ( kvd_max < abs(kvd) ) then \n                  kvd_max = abs(kvd)\n                end if \n              end do\n            end do\n          end do\n        end do\n      end do\n      call MPI_Allreduce( kvd_max, kvd_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n      kvd_max2 = max(kvd_max2, 1.d-20)\n      dt_perp = courant_num * pi / kvd_max2\n\n      cs = sqrt( tau(ranks) / Anum(ranks) )\n      vl_max = 0._DP\n      do iz = -nz, nz-1\n        if ( vl_max < cs * vmax / dpara(iz) ) vl_max = cs * vmax / dpara(iz)\n      end do\n      call MPI_Allreduce( vl_max, vl_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n      vl_max2 = max(vl_max2, 1.d-20)\n      dt_zz = courant_num / vl_max2\n\n      mir_max = 0._DP\n      do im = 0, nm\n        do iz = -nz, nz-1\n          if ( mir_max < cs * mir(iz,im) ) mir_max = cs * mir(iz,im)\n        end do\n      end do\n      call MPI_Allreduce( mir_max, mir_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n      mir_max2 = max(mir_max2, 1.d-20)\n      dt_vl = courant_num * dv / mir_max2\n\n      if ( trim(col_type) == \"LB\" ) then\n\n        nu_max = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP &\n               * ( 2._DP / dv**2 )\n        do iz = -nz, nz-1\n          nu_temp = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP &\n                  * ( 2._DP / dvp(iz)**2 )\n          if ( nu_max < nu_temp ) nu_max = nu_temp\n        end do\n        call MPI_Allreduce( nu_max, nu_max2, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n        nu_max2 = max(nu_max2, 1.d-20)\n        dt_col = courant_num / nu_max2\n        \n      else if ( trim(col_type) == \"full\".or. &\n                trim(col_type) == \"lorentz\" ) then\n\n       !nu_max = 0._DP\n       !do im = 0, nm\n       !  do iv = 1, 2*nv\n       !    do iz = -nz, nz-1\n       !      nu_temp = ( nu_ps(iz,iv,im) * vl(iv)**2    & \n       !                + nu_ds(iz,iv,im) * vp(iz,im)**2 &\n       !                ) * 0.5_DP * ( 2._DP / dv**2 )\n       !      if ( nu_max < nu_temp ) nu_max = nu_temp\n       !    end do\n       !  end do\n       !end do\n       !do im = 0, nm\n       !  do iv = 1, 2*nv\n       !    do iz = -nz, nz-1\n       !      nu_temp = ( nu_ds(iz,iv,im) * vl(iv)**2    & \n       !                + nu_ps(iz,iv,im) * vp(iz,im)**2 &\n       !                ) * 0.5_DP * ( 2._DP / dvp(iz)**2 )\n       !      if ( nu_max < nu_temp ) nu_max = nu_temp\n       !    end do\n       !  end do\n       !end do\n        nu_max = 0._DP\n        do iz = -nz, nz-1\n          do is = 0, ns-1\n            do im = 0, global_nm\n              do iv = 1, 2*global_nv\n                nu_temp = ( gnu_ps(iv,im,is,iz) * gvl(iv)**2    & \n                          + gnu_ds(iv,im,is,iz) * gvp(im,iz)**2 &\n                          ) * 0.5_DP * ( 2._DP / dv**2 )\n                if ( nu_max < nu_temp ) nu_max = nu_temp\n              end do\n            end do\n          end do\n        end do\n        do iz = -nz, nz-1\n          do is = 0, ns-1\n            do im = 0, global_nm\n              do iv = 1, 2*global_nv\n                nu_temp = ( gnu_ds(iv,im,is,iz) * gvl(iv)**2    & \n                          + gnu_ps(iv,im,is,iz) * gvp(im,iz)**2 &\n                          ) * 0.5_DP * ( 2._DP / dvp(iz)**2 )\n                if ( nu_max < nu_temp ) nu_max = nu_temp\n              end do\n            end do\n          end do\n        end do\n        call MPI_Allreduce( nu_max, nu_max2, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n        nu_max2 = max(nu_max2, 1.d-20)\n        dt_col = courant_num / nu_max2\n\n      else\n\n        write( olog, * ) \"This col_type is not supported by dtc:\", trim(col_type)\n        dt_col = 99._DP\n\n      end if\n\n\n      dt_linear = min( dt_perp, dt_zz, dt_vl )\n\n      if (trim(time_advnc) == \"rkg4\") then\n\n        dt_limit = min( dt_max, dt_linear, dt_col )\n        dt = dt_max\n        if ( adapt_dt ) then\n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) dt = dt_limit\n        end if\n        flag_time_advnc = 0\n\n      else if (trim(time_advnc) == \"imp_colli\") then\n\n        dt_limit = min( dt_max, dt_linear )\n        dt = dt_max\n        if ( adapt_dt ) then\n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) dt = dt_limit\n        end if\n        flag_time_advnc = 1\n\n      else if (trim(time_advnc) == \"auto_init\") then\n\n        dt_limit = min( dt_max, dt_linear )\n        dt = dt_max\n        if ( adapt_dt ) then\n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) dt = dt_limit\n        end if\n        if (dt < dt_col) then\n           flag_time_advnc = 0\n        else\n           flag_time_advnc = 1\n        end if\n\n      else\n\n        write( olog, * ) \" # Wrong type of time_advnc in namelist: \", time_advnc\n        call flush(olog)\n        call MPI_Finalize ( ierr_mpi )\n        stop\n\n      end if\n\n      flag_time_split = 0\n\n        write( olog, * ) \" # Time step size control\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # time_advnc   = \", time_advnc\n        write( olog, * ) \" # flag_time_adv= \", flag_time_advnc\n        write( olog, * ) \" # courant num. = \", courant_num\n        write( olog, * ) \" # ksq_max      = \", ksq_max\n        write( olog, * ) \" # dt_perp      = \", dt_perp\n        write( olog, * ) \" # dt_zz        = \", dt_zz\n        write( olog, * ) \" # dt_vl        = \", dt_vl\n        write( olog, * ) \" # dt_col       = \", dt_col\n        write( olog, * ) \" # dt_linear    = \", dt_linear\n        write( olog, * ) \" # dt_max       = \", dt_max\n        write( olog, * ) \" # dt           = \", dt\n        write( olog, * ) \"\"\n\n      dx = lx / real( nxw, kind=DP )\n      dy = ly / real( nyw, kind=DP )\n      dx_inv = 1._DP / dx\n      dy_inv = 1._DP / dy\n\n  \n  END SUBROUTINE dtc_init\n\n\n!--------------------------------------\n  SUBROUTINE dtc_cntrl( ff, phi, Al, hh, time, id )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    real(kind=DP), intent(in) :: time\n    integer, intent(in) :: id\n\n    real(kind=DP), save :: tout_dtc\n\n\n      if( id == 0 ) then\n\n        tout_dtc  = ( int( ( time + eps )/dtout_dtc ) + 1 ) * dtout_dtc\n \n        if ( trim(calc_type) == \"nonlinear\" ) call dtc_estimate\n\n        if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) then\n          dt = dt_limit\n          write( olog, * ) &\n            \" # dt is changed at time = \", time, \", dt = \", dt\n        end if\n     \n        if ( rankg == 0 ) then\n          write( unit=odtc, fmt=\"(f10.5, 1p, 3e15.7)\" )  &\n            time, dt, dt_limit, dt_nl\n        end if\n  \n      else if( id == 1 ) then\n\n        if ( time >= tout_dtc - eps ) then\n\n          tout_dtc   = tout_dtc + dtout_dtc\n   \n          if ( trim(calc_type) == \"nonlinear\" ) call dtc_estimate\n  \n          if ( dt < 0.8_DP * dt_limit.or. 1.2_DP * dt_limit < dt ) then\n\n            if (flag_time_advnc == 1) then! Operator split + implicit collision\n              if (flag_time_split == 1) then! dt/2 integration for 2nd-order split\n                call colliimp_colli(0.5_DP*dt, ff, phi, al, hh)\n                                              !%%% For debug %%%\n                                              ! if (rankg==0) write(olog,*) &\n                                              ! time, \"half-step for dtc_cntrl\"\n                                              !%%%%%%%%%%%%%%%%%\n              end if\n              flag_time_split = 0! flag_time_split==0 means you have physical quantities at time\n            end if\n\n            dt = dt_limit\n            write( olog, * ) &\n              \" # dt is changed at time = \", time, \", dt = \", dt\n          end if\n       \n          if ( rankg == 0 ) then\n            write( unit=odtc, fmt=\"(f10.5, 1p, 3e15.7)\" )  &\n              time, dt, dt_limit, dt_nl\n          end if\n\n        end if\n\n      end if\n\n\n  END SUBROUTINE dtc_cntrl\n\n\n!!--------------------------------------\n!  SUBROUTINE dtc_estimate\n!!--------------------------------------\n!\n!    real(kind=DP) :: wx_nl1, wx_nl2, wy_nl1, wy_nl2, w_nl_max, w_nl_max2\n!    real(kind=DP) :: cs\n!    integer  ::  mx, my, iz, iv, im\n!  \n!  \n!      w_nl_max = 0._DP\n!  \n!      cs = sqrt( tau(ranks) / Anum(ranks) )\n!\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          do iz = -nz, nz-1\n!            do mx = ist_xw, iend_xw\n!              do my = 0, nyw-1\n!                wx_nl1 = abs( dx_inv * real( eyw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * byw_xw(my,mx,iz,im), kind=DP ) )\n!                wx_nl2 = abs( dx_inv * aimag( eyw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * byw_xw(my,mx,iz,im)          ) )\n!                wy_nl1 = abs( dy_inv * real( exw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * bxw_xw(my,mx,iz,im), kind=DP ) )\n!                wy_nl2 = abs( dy_inv * aimag( exw_xw(my,mx,iz,im) - cs * vl(iv) &\n!                                             * bxw_xw(my,mx,iz,im)          ) )\n!                if ( w_nl_max < wx_nl1 ) w_nl_max = wx_nl1\n!                if ( w_nl_max < wx_nl2 ) w_nl_max = wx_nl2\n!                if ( w_nl_max < wy_nl1 ) w_nl_max = wy_nl1\n!                if ( w_nl_max < wy_nl2 ) w_nl_max = wy_nl2\n!              end do\n!            end do\n!          end do\n!        end do\n!      end do\n!  \n!      call MPI_Allreduce( w_nl_max, w_nl_max2, 1, MPI_DOUBLE_PRECISION, &\n!                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n!  \n!      dt_nl = courant_num / w_nl_max2\n!  \n!      dt_limit = min( dt_max, dt_linear, dt_nl )\n!\n!  \n!  END SUBROUTINE dtc_estimate\n\n!--------------------------------------\n  SUBROUTINE dtc_estimate\n!--------------------------------------\n\n    real(kind=DP) :: w_nl_max, w_nl_max2\n\n      w_nl_max = max(eps, dx_inv*exb_maxvx_eachrank, dy_inv*exb_maxvy_eachrank)\n  \n      call MPI_Allreduce( w_nl_max, w_nl_max2, 1, MPI_DOUBLE_PRECISION, &\n                          MPI_MAX, MPI_COMM_WORLD, ierr_mpi )\n  \n      dt_nl = courant_num / w_nl_max2\n  \n      dt_limit = min( dt_max, dt_linear, dt_nl )\n\n  \n  END SUBROUTINE dtc_estimate\n\n\nEND MODULE GKV_dtc\n", "MODULE GKV_clock\n!-------------------------------------------------------------------------------\n!\n!    Elapsed time measurements\n!\n!    Update history of gkvp_clock.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  implicit none\n\n  private\n\n  public   clock_timer, clock_etime, clock_sta, clock_end, clock_reset\n\n  real(kind=DP), dimension(1:2000), save :: sss, eee, elt\n  integer, dimension(1:2000), save :: ccount\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE clock_timer( isw, iflg )\n!--------------------------------------\n\n    integer, intent(in)  :: isw\n    integer, intent(out) :: iflg\n\n    real(kind=DP), save  :: sss0, eee0\n    real(kind=DP)        :: ttotl\n\n\n      if( isw == 0 ) then\n\n        if( rank == 0 ) then\n          call clock_etime ( sss0 )\n        end if\n\n        call MPI_Bcast( sss0, 1, MPI_DOUBLE_PRECISION, 0, &\n                      MPI_COMM_WORLD, ierr_mpi )\n\n        iflg = 0\n\n        sss(1:2000) = 0._DP\n        eee(1:2000) = 0._DP\n        elt(1:2000) = 0._DP\n        ccount(1:2000) = 0\n\n      else if( isw == 1 ) then\n\n        if( rank == 0 ) then\n          call clock_etime ( eee0 )\n        end if\n\n        call MPI_Bcast( eee0, 1, MPI_DOUBLE_PRECISION, 0, &\n                      MPI_COMM_WORLD, ierr_mpi )\n\n        if ( eee0-sss0 > e_limit ) then\n          write( olog, * ) \" # elapsed time is closing to the limit\", eee0-sss0\n          iflg = 1\n        else\n          iflg = 0\n        end if\n\n      else if( isw == 2 ) then\n\n        if( rank == 0 ) then\n          call clock_etime ( eee0 )\n        end if\n\n        call MPI_Bcast( eee0, 1, MPI_DOUBLE_PRECISION, 0, &\n                      MPI_COMM_WORLD, ierr_mpi )\n\n        ttotl   = eee0 - sss0\n        elt(1310) = sum(elt(1311:1319));               ccount(1310) = ccount(1311)\n        elt(1350) = elt(1351) + elt(1352) + elt(1353); ccount(1350) = ccount(1351)\n        elt(1360) = elt(1361) + elt(1362) + elt(1363); ccount(1360) = ccount(1361)\n        elt(1370) = elt(1371) + elt(1372) + elt(1373); ccount(1370) = ccount(1371)\n        elt(1380) = elt(1381) + elt(1382) + elt(1383); ccount(1380) = ccount(1381)\n      !elt(1420) = elt(1421) + elt(1422) + elt(1423); ccount(1420) = ccount(1421)\n      !elt(1440) = elt(1441) + elt(1442) + elt(1443); ccount(1440) = ccount(1441)\n        elt(1520) = elt(1521) + elt(1522) + elt(1523); ccount(1520) = ccount(1521)\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### elapsed time (sec) and call count #########\"\n        write( olog, '(a22,f15.5,i15)' ) \"   total            = \", ttotl\n        write( olog, '(a22,f15.5,i15)' ) \"   pre              = \", elt(1), ccount(1)\n        write( olog, '(a22,f15.5,i15)' ) \"   timesteploop     = \", elt(2), ccount(2)\n        write( olog, '(a22,f15.5,i15)' ) \"   post             = \", elt(3), ccount(3)\n        write( olog, '(a22,f15.5,i15)' ) \"   output           = \", elt(10), ccount(10)\n        write( olog, '(a22,f15.5,i15)' ) \"   rkg              = \", elt(11), ccount(11)\n        write( olog, '(a22,f15.5,i15)' ) \"   field            = \", elt(12), ccount(12)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm           = \", elt(13), ccount(13)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm           = \", elt(14), ccount(14)\n        write( olog, '(a22,f15.5,i15)' ) \"   zfilter          = \", elt(15), ccount(15)\n        write( olog, '(a22,f15.5,i15)' ) \"   checkp           = \", elt(16), ccount(16)\n        write( olog, '(a22,f15.5,i15)' ) \"   colliimp         = \", elt(17), ccount(17)\n        write( olog, '(a22,f15.5,i15)' ) \"   other            = \", elt(2)-elt(10)-elt(11) &\n                                         -elt(12)-elt(13)-elt(14)-elt(15)-elt(16)-elt(17), ccount(2)\n        write( olog, * ) \" #####################################################\"\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### elapsed time detail (sec) and call count #########\"\n        write( olog, '(a22,f15.5,i15)' ) \"   field:v0moment   = \", elt(1220), ccount(1220)\n        write( olog, '(a22,f15.5,i15)' ) \"   field:fsrfave    = \", elt(1230), ccount(1230)\n        write( olog, '(a22,f15.5,i15)' ) \"   field:other      = \", elt(1210), ccount(1210)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:colli     = \", elt(1310), ccount(1310)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:perp      = \", elt(1320), ccount(1320)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:para      = \", elt(1330), ccount(1330)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:other     = \", elt(1340), ccount(1340)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:boundf    = \", elt(1350), ccount(1350)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:shiftv    = \", elt(1360), ccount(1360)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:shiftm    = \", elt(1370), ccount(1370)\n        write( olog, '(a22,f15.5,i15)' ) \"   literm:bounde    = \", elt(1380), ccount(1380)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:pack      = \", elt(1410), ccount(1410)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:transpose = \", elt(1420), ccount(1420)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:realspcal = \", elt(1430), ccount(1430)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:transpose = \", elt(1440), ccount(1440)\n        write( olog, '(a22,f15.5,i15)' ) \"   nlterm:unpack    = \", elt(1450), ccount(1450)\n        write( olog, '(a22,f15.5,i15)' ) \"   zfilter:calc     = \", elt(1510), ccount(1510)\n        write( olog, '(a22,f15.5,i15)' ) \"   zfilter:comm     = \", elt(1520), ccount(1520)\n        write( olog, * ) \" ############################################################\"\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### elapsed time more detail (sec) and call count #########\"\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:ct         = \", elt(1311), ccount(1311)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:dt         = \", elt(1312), ccount(1312)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:cf         = \", elt(1313), ccount(1313)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:mom        = \", elt(1314), ccount(1314)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:ar         = \", elt(1315), ccount(1315)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:com        = \", elt(1316), ccount(1316)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:dvp        = \", elt(1317), ccount(1317)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:0          = \", elt(1318), ccount(1318)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:colli:hwset      = \", elt(1319), ccount(1319)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:boundf:bufferin  = \", elt(1351), ccount(1351)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:boundf:sendrecv  = \", elt(1352), ccount(1352)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:boundf:bufferout = \", elt(1353), ccount(1353)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftv:bufferin  = \", elt(1361), ccount(1361)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftv:sendrecv  = \", elt(1362), ccount(1362)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftv:bufferout = \", elt(1363), ccount(1363)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftm:bufferin  = \", elt(1371), ccount(1371)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftm:sendrecv  = \", elt(1372), ccount(1372)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:shiftm:bufferout = \", elt(1373), ccount(1373)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:bounde:bufferin  = \", elt(1381), ccount(1381)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:bounde:sendrecv  = \", elt(1382), ccount(1382)\n        write( olog, '(a29,f15.5,i15)' ) \"   literm:bounde:bufferout = \", elt(1383), ccount(1383)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:backward:Xfft    = \", elt(1421), ccount(1421)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:backward:shiftXY = \", elt(1422), ccount(1422)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:backward:Yfft    = \", elt(1423), ccount(1423)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:forward:Yfft     = \", elt(1441), ccount(1441)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:forward:shiftYX  = \", elt(1442), ccount(1442)\n        write( olog, '(a29,f15.5,i15)' ) \"   nlterm:forward:Xfft     = \", elt(1443), ccount(1443)\n        write( olog, '(a29,f15.5,i15)' ) \"   zfilter:comm:bufferin   = \", elt(1521), ccount(1521)\n        write( olog, '(a29,f15.5,i15)' ) \"   zfilter:comm:sendrecv   = \", elt(1522), ccount(1522)\n        write( olog, '(a29,f15.5,i15)' ) \"   zfilter:comm:bufferout  = \", elt(1523), ccount(1523)\n        write( olog, * ) \" #################################################################\"\n\n        write( olog, * ) \"\"\n        write( olog, * ) \" ######### For implicit collison solver #########\"\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:init     = \", elt(1700), ccount(1700)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:pack     = \", elt(1710), ccount(1710)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:alltoall = \", elt(1711), ccount(1711)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:unpack   = \", elt(1712), ccount(1712)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:bicgstab = \", elt(1720), ccount(1720)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:pack     = \", elt(1730), ccount(1730)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:alltoall = \", elt(1731), ccount(1731)\n        write( olog, '(a23,f15.5,i15)' ) \"   colliimp:unpack   = \", elt(1732), ccount(1732)\n        write( olog, * ) \" ################################################\"\n\n        iflg = 0\n\n      end if\n\n\n  END SUBROUTINE clock_timer\n\n\n!--------------------------------------\n  SUBROUTINE clock_etime( ttt )\n!--------------------------------------\n\n    real(kind=DP) :: ttt\n\n\n      ttt = MPI_Wtime()\n\n\n  END SUBROUTINE clock_etime\n\n\n!--------------------------------------\n  SUBROUTINE clock_sta( id )\n!--------------------------------------\n\n    integer, intent(in) :: id\n\n\n      call clock_etime( sss(id) )\n\n\n  END SUBROUTINE clock_sta\n\n\n!--------------------------------------\n  SUBROUTINE clock_end( id )\n!--------------------------------------\n\n    integer, intent(in) :: id\n\n\n      call clock_etime( eee(id) )\n\n      elt(id) = elt(id) + eee(id) - sss(id)\n\n      ccount(id)=ccount(id)+1\n\n\n  END SUBROUTINE clock_end\n\n\n!--------------------------------------\n  SUBROUTINE clock_reset\n!--------------------------------------\n\n\n      elt(10:2000) = 0._DP\n      ccount(10:2000) = 0\n\n\n  END SUBROUTINE clock_reset\n\n\nEND MODULE GKV_clock\n", "MODULE GKV_trans\n!-------------------------------------------------------------------------------\n!\n!    Entropy transfer diagnostics\n!\n!    Update history of gkvp_trans.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Use fileio module to switch Fortran/NetCDF binary output.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_intgrl, only: intgrl_thet, intgrl_v0_moment\n  use GKV_clock, only: clock_sta, clock_end\n  use GKV_exb, only: exb_NL_term\n  !fj start 202010\n  use GKV_fileio\n  !fj end 202010\n\n  implicit none\n\n  private\n\n  integer, save, &\n    dimension(:), allocatable :: triad_diag_mxt, triad_diag_myt\n  integer, save :: nbuff\n\n  public   trans_sum, trans_triad\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE trans_sum ( ff, phi, Al, neint, nmint )\n!--------------------------------------\n!     Check the entropy balance equation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi, Al\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny) :: neint, nmint\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf, wef, wbf\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi\n    complex(kind=DP), dimension(:,:,:), allocatable :: wc3\n    complex(kind=DP), dimension(-nx:nx,0:ny) :: wc2\n    integer  ::  mx, my, iz, iv, im\n\n\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( wef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( wbf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( psi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) )\n      allocate( wc3(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel workshare\n      wf(:,:,:,:,:) = (0._DP, 0._DP)\n      psi(:,:,:,:) = (0._DP, 0._DP)\n      chi(:,:,:,:) = (0._DP, 0._DP)\n      neint(:,:) = 0._DP\n      nmint(:,:) = 0._DP\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n                          * fmx(iz,iv,im) / tau(ranks) * psi(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call exb_NL_term( wf, psi, chi, wef )  ! Electrostatic part\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call exb_NL_term( wf, psi, chi, wbf )\n\n!$OMP parallel workshare\n      wbf(:,:,:,:,:) = wbf(:,:,:,:,:) - wef(:,:,:,:,:) ! Magnetic part\n!$OMP end parallel workshare\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wef(mx,my,iz,iv,im) = - fcs(ranks) / Znum(ranks) * wef(mx,my,iz,iv,im)  &\n                      * tau(ranks) * conjg( wf(mx,my,iz,iv,im) ) / fmx(iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment ( wef, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          neint(mx,my) = real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wbf(mx,my,iz,iv,im) = - fcs(ranks) / Znum(ranks) * wbf(mx,my,iz,iv,im)  &\n                      * tau(ranks) * conjg( wf(mx,my,iz,iv,im) ) / fmx(iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n      call intgrl_v0_moment ( wbf, wc3 )\n\n      call intgrl_thet ( wc3, wc2 )\n\n!$OMP parallel do\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          nmint(mx,my) = real( wc2(mx,my), kind=DP )\n        end do\n      end do\n\n\n      deallocate( wf )\n      deallocate( wef )\n      deallocate( wbf )\n      deallocate( psi )\n      deallocate( chi )\n      deallocate( wc3 )\n\n\n  END SUBROUTINE trans_sum\n\n\n!--------------------------------------\n  SUBROUTINE trans_triad ( time, ff, phi, Al )\n!--------------------------------------\n!   Triad transfer    T [(kx,ky)|(px,py),(qx,qy)] * delta(kx+px+qx=0,ky+py+qy=0)\n!   Setting (kx,ky)=(diagx,diagy) and (qx=-px-kx,qy=-py-ky), \n!   T=T(px,py) represents transfer from (px,py) and (-px-diagx,-py-diagy) to (diagx,diagy).\n\n    real(kind=DP), intent(in)                                     :: time\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                             :: phi, Al\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: gg\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: psi, chi, wg\n    complex(kind=DP), dimension(:,:,:), allocatable :: wps, wch\n    real(kind=DP), dimension(:,:), allocatable :: jkpq_es, jpqk_es, jqkp_es, &\n                                                  jkpq_em, jpqk_em, jqkp_em\n    real(kind=DP) :: ceff\n    integer  ::  mx, my, iz, iv, im, it, mxt, myt\n    character(1)   :: srank\n    character(3)   :: cnew\n    character(4)   :: cmx, cmy\n    character(256)   :: env_string\n    integer, save ::  iflg\n\n    data iflg / 0 /\n    namelist /triad/ mxt, myt\n\n\n      !%%% Initialize triad_diag_mxt, triad_diag_myt, nbuff %%%\n      if( iflg == 0 ) then\n\n        iflg = 1\n\n        close(inml)\n        call getenv ( 'fu05',env_string )\n        open(inml, file=env_string )\n\n        allocate(triad_diag_mxt(0:num_triad_diag-1))\n        allocate(triad_diag_myt(0:num_triad_diag-1))\n\n        do it = 0, num_triad_diag-1\n          read(inml, nml=triad)\n          triad_diag_mxt(it) = mxt\n          triad_diag_myt(it) = myt\n\n          !fj start 202011\n          !if ( rank == 0 ) then\n          !  write( srank, fmt=\"(i1.1)\" ) ranks\n          !  write( cnew,  fmt=\"(i3.3)\" ) inum\n          !  write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n          !  write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n          !  open( otri, file=trim(f_phi)//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, & \n          !              form=\"unformatted\", status=\"replace\" )\n          !  close( otri )\n          !end if\n          write( srank, fmt=\"(i1.1)\" ) ranks\n          write( cnew,  fmt=\"(i3.3)\" ) inum\n          write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n          write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n          call fileio_open_tri( trim(f_phi), cmx, cmy, .true. )\n          call fileio_close_tri\n          !fj end 202011\n\n        end do\n\n        if ( mod(2*nz*(nm+1),nprocw) == 0 ) then\n          nbuff = 2*nz*(nm+1)/nprocw\n        else\n          nbuff = 2*nz*(nm+1)/nprocw + 1\n        end if\n\n      end if\n\n      !%%% Set gg, psi, chi %%%\n      allocate( gg(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( psi(-nx:nx,0:ny,-nz:nz-1,0:nm) )\n      allocate( chi(-nx:nx,0:ny,-nz:nz-1,0:nm) )\n      allocate( wg(-nx:nx,0:global_ny,1:2*nv,0:nbuff-1) )\n      allocate( wps(-nx:nx,0:global_ny,0:nbuff-1) )\n      allocate( wch(-nx:nx,0:global_ny,0:nbuff-1) )\n      allocate( jkpq_es(-nx:nx,-global_ny:global_ny) )\n      allocate( jpqk_es(-nx:nx,-global_ny:global_ny) )\n      allocate( jqkp_es(-nx:nx,-global_ny:global_ny) )\n      allocate( jkpq_em(-nx:nx,-global_ny:global_ny) )\n      allocate( jpqk_em(-nx:nx,-global_ny:global_ny) )\n      allocate( jqkp_em(-nx:nx,-global_ny:global_ny) )\n!$OMP parallel workshare\n      gg(:,:,:,:,:) = (0._DP, 0._DP)\n      psi(:,:,:,:) = (0._DP, 0._DP)\n      chi(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end parallel workshare\n\n!$OMP parallel do collapse(2)\n      do im = 0, nm\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                psi(mx,my,iz,im) = j0(mx,my,iz,im) * phi(mx,my,iz)\n                chi(mx,my,iz,im) = j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n      end do\n!$OMP parallel do collapse(2)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                gg(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im)                       &\n                                   + sgn(ranks) * Znum(ranks) * fmx(iz,iv,im) &\n                                              / tau(ranks) * psi(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n\n      !%%% Multiply the jacobian on gg for zz,vl,mu integration %%%\n      if ( rankm == 0 ) then\n        im = 0\n!$OMP parallel do private(ceff)\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = 0._DP\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        im = 1\n!$OMP parallel do private(ceff)\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi * (     &\n                     1._DP + 1._DP/12._DP + 22._DP / 720._DP )&\n                   * rootg(iz) / cfsrf                        &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        im = 2\n!$OMP parallel do private(ceff)\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi * ( &\n                     1._DP - 11._DP / 720._DP )           &\n                   * rootg(iz) / cfsrf                    &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n!$OMP parallel do private(ceff)\n        do im = 3, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi     &\n                   * rootg(iz) / cfsrf                    &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        end do\n      else\n!$OMP parallel do private(ceff)\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              ceff = vp(iz,im) * dvp(iz) * dv * twopi     &\n                   * rootg(iz) / cfsrf                    &\n                   * tau(ranks) / (2._DP * fmx(iz,iv,im))\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  gg(mx,my,iz,iv,im) = sqrt(ceff) * gg(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        end do\n      end if\n\n      !%%% Transpose from (y,z,v,m) to (zm,z,v,m) decomposition %%%\n      call trans_triad_transpose(gg, psi, chi, wg, wps, wch)\n\n      do it = 0, num_triad_diag-1\n\n        !%%% Calculate traid coupling %%%\n        call trans_triad_coupling(it, wg, wps, wch, jkpq_es, jpqk_es, jqkp_es,&\n                                                    jkpq_em, jpqk_em, jqkp_em)\n\n        !%%% Output %%%\n        !fj start 202011\n        !if ( rank == 0 ) then\n        !  write( srank, fmt=\"(i1.1)\" ) ranks\n        !  write( cnew,  fmt=\"(i3.3)\" ) inum\n        !  write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n        !  write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n        !  open( otri, file=trim(f_phi)//\"s\"//srank//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew, & \n        !              form=\"unformatted\", status=\"unknown\", position=\"append\" )\n        !  write( unit=otri ) time, jkpq_es, jpqk_es, jqkp_es, jkpq_em, jpqk_em, jqkp_em\n        !  close( otri )\n        !end if\n        write( srank, fmt=\"(i1.1)\" ) ranks\n        write( cnew,  fmt=\"(i3.3)\" ) inum\n        write( cmx,   fmt=\"(i4.4)\" ) triad_diag_mxt(it)\n        write( cmy,   fmt=\"(i4.4)\" ) triad_diag_myt(it)\n        call fileio_open_tri( trim(f_phi), cmx, cmy, .false. )\n        call fileio_write_tri( jkpq_es, jpqk_es, jqkp_es, jkpq_em, jpqk_em, jqkp_em, time )\n        call fileio_close_tri\n        !fj end 202011\n\n      end do\n\n      deallocate( gg )\n      deallocate( psi )\n      deallocate( chi )\n      deallocate( wg )\n      deallocate( wps )\n      deallocate( wch )\n      deallocate( jkpq_es )\n      deallocate( jpqk_es )\n      deallocate( jqkp_es )\n      deallocate( jkpq_em )\n      deallocate( jpqk_em )\n      deallocate( jqkp_em )\n\n\n  END SUBROUTINE trans_triad\n\n\n!--------------------------------------\n  ", "SUBROUTINE trans_triad_transpose ( gg, psi, chi, wg, wps, wch )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: gg\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm)        :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:global_ny,1:2*nv,0:nbuff-1) :: wg\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:global_ny,0:nbuff-1)        :: wps, wch\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: send_gg, recv_gg\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: send_psi, recv_psi, &\n                                                         send_chi, recv_chi\n    integer  ::  mx, my, iz, iv, im, izm, ibuff, iprocw, global_my\n\n\n      allocate( send_gg(-nx:nx,0:ny,1:2*nv,0:nbuff-1,0:nprocw-1) )\n      allocate( recv_gg(-nx:nx,0:ny,1:2*nv,0:nbuff-1,0:nprocw-1) )\n      allocate( send_psi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n      allocate( recv_psi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n      allocate( send_chi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n      allocate( recv_chi(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) )\n\n    !%%% PACK: gg -> send_gg %%%\n!$OMP parallel workshare\n      send_gg(:,:,:,:,:) = (0._DP, 0._DP)\n      send_psi(:,:,:,:) = (0._DP, 0._DP)\n      send_chi(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end parallel workshare\n!$OMP parallel do private(izm,ibuff,iprocw)\n      do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                izm = (2*nz)*im + (iz + nz)\n                ibuff = mod(izm, nbuff)\n                iprocw = izm / nbuff\n                send_gg(mx,my,iv,ibuff,iprocw) = gg(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP parallel do private(izm,ibuff,iprocw)\n      do im = 0, nm\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                izm = (2*nz)*im + (iz + nz)\n                ibuff = mod(izm, nbuff)\n                iprocw = izm / nbuff\n                send_psi(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n                send_chi(mx,my,ibuff,iprocw) = chi(mx,my,iz,im)\n              end do\n            end do\n          end do\n      end do\n\n    !%%% TRANSPOSE: send_gg -> recv_gg %%%\n      call MPI_Alltoall( send_gg,                      &\n                         (2*nx+1)*(ny+1)*(2*nv)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,           &\n                         recv_gg,                      &\n                         (2*nx+1)*(ny+1)*(2*nv)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,           &\n                         fft_comm_world,               &\n                         ierr_mpi )\n      call MPI_Alltoall( send_psi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         recv_psi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n      call MPI_Alltoall( send_chi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         recv_chi,              &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n\n    !%%% UNPACK: recv_gg -> wg %%%\n!$OMP parallel do private(iprocw,my)\n      do ibuff = 0, nbuff-1\n        do iv = 1, 2*nv\n          do global_my = 0, global_ny\n            do mx = -nx, nx\n              iprocw = global_my / (ny+1)\n              my = mod(global_my, ny+1)\n              wg(mx,global_my,iv,ibuff) = recv_gg(mx,my,iv,ibuff,iprocw)\n            end do\n          end do\n        end do\n      end do\n!$OMP parallel do private(iprocw,my)\n      do ibuff = 0, nbuff-1\n          do global_my = 0, global_ny\n            do mx = -nx, nx\n              iprocw = global_my / (ny+1)\n              my = mod(global_my, ny+1)\n              wps(mx,global_my,ibuff) = recv_psi(mx,my,ibuff,iprocw)\n              wch(mx,global_my,ibuff) = recv_chi(mx,my,ibuff,iprocw)\n            end do\n          end do\n      end do\n\n      deallocate( send_gg )\n      deallocate( recv_gg )\n      deallocate( send_psi )\n      deallocate( recv_psi )\n      deallocate( send_chi )\n      deallocate( recv_chi )\n                                         !%%% For debug %%%\n                                         !iz = nz-1\n                                         !im = nm\n                                         !call MPI_Allgather(     &\n                                         !     psi(-nx,0,iz,im),  &\n                                         !     (2*nx+1)*(ny+1),   &\n                                         !     MPI_DOUBLE_COMPLEX,&\n                                         !     wch(-nx,0,0),      &\n                                         !     (2*nx+1)*(ny+1),   &\n                                         !     MPI_DOUBLE_COMPLEX,&\n                                         !     fft_comm_world,    &\n                                         !     ierr_mpi)\n                                         !izm = (2*nz)*im+(iz+nz)\n                                         !ibuff = mod(izm,nbuff)\n                                         !iprocw = izm/nbuff\n                                         !if (rankg==iprocw) then\n                                         !write(888,*)\"#\",ibuff,iprocw\n                                         !do my = 0, global_ny\n                                         !  do mx = -nx, nx\n                                         !    write(888,*) mx, my,    &\n                                         !     dble(wps(mx,my,ibuff)),&\n                                         !    aimag(wps(mx,my,ibuff)),&\n                                         !     dble(wch(mx,my,0)),    &\n                                         !    aimag(wch(mx,my,0))\n                                         !  end do\n                                         !  write(888,*)\n                                         !end do\n                                         !end if\n                                         !call MPI_Finalize(ierr_mpi)\n                                         !stop\n                                         !%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE trans_triad_transpose\n\n\n!--------------------------------------\n  ", "SUBROUTINE trans_triad_coupling ( it, wg, wps, wch, jkpq_es, jpqk_es, jqkp_es,&\n                                                      jkpq_em, jpqk_em, jqkp_em )\n!--------------------------------------\n\n    integer, intent(in)                              :: it\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:global_ny,1:2*nv,0:nbuff-1) :: wg\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:global_ny,0:nbuff-1)        :: wps, wch\n    real(kind=DP), intent(out), &\n      dimension(-nx:nx,-global_ny:global_ny) :: jkpq_es, jpqk_es, jqkp_es, &\n                                                jkpq_em, jpqk_em, jqkp_em\n\n    complex(kind=DP), dimension(:,:), allocatable :: gg, psi, chi\n    real(kind=DP), dimension(:,:), allocatable :: &\n                        wkpq_es, wpqk_es, wqkp_es, wkpq_em, wpqk_em, wqkp_em\n    real(kind=DP) :: dky, wky(-global_ny:global_ny), cs1\n    integer :: mx, my, px, py, qx, qy! (mx,my) + (px,py) + (qx,qy) = (0,0)\n    integer :: iv, ibuff\n\n      allocate(  gg(-nx:nx,-global_ny:global_ny) )\n      allocate( psi(-nx:nx,-global_ny:global_ny) )\n      allocate( chi(-nx:nx,-global_ny:global_ny) )\n      allocate( wkpq_es(-nx:nx,-global_ny:global_ny) )\n      allocate( wpqk_es(-nx:nx,-global_ny:global_ny) )\n      allocate( wqkp_es(-nx:nx,-global_ny:global_ny) )\n      allocate( wkpq_em(-nx:nx,-global_ny:global_ny) )\n      allocate( wpqk_em(-nx:nx,-global_ny:global_ny) )\n      allocate( wqkp_em(-nx:nx,-global_ny:global_ny) )\n\n     !-set (mx,my)-\n      mx = triad_diag_mxt(it)\n      my = triad_diag_myt(it)\n\n     !-set wky-\n      dky = ky(1) - ky(0)\n      do py = -global_ny, global_ny\n        wky(py) = dky * real( py, kind=DP )\n      end do\n\n!$OMP parallel workshare\n      wkpq_es(:,:) = 0._DP\n      wpqk_es(:,:) = 0._DP\n      wqkp_es(:,:) = 0._DP\n      wkpq_em(:,:) = 0._DP\n      wpqk_em(:,:) = 0._DP\n      wqkp_em(:,:) = 0._DP\n!$OMP end parallel workshare\n      cs1 = sqrt( tau(ranks) / Anum(ranks) )\n!$OMP parallel default(none) &\n!$OMP shared(mx,my,kx,wky,vl,cs1,nbuff,wps,wch,wg) &\n!$OMP shared(wkpq_es,wpqk_es,wqkp_es,wkpq_em,wpqk_em,wqkp_em) &\n!$OMP private(px,py,qx,qy,iv,ibuff,psi,chi,gg)\n!$OMP do reduction(+:wkpq_es) reduction(+:wpqk_es) reduction(+:wqkp_es) &\n!$OMP    reduction(+:wkpq_em) reduction(+:wpqk_em) reduction(+:wqkp_em)\n      do ibuff = 0, nbuff-1\n\n       !-copy-\n        do py = 0, global_ny\n          do px = -nx, nx\n            psi(px,py) = wps(px,py,ibuff)\n            chi(px,py) = wch(px,py,ibuff)\n          end do\n        end do\n        do py = 1, global_ny\n          do px = -nx, nx\n            psi(-px,-py) = conjg( wps(px,py,ibuff) )\n            chi(-px,-py) = conjg( wch(px,py,ibuff) )\n          end do\n        end do\n\n        do iv = 1, 2*nv\n\n         !-copy-\n          do py = 0, global_ny\n            do px = -nx, nx\n              gg(px,py) = wg(px,py,iv,ibuff)\n            end do\n          end do\n          do py = 1, global_ny\n            do px = -nx, nx\n              gg(-px,-py) = conjg( wg(px,py,iv,ibuff) )\n            end do\n          end do\n\n         !-triad coupling among (mx,my)+(px,py)+(qx,qy)=0-\n          do py = max(-global_ny-my,-global_ny), min(global_ny,global_ny-my)\n            qy = - my - py\n            do px = max(-nx-mx,-nx), min(nx,nx-mx)\n              qx = - mx - px\n            !wkpq(px,py) = wkpq(px,py)                                         &\n            !  - (- kx(px) * wky(qy) + wky(py) * kx(qx))                       &\n            !  * real((  (psi(px,py) - cs1 * vl(iv) * chi(px,py)) * gg(qx,qy)  &\n            !          - (psi(qx,qy) - cs1 * vl(iv) * chi(qx,qy)) * gg(px,py)) &\n            !                                              * gg(mx,my), kind=DP)\n            !wpqk(px,py) = wpqk(px,py)                                         &\n            !  - (- kx(qx) * wky(my) + wky(qy) * kx(mx))                       &\n            !  * real((  (psi(qx,qy) - cs1 * vl(iv) * chi(qx,qy)) * gg(mx,my)  &\n            !          - (psi(mx,my) - cs1 * vl(iv) * chi(mx,my)) * gg(qx,qy)) &\n            !                                              * gg(px,py), kind=DP)\n            !wqkp(px,py) = wqkp(px,py)                                         &\n            !  - (- kx(mx) * wky(py) + wky(my) * kx(px))                       &\n            !  * real((  (psi(mx,my) - cs1 * vl(iv) * chi(mx,my)) * gg(px,py)  &\n            !          - (psi(px,py) - cs1 * vl(iv) * chi(px,py)) * gg(mx,my)) &\n            !                                              * gg(qx,qy), kind=DP)\n              wkpq_es(px,py) = wkpq_es(px,py)             &\n                - (- kx(px) * wky(qy) + wky(py) * kx(qx)) &\n                * real((  (psi(px,py)) * gg(qx,qy)        &\n                        - (psi(qx,qy)) * gg(px,py))       &\n                                      * gg(mx,my), kind=DP)\n              wpqk_es(px,py) = wpqk_es(px,py)             &\n                - (- kx(qx) * wky(my) + wky(qy) * kx(mx)) &\n                * real((  (psi(qx,qy)) * gg(mx,my)        &\n                        - (psi(mx,my)) * gg(qx,qy))       &\n                                      * gg(px,py), kind=DP)\n              wqkp_es(px,py) = wqkp_es(px,py)             &\n                - (- kx(mx) * wky(py) + wky(my) * kx(px)) &\n                * real((  (psi(mx,my)) * gg(px,py)        &\n                        - (psi(px,py)) * gg(mx,my))       &\n                                      * gg(qx,qy), kind=DP)\n              wkpq_em(px,py) = wkpq_em(px,py)                        &\n                - (- kx(px) * wky(qy) + wky(py) * kx(qx))            &\n                * real((  (- cs1 * vl(iv) * chi(px,py)) * gg(qx,qy)  &\n                        - (- cs1 * vl(iv) * chi(qx,qy)) * gg(px,py)) &\n                                                 * gg(mx,my), kind=DP)\n              wpqk_em(px,py) = wpqk_em(px,py)                        &\n                - (- kx(qx) * wky(my) + wky(qy) * kx(mx))            &\n                * real((  (- cs1 * vl(iv) * chi(qx,qy)) * gg(mx,my)  &\n                        - (- cs1 * vl(iv) * chi(mx,my)) * gg(qx,qy)) &\n                                                 * gg(px,py), kind=DP)\n              wqkp_em(px,py) = wqkp_em(px,py)                        &\n                - (- kx(mx) * wky(py) + wky(my) * kx(px))            &\n                * real((  (- cs1 * vl(iv) * chi(mx,my)) * gg(px,py)  &\n                        - (- cs1 * vl(iv) * chi(px,py)) * gg(mx,my)) &\n                                                 * gg(qx,qy), kind=DP)\n            end do\n          end do\n\n        end do\n      end do\n!$OMP end do\n!$OMP end parallel\n\n     !-zz,vl,mu integration-\n!$OMP parallel workshare\n      jkpq_es(:,:) = 0._DP\n      jpqk_es(:,:) = 0._DP\n      jqkp_es(:,:) = 0._DP\n      jkpq_em(:,:) = 0._DP\n      jpqk_em(:,:) = 0._DP\n      jqkp_em(:,:) = 0._DP\n!$OMP end parallel workshare\n      call MPI_Allreduce( wkpq_es, jkpq_es, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wpqk_es, jpqk_es, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wqkp_es, jqkp_es, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wkpq_em, jkpq_em, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wpqk_em, jpqk_em, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n      call MPI_Allreduce( wqkp_em, jqkp_em, (2*nx+1)*(2*global_ny+1), &\n                          MPI_DOUBLE_PRECISION,                       &\n                          MPI_SUM, sub_comm_world, ierr_mpi )\n\n      deallocate(  gg )\n      deallocate( psi )\n      deallocate( chi )\n      deallocate( wkpq_es )\n      deallocate( wpqk_es )\n      deallocate( wqkp_es )\n      deallocate( wkpq_em )\n      deallocate( wpqk_em )\n      deallocate( wqkp_em )\n\n  END SUBROUTINE trans_triad_coupling\n\n\nEND MODULE GKV_trans\n", "MODULE GKV_colli\n!-------------------------------------------------------------------------------\n!\n!    Collision term\n!\n!    Update history of gkvp_colli.f90\n!    --------------\n!      gkvp_f0.61 (S. Maeyama, Mar 2020)\n!        - Treat tracer particles (fcs=0).\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Deallocations of gge, ggo are added.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only : clock_sta, clock_end\n  use GKV_bndry, only : bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n           bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout, &\n           bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout\n\n  implicit none\n\n  private\n\n  integer, save :: nchunk_xy = 1, nchunk_yvb = 1, nchunk_ymb = 1\n\n  public   colli_set_param, colli_LB!, colli_full\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE colli_set_param (q0, eps_r, nust)\n!-------------------------------------------------------------------------------\n!\n!    Set parameters for GK collision term\n!\n!    by M. Nakata and M. Nunami, April 2014\n!\n!-------------------------------------------------------------------------------\n\n    real(kind=DP), parameter :: mp      = 1.67262178d-24, & ! proton mass in g\n                                ee      = 4.80320425d-10, & ! elementary charge in esu\n                                ev2erg  = 1.60217657d-12    ! erg/eV  (cf. 1J = 10^7 erg)\n    \n    real(kind=DP),                    intent(in)  :: q0, eps_r\n    real(kind=DP), dimension(0:ns-1,0:ns-1), intent(out) :: nust\n\n    real(kind=DP), dimension(0:ns-1)        :: tmpr, dens, freq_factor\n    real(kind=DP), dimension(0:ns-1,0:ns-1) :: log_lambda\n!    real(kind=DP)                           :: cph, dph, cgg\n\n    integer :: is, is1, is2\n  \n! --- temperature [in eV] and density [in cm^(-3)]\n    do is = 0, ns-1\n      tmpr(is) = tau(is) * Tref*1.d3\n      dens(is) = Nref*1.d-6 * fcs(is)/Znum(is)\n    end do\n\n! --- factor for collision frequencies\n    do is = 0, ns-1\n      freq_factor(is)  = (dens(is) * ee**4 * Lref*1.d2) / (Tref*1.d3*ev2erg)**2 \n    end do\n\n\n! --- Coulomb logarithm in cm^(-3) and eV units (see NRL plasma Formulary)  \n    do is1 = 0, ns-1\n      if (sgn(is1) < 0.d0) then  !! For is1 = electron\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! e-e case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23.5_DP - dlog( dsqrt( dens(is1) ) * tmpr(is1)**(-1.25_DP) )  &\n                                            - dsqrt( 1.d-5 + (( dlog(tmpr(is1)) - 2._DP )**2 )/16._DP )\n            end if\n          else                        !! e-i case\n            if (dens(is1) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is1) ) / tmpr(is1) )\n            end if\n          end if\n        end do\n\n      else                     !! For is1 = ions\n\n        do is2 = 0, ns-1 \n          if (sgn(is2) < 0.d0) then   !! i-e case\n            if (dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 24._DP - dlog( dsqrt( dens(is2) ) / tmpr(is2) )\n            end if\n          else                       !! i-i case\n            if (dens(is1) == 0.d0 .and. dens(is2) == 0.d0) then !-care for tracer particle(dens=0)-\n              log_lambda(is1,is2) = 0._DP\n            else\n              log_lambda(is1,is2) = 23._DP &\n                - dlog( Znum(is1)*Znum(is2)*(Anum(is1)+Anum(is2))/(Anum(is1)*tmpr(is2)+Anum(is2)*tmpr(is1)) &\n                        * dsqrt( (dens(is1) * Znum(is1)**2)/tmpr(is1)                                       &\n                               + (dens(is2) * Znum(is2)**2)/tmpr(is2) ) )\n            end if\n          end if\n        end do\n\n      end if\n    end do\n\n! --- Constant parameters\n    do is1 = 0, ns-1\n      do is2 = 0, ns-1 \n\n         ctauiv(is1,is2) = freq_factor(is2) * (8._DP*dsqrt(pi)/3._DP/dsqrt(2._DP))*log_lambda(is1,is2)  & \n                                   * ( Znum(is1)**2*Znum(is2)**2/dsqrt(Anum(is1))/tau(is1)**1.5 )\n\n         calpha(is1,is2) = dsqrt( tau(is1) * Anum(is2) / ( tau(is2) * Anum(is1) ) )\n         ctheta(is1,is2) = dsqrt( tau(is1) * ( Anum(is1) + Anum(is2) ) / ( tau(is1) * Anum(is2) + tau(is2) * Anum(is1) ) )\n\n         cgamma(is1,is2) = - Anum(is1) * calpha(is1,is2)                                      &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**1.5_DP \n\n         ceta(is1,is2)   = - tau(is1) * 3._DP * calpha(is1,is2)                               &\n                            * (tau(is1)/tau(is2) + calpha(is1,is2)**2) * ctauiv(is1,is2)      &\n                             / (1._DP + calpha(is1,is2)**2)**2.5_DP\n\n          cxi(is1,is2)   =  calpha(is1,is2) * ( ctheta(is1,is2) - 1._DP ) * ctauiv(is1,is2)   &\n                             / dsqrt(1._DP + calpha(is1,is2)**2) \n\n         nust(is1,is2)   = q0*(ctauiv(is1,is2)/dsqrt(2._DP))/(eps_r**1.5*dsqrt(tau(is1)/Anum(is1)))\n\n      end do\n    end do\n\n!!!%%% Parameters for colli_full %%%\n!!!! --- xxa = v/vta/sqrt(2), where vta = sqrt(Ta/ma)\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1\n!!!          xxa(iz,iv,im) = dsqrt(vl(iv)**2 + vp(iz,im)**2)/dsqrt(2._DP) \n!!!        end do \n!!!      end do\n!!!    end do\n!!!\n!!!! --- collision frequencies and v-space functions\n!!!    do im = 0, nm\n!!!      do iv = 1, 2*nv\n!!!        do iz = -nz, nz-1 \n!!!          do is1 = 0, ns-1\n!!!            do is2 = 0, ns-1 \n!!!\n!!!              cph = derf(calpha(is1,is2)*xxa(iz,iv,im))\n!!!              dph = 2._DP/dsqrt(pi)*dexp(-calpha(is1,is2)**2*xxa(iz,iv,im)**2)\n!!!              cgg = (cph - calpha(is1,is2)*xxa(iz,iv,im)*dph)/(calpha(is1,is2)**2*xxa(iz,iv,im)**2)*0.5_DP\n!!!\n!!!              nu_d(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*(cph-cgg)/xxa(iz,iv,im)**3\n!!!              nu_p(iz,iv,im,is1,is2) = 1.50_DP*dsqrt(pi)*ctauiv(is1,is2)*(  cgg  )/xxa(iz,iv,im)**3\n!!!              nu_h(iz,iv,im,is1,is2) = 0.75_DP*dsqrt(pi)*ctauiv(is1,is2)*calpha(is1,is2)*dph/xxa(iz,iv,im)**2\n!!!              nu_g(iz,iv,im,is1,is2) = nu_p(iz,iv,im,is1,is2)*xxa(iz,iv,im)**2*(1._DP-calpha(is1,is2)**2)\n!!!\n!!!              c_t0(iz,iv,im,is1,is2,1)  = - (1._DP + calpha(is1,is2)**2)*fmx(iz,iv,im)*nu_p(iz,iv,im,is1,is2)               &\n!!!                                             * xxa(iz,iv,im)**2*vl(iv)\n!!!              c_t0(iz,iv,im,is1,is2,2)  = - 1.5_DP*dsqrt(pi)*ctauiv(is1,is2)*fmx(iz,iv,im)                                  & \n!!!                                             * ( cph - calpha(is1,is2)*xxa(iz,iv,im)*(1._DP + calpha(is1,is2)**2)*dph )     & \n!!!                                             / calpha(is1,is2)**2 / xxa(iz,iv,im)\n!!!\n!!!              x_tst(1,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*fmx(iz,iv,im)*vl(iv)\n!!!              x_tst(2,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv) \n!!!              x_tst(3,iz,iv,im,is1,is2) = x_tst(1,iz,iv,im,is1,is2)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)/vl(iv)\n!!!              x_tst(4,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,1)                              &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)           &\n!!!                                                              * fmx(iz,iv,im)*vl(iv)/dsqrt(1._DP + calpha(is1,is2)**2) )\n!!!              x_tst(5,iz,iv,im,is1,is2) =  x_tst(4,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              x_tst(6,iz,iv,im,is1,is2) = (ctheta(is1,is2) - 1._DP)*( c_t0(iz,iv,im,is1,is2,2)*2._DP/3._DP                &\n!!!                                                      - (ctheta(is1,is2) - 1._DP)*calpha(is1,is2)*ctauiv(is1,is2)         &\n!!!                                                              * fmx(iz,iv,im)*(xxa(iz,iv,im)**2/1.5_DP - 1._DP)*2._DP     &\n!!!                                                               / (1._DP + calpha(is1,is2)**2)**1.5 )\n!!!\n!!!              y_fld(1,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))*calpha(is1,is2)*Anum(is1)             & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/tau(is1)/cgamma(is1,is2)     &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,1) - cxi(is1,is2)*fmx(iz,iv,im)*vl(iv) ) \n!!!              y_fld(2,iz,iv,im,is1,is2) = y_fld(1,iz,iv,im,is1,is2)*vp(iz,im)/vl(iv)  \n!!!              y_fld(3,iz,iv,im,is1,is2) = - (fcs(is2)/Znum(is2))/(fcs(is1)/Znum(is1))                                     & \n!!!                                                    * tau(is2)*ctheta(is1,is2)*ctheta(is2,is1)/ceta(is1,is2)              &\n!!!                                                    * ( c_t0(iz,iv,im,is1,is2,2)                                          &\n!!!                                                           - cxi(is1,is2)/(1._DP+calpha(is1,is2)**2)*fmx(iz,iv,im)        &\n!!!                                                               *(2._DP*xxa(iz,iv,im)**2 - 3._DP) ) \n!!!              y_fld(4,iz,iv,im,is1,is2) = - y_fld(1,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(5,iz,iv,im,is1,is2) = - y_fld(2,iz,iv,im,is1,is2)*cxi(is2,is1) \n!!!              y_fld(6,iz,iv,im,is1,is2) = - y_fld(3,iz,iv,im,is1,is2)*2._DP*cxi(is2,is1)/(1._DP+calpha(is2,is1)**2) \n!!!\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do\n!!!    end do \n!!!\n!!!! --- summation of collision frequencies with respect to is2, and adiabatic term (used in colli_GK_CT)\n!!!    nu_hs = 0._DP \n!!!    nu_gs = 0._DP \n!!!    nu_ds = 0._DP \n!!!    nu_ps = 0._DP \n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1 \n!!!            do is2 = 0, ns-1 \n!!!                nu_hs(iz,iv,im) = nu_hs(iz,iv,im) + nu_h(iz,iv,im,is1,is2)\n!!!                nu_gs(iz,iv,im) = nu_gs(iz,iv,im) + nu_g(iz,iv,im,is1,is2)\n!!!                nu_ds(iz,iv,im) = nu_ds(iz,iv,im) + nu_d(iz,iv,im,is1,is2)\n!!!                nu_ps(iz,iv,im) = nu_ps(iz,iv,im) + nu_p(iz,iv,im,is1,is2)\n!!!            end do \n!!!          end do \n!!!        end do\n!!!      end do \n!!!\n!!!    if (trim(col_type) == \"lorentz\") then\n!!!      nu_hs(:,:,:) = 0._DP\n!!!      nu_ps(:,:,:) = 0._DP\n!!!      x_tst(:,:,:,:,:,:) = 0._DP\n!!!      y_fld(:,:,:,:,:,:) = 0._DP\n!!!      nu_gs(:,:,:) = - nu_ds(:,:,:)\n!!!    end if\n!!!\n!!!! --- adiabatic part (used in colli_GK_CT)\n!!!    is1 = ranks\n!!!      do im = 0, nm\n!!!\n!!!        if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                               - ( nu_ds(iz,iv,im)*vl(iv)**2                           &\n!!!                                     * ksq(mx,my,iz)*Anum(is1)/Znum(is1)/omg(iz)**2    &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        else\n!!!\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1 \n!!!              do my = ist_y, iend_y \n!!!                do mx = 0, nx\n!!!                  adbtc(mx,my,iz,iv,im) =                                              &\n!!!                                 ( -( nu_ds(iz,iv,im)*vl(iv)**2                        &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2                     &\n!!!                                     * (j0(mx,my,iz,im) - j2(mx,my,iz,im))             &\n!!!                                   -( nu_hs(iz,iv,im)*vp(iz,im)                        &\n!!!                                       - 0.5_DP*nu_ps(iz,iv,im)*vp(iz,im)              &\n!!!                                               *(1._DP-vl(iv)**2-vp(iz,im)**2)         &\n!!!                                       + 0.5_DP*nu_ds(iz,iv,im)                        &\n!!!                                               *(vl(iv)**2/vp(iz,im)-vp(iz,im)) )      &\n!!!                                     * dsqrt(ksq(mx,my,iz)*Anum(is1)/tau(is1))/omg(iz) &\n!!!                                     * j1(mx,my,iz,im)                                 &\n!!!                                   -( nu_ds(iz,iv,im)                                  &\n!!!                                               *(2._DP*vl(iv)**2+vp(iz,im)**2)         &\n!!!                                       + nu_ps(iz,iv,im)*vp(iz,im)**2 )                &\n!!!                                     * 0.25_DP*ksq(mx,my,iz)*Anum(is1)                 &\n!!!                                             /Znum(is1)/omg(iz)**2 * j0(mx,my,iz,im)   &\n!!!                                 ) * fmx(iz,iv,im)*sgn(is1)*real(iFLR, kind=DP)\n!!!                end do \n!!!              end do \n!!!            end do \n!!!          end do \n!!!\n!!!        end if\n!!!\n!!!      end do\n!!!\n!!!\n!!!! --- set v-space functions used in colli_moment\n!!!\n!!!    vfunc(:,:,:,:,:) = 0._DP\n!!!    jfunc(:,:,:,:,:) = 0._DP\n!!!\n!!!    ", "if ( iFLR == 1 ) then\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = & \n!!!      !                              j1(mx,my,iz,im)*vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = & \n!!!      !                              j0(mx,my,iz,im)*c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = j0(mx,my,iz,im)*vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = j1(mx,my,iz,im)*vp(iz,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = j0(mx,my,iz,im)*(xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = vp(iz,im)*c_t0(iz,iv,im,is1,is2,1)/vl(iv)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = vp(iz,im)\n!!!                vfunc(iz,iv,im,is2,6) = xxa(iz,iv,im)**2-1.5_DP\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,2) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,3) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,4) = j0(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,5) = j1(mx,my,iz,im)\n!!!              jfunc(mx,my,iz,im,6) = j0(mx,my,iz,im)\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!   \n!!!    else \n!!!\n!!!      !is1 = ranks\n!!!      !  do is2 = 0, ns-1\n!!!      !    do im = 0, nm\n!!!      !      do iv = 1, 2*nv\n!!!      !        do iz = -nz, nz-1\n!!!      !          do my = ist_y, iend_y\n!!!      !            do mx = -nx,nx\n!!!      !              vfunc(mx,my,iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!      !              vfunc(mx,my,iz,iv,im,is2,2) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,4) = vl(iv)\n!!!      !              vfunc(mx,my,iz,iv,im,is2,5) = 0._DP\n!!!      !              vfunc(mx,my,iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!      !            end do \n!!!      !          end do \n!!!      !        end do \n!!!      !      end do \n!!!      !    end do \n!!!      !  end do \n!!!      is1 = ranks\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                vfunc(iz,iv,im,is2,1) = c_t0(iz,iv,im,is1,is2,1)/fmx(iz,iv,im) \n!!!                vfunc(iz,iv,im,is2,2) = 0._DP\n!!!                vfunc(iz,iv,im,is2,3) = c_t0(iz,iv,im,is1,is2,2)/fmx(iz,iv,im)\n!!!                vfunc(iz,iv,im,is2,4) = vl(iv)\n!!!                vfunc(iz,iv,im,is2,5) = 0._DP\n!!!                vfunc(iz,iv,im,is2,6) = (xxa(iz,iv,im)**2-1.5_DP)\n!!!              end do \n!!!            end do \n!!!          end do \n!!!        end do \n!!!      do im = 0, nm\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx,nx\n!!!              jfunc(mx,my,iz,im,1) = 1._DP\n!!!              jfunc(mx,my,iz,im,2) = 0._DP\n!!!              jfunc(mx,my,iz,im,3) = 1._DP\n!!!              jfunc(mx,my,iz,im,4) = 1._DP\n!!!              jfunc(mx,my,iz,im,5) = 0._DP\n!!!              jfunc(mx,my,iz,im,6) = 1._DP\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!\n!!!    end if\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n! -----------------------------------\n! --- Output constants\n    if ( rankg == nprocz/2 ) then\n\n      do is1 = 0, ns-1\n        do is2 = 0, ns-1 \n          write(unit=ocst,fmt=\"(2I3,SP,256ES24.15e3)\") is1, is2, ctheta(is1,is2), calpha(is1,is2), &\n                                                                 fcs(is1)/Znum(is1)*ceta(is1,is2), &\n                                                               fcs(is1)/Znum(is1)*cgamma(is1,is2), & \n                                                                    cxi(is1,is2), ctauiv(is1,is2), &\n                                                                              log_lambda(is1,is2)\n! --- Note that, for ns >=3, cgamma(is1,is2) /= cgamma(is2,is1), but dens(is1)*cgamma(is1,is2) = dense(is2)*cgamma(is2,is1)\n! ---  due to normalizartion with dens(is). \n        end do\n      end do\n\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=4000,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_h(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_g(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_d(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((nu_p(iz,iv,im,is1,is2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=4005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                  ((c_t0(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=4000,fmt=*)\n!        write (unit=4001,fmt=*)\n!        write (unit=4002,fmt=*)\n!        write (unit=4003,fmt=*)\n!        write (unit=4004,fmt=*)\n!        write (unit=4005,fmt=*)\n!      end do\n!\n!! --- for debug\n!      iz = -nz\n!      do im = 0, nm\n!        do iv = 1, 2*nv\n!          write(unit=5001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=5006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((x_tst(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6001,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,1), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6002,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,2), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6003,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,3), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6004,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,4), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6005,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,5), is2 = 0, ns-1), is1 = 0, ns-1)\n!          write(unit=6006,fmt=\"(2f15.8,SP,256ES24.15e3)\") vl(iv), vp(iz,im), & \n!                                    ((y_fld(iz,iv,im,is1,is2,6), is2 = 0, ns-1), is1 = 0, ns-1)\n!        end do\n!        write (unit=5001,fmt=*)\n!        write (unit=5002,fmt=*)\n!        write (unit=5003,fmt=*)\n!        write (unit=5004,fmt=*)\n!        write (unit=5005,fmt=*)\n!        write (unit=5006,fmt=*)\n!        write (unit=6001,fmt=*)\n!        write (unit=6002,fmt=*)\n!        write (unit=6003,fmt=*)\n!        write (unit=6004,fmt=*)\n!        write (unit=6005,fmt=*)\n!        write (unit=6006,fmt=*)\n!      end do\n\n    end if\n\n    return\n\n   END SUBROUTINE colli_set_param\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB( ff, phi, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: gge, ggo\n    integer :: iz\n    integer, save :: iflg\n    data iflg / 0 /\n!$  integer :: nthreads, omp_get_num_threads\n\n      if ( iflg == 0 ) then\n        iflg = 1\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_xy = ((2*nx+1)*(ny+1)-1) / (nthreads-1) + 1\n!$      nchunk_yvb = ((ny+1)*(2*nv)*(2*nvb)-1) / (nthreads-1) + 1\n!$      nchunk_ymb = ((ny+1)*(nm+1)*(2*nvb)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n      end if\n\n      allocate( vb1e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( vb2e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( mb1e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( mb2e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( gge(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) )\n      allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n      allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n      allocate( ggo(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) )\n\n!$OMP parallel default(none) &\n!$OMP shared(ff,phi,cf,vb1e,vb2e,mb1e,mb2e,gge) &\n!$OMP shared(vb1o,vb2o,mb1o,mb2o,ggo) &\n!$OMP private(iz)\n\n!$OMP workshare\n      vb1e(:,:,:,:) = (0._DP, 0._DP)\n      vb2e(:,:,:,:) = (0._DP, 0._DP)\n      mb1e(:,:,:,:) = (0._DP, 0._DP)\n      mb2e(:,:,:,:) = (0._DP, 0._DP)\n       gge(:,:,:,:) = (0._DP, 0._DP)\n      vb1o(:,:,:,:) = (0._DP, 0._DP)\n      vb2o(:,:,:,:) = (0._DP, 0._DP)\n      mb1o(:,:,:,:) = (0._DP, 0._DP)\n      mb2o(:,:,:,:) = (0._DP, 0._DP)\n       ggo(:,:,:,:) = (0._DP, 0._DP)\n      cf(:,:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n!!%%% Without overlap %%%\n!      do iz = -nz, nz-1\n!        call colli_LB_buffin(iz, ff, phi, vb1e, mb1e)\n!!$OMP barrier\n!!$OMP master\n!        call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!!$OMP barrier\n!        call colli_LB_buffout(iz, ff, phi, vb2e, mb2e, gge)\n!!$OMP barrier\n!        call colli_LB_calc(iz, gge, cf)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      do iz = -nz, nz-1+3\n        if (mod(iz+nz,2) == 0) then ! even\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1e, mb1e)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2e, mb2e, gge)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, ggo, cf)\n        else                        ! odd\n!$OMP master\n          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!$OMP end master\n          if (-nz  <=iz .and. iz<=nz-1  ) call colli_LB_buffin(iz, ff, phi, vb1o, mb1o)\n          if (-nz+2<=iz .and. iz<=nz-1+2) call colli_LB_buffout(iz-2, ff, phi, vb2o, mb2o, ggo)\n          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_calc(iz-3, gge, cf)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( vb1e )\n      deallocate( vb2e )\n      deallocate( mb1e )\n      deallocate( mb2e )\n      deallocate(  gge )\n      deallocate( vb1o )\n      deallocate( vb2o )\n      deallocate( mb1o )\n      deallocate( mb2o )\n      deallocate(  ggo )\n\n  END SUBROUTINE colli_LB\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_buffin( iz, ff, phi, vb1, mb1 )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    real(kind=DP) :: cs1\n    integer :: mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_ymb)\n      do iv = 1, nvb\n        do im = 0, nm\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im) &\n                                  + cs1 * fmx(iz,         iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n              vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im) &\n                                  + cs1 * fmx(iz,2*nv-nvb+iv,im) &\n                               * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do collapse(3) schedule(dynamic,nchunk_yvb)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1) &\n                                  + cs1 * fmx(iz,iv,     im-1) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im) &\n                                  + cs1 * fmx(iz,iv,nm-nvb+im) &\n                      * phi(mx,my,iz) * j0(mx,my,iz,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffin\n\n\n!--------------------------------------\n  SUBROUTINE colli_LB_buffout( iz, ff, phi, vb2, mb2, gg )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n\n    real(kind=DP) :: cs1\n    integer  ::  mx, my, iv, im\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n      do my = ist_y, iend_y\n        do mx = -nx, nx\n          do im = 0, nm\n            do iv = 1, 2*nv\n              gg(iv,im,mx,my) = ff(mx,my,iz,iv,im) &\n                        + cs1 * fmx(iz,iv,im) * phi(mx,my,iz) * j0(mx,my,iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = (0._DP, 0._DP)\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 0, nm\n              do iv = 1, nvb\n                gg(-nvb+iv,im,mx,my) = vb2(mx,my,im,iv    )\n                gg(2*nv+iv,im,mx,my) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = (0._DP, 0._DP)\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n            do im = 1, nvb\n              do iv = 1, 2*nv\n                gg(iv,-nvb-1+im,mx,my) = mb2(mx,my,iv,im    )\n                gg(iv,nm+im    ,mx,my) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n  END SUBROUTINE colli_LB_buffout\n\n\n!--------------------------------------\n  ", "SUBROUTINE colli_LB_calc( iz, gg, cf )\n!--------------------------------------\n!   Lenard-Bernstein model collsion operator\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(1-nvb:2*nv+nvb,0-nvb:nm+nvb,-nx:nx,0:ny) :: gg\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n\n    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4, cs1, cflr\n    integer  ::  mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1311)\n                                         ! call fapp_start(\"literm_colli\",1311,1)\n!$OMP end master\n\n! --- Note that nu(ranks) is a bias factor \n      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n\n       cs1 = sgn(ranks) * Znum(ranks) / tau(ranks) * real(iFLR, kind=DP)\n      cef1 = nu_s / ( 12._DP * dv * dv )\n      cef2 = nu_s / ( 12._DP * dv )\n      cef3 = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n      cef4 = nu_s / ( 12._DP * dvp(iz) )\n      cflr = nu_s * Anum(ranks) * tau(ranks)  &\n                  / ( Znum(ranks) * omg(iz) )**2 * real(iFLR, kind=DP)\n\n\n      if ( rankm /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            do im = 0, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                           ) * cef1                                    &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &      \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankm == 0\n\n!$OMP do collapse(2) schedule(dynamic,nchunk_xy)\n        do my = ist_y, iend_y\n          do mx = -nx, nx\n\n            im = 0\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            -          gg(iv,im+2,mx,my)               &\n                          ) * cef3 * 2._DP                             &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            im = 1\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im  ,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im  ,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &   \n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n\n            do im = 2, nm\n              do iv = 1, 2*nv\n                cf(mx,my,iz,iv,im) =                                   &\n                          ( -          gg(iv+2,im,mx,my)               &\n                            + 16._DP * gg(iv+1,im,mx,my)               &\n                            - 30._DP * gg(iv  ,im,mx,my)               &\n                            + 16._DP * gg(iv-1,im,mx,my)               &\n                            -          gg(iv-2,im,mx,my)               &\n                          ) * cef1                                     &\n                        + ( -          gg(iv+2,im,mx,my)               &\n                            +  8._DP * gg(iv+1,im,mx,my)               &\n                            -  8._DP * gg(iv-1,im,mx,my)               &\n                            +          gg(iv-2,im,mx,my)               &\n                          ) * cef2 * vl(iv)                            &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            + 16._DP * gg(iv,im+1,mx,my)               &\n                            - 30._DP * gg(iv,im  ,mx,my)               &\n                            + 16._DP * gg(iv,im-1,mx,my)               &\n                            -          gg(iv,im-2,mx,my)               &\n                          ) * cef3                                     &\n                        + ( -          gg(iv,im+2,mx,my)               &\n                            +  8._DP * gg(iv,im+1,mx,my)               &\n                            -  8._DP * gg(iv,im-1,mx,my)               &\n                            +          gg(iv,im-2,mx,my)               &\n                          ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n                        + nu_s * 3._DP * gg(iv,im,mx,my)               &\n                        - cflr * ksq(mx,my,iz) * gg(iv,im,mx,my)\n              end do\n            end do\n\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n!$OMP master\n                                    ! call fapp_stop(\"literm_colli\",1311,1)\n                                      call clock_end(1311)\n!$OMP end master\n\n\n  END SUBROUTINE colli_LB_calc\n\n\n\n!!--------------------------------------\n!  SUBROUTINE colli_LB( ff, phi, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!    complex(kind=DP), intent(out), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: vb1e, vb2e, vb1o, vb2o\n!    complex(kind=DP), dimension(:,:,:,:), allocatable :: mb1e, mb2e, mb1o, mb2o\n!    integer :: iz\n!\n!      allocate( vb1e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2e(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2e(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( vb1o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( vb2o(-nx:nx,0:ny,0:nm,1:2*nvb) )\n!      allocate( mb1o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!      allocate( mb2o(-nx:nx,0:ny,1:2*nv,1:2*nvb) )\n!\n!!$OMP parallel default(none) &\n!!$OMP shared(ff,cf,vb1e,vb2e,mb1e,mb2e) &\n!!$OMP shared(vb1o,vb2o,mb1o,mb2o) &\n!!$OMP private(iz)\n!\n!!!%%% Without overlap %%%\n!!      do iz = -nz, nz-1\n!!        call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!!!$OMP barrier\n!!!$OMP master\n!!        call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!!$OMP end master\n!!!$OMP barrier\n!!        call bndry_vm_buffout(iz, vb2e, mb2e, ff)\n!!!$OMP barrier\n!!        call colli_LB_model_rev(iz, ff, cf)\n!!!$OMP barrier\n!!      end do\n!!!%%%%%%%%%%%%%%%%%%%%%%%\n!\n!\n!!%%% With overlap %%%\n!      do iz = -nz, nz-1+3\n!        if (mod(iz+nz,2) == 0) then ! even\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1o, vb2o, mb1o, mb2o)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1e, mb1e)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2e, mb2e, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        else                        ! odd\n!!$OMP master\n!          if (-nz+1<=iz .and. iz<=nz-1+1) call bndry_vm_sendrecv(vb1e, vb2e, mb1e, mb2e)\n!!$OMP end master\n!          if (-nz  <=iz .and. iz<=nz-1  ) call bndry_vm_buffin(iz, ff, vb1o, mb1o)\n!          if (-nz+2<=iz .and. iz<=nz-1+2) call bndry_vm_buffout(iz-2, vb2o, mb2o, ff)\n!          if (-nz+3<=iz .and. iz<=nz-1+3) call colli_LB_model_rev(iz-3, ff, cf)\n!        end if\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%\n!\n!!$OMP end parallel\n!\n!      deallocate( vb1e )\n!      deallocate( vb2e )\n!      deallocate( mb1e )\n!      deallocate( mb2e )\n!      deallocate( vb1o )\n!      deallocate( vb2o )\n!      deallocate( mb1o )\n!      deallocate( mb2o )\n!\n!  END SUBROUTINE colli_LB\n!\n!\n!!--------------------------------------\n!  ", "SUBROUTINE colli_LB_model_rev( iz, ff, cf )\n!!--------------------------------------\n!!   Lenard-Bernstein model collsion operator\n!\n!    integer, intent(in) :: iz\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!\n!    real(kind=DP) :: nu_s, cef1, cef2, cef3, cef4\n!    integer  ::  mx, my, iv, im\n!\n!\n!!$OMP master\n!                                           call clock_sta(1311)\n!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!$OMP end master\n!\n!! --- Note that nu(ranks) is a bias factor \n!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!      nu_s = 1.d-3\n!\n!      cef1   = nu_s / ( 12._DP * dv * dv )\n!      cef2   = nu_s / ( 12._DP * dv )\n!      cef3   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!      cef4   = nu_s / ( 12._DP * dvp(iz) )\n!\n!      if( rankm /= 0  ) then\n!\n!        do im = 0, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!                              -          ff(mx,my,iz,iv-2,im)                 &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                               * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      else\n!\n!        im = 0\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -          ff(mx,my,iz,iv,im+2)                &\n!                             ) * cef3 * 2._DP                                 &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        im = 1\n!\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im  )                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!\n!        do im = 2, nm\n!!$OMP do schedule(dynamic)\n!          do iv = 1, 2*nv\n!              do my = ist_y, iend_y\n!                do mx = -nx, nx\n!                  cf(mx,my,iz,iv,im) =                                        &\n!                             ( -          ff(mx,my,iz,iv+2,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!                               - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!                               + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!                               -          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef1                                         &\n!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!                               +          ff(mx,my,iz,iv-2,im)                &\n!                             ) * cef2 * vl(iv)                                &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!                               -          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef3                                         &\n!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!                               +          ff(mx,my,iz,iv,im-2)                &\n!                             ) * cef4 * ( vp(iz,im) + 1._DP / vp(iz,im) )     &\n!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!                             * real(iFLR, kind=DP)\n!                end do\n!              end do\n!          end do\n!!$OMP end do nowait\n!        end do\n!\n!      end if\n!\n!!$OMP master\n!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!                                      call clock_end(1311)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE colli_LB_model_rev\n\n\n\n\n!!!!%%% Subroutines for colli_LB (old version) %%%\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_LB( ff, phi, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    integer :: im\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!\n!!!!$OMP parallel default(none) &\n!!!!$OMP shared(ff,cf,vb1,vb2,mb1,mb2) &\n!!!!$OMP private(im)\n!!!\n!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!$OMP barrier\n!!!\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!      call colli_zeroset( cf )\n!!!!$OMP barrier\n!!!\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_m_buffout ( mb2, ff )\n!!!!$OMP barrier\n!!!\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!        call colli_LB_model( ff, im-2, cf(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!      call colli_LB_model( ff, nm-1, cf(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!      call colli_LB_model( ff, nm, cf(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!\n!!!  END SUBROUTINE colli_LB\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_LB_model( ff, im, cf )\n!!!!--------------------------------------\n!!!!   Lenard-Bernstein model collsion operator\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    real(kind=DP) :: nu_s, cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3, cef4\n!!!    integer  ::  mx, my, iz, iv\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1311)\n!!!                                         ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!! --- Note that nu(ranks) is a bias factor \n!!!      nu_s = nu(ranks)*3._DP*dsqrt(pi)*ctauiv(ranks,ranks)/4._DP\n!!!!      nu_s = 1.d-3\n!!!\n!!!      cef1   = nu_s / ( 12._DP * dv * dv )\n!!!      cef2   = nu_s / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = nu_s / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!        cef4(iz)   = nu_s / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!      if( rankm /= 0  ) then\n!!!\n!!!          do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                           &\n!!!                            ( -          ff(mx,my,iz,iv+2,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv+1,im)                 &\n!!!                              - 30._DP * ff(mx,my,iz,iv  ,im)                 &\n!!!                              + 16._DP * ff(mx,my,iz,iv-1,im)                 &\n!!!                              -          ff(mx,my,iz,iv-2,im)                 &\n!!!                             ) * cef1                                         &\n!!!                           + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                               +          ff(mx,my,iz,iv-2,im)                &\n!!!                             ) * cef2 * vl(iv)                                &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               -          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef3(iz)                                     &\n!!!                           + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im-2)                &\n!!!                             ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                           + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &      \n!!!                           - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                             / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!!$OMP end do nowait\n!!!          end do\n!!!\n!!!      else\n!!!\n!!!          if ( im == 0 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -          ff(mx,my,iz,iv,im+2)                &\n!!!                               ) * cef3(iz) * 2._DP                             &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else if ( im == 1 ) then\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im  )                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &   \n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) &\n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          else  ! 2=<im=<nm\n!!!\n!!!            do iv = 1, 2*nv\n!!!!$OMP do schedule (dynamic)\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    cf(mx,my,iz,iv) =                                           &\n!!!                               ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv  ,im)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 -          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef1                                         &\n!!!                             + ( -          ff(mx,my,iz,iv+2,im)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv+1,im)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv-1,im)                &\n!!!                                 +          ff(mx,my,iz,iv-2,im)                &\n!!!                               ) * cef2 * vl(iv)                                &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 - 30._DP * ff(mx,my,iz,iv,im  )                &\n!!!                                 + 16._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 -          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef3(iz)                                     &\n!!!                             + ( -          ff(mx,my,iz,iv,im+2)                &\n!!!                                 +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                                 -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                                 +          ff(mx,my,iz,iv,im-2)                &\n!!!                               ) * cef4(iz) * ( vp(iz,im) + 1._DP / vp(iz,im) ) &\n!!!                             + nu_s * 3._DP * ff(mx,my,iz,iv,im)                &\n!!!                             - nu_s * ksq(mx,my,iz) * Anum(ranks) * tau(ranks)  &\n!!!                               / ( Znum(ranks) * omg(iz) )**2 * ff(mx,my,iz,iv,im) & \n!!!                               * real(iFLR, kind=DP)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!!$OMP end do nowait\n!!!            end do\n!!!\n!!!          end if\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_LB_model\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_zeroset( cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    zero clear for collision terms \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)    :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli\",1311,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv,im) = ( 0._DP, 0._DP )     \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_zeroset\n\n\n!!!%%% Subroutines for colli_full %%%\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 4th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 12._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 12._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 12._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 32._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -  2._DP * ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 31._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[2,nm] nm for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  cf(mx,my,iz,iv) =                                                &\n!!!                             ( -          ff(mx,my,iz,iv-2,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv  ,im)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( -          ff(mx,my,iz,iv,im-2)                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im-1)                     &\n!!!                               - 30._DP * ff(mx,my,iz,iv,im  )                     &\n!!!                               + 16._DP * ff(mx,my,iz,iv,im+1)                     &\n!!!                               -          ff(mx,my,iz,iv,im+2)                     &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( +          dfdvp(mx,my,iz,iv-2)                     &             \n!!!                               -  8._DP * dfdvp(mx,my,iz,iv-1)                     &\n!!!                               +  8._DP * dfdvp(mx,my,iz,iv+1)                     &\n!!!                               -          dfdvp(mx,my,iz,iv+2)                     &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( +          ff(mx,my,iz,iv-2,im)                     &\n!!!                               -  8._DP * ff(mx,my,iz,iv-1,im)                     &\n!!!                               +  8._DP * ff(mx,my,iz,iv+1,im)                     &\n!!!                               -          ff(mx,my,iz,iv+2,im)                     &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CT6( ff, phi, dfdvp, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Differential and FLR terms of test particle part in gyrokinetic collision\n!!!!                                                         with 6th order CFD\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi\n!!!    integer, intent(in) :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP) :: cef1, cef2\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef3\n!!!    integer  ::  mx, my, iz, iv, is1\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1311)\n!!!                                    ! call fapp_start(\"literm_colli_ct\",1311,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      cef1   = 1._DP / ( 90._DP * dv * dv )\n!!!      cef2   = 1._DP / ( 60._DP * dv )\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef3(iz)   = 1._DP / ( 90._DP * dvp(iz) * dvp(iz) )\n!!!      end do\n!!!\n!!!      if ( rankm == 0 .AND. im == 0 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 270._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               -   27_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +   2._DP * ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                 )                                                 &           \n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im) * 2._DP*vl(iv)**2 )           &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else if ( rankm == 0 .AND. im == 1 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( + 135._DP  * ff(mx,my,iz,iv,im-1)                   &\n!!!                               - 258.5_DP * ff(mx,my,iz,iv,im  )                   &\n!!!                               + 136._DP  * ff(mx,my,iz,iv,im+1)                   &\n!!!                               - 13.5_DP  * ff(mx,my,iz,iv,im+2)                   &\n!!!                               +            ff(mx,my,iz,iv,im+3)                   &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else ", "if ( rankm == 0 .AND. im == 2 ) then\n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 136._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      else  ! im=[0,nm] for rankm > 0 and im=[3,nm] for rankm = 0  \n!!!\n!!!        is1 = ranks\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) =                                               &\n!!!                             ( +           ff(mx,my,iz,iv-3,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv  ,im)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef1                                              &\n!!!                               * (   nu_ps(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ds(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &          \n!!!                           + ( +           ff(mx,my,iz,iv,im-3)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im-2)                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im-1)                    &\n!!!                               - 245._DP * ff(mx,my,iz,iv,im  )                    &\n!!!                               + 135._DP * ff(mx,my,iz,iv,im+1)                    &\n!!!                               - 13.5_DP * ff(mx,my,iz,iv,im+2)                    &\n!!!                               +           ff(mx,my,iz,iv,im+3)                    &\n!!!                             ) * cef3(iz)                                          &\n!!!                               * (   nu_ds(iz,iv,im)*vl(iv)**2                     & \n!!!                                   + nu_ps(iz,iv,im)*vp(iz,im)**2                  &\n!!!                                 ) * 0.5_DP                                        &           \n!!!                           + ( -           dfdvp(mx,my,iz,iv-3)                    &             \n!!!                               +   9._DP * dfdvp(mx,my,iz,iv-2)                    &\n!!!                               -  45._DP * dfdvp(mx,my,iz,iv-1)                    &\n!!!                               +  45._DP * dfdvp(mx,my,iz,iv+1)                    &\n!!!                               -   9._DP * dfdvp(mx,my,iz,iv+2)                    &\n!!!                               +           dfdvp(mx,my,iz,iv+3)                    &\n!!!                             ) * cef2 * vl(iv) * vp(iz,im)                         & \n!!!                               * (   nu_ps(iz,iv,im)                               & \n!!!                                   - nu_ds(iz,iv,im) )                             &\n!!!                           + ( -           ff(mx,my,iz,iv-3,im)                    &\n!!!                               +   9._DP * ff(mx,my,iz,iv-2,im)                    &\n!!!                               -  45._DP * ff(mx,my,iz,iv-1,im)                    &\n!!!                               +  45._DP * ff(mx,my,iz,iv+1,im)                    &\n!!!                               -   9._DP * ff(mx,my,iz,iv+2,im)                    &\n!!!                               +           ff(mx,my,iz,iv+3,im)                    &\n!!!                             ) * cef2 * nu_gs(iz,iv,im)*vl(iv)                     & \n!!!                           + ( dfdvp(mx,my,iz,iv) )                                &\n!!!                               * (   nu_gs(iz,iv,im)*vp(iz,im)                     & \n!!!                                   + nu_ds(iz,iv,im)*0.5_DP                        &\n!!!                                     * (vl(iv)**2/vp(iz,im)+vp(iz,im))             &\n!!!                                 )                                                 &\n!!!                           + ( nu_hs(iz,iv,im)*xxa(iz,iv,im)**2*2._DP              & \n!!!                                - 0.25_DP*ksq(mx,my,iz)*Anum(is1)*tau(is1)         &\n!!!                                 * ( nu_ds(iz,iv,im)                               &\n!!!                                      * (2._DP*vl(iv)**2 + vp(iz,im)**2)           &\n!!!                                    + nu_ps(iz,iv,im)*vp(iz,im)**2 )               &\n!!!                                 / (Znum(is1)*omg(iz))**2 * real(iFLR, kind=DP)    &\n!!!                             ) * ff(mx,my,iz,iv,im)                                &\n!!!                           + adbtc(mx,my,iz,iv,im)*phi(mx,my,iz)                    \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_ct\",1311,1)\n!!!                                      call clock_end(1311)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CT6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_DT( moment_ab_wk, im, cf )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Non-isothermal terms of test particle part and field particle part \n!!!!                                                      in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1312)\n!!!                                    ! call fapp_start(\"literm_colli_dt\",1312,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dt\",1312,1)\n!!!                                      call clock_end(1312)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_GK_CF_DT(moment_ba_wk, moment_ab_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle and non-isothermal parts in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk, moment_ab_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + x_tst(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!\n!!!                                    + x_tst(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(1,mx,my,iz,is2)      &\n!!!                                    + x_tst(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(3,mx,my,iz,is2)      &\n!!!                                    + x_tst(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(4,mx,my,iz,is2)      &\n!!!                                    + x_tst(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ab_wk(6,mx,my,iz,is2)          \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF_DT\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_GK_CF(moment_ba_wk, im, cf)\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Field particle part in gyrokinetic collision\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1)       :: moment_ba_wk\n!!!    integer, intent(in)                                :: im\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)           :: cf\n!!!\n!!!    integer  ::  mx, my, iz, iv, is1, is2\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1313)\n!!!                                    ! call fapp_start(\"literm_colli_cf\",1313,1)\n!!!!$OMP end master\n!!!\n!!!     if ( iFLR == 1 ) then  ! full-GK\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(2,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(2,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  & \n!!!                                    + y_fld(5,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(5,mx,my,iz,is2)      &\n!!!                                      * j1(mx,my,iz,im)                  & \n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)      &\n!!!                                      * j0(mx,my,iz,im)                  \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     else if ( iFLR == 0 ) then ! DK-limit\n!!!\n!!!       is1 = ranks\n!!!         do is2 = 0, ns-1\n!!!!%%%% do schedule (dynamic)\n!!!!$OMP do\n!!!           do iv = 1, 2*nv\n!!!             do iz = -nz, nz-1\n!!!               do my = ist_y, iend_y\n!!!                 do mx = -nx, nx\n!!!                   cf(mx,my,iz,iv) = cf(mx,my,iz,iv)                     &\n!!!                                    + y_fld(1,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(1,mx,my,iz,is2)      &\n!!!                                    + y_fld(3,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(3,mx,my,iz,is2)      &\n!!!                                    + y_fld(4,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(4,mx,my,iz,is2)      &\n!!!                                    + y_fld(6,iz,iv,im,is1,is2)          &\n!!!                                     * moment_ba_wk(6,mx,my,iz,is2)         \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!%%%% end do nowait\n!!!!$OMP end do\n!!!        end do\n!!!\n!!!     end if\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_cf\",1313,1)\n!!!                                      call clock_end(1313)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_GK_CF\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_calc( hh, phi, ww )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: local velocity moment part \n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!\n!!!    !complex(kind=DP), intent(out), &\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!\n!!!    real(kind=DP) :: v2a, v2b, dflg\n!!!    complex(kind=DP) :: wf1, wf2\n!!!    integer :: mx, my, iz, iv, im, is1, is2, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1314)\n!!!                                    ! call fapp_start(\"literm_colli_mom\",1314,1)\n!!!!$OMP end master\n!!!\n!!!      if ( rankm == 0 ) then\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii,v2a,v2b,wf1,wf2)\n!!!      do ii = 1, 6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!\n!!!! for edge compensation\n!!!!         im  = 1\n!!!          do im = 1, 1\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !v2a = vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    !v2b = vfunc(mx,my,iz,iv,im+1,is2,ii)\n!!!                    v2a = jfunc(mx,my,iz,im,ii)  *vfunc(iz,iv,im,is2,ii)\n!!!                    v2b = jfunc(mx,my,iz,im+1,ii)*vfunc(iz,iv,im+1,is2,ii)\n!!!                    wf1 = hh(mx,my,iz,iv,im)   \n!!!                    wf2 = hh(mx,my,iz,iv,im+1)\n!!!                    ww(mx,my,iz,is2,ii)  = ww(mx,my,iz,is2,ii)            &\n!!!                          - ( - wf1/12._DP*v2a + ( wf2*v2b - wf1*2._DP*v2a )*11._DP/720._DP ) \n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      else\n!!!\n!!!!$OMP do collapse(2) schedule(dynamic) private(mx,my,iz,iv,im,is2,ii)\n!!!      do ii=1,6\n!!!        do is2 = 0, ns-1\n!!!          do im = 0, nm\n!!!            do iv = 1, 2*nv\n!!!              do iz = -nz, nz-1\n!!!                do my = ist_y, iend_y\n!!!                  do mx = -nx, nx\n!!!                    !ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*vfunc(mx,my,iz,iv,im,is2,ii)\n!!!                    ww(mx,my,iz,is2,ii) = ww(mx,my,iz,is2,ii) + hh(mx,my,iz,iv,im)*jfunc(mx,my,iz,im,ii)*vfunc(iz,iv,im,is2,ii)\n!!!                  end do\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!      end if\n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_mom\",1314,1)\n!!!                                      call clock_end(1314)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_calc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_moment_redc( ww, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Moment calculations for gyrokinetic collision: All_reduce_part\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww\n!!! \n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: wn\n!!!\n!!!\n!!!!$OMP master\n!!!                                           call clock_sta(1315)\n!!!                                         ! call fapp_start(\"literm_colli_ar\",1315,1)\n!!!!$OMP end master\n!!!\n!!!      call MPI_Allreduce( ww, wn, nxyz*ns*6, MPI_DOUBLE_COMPLEX, &\n!!!                          MPI_SUM, vel_comm_world, ierr_mpi )\n!!!\n!!!!$OMP master\n!!!                                         ! call fapp_stop(\"literm_colli_ar\",1315,1)\n!!!                                           call clock_end(1315)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_moment_redc\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_comm_alltoall( wm, wn )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    Inter-species communication of moment quantities for field particle part\n!!!!       with MPI_AlltoAll\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wm\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)  :: wn\n!!!\n!!!    complex(kind=DP),              & \n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:6,0:ns-1)  :: send_buff, recv_buff\n!!!\n!!!    integer :: mx, my, iz, is, ii\n!!!    integer :: datasize, datasize_ns\n!!!\n!!!\n!!!!$OMP master\n!!!                                       call clock_sta(1316)\n!!!                                     ! call fapp_start(\"literm_colli_com\",1316,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      datasize = (2*nx+1)*(ny+1)*(2*nz)*6\n!!!      datasize_ns = (2*nx+1)*(ny+1)*(2*nz)*6*ns\n!!!\n!!!      if ( vel_rank == 0 ) then\n!!!\n!!!        do ii = 1, 6\n!!!          do is = 0, ns-1\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!!                  send_buff(mx,my,iz,ii,is)  = real(ranks,kind=DP) + ii ! for debug\n!!!                  send_buff(mx,my,iz,ii,is)  = wm(mx,my,iz,is,ii)\n!!!                end do\n!!!              end do \n!!!            end do\n!!!          end do\n!!!        end do\n!!!\n!!!\n!!!          call MPI_Alltoall( send_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  &\n!!!                             recv_buff(-nx,ist_y,-nz,1,0), datasize, MPI_DOUBLE_COMPLEX,  & \n!!!                             col_comm_world, ierr_mpi  )\n!!! \n!!!!! --- for debug \n!!!!        write(unit=8000+ranks,fmt=\"(I3,SP,6ES24.15e3)\") ranks, real(recv_buff(0,1,1,1,0)), real(recv_buff(0,1,1,6,0)), &\n!!!!                                                           real(recv_buff(0,1,1,1,1)), real(recv_buff(0,1,1,6,1)), &\n!!!!                                                           real(recv_buff(0,1,1,1,2)), real(recv_buff(0,1,1,6,2))\n!!!!        write(unit=8000+ranks,fmt=*)\n!!!\n!!!      end if\n!!!\n!!!\n!!!      call MPI_Bcast( recv_buff(-nx,ist_y,-nz,1,0), datasize_ns, MPI_DOUBLE_COMPLEX, & \n!!!                      0, vel_comm_world, ierr_mpi  ) \n!!!\n!!!\n!!!      do is = 0, ns-1\n!!!        do ii = 1, 6\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wn(mx,my,iz,is,ii) = recv_buff(mx,my,iz,ii,is)\n!!!              end do\n!!!            end do \n!!!          end do\n!!!        end do         \n!!!      end do         \n!!!\n!!!!$OMP master\n!!!                                     ! call fapp_stop(\"literm_colli_com\",1316,1)\n!!!                                       call clock_end(1316)\n!!!!$OMP end master\n!!!\n!!!  END SUBROUTINE colli_comm_alltoall\n!!!\n!!!\n!!!!--------------------------------------\n!!!  ", "SUBROUTINE colli_dfdvp( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 4th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 12._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +          ff(mx,my,iz,iv,im  )                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!        do im = 2, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!\n!!!      else   \n!!!\n!!!        do im = 0, nm\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +          ff(mx,my,iz,iv,im-2)                &\n!!!                               -  8._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  8._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -          ff(mx,my,iz,iv,im+2)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!        end do\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_dfdvp6( ff, dfdvp )\n!!!!--------------------------------------\n!!!!-------------------------------------------------------------------------------\n!!!!\n!!!!    calculation of df/dv_perp term with 6th order CFD\n!!!!\n!!!!    by M. Nakata, M. Nunami, April 2014\n!!!!\n!!!!-------------------------------------------------------------------------------\n!!!\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: dfdvp\n!!!\n!!!    real(kind=DP), dimension(-nz:nz-1) :: cef4\n!!!    integer  ::  mx, my, iz, iv, im\n!!!\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1317)\n!!!                                    ! call fapp_start(\"literm_colli_dvp\",1317,1)\n!!!!$OMP end master\n!!!\n!!!\n!!!      do iz = -nz, nz-1\n!!!        cef4(iz)   = 1._DP / ( 60._DP * dvp(iz) )\n!!!      end do\n!!!\n!!!\n!!!      if ( rankm == 0 ) then \n!!!\n!!!        im = 0\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) = (0._DP, 0._DP) \n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 1\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im  )                &\n!!!                               + 44._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!        im = 2\n!!!!$OMP do schedule (dynamic)\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 46._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!!$OMP end do nowait\n!!!\n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 3, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!\n!!!      else   \n!!!\n!!!!$OMP do schedule (dynamic)\n!!!        do im = 0, nm\n!!!          do iv = 1, 2*nv\n!!!            do iz = -nz, nz-1\n!!!              do my = ist_y, iend_y\n!!!                do mx = -nx, nx\n!!!                  dfdvp(mx,my,iz,iv,im) =                                     &\n!!!                             ( -          ff(mx,my,iz,iv,im-3)                &\n!!!                               +  9._DP * ff(mx,my,iz,iv,im-2)                &\n!!!                               - 45._DP * ff(mx,my,iz,iv,im-1)                &\n!!!                               + 45._DP * ff(mx,my,iz,iv,im+1)                &\n!!!                               -  9._DP * ff(mx,my,iz,iv,im+2)                &\n!!!                               +          ff(mx,my,iz,iv,im+3)                &\n!!!                             ) * cef4(iz)\n!!!                end do\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!!$OMP end do nowait\n!!!     \n!!!      end if \n!!!\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_dvp\",1317,1)\n!!!                                      call clock_end(1317)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_dfdvp6\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_hhset(hh,phi,ff)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1)               :: phi\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    real(kind=DP) :: dflg\n!!!    integer :: mx, my, iz, iv, im, is1\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!     !dflg = real(1-icheck,kind=DP)\n!!!      dflg = real(1-icheck,kind=DP) * real(iFLR,kind=DP)\n!!!\n!!!      is1 = ranks\n!!!!$OMP do collapse(2) private(mx,my,iz,iv,im)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                hh(mx,my,iz,iv,im) = ( ff(mx,my,iz,iv,im) + dflg*sgn(is1)*j0(mx,my,iz,im)*phi(mx,my,iz)   &\n!!!                                                                * fmx(iz,iv,im)*Znum(is1)/tau(is1) )      &\n!!!                                    * vp(iz,im) * dvp(iz) * dv * twopi\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!!$OMP end do nowait\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_hhset\n!!!\n!!!\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_wwset(ww)\n!!!!--------------------------------------\n!!!    complex(kind=DP), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6)        :: ww \n!!!    integer :: mx, my, iz, is1, ii\n!!!\n!!!!$OMP master\n!!!                                      call clock_sta(1319)\n!!!                                    ! call fapp_start(\"literm_colli_hwset\",1319,1)\n!!!!$OMP end master\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,is1,ii)\n!!!    do ii = 1, 6\n!!!      do is1 = 0, ns-1\n!!!        do iz = -nz, nz-1\n!!!          do my = ist_y, iend_y\n!!!            do mx = -nx, nx\n!!!              ww(mx,my,iz,is1,ii) = ( 0._DP, 0._DP )\n!!!            end do \n!!!          end do \n!!!        end do \n!!!      end do \n!!!    end do \n!!!!$OMP end do\n!!!\n!!!!$OMP master\n!!!                                    ! call fapp_stop(\"literm_colli_hwset\",1319,1)\n!!!                                      call clock_end(1319)\n!!!!$OMP end master\n!!!\n!!!\n!!!  END SUBROUTINE colli_wwset\n!!!\n!!!\n!!!!!--------------------------------------\n!!!!  ", "SUBROUTINE colli_full( ff, phi, cf )! Analytic derivative of J0*phi\n!!!!!--------------------------------------\n!!!!!   Sugama collision operator\n!!!!\n!!!!    complex(kind=DP), intent(inout), &\n!!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!!    complex(kind=DP), intent(in), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!!    complex(kind=DP), intent(out), &\n!!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!!\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!!\n!!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff,phi,dfdvp) &\n!!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP private(im,ii) \n!!!!\n!!!!      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!!!!      call colli_hhset(hh2,phi,ff)\n!!!!      call colli_wwset(wrkm)\n!!!!!$OMP barrier\n!!!!\n!!!!!----------------------------------------------------- ovlp1\n!!!!!$OMP master\n!!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!!$OMP end master\n!!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!!      call colli_zeroset( cff )\n!!!!\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      call bndry_shifts_m_buffout ( mb2, ff )\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp2\n!!!!!$OMP master\n!!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!!$OMP end master\n!!!!\n!!!!!!!      call colli_dfdvp6( ff, dfdvp ) ! 6th-order CFD\n!!!!      call colli_dfdvp( ff, dfdvp ) ! 4th-order CFD\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- non-ovlp part\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp3\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!! --- No calculations appear here in f0.52 (Nakata July2015)\n!!!!!!!      call colli_zeroset( cdt )\n!!!!\n!!!!!$OMP barrier\n!!!!\n!!!!      do im = 1, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!!\n!!!!!-----------------------------------------------------\n!!!!!$OMP end parallel\n!!!!\n!!!!\n!!!!!$OMP parallel default (none) &\n!!!!!$OMP shared(ff) &\n!!!!!$OMP shared(cft,cff) &\n!!!!!$OMP shared(phi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!!\n!!!!!----------------------------------------------------- ovlp4\n!!!!!$OMP master\n!!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!!$OMP end master\n!!!!\n!!!!      do im = 0, nm\n!!!!        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!      end do\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!!do nn = 0, ns-1\n!!!!  do iz = -nz, nz-1\n!!!!    do my = ist_y, iend_y\n!!!!      do mx = -nx, nx\n!!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!!\n!!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!!      enddo\n!!!!    enddo\n!!!!  enddo\n!!!!enddo\n!!!!!$OMP enddo\n!!!!!-----------------------------------------------------\n!!!!\n!!!!!----------------------------------------------------- ovlp5\n!!!!      im = 0\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp6\n!!!!      im = 1\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp7\n!!!!      im = 2\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD \n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!!----------------------------------------------------- \n!!!!\n!!!!!----------------------------------------------------- ovlp8\n!!!!      do im = 3, nm\n!!!!!$OMP master\n!!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!!$OMP end master\n!!!!\n!!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), ff(:,:,:,:,im-1) )\n!!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!!        call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD\n!!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!!$OMP barrier\n!!!!      end do\n!!!!!----------------------------------------------------- \n!!!!\n!!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), ff(:,:,:,:,nm) )\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!!$OMP barrier\n!!!!\n!!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 6th-order CFD\n!!!!      call colli_GK_CT( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 4th-order CFD\n!!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!!$OMP barrier\n!!!!\n!!!!!$OMP end parallel\n!!!!\n!!!!!$OMP parallel workshare\n!!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!!$OMP end parallel workshare\n!!!!\n!!!!      deallocate( vb1 )\n!!!!      deallocate( vb2 )\n!!!!      deallocate( mb1 )\n!!!!      deallocate( mb2 )\n!!!!      deallocate( cft )\n!!!!      deallocate( cff )\n!!!!      deallocate( wrkm )\n!!!!      deallocate( moment_ab )\n!!!!      deallocate( moment_ba )\n!!!!      deallocate( moment_ab_wk )\n!!!!      deallocate( moment_ba_wk )\n!!!!      deallocate( dfdvp )\n!!!!      deallocate( hh2 )\n!!!!\n!!!!  END SUBROUTINE colli_full\n!!!!--------------------------------------\n!!!  SUBROUTINE colli_full( ff, phi, cf )! Finite difference of J0*phi\n!!!!--------------------------------------\n!!!!   Sugama collision operator\n!!!\n!!!    complex(kind=DP), intent(inout), &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n!!!    complex(kind=DP), intent(in), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n!!!    complex(kind=DP), intent(out), &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: cf\n!!!\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: wff\n!!!    complex(kind=DP),  &\n!!!      dimension(-nx:nx,0:ny,-nz:nz-1) :: wphi\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: cft, cff\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wrkm, moment_ab, moment_ba\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: moment_ab_wk, moment_ba_wk\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: dfdvp\n!!!    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: hh2\n!!!    integer  ::  mx, my, iz, iv, im, ii, nn\n!!!\n!!!      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n!!!      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n!!!      allocate( cft(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( cff(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!      allocate( wrkm(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ba(-nx:nx,0:ny,-nz:nz-1,0:ns-1,1:6) )\n!!!      allocate( moment_ab_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( moment_ba_wk(1:6,-nx:nx,0:ny,-nz:nz-1,0:ns-1) )\n!!!      allocate( dfdvp(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) )\n!!!      allocate( hh2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n!!!\n!!!!$OMP parallel do collapse(2)\n!!!      do im = 0, nm\n!!!        do iv = 1, 2*nv\n!!!          do iz = -nz, nz-1\n!!!            do my = ist_y, iend_y\n!!!              do mx = -nx, nx\n!!!                wff(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) + sgn(ranks) * Znum(ranks) &\n!!!                          * fmx(iz,iv,im) / tau(ranks) * j0(mx,my,iz,im) * phi(mx,my,iz) &\n!!!                                                                     * real(iFLR, kind=DP)\n!!!              end do\n!!!            end do\n!!!          end do\n!!!        end do\n!!!      end do\n!!!      wphi(:,:,:) = (0._DP, 0._DP)\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(ff,wff,phi,dfdvp) &\n!!!!$OMP shared(mb1,mb2,vb1,vb2) &\n!!!!$OMP shared(wrkm,moment_ab,moment_ba,hh2) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP private(im,ii) \n!!!\n!!!      call bndry_shifts_m_buffin ( wff, mb1, mb2 )\n!!!      call colli_hhset(hh2,phi,ff)\n!!!      call colli_wwset(wrkm)\n!!!!$OMP barrier\n!!!\n!!!!----------------------------------------------------- ovlp1\n!!!!$OMP master\n!!!      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!!!!$OMP end master\n!!!      call colli_moment_calc( hh2, phi, wrkm )\n!!!      call colli_zeroset( cff )\n!!!\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      call bndry_shifts_m_buffout ( mb2, wff )\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp2\n!!!!$OMP master\n!!!      call colli_moment_redc( wrkm, moment_ab )\n!!!!$OMP end master\n!!!\n!!!!!!      call colli_dfdvp6( ff, dfdvp ) ! 6th-order CFD\n!!!      call colli_dfdvp( wff, dfdvp ) ! 4th-order CFD\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- non-ovlp part\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( dfdvp(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp3\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!! --- No calculations appear here in f0.52 (Nakata July2015)\n!!!!!!      call colli_zeroset( cdt )\n!!!\n!!!!$OMP barrier\n!!!\n!!!      do im = 1, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), dfdvp(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!      end do\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), dfdvp(:,:,:,:,nm) )\n!!!\n!!!!-----------------------------------------------------\n!!!!$OMP end parallel\n!!!\n!!!\n!!!!$OMP parallel default (none) &\n!!!!$OMP shared(wff) &\n!!!!$OMP shared(cft,cff) &\n!!!!$OMP shared(wphi,dfdvp,moment_ab,moment_ba,wrkm,moment_ab_wk,moment_ba_wk) &\n!!!!$OMP shared(vb1,vb2,mb1,mb2) &\n!!!!$OMP shared(rankw,ist_y,iend_y) &\n!!!!$OMP private(mx,my,iz,iv,im,nn) \n!!!\n!!!!----------------------------------------------------- ovlp4\n!!!!$OMP master\n!!!      call colli_comm_alltoall( moment_ab, moment_ba )\n!!!!$OMP end master\n!!!\n!!!      do im = 0, nm\n!!!        call bndry_shifts_v_buffin ( wff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!      end do\n!!!!$OMP barrier\n!!!\n!!!!$OMP do collapse(2) private(mx,my,iz,nn)\n!!!do nn = 0, ns-1\n!!!  do iz = -nz, nz-1\n!!!    do my = ist_y, iend_y\n!!!      do mx = -nx, nx\n!!!        moment_ab_wk(1,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,1)\n!!!        moment_ab_wk(2,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,2)\n!!!        moment_ab_wk(3,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,3)\n!!!        moment_ab_wk(4,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,4)\n!!!        moment_ab_wk(5,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,5)\n!!!        moment_ab_wk(6,mx,my,iz,nn) = moment_ab(mx,my,iz,nn,6)\n!!!\n!!!        moment_ba_wk(1,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,1)\n!!!        moment_ba_wk(2,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,2)\n!!!        moment_ba_wk(3,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,3)\n!!!        moment_ba_wk(4,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,4)\n!!!        moment_ba_wk(5,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,5)\n!!!        moment_ba_wk(6,mx,my,iz,nn) = moment_ba(mx,my,iz,nn,6)\n!!!      enddo\n!!!    enddo\n!!!  enddo\n!!!enddo\n!!!!$OMP enddo\n!!!!-----------------------------------------------------\n!!!\n!!!!----------------------------------------------------- ovlp5\n!!!      im = 0\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp6\n!!!      im = 1\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp7\n!!!      im = 2\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD \n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!!----------------------------------------------------- \n!!!\n!!!!----------------------------------------------------- ovlp8\n!!!      do im = 3, nm\n!!!!$OMP master\n!!!        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!!!!$OMP end master\n!!!\n!!!        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im-1), wff(:,:,:,:,im-1) )\n!!!!!!        call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 6th-order CFD\n!!!        call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,im-2), im-2, cft(:,:,:,:,im-2) ) ! 4th-order CFD\n!!!        call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, im-2, cff(:,:,:,:,im-2) )\n!!!!$OMP barrier\n!!!      end do\n!!!!----------------------------------------------------- \n!!!\n!!!      call bndry_shifts_v_buffout ( vb2(:,:,:,:,nm), wff(:,:,:,:,nm) )\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm-1), nm-1, cft(:,:,:,:,nm-1) ) ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm-1, cff(:,:,:,:,nm-1) )\n!!!!$OMP barrier\n!!!\n!!!!!!      call colli_GK_CT6( ff, phi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 6th-order CFD\n!!!      call colli_GK_CT( wff, wphi, dfdvp(:,:,:,:,nm), nm, cft(:,:,:,:,nm) ) ! 4th-order CFD\n!!!      call colli_GK_CF_DT( moment_ba_wk, moment_ab_wk, nm, cff(:,:,:,:,nm) )\n!!!!$OMP barrier\n!!!\n!!!!$OMP end parallel\n!!!\n!!!!$OMP parallel workshare\n!!!      cf(:,:,:,:,:) = cft(:,:,:,:,:) + cff(:,:,:,:,:)\n!!!!$OMP end parallel workshare\n!!!\n!!!      deallocate( vb1 )\n!!!      deallocate( vb2 )\n!!!      deallocate( mb1 )\n!!!      deallocate( mb2 )\n!!!      deallocate( cft )\n!!!      deallocate( cff )\n!!!      deallocate( wrkm )\n!!!      deallocate( moment_ab )\n!!!      deallocate( moment_ba )\n!!!      deallocate( moment_ab_wk )\n!!!      deallocate( moment_ba_wk )\n!!!      deallocate( dfdvp )\n!!!      deallocate( hh2 )\n!!!\n!!!  END SUBROUTINE colli_full\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nEND MODULE GKV_colli\n", "MODULE GKV_fld\n!-------------------------------------------------------------------------------\n!\n!    Field solver\n!\n!    Update history of gkvp_fld.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Intent is changed from intent(out) :: phi to intent(inout) :: phi,\n!          to keep initialized values at padding iend_y<my.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_intgrl, only: intgrl_fsrf, intgrl_v0_moment, intgrl_v0_moment_ms\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   fld_esfield, fld_emfield_ff, fld_emfield_hh, fld_ff2hh, fld_hh2ff\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE fld_esfield ( ff, phi )\n!--------------------------------------\n!     electrostatic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw, ww\n    complex(kind=DP), dimension(-nx:nx) :: zf\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n      allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n                                           call clock_sta(1220)\n                                        ! call fapp_start(\"esfield_v0moment\",1220,1)\n      call intgrl_v0_moment_ms ( wf, nw )\n                                        ! call fapp_stop(\"esfield_v0moment\",1220,1)\n                                           call clock_end(1220)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          nw(0,0,iz) = ( 0._DP, 0._DP )      !  zero-zero\n        end do\n      end if\n\n      if ( ns == 1 ) then\n! --- adiabatic model for ITG-ae or ETG-ai\n        \n        zf = ( 0._DP, 0._DP )\n\n        if ( sgn(0) > 0._DP ) then ! --- ZF-calculation for ITG-ae \n\n         ! --- calculation of zonal flow potential\n          if ( rankw == 0 ) then\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n            my   = 0\n!$OMP parallel do\n            do iz = -nz, nz-1\n                do mx = -nx, -1\n                  ww(mx,my,iz)   = nw(mx,my,iz)                                     &\n                               / ( (  1._DP - g0(mx,my,iz)  + tau(0)*tau_ad ) * fctgt(mx) )\n                end do\n                mx = 0\n                  ww(mx,my,iz) = (0._DP, 0._DP)\n                do mx = 1, nx\n                  ww(mx,my,iz)   = nw(mx,my,iz)                                     &\n                               / ( (  1._DP - g0(mx,my,iz)  + tau(0)*tau_ad ) * fctgt(mx) )\n                end do\n            end do\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n    \n                                           call clock_sta(1230)\n                                        ! call fapp_start(\"esfield_fsrf\",1230,1)\n            call intgrl_fsrf ( ww, zf )\n                                        ! call fapp_stop(\"esfield_fsrf\",1230,1)\n                                           call clock_end(1230)\n    \n            zf(0)   = ( 0._DP, 0._DP )\n\n          end if\n\n        end if\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              phi(mx, my,iz) = nw(mx, my,iz) / ( 1._DP - g0(mx, my,iz) + tau(0)*tau_ad )\n            end do\n          end do\n        end do\n  \n        if ( rankw == 0 ) then\n!$OMP parallel do private(my)\n          do iz = -nz, nz-1\n            my = 0\n              do mx = -nx, nx\n              phi(mx,my,iz) = ( nw(mx,my,iz) + zf(mx)*tau(0)*tau_ad ) &\n                             / ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )\n              end do\n          end do\n        end if\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n      else\n! --- kinetic model for multi-species\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              phi(mx,my,iz) = nw(mx,my,iz) * fct_poisson(mx,my,iz)\n            end do\n          end do\n        end do\n\n      deallocate( wf )\n      deallocate( nw )\n      deallocate( ww )\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n      end if\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          phi(0,0,iz) = ( 0._DP, 0._DP )\n        end do\n      end if\n\n\n  END SUBROUTINE fld_esfield\n\n\n!--------------------------------------\n  SUBROUTINE fld_emfield_ff ( ff, Al )\n!--------------------------------------\n!     magnetic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks) &\n                                   * sqrt( tau(ranks) / Anum(ranks) ) * vl(iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n                                           call clock_sta(1220)\n                                        ! call fapp_start(\"esfield_v0moment\",1220,1)\n      call intgrl_v0_moment_ms ( wf, nw )\n                                        ! call fapp_stop(\"esfield_v0moment\",1220,1)\n                                           call clock_end(1220)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          nw(0,0,iz) = ( 0._DP, 0._DP )      !  zero-zero\n        end do\n      end if\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n\n              if ( rankw == 0.and. mx == 0.and. my == 0 ) then\n                Al(mx,my,iz) = ( 0._DP, 0._DP )\n              else\n                Al(mx,my,iz) = nw(mx,my,iz) * beta / ksq(mx,my,iz)\n              end if\n\n            end do\n          end do\n        end do\n\n      deallocate( wf )\n      deallocate( nw )\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n  END SUBROUTINE fld_emfield_ff\n\n\n!--------------------------------------\n  SUBROUTINE fld_emfield_hh ( hh, Al )\n!--------------------------------------\n!     magnetic field calculation\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw\n    integer  ::  mx, my, iz, iv, im\n\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n      allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                wf(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im) * j0(mx,my,iz,im) * sgn(ranks) * fcs(ranks) &\n                                   * sqrt( tau(ranks) / Anum(ranks) ) * vl(iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n                                           call clock_sta(1220)\n                                        ! call fapp_start(\"esfield_v0moment\",1220,1)\n      call intgrl_v0_moment_ms ( wf, nw )\n                                        ! call fapp_stop(\"esfield_v0moment\",1220,1)\n                                           call clock_end(1220)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          nw(0,0,iz) = ( 0._DP, 0._DP )      !  zero-zero\n        end do\n      end if\n\n                                           call clock_sta(1210)\n                                        ! call fapp_start(\"esfield_other\",1210,1)\n!$OMP parallel do\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              Al(mx,my,iz) = nw(mx,my,iz) * beta * fct_ampere(mx,my,iz)\n            end do\n          end do\n        end do\n\n      deallocate( wf )\n      deallocate( nw )\n                                        ! call fapp_stop(\"esfield_other\",1210,1)\n                                           call clock_end(1210)\n\n      if ( rankw == 0 ) then\n        do iz = -nz, nz-1\n          Al(0,0,iz) = ( 0._DP, 0._DP )\n        end do\n      end if\n\n\n  END SUBROUTINE fld_emfield_hh\n\n\n!--------------------------------------\n  SUBROUTINE fld_ff2hh ( ff, Al, hh )\n!--------------------------------------\n!     ff -> hh\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n\n    integer :: mx, my, iz, iv, im\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                hh(mx,my,iz,iv,im) = ff(mx,my,iz,iv,im)  &\n                    + sgn(ranks) * Znum(ranks)  / sqrt( Anum(ranks) * tau(ranks) )  &\n                    * fmx(iz,iv,im) * vl(iv) * j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n\n  END SUBROUTINE fld_ff2hh\n\n\n!--------------------------------------\n  SUBROUTINE fld_hh2ff ( hh, Al, ff )\n!--------------------------------------\n!     hh -> ff\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iz, iv, im\n\n!$OMP parallel\n      do im = 0, nm\n!$OMP do\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,im) = hh(mx,my,iz,iv,im)  &\n                      - sgn(ranks) * Znum(ranks)  / sqrt( Anum(ranks) * tau(ranks) )  &\n                      * fmx(iz,iv,im) * vl(iv) * j0(mx,my,iz,im) * Al(mx,my,iz)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n!$OMP end parallel\n\n\n  END SUBROUTINE fld_hh2ff\n\n\nEND MODULE GKV_fld\n", "MODULE GKV_bndry\n!-------------------------------------------------------------------------------\n!\n!    MPI send/recv communications in zz,vl,mu\n!\n!    Update history of gkvp_bndry.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n/\n  public   bndry_zvm_bound_f, bndry_bound_e,  &\n      bndry_bound_f_buffin, bndry_bound_f_sendrecv, bndry_bound_f_buffout,  &\n      bndry_shifts_v_buffin, bndry_shifts_v_sendrecv, bndry_shifts_v_buffout,  &\n      bndry_zv_buffin, bndry_zv_sendrecv, bndry_zv_buffout, &\n      bndry_vm_buffin, bndry_vm_sendrecv, bndry_vm_buffout, &\n      bndry_shifts_m_buffin, bndry_shifts_m_sendrecv, bndry_shifts_m_buffout\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zvm_bound_f( ff )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: vb1, vb2\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: mb1, mb2\n    integer :: im\n\n      allocate( zb1_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) )\n      allocate( vb1(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( vb2(-nx:nx,0:ny,-nz:nz-1,1:2*nvb,0:nm) )\n      allocate( mb1(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n      allocate( mb2(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) )\n\n!$OMP parallel default (none) &\n!$OMP shared(ff,zb1_bottom,zb1_top,zb2_bottom,zb2_top,vb1,vb2,mb1,mb2) &\n!$OMP private(im)\n      do im = 0, nm\n        call bndry_bound_f_buffin ( ff(:,:,:,:,im), zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_bound_f_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                      zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_bound_f_buffout ( zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      do im = 0, nm\n        call bndry_shifts_v_buffin ( ff(:,:,:,:,im), vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP barrier\n!$OMP master\n        call bndry_shifts_v_sendrecv ( vb1(:,:,:,:,im), vb2(:,:,:,:,im) )\n!$OMP end master\n!$OMP barrier\n        call bndry_shifts_v_buffout ( vb2(:,:,:,:,im), ff(:,:,:,:,im) )\n      end do\n!$OMP barrier\n\n      call bndry_shifts_m_buffin ( ff, mb1, mb2 )\n!$OMP barrier\n!$OMP master\n      call bndry_shifts_m_sendrecv ( mb1, mb2 )\n!$OMP end master\n!$OMP barrier\n      call bndry_shifts_m_buffout ( mb2, ff )\n!$OMP end parallel\n\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n      deallocate( vb1 )\n      deallocate( vb2 )\n      deallocate( mb1 )\n      deallocate( mb2 )\n\n  END SUBROUTINE bndry_zvm_bound_f\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffin( ff, zb1_bottom, zb1_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                zb1_bottom(mx,my,iz,iv) = ff(mx,my,-nz+iz  ,iv)\n                zb1_top   (mx,my,iz,iv) = ff(mx,my, nz-nzb+iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_bound_f_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_f_buffout ( zb2_bottom, zb2_top, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_bound_f_buffout\n\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_buffin( ff, vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1, vb2\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1361)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1361,1)\n!$OMP end master\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do iv = 1, 2*nvb\n!$OMP do schedule (dynamic)\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                vb1(mx,my,iz,iv    ) = ff(mx,my,iz,         iv)\n                vb1(mx,my,iz,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv)\n!              vb1(mx,my,iz,1) = ff(mx,my,iz,     1)\n!              vb1(mx,my,iz,2) = ff(mx,my,iz,     2)\n!              vb1(mx,my,iz,3) = ff(mx,my,iz,     3)\n!              vb1(mx,my,iz,4) = ff(mx,my,iz,2*nv-2)\n!              vb1(mx,my,iz,5) = ff(mx,my,iz,2*nv-1)\n!              vb1(mx,my,iz,6) = ff(mx,my,iz,2*nv  )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1361,1)\n                                           call clock_end(1361)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_v_sendrecv( vb1, vb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    integer  ::  slngv\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1362)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1362,1)\n!      call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n!                         vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n!                         vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1362,1)\n                                           call clock_end(1362)\n\n\n  END SUBROUTINE bndry_shifts_v_sendrecv\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_shifts_v_buffout( vb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1363)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1363,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do iv = 1, nvb\n                ff(mx,my,iz,-nvb+iv) = vb2(mx,my,iz,iv    )\n                ff(mx,my,iz,2*nv+iv) = vb2(mx,my,iz,iv+nvb)\n!              ff(mx,my,iz,    -2) = vb2(mx,my,iz,1)\n!              ff(mx,my,iz,    -1) = vb2(mx,my,iz,2)\n!              ff(mx,my,iz,     0) = vb2(mx,my,iz,3)\n!              ff(mx,my,iz,2*nv+1) = vb2(mx,my,iz,4)\n!              ff(mx,my,iz,2*nv+2) = vb2(mx,my,iz,5)\n!              ff(mx,my,iz,2*nv+3) = vb2(mx,my,iz,6)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1363,1)\n                                           call clock_end(1363)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_v_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffin( ff, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1, mb2\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n      do im = 1, 2*nvb\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mb2(mx,my,iz,iv,im) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end do\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                mb1(mx,my,iz,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n                mb1(mx,my,iz,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n!              mb1(mx,my,iz,iv,1) = ff(mx,my,iz,iv,   0)\n!              mb1(mx,my,iz,iv,2) = ff(mx,my,iz,iv,   1)\n!              mb1(mx,my,iz,iv,3) = ff(mx,my,iz,iv,   2)\n!              mb1(mx,my,iz,iv,4) = ff(mx,my,iz,iv,nm-2)\n!              mb1(mx,my,iz,iv,5) = ff(mx,my,iz,iv,nm-1)\n!              mb1(mx,my,iz,iv,6) = ff(mx,my,iz,iv,nm  )\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_sendrecv( mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    integer  ::  slngm\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngm = (2*nx+1)*(ny+1)*(2*nz)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                         ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n!                         mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n!                         mb2(-nx,0,-nz,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( mb2(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,-nz,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n\n  END SUBROUTINE bndry_shifts_m_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_shifts_m_buffout( mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1373)\n                                         ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              do im = 1, nvb\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iz,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iz,iv,im+nvb)\n!              ff(mx,my,iz,iv,  -3) = mb2(mx,my,iz,iv,1)\n!              ff(mx,my,iz,iv,  -2) = mb2(mx,my,iz,iv,2)\n!              ff(mx,my,iz,iv,  -1) = mb2(mx,my,iz,iv,3)\n!              ff(mx,my,iz,iv,nm+1) = mb2(mx,my,iz,iv,4)\n!              ff(mx,my,iz,iv,nm+2) = mb2(mx,my,iz,iv,5)\n!              ff(mx,my,iz,iv,nm+3) = mb2(mx,my,iz,iv,6)\n              end do\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_shifts_m_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_bound_e ( ew )\n!--------------------------------------\n!  Impose the modified periodic boundary condition \n!    in the z-direction for the electric field\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)   :: ew\n\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb1e_bottom, zb1e_top\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: zb2e_bottom, zb2e_top\n    integer  ::  mx, my, iz, im, mwn, mwp\n    integer  ::  slngze\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      allocate( zb1e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb1e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_bottom(-nx:nx,0:ny,0:nzb-1,0:nm) )\n      allocate( zb2e_top(-nx:nx,0:ny,0:nzb-1,0:nm) )\n\n      slngze  = (2*nx+1)*(ny+1)*(nm+1) * nzb\n\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP private(mx,my,iz,im)\n!$OMP master\n                                           call clock_sta(1381)\n                                         ! call fapp_start(\"literm_bounde_bufferin\",1381,1)\n!$OMP end master\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2e_bottom(mx,my,iz,im) = ( 0._DP, 0._DP )\n              zb2e_top   (mx,my,iz,im) = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n!$OMP do schedule (dynamic)\n      do im = 0, nm\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb1e_bottom(mx,my,iz,im) = ew(mx,my,-nz+iz  ,im)\n              zb1e_top   (mx,my,iz,im) = ew(mx,my, nz-nzb+iz,im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferin\",1381,1)\n                                           call clock_end(1381)\n!$OMP end master\n!$OMP end parallel\n\n                                           call clock_sta(1382)\n                                         ! call fapp_start(\"literm_bounde_sendrecv\",1382,1)\n!      call MPI_sendrecv( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1e_bottom, slngze, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1e_top,    slngze, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_bounde_sendrecv\",1382,1)\n                                           call clock_end(1382)\n\n! --- substitution\n!$OMP parallel default(none) &\n!$OMP shared(zb2e_bottom,zb2e_top,zb1e_bottom,zb1e_top,ist_y,iend_y,ew) &\n!$OMP shared(rankz,z_bound,ck,dj) &\n!$OMP private(mx,my,iz,im,mwp,mwn)\n!$OMP master\n                                           call clock_sta(1383)\n                                         ! call fapp_start(\"literm_bounde_bufferout\",1383,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,-nz-nzb+iz,im) = zb2e_bottom(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-1,im)   =   ew(mx,my,-nz  ,im)\n                    ew(mx,my,-nz-2,im)   = - ew(mx,my,-nz+1,im) + 2._DP * ew(mx,my,-nz  ,im)\n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ew(mx,my,-nz-nzb+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,-nz-nzb+iz,im) = ck(my) * zb2e_bottom(mwn,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do im = 0, nm\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ew(mx,my,nz+iz,im) = zb2e_top(mx,my,iz,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do\n\n      else   ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz  ,im)   =   ew(mx,my,nz-1,im)\n                    ew(mx,my,nz+1,im)   = - ew(mx,my,nz-2,im) + 2._DP * ew(mx,my,nz-1,im) \n                  else\n                    do iz = 0, nzb-1\n                      ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do\n\n        else if ( trim(z_bound) == \"zerofixed\" .OR. trim(z_bound) == \"mixed\" ) then\n\n!$OMP do schedule (dynamic)\n          do im = 0, nm\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ew(mx,my,nz+iz,im)   = ( 0._DP, 0._DP )\n                  else\n                    ew(mx,my,nz+iz,im) = conjg( ck(my) ) * zb2e_top(mwp,my,iz,im)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_bounde_bufferout\",1383,1)\n                                           call clock_end(1383)\n!$OMP end master\n!$OMP end parallel\n\n      deallocate( zb1e_bottom )\n      deallocate( zb1e_top )\n      deallocate( zb2e_bottom )\n      deallocate( zb2e_top )\n\n\n  END SUBROUTINE bndry_bound_e\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_zv_buffin( ff, zb1_bottom, zb1_top, vb1 )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n\n    integer :: iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1351)\n                                         ! call fapp_start(\"literm_boundf_bufferin\",1351,1)\n!$OMP end master\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            zb1_bottom(:,:,iz,iv) = ff(:,:,-nz+iz  ,iv)\n            zb1_top   (:,:,iz,iv) = ff(:,:, nz-nzb+iz,iv)\n          end do\n        end do\n!$OMP end do nowait\n\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!!$OMP do schedule(dynamic)\n!          do iz = -nz, nz-1\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,iz,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!          end do\n!!$OMP end do nowait\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do iz = -nz, nz-1\n            vb1(:,:,iz,iv    ) = ff(:,:,iz,         iv)\n            vb1(:,:,iz,iv+nvb) = ff(:,:,iz,2*nv-nvb+iv)\n          end do\n        end do\n!$OMP end do nowait\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferin\",1351,1)\n                                           call clock_end(1351)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffin\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_sendrecv ( zb1_bottom, zb1_top, zb2_bottom, zb2_top, vb1, vb2 )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n\n    integer :: slngz, slngv\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n      slngv = (2*nx+1)*(ny+1)*(2*nz) * nvb\n\n                                           call clock_sta(1352)\n                                         ! call fapp_start(\"literm_boundf_sendrecv\",1352,1)\n     !call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n     !                   zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n     !                   zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n     !                   vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n     !                   sub_comm_world, status, ierr_mpi )\n     !call MPI_sendrecv( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n     !                   vb2(-nx,0,-nz,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n     !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,-nz,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"literm_boundf_sendrecv\",1352,1)\n                                           call clock_end(1352)\n\n\n  END SUBROUTINE bndry_zv_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_zv_buffout ( zb2_bottom, zb2_top, vb2, ff )\n!--------------------------------------\n!   Impose the modified periodic boundary condition \n!     in the z-direction for the distribution function\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nvb) :: vb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb) :: ff\n\n    integer :: mx, my, iz, iv, mwn, mwp\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1353)\n                                         ! call fapp_start(\"literm_boundf_bufferout\",1353,1)\n!$OMP end master\n\n      if( rankz /= 0 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,-nz-nzb+iz,iv) = zb2_bottom(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    else                       ! outflow\n                      ff(mx,my,-nz-1,iv) =   ff(mx,my,-nz  ,iv)\n                      ff(mx,my,-nz-2,iv) = - ff(mx,my,-nz+1,iv) + 2._DP * ff(mx,my,-nz  ,iv)\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                  if( abs(mwn) > nx ) then\n                    ff(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              ff(:,:,nz+iz,iv) = zb2_top(:,:,iz,iv)\n            end do\n          end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n        if ( trim(z_bound) == \"outflow\" .OR. trim(z_bound) == \"mixed\") then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    if ( vl(iv) > 0._DP ) then ! outflow\n                      ff(mx,my,nz  ,iv) =   ff(mx,my,nz-1,iv)\n                      ff(mx,my,nz+1,iv) = - ff(mx,my,nz-2,iv) + 2._DP * ff(mx,my,nz-1,iv)\n                    else                       ! inflow\n                      do iz = 0, nzb-1\n                        ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                      end do\n                    end if\n                  else\n                    do iz = 0, nzb-1\n                      ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                    end do\n                  end if\n\n                end do\n              end do\n          end do\n!$OMP end do nowait\n\n        else if ( trim(z_bound) == \"zerofixed\" ) then\n\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, 2*nv\n            do iz = 0, nzb-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                  if( abs(mwp) > nx ) then\n                    ff(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                  else\n                    ff(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                  end if\n\n                end do\n              end do\n            end do\n          end do\n!$OMP end do nowait\n\n        else\n\n          write( olog, * ) \" # z_bound is to be  outflow  or  zerofixed\"\n          call flush(olog)\n          stop\n\n        end if\n\n      end if\n\n\n        if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = (0._DP, 0._DP)\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = (0._DP, 0._DP)\n            end do\n          end do\n!$OMP end do nowait\n        else\n!$OMP do collapse(2) schedule(dynamic)\n          do iv = 1, nvb\n            do iz = -nz, nz-1\n              ff(:,:,iz,-nvb+iv) = vb2(:,:,iz,iv    )\n              ff(:,:,iz,2*nv+iv) = vb2(:,:,iz,iv+nvb)\n            end do\n          end do\n!$OMP end do nowait\n        end if\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_boundf_bufferout\",1353,1)\n                                           call clock_end(1353)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_zv_buffout\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffin( iz, ff, vb1, mb1 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out),  &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n\n    integer :: mx, my, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1371)\n                                         ! call fapp_start(\"literm_shifts_bufferin\",1371,1)\n!$OMP end master\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do iv = 1, 2*nvb\n!        do im = 0, nm\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                vb2(mx,my,im,iv) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                vb1(mx,my,im,iv    ) = ff(mx,my,iz,         iv,im)\n                vb1(mx,my,im,iv+nvb) = ff(mx,my,iz,2*nv-nvb+iv,im)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n!! --- zero clear is required for rankv = 0, nprocv-1 and rankm = 0, nprocm-1\n!      do im = 1, 2*nvb\n!        do iv = 1, 2*nv\n!            do my = ist_y, iend_y\n!              do mx = -nx, nx\n!                mb2(mx,my,iv,im) = ( 0._DP, 0._DP )\n!              end do\n!            end do\n!        end do\n!      end do\n\n!$OMP do collapse(2) schedule(dynamic)\n      do im = 1, nvb\n        do iv = 1, 2*nv\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              mb1(mx,my,iv,im    ) = ff(mx,my,iz,iv,     im-1)\n              mb1(mx,my,iv,im+nvb) = ff(mx,my,iz,iv,nm-nvb+im)\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n\n\n!$OMP master\n                                         ! call fapp_stop(\"literm_shifts_bufferin\",1371,1)\n                                           call clock_end(1371)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffin\n\n\n!--------------------------------------\n  ", "SUBROUTINE bndry_vm_sendrecv ( vb1, vb2, mb1, mb2 )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb1\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n\n    integer :: slngv, slngm\n    integer, dimension(8) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,8) :: istatus\n\n\n      slngv = (2*nx+1)*(ny+1)*(nm+1) * nvb\n      slngm = (2*nx+1)*(ny+1)*(2*nv) * nvb\n\n                                           call clock_sta(1372)\n                                        ! call fapp_start(\"literm_shifts_sendrecv\",1372,1)\n    !call MPI_sendrecv( vb1(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n    !                   vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n    !                   sub_comm_world, status, ierr_mpi )\n    !call MPI_sendrecv( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n    !                   vb2(-nx,0,0,1    ), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n    !                   sub_comm_world, status, ierr_mpi )\n    !call MPI_sendrecv( mb1(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n    !                   mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n    !                   sub_comm_world, status, ierr_mpi )\n    !call MPI_sendrecv( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n    !                   mb2(-nx,0,1,1    ), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n    !                   sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( vb2(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( vb2(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 3, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_irecv( mb2(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 4, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,    1), slngv, MPI_DOUBLE_COMPLEX, ivdn, 1, &\n                      sub_comm_world, ireq(5), ierr_mpi )\n      call MPI_isend( vb1(-nx,0,0,nvb+1), slngv, MPI_DOUBLE_COMPLEX, ivup, 2, &\n                      sub_comm_world, ireq(6), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,    1), slngm, MPI_DOUBLE_COMPLEX, imdn, 3, &\n                      sub_comm_world, ireq(7), ierr_mpi )\n      call MPI_isend( mb1(-nx,0,1,nvb+1), slngm, MPI_DOUBLE_COMPLEX, imup, 4, &\n                      sub_comm_world, ireq(8), ierr_mpi )\n      call MPI_waitall( 8, ireq, istatus, ierr_mpi )\n                                        ! call fapp_stop(\"literm_shifts_sendrecv\",1372,1)\n                                           call clock_end(1372)\n\n  END SUBROUTINE bndry_vm_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE bndry_vm_buffout ( iz, vb2, mb2, ff )\n!--------------------------------------\n!     Shift communications in v and m directions\n\n    integer, intent(in) :: iz\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nm,1:2*nvb) :: vb2\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,1:2*nv,1:2*nvb) :: mb2\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n    integer :: mx, my, iv, im\n\n\n! --- substitution\n!$OMP master\n                                           call clock_sta(1373)\n                                        ! call fapp_start(\"literm_shifts_bufferout\",1373,1)\n!$OMP end master\n\n      if ( rankv == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = (0._DP, 0._DP)\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankv == nprocv-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do iv = 1, nvb\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,-nvb+iv,im) = vb2(mx,my,im,iv    )\n                ff(mx,my,iz,2*nv+iv,im) = vb2(mx,my,im,iv+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n\n      if ( rankm == 0 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = (0._DP, 0._DP)\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else if ( rankm == nprocm-1 ) then\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = (0._DP, 0._DP)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      else\n!$OMP do collapse(2) schedule(dynamic)\n        do im = 1, nvb\n          do iv = 1, 2*nv\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ff(mx,my,iz,iv,-nvb-1+im) = mb2(mx,my,iv,im    )\n                ff(mx,my,iz,iv,nm+im    ) = mb2(mx,my,iv,im+nvb)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n      end if\n\n!$OMP master\n                                        ! call fapp_stop(\"literm_shifts_bufferout\",1373,1)\n                                           call clock_end(1373)\n!$OMP end master\n\n\n  END SUBROUTINE bndry_vm_buffout\n\n\nEND MODULE GKV_bndry\n", "MODULE GKV_zfilter\n!-------------------------------------------------------------------------------\n!\n!    Filtering in zz to reduce high-kz numerical oscillations\n!\n!    Update history of gkvp_zfilter.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   zfilter\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE zfilter ( vv )\n!--------------------------------------\n!     z-derivative of f\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: vv\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: ww\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    integer :: im\n\n      allocate( ww(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) )\n      allocate( zb1_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n\n!$OMP parallel default (none) &\n!$OMP shared (vv,ww,zb1_bottom,zb1_top,zb2_bottom,zb2_top) &\n!$OMP private (im)\n      call zfilter_copy (         vv(:,:,:,:,0),      ww(:,:,:,:,0),  &\n                          zb1_bottom(:,:,:,:,0), zb1_top(:,:,:,:,0),  &\n                          zb2_bottom(:,:,:,:,0), zb2_top(:,:,:,:,0) )\n!$OMP barrier\n\n      im = 0\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!$OMP barrier\n\n      im = 1\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n                               ww(:,:,:,:,im-1) )\n!$OMP barrier\n\n      do im = 2, nm-1\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n                               ww(:,:,:,:,im-1) )\n        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!$OMP barrier\n      end do\n\n      im = nm\n!$OMP master\n        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!$OMP end master\n!!!!! barrier! for test without overlaps\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n                               ww(:,:,:,:,im-1) )\n        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!$OMP barrier\n\n        call zfilter_buffout ( zb2_bottom(:,:,:,:,nm), zb2_top(:,:,:,:,nm), &\n                               ww(:,:,:,:,nm) )\n        call zfilter_filtering ( ww(:,:,:,:,nm-1), vv(:,:,:,:,nm-1) )\n!$OMP barrier\n\n        call zfilter_filtering ( ww(:,:,:,:,nm), vv(:,:,:,:,nm) )\n!$OMP end parallel\n\n      deallocate( ww )\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n\n  END SUBROUTINE zfilter\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_copy( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv) :: vv\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    complex(kind=DP) :: wk\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1521)\n                                        ! call fapp_start(\"zfilter_comm_bufferin\",1521,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my,-nz+iz ,iv)\n              zb1_bottom(mx,my,iz,iv) = wk\n                  ww(mx,my,-nz+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = -nz+nzb, nz-1-nzb\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n                      ww(mx,my,iz,iv) = vv(mx,my,iz,iv)\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my, nz-nzb+iz,iv)\n              zb1_top   (mx,my,iz,iv) = wk\n              ww(mx,my, nz-nzb+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2_bottom(mx,my,iz,iv)  = ( 0._DP, 0._DP )\n              zb2_top   (mx,my,iz,iv)  = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"zfilter_comm_bufferin\",1521,1)\n                                           call clock_end(1521)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_copy\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_sendrecv( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1522)\n                                        ! call fapp_start(\"zfilter_comm_sendrecv\",1522,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                        ! call fapp_stop(\"zfilter_comm_sendrecv\",1522,1)\n                                           call clock_end(1522)\n\n\n   END SUBROUTINE zfilter_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_buffout( zb2_bottom, zb2_top, ww )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n!$OMP master\n                                           call clock_sta(1523)\n                                        ! call fapp_start(\"zfilter_comm_bufferout\",1523,1)\n!$OMP end master\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankz==0\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                if( abs(mwn) > nx ) then\n                  ww(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else! rankz==nprocz-1\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                if( abs(mwp) > nx ) then\n                  ww(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n!$OMP master\n                                        ! call fapp_stop(\"zfilter_comm_bufferout\",1523,1)\n                                           call clock_end(1523)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_buffout\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_filtering( ww, vv )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)         :: vv\n\n    real(kind=DP) :: alph, ceff\n    integer  ::  mx, my, iz, iv\n\n\n      alph   = 1._DP\n      ceff   = alph / 16._DP\n\n!$OMP master\n                                             call clock_sta(1510)\n                                          ! call fapp_start(\"zfilter_calc\",1510,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vv(mx,my,iz,iv) =                               &\n                      ( 1._DP - alph )  * ww(mx,my,iz ,iv)   &\n                    + ceff * ( -          ww(mx,my,iz+2,iv)   &\n                               +  4._DP * ww(mx,my,iz+1,iv)   &\n                               + 10._DP * ww(mx,my,iz ,iv)   &\n                               +  4._DP * ww(mx,my,iz-1,iv)   &\n                               -          ww(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                          ! call fapp_stop(\"zfilter_calc\",1510,1)\n                                             call clock_end(1510)\n!$OMP end master\n\n  END SUBROUTINE zfilter_filtering\n\n\nEND MODULE GKV_zfilter\n", "MODULE GKV_zfilter\n!-------------------------------------------------------------------------------\n!\n!    Some useful tools and tips\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  public   zfilter\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE zfilter ( vv )\n!--------------------------------------\n!     z-derivative of f\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: vv\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: ww\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb1_bottom, zb1_top\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: zb2_bottom, zb2_top\n    integer :: im\n\n      allocate( ww(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) )\n      allocate( zb1_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb1_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_bottom(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n      allocate( zb2_top(-nx:nx,0:ny, 0:nzb-1, 1:2*nv,0:nm) )\n\n!$OMP parallel default (none) &\n!$OMP shared (vv,ww,zb1_bottom,zb1_top,zb2_bottom,zb2_top) &\n!$OMP private (im)\n\n!!%%% Without overlap * nm %%%\n      call zfilter_copy_v2 ( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n      call zfilter_sendrecv_v2 ( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n      call zfilter_buffout_v2 ( zb2_bottom, zb2_top, ww )\n      call zfilter_filtering_v2 ( ww, vv )\n\n!!%%%%%%%%%%%%%%%%%%%%\n\n!!%%% With overlap %%%\n!      call zfilter_copy (         vv(:,:,:,:,0),      ww(:,:,:,:,0),  &\n!                          zb1_bottom(:,:,:,:,0), zb1_top(:,:,:,:,0),  &\n!                          zb2_bottom(:,:,:,:,0), zb2_top(:,:,:,:,0) )\n!!$OMP barrier\n!\n!      im = 0\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n!                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n!                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!!$OMP barrier\n!\n!      im = 1\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n!                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n!                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n!                               ww(:,:,:,:,im-1) )\n!!$OMP barrier\n!\n!      do im = 2, nm-1\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_copy (         vv(:,:,:,:,im+1),      ww(:,:,:,:,im+1),  &\n!                            zb1_bottom(:,:,:,:,im+1), zb1_top(:,:,:,:,im+1),  &\n!                            zb2_bottom(:,:,:,:,im+1), zb2_top(:,:,:,:,im+1) )\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n!                               ww(:,:,:,:,im-1) )\n!        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!!$OMP barrier\n!      end do\n!\n!      im = nm\n!!$OMP master\n!        call zfilter_sendrecv ( zb1_bottom(:,:,:,:,im), zb1_top(:,:,:,:,im),  &\n!                                zb2_bottom(:,:,:,:,im), zb2_top(:,:,:,:,im) )\n!!$OMP end master\n!!!!!! barrier ! for test without overlaps\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,im-1), zb2_top(:,:,:,:,im-1), &\n!                               ww(:,:,:,:,im-1) )\n!        call zfilter_filtering ( ww(:,:,:,:,im-2), vv(:,:,:,:,im-2) )\n!!$OMP barrier\n!\n!        call zfilter_buffout ( zb2_bottom(:,:,:,:,nm), zb2_top(:,:,:,:,nm), &\n!                               ww(:,:,:,:,nm) )\n!        call zfilter_filtering ( ww(:,:,:,:,nm-1), vv(:,:,:,:,nm-1) )\n!!$OMP barrier\n!\n!        call zfilter_filtering ( ww(:,:,:,:,nm), vv(:,:,:,:,nm) )\n!!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      deallocate( ww )\n      deallocate( zb1_bottom )\n      deallocate( zb1_top )\n      deallocate( zb2_bottom )\n      deallocate( zb2_top )\n\n  END SUBROUTINE zfilter\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_copy( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv) :: vv\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    complex(kind=DP) :: wk\n    integer  ::  mx, my, iz, iv\n\n\n!$OMP master\n                                           call clock_sta(1521)\n                                         ! call fapp_start(\"zfilter_comm_bufferin\",1521,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my,-nz+iz  ,iv)\n              zb1_bottom(mx,my,iz,iv) = wk\n                  ww(mx,my,-nz+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = -nz+nzb, nz-1-nzb\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n                      ww(mx,my,iz,iv) = vv(mx,my,iz,iv)\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my, nz-nzb+iz,iv)\n              zb1_top   (mx,my,iz,iv) = wk\n              ww(mx,my, nz-nzb+iz,iv) = wk\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2_bottom(mx,my,iz,iv)  = ( 0._DP, 0._DP )\n              zb2_top   (mx,my,iz,iv)  = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"zfilter_comm_bufferin\",1521,1)\n                                           call clock_end(1521)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_copy\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_sendrecv( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv) * nzb\n\n                                           call clock_sta(1522)\n                                         ! call fapp_start(\"zfilter_comm_sendrecv\",1522,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                         ! call fapp_stop(\"zfilter_comm_sendrecv\",1522,1)\n                                           call clock_end(1522)\n\n\n   END SUBROUTINE zfilter_sendrecv\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_buffout( zb2_bottom, zb2_top, ww )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n\n    integer  ::  mx, my, iz, iv, mwn, mwp\n\n\n!$OMP master\n                                           call clock_sta(1523)\n                                         ! call fapp_start(\"zfilter_comm_bufferout\",1523,1)\n!$OMP end master\n      if( rankz /= 0 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,-nz-nzb+iz,iv) = zb2_bottom(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else  ! rankz==0\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwn   = mx + dj(my)          ! --- mw = mx + dj for the negative-z \n\n                if( abs(mwn) > nx ) then\n                  ww(mx,my,-nz-nzb+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,-nz-nzb+iz,iv) = ck(my) * zb2_bottom(mwn,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,nz+iz,iv) = zb2_top(mx,my,iz,iv)\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      else ! rankz==nprocz-1\n\n!$OMP do schedule (dynamic)\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwp   = mx - dj(my)          ! --- mw = mx - dj for the positive-z \n\n                if( abs(mwp) > nx ) then\n                  ww(mx,my,nz+iz,iv) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,nz+iz,iv) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n!$OMP end do nowait\n\n      end if\n!$OMP master\n                                         ! call fapp_stop(\"zfilter_comm_bufferout\",1523,1)\n                                           call clock_end(1523)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_buffout\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_filtering( ww, vv )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv)         :: vv\n\n    real(kind=DP) :: alph, ceff\n    integer  ::  mx, my, iz, iv\n\n\n      alph   = 1._DP\n      ceff   = alph / 16._DP\n\n!$OMP master\n                                             call clock_sta(1510)\n                                           ! call fapp_start(\"zfilter_calc\",1510,1)\n!$OMP end master\n!$OMP do schedule (dynamic)\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vv(mx,my,iz,iv) =                               &\n                      ( 1._DP - alph )  * ww(mx,my,iz  ,iv)   &\n                    + ceff * ( -          ww(mx,my,iz+2,iv)   &\n                               +  4._DP * ww(mx,my,iz+1,iv)   &\n                               + 10._DP * ww(mx,my,iz  ,iv)   &\n                               +  4._DP * ww(mx,my,iz-1,iv)   &\n                               -          ww(mx,my,iz-2,iv) )\n            end do\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                           ! call fapp_stop(\"zfilter_calc\",1510,1)\n                                             call clock_end(1510)\n!$OMP end master\n\n  END SUBROUTINE zfilter_filtering\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_copy_v2( vv, ww, zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: vv\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n\n    complex(kind=DP) :: wk\n    integer  ::  mx, my, iz, iv, im\n\n\n!$OMP master\n                                           call clock_sta(1521)\n                                         ! call fapp_start(\"zfilter_comm_bufferin\",1521,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule (dynamic)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my,-nz+iz  ,iv,im)\n              zb1_bottom(mx,my,iz,iv,im) = wk\n                  ww(mx,my,-nz+iz,iv,im) = wk\n            end do\n          end do\n        end do\n        do iz = -nz+nzb, nz-1-nzb\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n                      ww(mx,my,iz,iv,im) = vv(mx,my,iz,iv,im)\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wk                         = vv(mx,my, nz-nzb+iz,iv,im)\n              zb1_top   (mx,my,iz,iv,im) = wk\n              ww(mx,my, nz-nzb+iz,iv,im) = wk\n            end do\n          end do\n        end do\n        do iz = 0, nzb-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              zb2_bottom(mx,my,iz,iv,im)  = ( 0._DP, 0._DP )\n              zb2_top   (mx,my,iz,iv,im)  = ( 0._DP, 0._DP )\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"zfilter_comm_bufferin\",1521,1)\n                                           call clock_end(1521)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_copy_v2\n\n\n!--------------------------------------\n  ", "SUBROUTINE zfilter_sendrecv_v2( zb1_bottom, zb1_top, zb2_bottom, zb2_top )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb1_bottom, zb1_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n\n    integer  ::  slngz\n    integer, dimension(4) :: ireq\n    integer, dimension(MPI_STATUS_SIZE,4) :: istatus\n\n\n      slngz  = (2*nx+1)*(ny+1)*(2*nv)*(nm+1) * nzb\n\n                                           call clock_sta(1522)\n                                        ! call fapp_start(\"zfilter_comm_sendrecv\",1522,1)\n!      call MPI_sendrecv( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n!                         zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n!                         sub_comm_world, status, ierr_mpi )\n!\n!      call MPI_sendrecv( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n!                         zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n!                         sub_comm_world, status, ierr_mpi )\n\n      call MPI_irecv( zb2_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 1, &\n                      sub_comm_world, ireq(1), ierr_mpi )\n      call MPI_irecv( zb2_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 2, &\n                      sub_comm_world, ireq(2), ierr_mpi )\n      call MPI_isend( zb1_bottom, slngz, MPI_DOUBLE_COMPLEX, izdn, 1, &\n                      sub_comm_world, ireq(3), ierr_mpi )\n      call MPI_isend( zb1_top,    slngz, MPI_DOUBLE_COMPLEX, izup, 2, &\n                      sub_comm_world, ireq(4), ierr_mpi )\n      call MPI_waitall( 4, ireq, istatus, ierr_mpi )\n                                        ! call fapp_stop(\"zfilter_comm_sendrecv\",1522,1)\n                                           call clock_end(1522)\n\n\n   END SUBROUTINE zfilter_sendrecv_v2\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_buffout_v2( zb2_bottom, zb2_top, ww )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nzb-1,1:2*nv,0:nm) :: zb2_bottom, zb2_top\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) :: ww\n\n    integer  ::  mx, my, iz, iv, im, mwn, mwp\n\n\n!$OMP master\n                                           call clock_sta(1523)\n                                        ! call fapp_start(\"zfilter_comm_bufferout\",1523,1)\n!$OMP end master\n      if( rankz /= 0 ) then\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,-nz-nzb+iz,iv,im) = zb2_bottom(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      else ! rankz==0\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwn   = mx + dj(my)         ! --- mw = mx + dj for the negative-z \n\n                if( abs(mwn) > nx ) then\n                  ww(mx,my,-nz-nzb+iz,iv,im) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,-nz-nzb+iz,iv,im) = ck(my) * zb2_bottom(mwn,my,iz,iv,im)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      end if\n\n      if( rankz /= nprocz-1 ) then\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ww(mx,my,nz+iz,iv,im) = zb2_top(mx,my,iz,iv,im)\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      else! rankz==nprocz-1\n\n!!TBI!!!$OMP do schedule (dynamic)\n        do im = 0, nm\n        do iv = 1, 2*nv\n          do iz = 0, nzb-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                mwp   = mx - dj(my)         ! --- mw = mx - dj for the positive-z \n\n                if( abs(mwp) > nx ) then\n                  ww(mx,my,nz+iz,iv,im) = ( 0._DP, 0._DP )\n                else\n                  ww(mx,my,nz+iz,iv,im) = conjg( ck(my) ) * zb2_top(mwp,my,iz,iv,im)\n                end if\n\n              end do\n            end do\n          end do\n        end do\n        end do\n!!TBI!!!$OMP end do nowait\n\n      end if\n!$OMP master\n                                        ! call fapp_stop(\"zfilter_comm_bufferout\",1523,1)\n                                           call clock_end(1523)\n!$OMP end master\n\n\n  END SUBROUTINE zfilter_buffout_v2\n\n\n!--------------------------------------\n  SUBROUTINE zfilter_filtering_v2( ww, vv )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1:2*nv,0:nm) :: ww\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)         :: vv\n\n    real(kind=DP) :: alph, ceff\n    integer  ::  mx, my, iz, iv, im\n\n\n      alph   = 1._DP\n      ceff   = alph / 16._DP\n\n!$OMP master\n                                             call clock_sta(1510)\n                                          ! call fapp_start(\"zfilter_calc\",1510,1)\n!$OMP end master\n!!TBI!!!$OMP do schedule (dynamic)\n      do im = 0, nm\n      do iv = 1, 2*nv\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              vv(mx,my,iz,iv,im) =                               &\n                      ( 1._DP - alph )  * ww(mx,my,iz ,iv,im)   &\n                    + ceff * ( -          ww(mx,my,iz+2,iv,im)   &\n                               +  4._DP * ww(mx,my,iz+1,iv,im)   &\n                               + 10._DP * ww(mx,my,iz ,iv,im)   &\n                               +  4._DP * ww(mx,my,iz-1,iv,im)   &\n                               -          ww(mx,my,iz-2,iv,im) )\n            end do\n          end do\n        end do\n      end do\n      end do\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                          ! call fapp_stop(\"zfilter_calc\",1510,1)\n                                             call clock_end(1510)\n!$OMP end master\n\n  END SUBROUTINE zfilter_filtering_v2\n\n\nEND MODULE GKV_zfilter\n", "MODULE GKV_fft\n!-------------------------------------------------------------------------------\n!\n!    FFT module for E x B term calculation using FFTW\n!\n!    Update history of gkvp_fft_fftw.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  include \"fftw3.f\"\n\n  private\n\n  integer(kind=DP), save      :: plan_x_forward, plan_x_backward\n  integer(kind=DP), save      :: plan_y_forward, plan_y_backward\n\n  public   fft_pre,  &\n          !fft_backward_Xfft, fft_backward_chXY, fft_backward_Yfft, &\n          !fft_forward_Yfft, fft_forward_chYX, fft_forward_Xfft,    &\n           plan_x_forward, plan_x_backward,                         &\n           plan_y_forward, plan_y_backward\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE fft_pre( )\n!--------------------------------------\n!  Initialization of FFT\n\n    complex(kind=DP) :: wk1_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk2_x_z(0:2*nxw-1)\n    complex(kind=DP) :: wk1_y_z(0:nyw)\n    real(kind=DP)    :: wk2_y_r(0:2*nyw-1)\n\n\n     wk1_x_z(:) = (0._DP, 0._DP)\n     wk2_x_z(:) = (0._DP, 0._DP)\n     wk1_y_z(:) = (0._DP, 0._DP)\n     wk2_y_r(:) = 0._DP\n\n     call dfftw_plan_dft_1d( plan_x_backward,     &\n                             (2*nxw),             &\n                             wk1_x_z,             &  ! complex in\n                             wk2_x_z,             &  ! complex out\n                             FFTW_BACKWARD,       &\n                             FFTW_MEASURE )\n                            !! FFTW_ESTIMATE )\n\n     call dfftw_plan_dft_c2r_1d( plan_y_backward, &\n                                 (2*nyw),         &\n                                 wk1_y_z,         &  ! complex in\n                                 wk2_y_r,         &  ! real    out\n                                 FFTW_MEASURE )\n                                !! FFTW_ESTIMATE )\n\n     call dfftw_plan_dft_r2c_1d( plan_y_forward,  &\n                                 (2*nyw),         &\n                                 wk2_y_r,         &  ! real    in\n                                 wk1_y_z,         &  ! complex out\n                                 FFTW_MEASURE )\n                                !! FFTW_ESTIMATE )\n\n     call dfftw_plan_dft_1d( plan_x_forward,      &\n                             (2*nxw),             &\n                             wk2_x_z,             &  ! complex in\n                             wk1_x_z,             &  ! complex out\n                             FFTW_FORWARD,        &\n                             FFTW_MEASURE )\n                            !! FFTW_ESTIMATE )\n\n\n  END SUBROUTINE fft_pre\n\n\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Xfft ( exbdf, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_out! for outplace\n!    integer :: ist_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1421)\n!                                        ! call fapp_start(\"nlterm_backward_Xfft\",1421,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_backward,  &\n!                          exbdf(0,my,i),    &    ! complex in\n!                       !  exbdf(0,my,i)        ) ! complex out\n!                          wk_x_out             ) ! complex out! for outplace\n!\n!       ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            do mx = ist_xw, iend_xw\n!            !  send_buff(my,mx,i,irank) = exbdf(mx+ist_xw_g_rank,my,i)\n!               send_buff(my,mx,i,irank) = wk_x_out(mx+ist_xw_g_rank)! for outplace\n!            enddo\n!          enddo\n!\n!        enddo\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_backward_Xfft\",1421,1)\n!                                           call clock_end(1421)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Xfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_chXY ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         Y divide -> X divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1422)\n!                                        ! call fapp_start(\"nlterm_backward_shiftXY\",1422,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                        ! call fapp_stop(\"nlterm_backward_shiftXY\",1422,1)\n!                                           call clock_end(1422)\n!    \n!\n!  END SUBROUTINE fft_backward_chXY\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_backward_Yfft ( recv_buff, exbdf_xw, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_in(0:nyw)! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Backward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1423)\n!                                        ! call fapp_start(\"nlterm_backward_Yfft\",1423,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!       ! --- restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!           !  exbdf_xw(my,mx,i) = recv_buff(my-ist_y_g_rank,mx,i,irank)\n!              wk_y_in(my) = recv_buff(my-ist_y_g_rank,mx,i,irank)! for outplace\n!            end do\n!          end do\n!       ! --- set filler ---\n!          do my = global_ny+1, nyw\n!         !  exbdf_xw(my,mx,i) = ( 0._DP, 0._DP )\n!            wk_y_in(my) = ( 0._DP, 0._DP )! for outplace\n!          end do\n!\n!          call dfftw_execute_dft_c2r( &\n!                          plan_y_backward,   &\n!                       !  exbdf_xw(0,mx,i),  &   ! complex in\n!                          wk_y_in,            &   ! complex in! for outplace\n!                          exbdf_xw(0,mx,i)     ) ! real    out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_backward_Yfft\",1423,1)\n!                                           call clock_end(1423)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_backward_Yfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Yfft ( exbdf_xw, send_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:nyw,0:nxw_size,num_trans)   :: exbdf_xw\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP) :: wk_y_out(0:nyw)! for outplace\n!    integer :: ist_y_g_rank, iend_y_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in Y ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1441)\n!                                        ! call fapp_start(\"nlterm_forward_Yfft\",1441,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do mx = ist_xw, iend_xw\n!\n!          call dfftw_execute_dft_r2c( &\n!                          plan_y_forward,    &\n!                          exbdf_xw(0,mx,i),  &   ! real in\n!                       !  exbdf_xw(0,mx,i)     ) ! complex out\n!                          wk_y_out             ) ! complex out! for outplace\n!\n!       ! --- set send buffer ---\n!          do irank = 0, nprocw-1\n!            ist_y_g_rank  = (ny+1)*irank\n!            iend_y_g_rank = min ( (ny+1)*(irank+1)-1, global_ny )\n!            do my = ist_y_g_rank, iend_y_g_rank\n!           !  send_buff(my-ist_y_g_rank,mx,i,irank) = exbdf_xw(my,mx,i)\n!              send_buff(my-ist_y_g_rank,mx,i,irank) = wk_y_out(my)! for outplace\n!            end do\n!          end do\n!\n!      end do\n!    end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_forward_Yfft\",1441,1)\n!                                           call clock_end(1441)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Yfft\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_chYX ( send_buff, recv_buff, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: send_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    integer, intent(in)  :: num_trans\n!\n!    integer :: nsize_com\n!    integer :: irc\n!\n!\n!! ---- Data Exchange ----------------------------------\n!!         X divide -> Y divide\n!      nsize_com = (ny+1)*(nxw_size+1)*num_trans\n!\n!                                           call clock_sta(1442)\n!                                        ! call fapp_start(\"nlterm_forward_shiftYX\",1442,1)\n!      call mpi_alltoall( send_buff, &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         recv_buff,              &\n!                         nsize_com,              &\n!                         MPI_DOUBLE_COMPLEX,     &\n!                         fft_comm_world,         &\n!                         irc        )\n!                                        ! call fapp_stop(\"nlterm_forward_shiftYX\",1442,1)\n!                                           call clock_end(1442)\n!\n!\n!  END SUBROUTINE fft_forward_chYX\n!\n!\n!!--------------------------------------\n!  SUBROUTINE fft_forward_Xfft ( recv_buff, exbdf, num_trans )\n!!--------------------------------------\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(0:ny, 0:nxw_size, num_trans, 0:nprocw-1) :: recv_buff\n!    complex(kind=DP), intent(out), &\n!      dimension(0:2*nxw-1,0:ny,num_trans)   :: exbdf\n!    integer, intent(in)  :: num_trans\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: wk_x_in! for outplace\n!    integer :: ist_xw_g_rank, iend_xw_g_rank\n!    integer :: mx, my, i, irank\n!\n!\n!! ---- Forward FFT in X ----------------------------------\n!!$OMP master\n!                                           call clock_sta(1443)\n!                                        ! call fapp_start(\"nlterm_forward_Xfft\",1443,1)\n!!$OMP end master\n!!$OMP do schedule (dynamic)\n!      do i = 1, num_trans\n!        do my = ist_y, iend_y\n!\n!       ! ---  restore receive buffer ---\n!          do irank = 0, nprocw-1\n!            ist_xw_g_rank  = (nxw_size+1)*irank\n!            iend_xw_g_rank = min ( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!            do mx = ist_xw_g_rank, iend_xw_g_rank\n!           !  exbdf(mx,my,i) = recv_buff(my,mx-ist_xw_g_rank,i,irank)\n!              wk_x_in(mx) = recv_buff(my,mx-ist_xw_g_rank,i,irank)! for outplace\n!            enddo\n!          enddo\n!\n!          call dfftw_execute_dft ( &\n!                          plan_x_forward,   &\n!                       !  exbdf(0,my,i),    &   ! complex in\n!                          wk_x_in,          &   ! complex in! for outplace\n!                          exbdf(0,my,i)       ) ! complex out\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                        ! call fapp_stop(\"nlterm_forward_Xfft\",1443,1)\n!                                           call clock_end(1443)\n!!$OMP end master\n!\n!\n!  END SUBROUTINE fft_forward_Xfft\n\n\nEND MODULE GKV_fft\n", "MODULE GKV_exb\n!-------------------------------------------------------------------------------\n!\n!    E x B term\n!\n!    Update history of gkvp_exb.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fft, only: plan_x_forward, plan_x_backward, &\n                     plan_y_forward, plan_y_backward\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  real(kind=DP), save :: exb_maxvx_eachrank, exb_maxvy_eachrank\n\n  integer, parameter :: nbuff = ((2*nz)*(nm+1)-1)/nprocw + 1\n                            !if ( mod(2*nz*(nm+1),nprocw) == 0 ) then\n                            !  nbuff = 2*nz*(nm+1)/nprocw\n                            !else\n                            !  nbuff = 2*nz*(nm+1)/nprocw + 1\n                            !end if\n  real(kind=DP), dimension(0:global_ny), save :: gky\n  integer, save :: nchunk_zm = 1, nchunk_yb = 1, nchunk_xb = 1\n\n  integer, save :: nchunk_yzm = 1, nchunk_xzm = 1\n\n\n  public   exb_NL_term, exb_maxvx_eachrank, exb_maxvy_eachrank\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term(hh, psi, chi, pb)\n!--------------------------------------\n!  Nonlinear term calculation interface\n    implicit none\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: pb\n\n    real(kind=DP) :: dky\n    integer, save :: iflg\n    integer :: my\n!$  integer :: nthreads, omp_get_num_threads\n    data iflg / 0 /\n                                               !%%% For debug %%%\n                                               !complex(kind=DP) ::                        &\n                                               !  whh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm),   &\n                                               !  wpsi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm), &\n                                               !  wchi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)\n                                               !integer :: mx, iz, iv, im\n                                               !%%%%%%%%%%%%%%%%%\n\n    if( iflg == 0 ) then\n      iflg = 1\n      dky = ky(1) - ky(0)\n      do my = 0, global_ny\n        gky(my) = dky * real(my, kind=DP)\n      end do\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zm = ((2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_yb = ((global_ny+1)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_xb = ((2*nxw)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_yzm = ((iend_y-ist_y+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_xzm = ((iend_xw-ist_xw+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n    end if\n                                               !%%% For debug %%%\n                                               !whh(:,:,:,:,:) = (0._DP, 0._DP)\n                                               !wpsi(:,:,:,:) = (0._DP, 0._DP)\n                                               !wchi(:,:,:,:) = (0._DP, 0._DP)\n                                               !if (rankw == 0) then\n                                               !  whh(0,1,:,:,:) = (0.5_DP, 0._DP)\n                                               !  wpsi(2,0,:,:) = (0._DP, 0.5_DP)\n                                               !  wpsi(-2,0,:,:) = (0._DP, -0.5_DP)\n                                               !end if\n                                               !%%%%%%%%%%%%%%%%%\n\n    if (trim(calc_type) == \"nonlinear\") then\n\n        call exb_NL_term_y2zm(hh, psi, chi, pb)\n\n        !call exb_NL_term_y2x(hh, psi, chi, pb)\n\n    else\n\n!$OMP parallel workshare\n      pb(:,:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n    end if\n\n                                               !%%% For debug %%%\n                                               !if (rankz == 0 .and. rankv == 0 .and. rankm == 0 .and. ranks == 0) then\n                                               !  im = 0; iv = 1; iz = 0\n                                               !  do my = 0, ny\n                                               !    do mx = -nx, nx\n                                               !      write(80000+rankg,*) kx(mx), ky(my),  &\n                                               !  dble(whh(mx,my,iz,iv,im)), aimag(whh(mx,my,iz,iv,im)), &\n                                               !  dble(wpsi(mx,my,iz,im)), aimag(wpsi(mx,my,iz,im)), &\n                                               !  dble(pb(mx,my,iz,iv,im)), aimag(pb(mx,my,iz,iv,im))\n                                               !    end do\n                                               !    write(80000+rankg,*)\n                                               !  end do\n                                               !end if\n                                               !call MPI_Finalize(ierr_mpi)\n                                               !stop\n                                               !%%%%%%%%%%%%%%%%%\n\n\n  END SUBROUTINE exb_NL_term\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term_y2zm( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: &\n                      wc1o, wc2o, wc3o, wc4o,   wc1e, wc2e, wc3e, wc4e\n    complex(kind=DP), dimension(:,:,:), allocatable ::   &\n                         wwdxo, wwdyo, wwefo,      wwdxe, wwdye, wwefe\n    integer :: iv\n\n      allocate(dpdx(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(dpdy(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(dadx(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(dady(0:2*nyw-1,0:2*nxw-1,0:nbuff-1))\n      allocate(wc1o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc2o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc3o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc4o(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc1e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc2e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc3e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wc4e(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1))\n      allocate(wwdxo(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwdyo(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwefo(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwdxe(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwdye(0:global_ny,0:2*nxw-1,0:nbuff-1))\n      allocate(wwefe(0:global_ny,0:2*nxw-1,0:nbuff-1))\n\n!$OMP parallel default(none)                          &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)       &\n!$OMP shared(wc1o,wc2o,wc3o,wc4o,wc1e,wc2e,wc3e,wc4e) &\n!$OMP shared(wwdxo,wwdyo,wwefo,wwdxe,wwdye,wwefe)     &\n!$OMP private(iv)\n\n!$OMP workshare\n      wc1o(:,:,:,:) = (0._DP, 0._DP)\n      wc3o(:,:,:,:) = (0._DP, 0._DP)\n      wc1e(:,:,:,:) = (0._DP, 0._DP)\n      wc3e(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!!      call exb_pack_y2zm(psi(-nx:nx,0:ny,-nz:nz-1,0:nm),wc3o)\n!      call exb_pack_psi_y2zm(psi,wc3o)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3o,wc4o)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n!!$OMP barrier\n!!      call exb_pack_y2zm(chi(-nx:nx,0:ny,-nz:nz-1,0:nm),wc3e)\n!      call exb_pack_psi_y2zm(chi,wc3e)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3e,wc4e)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!!        call exb_pack_y2zm(hh(:,:,:,iv,:),wc1o)\n!        call exb_pack_hh_y2zm(iv,hh,wc1o)\n!!$OMP barrier\n!        call exb_transpose_y2zm(wc1o,wc2o)\n!!$OMP barrier\n!        call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n!!$OMP barrier\n!        call exb_realspcal_y2zm(iv,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n!!$OMP barrier\n!        call exb_pack_zm2y(wwefo,wc3o)\n!!$OMP barrier\n!        call exb_transpose_zm2y(wc3o,wc4o)\n!!$OMP barrier\n!        call exb_unpack_zm2y(iv,wc4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2zm(psi,wc3o)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3o,wc4o)\n      call exb_pack_psi_y2zm(chi,wc3e)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3e,wc4e)\n      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n      do iv = 1, 2*nv+6\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1e,wc2e)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3e,wc4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxe,wwdye,wwefe)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefo,wc3o)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1o,wc2o)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3o,wc4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2e,wwdxe,wwdye)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefe,wc3e)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2zm(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wc1o)\n      deallocate(wc2o)\n      deallocate(wc3o)\n      deallocate(wc4o)\n      deallocate(wc1e)\n      deallocate(wc2e)\n      deallocate(wc3e)\n      deallocate(wc4e)\n      deallocate(wwdxo)\n      deallocate(wwdyo)\n      deallocate(wwefo)\n      deallocate(wwdxe)\n      deallocate(wwdye)\n      deallocate(wwefe)\n\n  END SUBROUTINE exb_NL_term_y2zm\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2zm ( psi, wc4 )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2zm)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n!\n!    integer :: mx, my, iz, im, izm, ibuff, iprocw\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(2) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!\n!         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n!          izm = (2*nz)*im + (iz + nz)\n!          ibuff = mod(izm, nbuff)\n!          iprocw = izm / nbuff\n!          do my = ist_y, iend_y\n!            do mx = -nx, nx\n!              wc4(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n!            end do\n!          end do\n!         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2zm ( psi, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2zm ( iv, hh, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(mx,my,ibuff,iprocw) = hh(mx,my,iz,iv,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_transpose_y2zm ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_y2zm ( wc4, wwdx, wwdy )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nx:nx) :: psi\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: my, ibuff, iprocw, global_my\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_yb)\n      do ibuff = 0, nbuff-1\n        do global_my = 0, global_ny\n\n         !%%% UNPACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          iprocw = global_my / (ny+1)\n          my = mod(global_my, ny+1)\n          psi(-nx:nx) = wc4(-nx:nx,my,ibuff,iprocw)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Backward x-FFT (kx,ky)->(ky,x) %%%\n          w1(0:nx) = ui * kx(0:nx) * psi(0:nx)\n          w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1)\n          call dfftw_execute_dft(plan_x_backward, w1, w2)\n          wwdx(global_my,0:2*nxw-1,ibuff) = w2(0:2*nxw-1)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Backward x-FFT (kx,ky)->(ky,x) %%%\n          w1(0:nx) = ui * gky(global_my) * psi(0:nx)\n          w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          w1(2*nxw-nx:2*nxw-1) = ui * gky(global_my) * psi(-nx:-1)\n          call dfftw_execute_dft(plan_x_backward, w1, w2)\n          wwdy(global_my,0:2*nxw-1,ibuff) = w2(0:2*nxw-1)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_backwardfft_y2zm ( wwdx, wwdy, dpdx, dpdy )\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwdx, wwdy\n    real(kind=DP), intent(out), &\n      dimension(0:2*nyw-1,0:2*nxw-1,0:nbuff-1) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    integer :: ix, ibuff\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_xb)\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n\n         !%%% Backward y-FFT (ky,x)->(y,x) %%%\n          w3(0:global_ny) = wwdx(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdx(:,ix,ibuff))\n          w3(0:global_ny) = wwdy(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdy(:,ix,ibuff))\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2zm ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:2*nxw-1,0:nbuff-1) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwdx, wwdy\n    complex(kind=DP), intent(out), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwef\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    real(kind=DP), dimension(0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: ix, iy, ibuff\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_xb)\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n\n         !%%% Backward y-FFT (ky,x)->(y,x) %%%\n          w3(0:global_ny) = wwdx(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdx)\n          w3(0:global_ny) = wwdy(0:global_ny,ix,ibuff)\n          w3(global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdy)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Poisson brackets in (y,x) %%%\n          do iy = 0, 2*nyw-1\n            pbxy(iy) = cef * ( & ! Normalization for 2D Forward FFT\n                       (dpdx(iy,ix,ibuff) - cs1 * vl(iv) * dadx(iy,ix,ibuff)) * dhdy(iy) &\n                     - (dpdy(iy,ix,ibuff) - cs1 * vl(iv) * dady(iy,ix,ibuff)) * dhdx(iy))\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% Forward y-FFT (y,x)->(ky,x) %%%\n          call dfftw_execute_dft_r2c(plan_y_forward, pbxy, w3)\n          wwef(0:global_ny,ix,ibuff) = w3(0:global_ny)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_zm2y ( wwef, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:global_ny,0:2*nxw-1,0:nbuff-1) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    complex(kind=DP), dimension(-nx:nx) :: ef\n    integer :: mx, my, ibuff, iprocw, global_my\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_yb)\n      do ibuff = 0, nbuff-1\n        do global_my = 0, global_ny\n\n         !%%% Forward x-FFT (ky,x)->(kx,ky) %%%\n          w2(0:2*nxw-1) = wwef(global_my,0:2*nxw-1,ibuff) ! FFTW may destroy input array!\n          call dfftw_execute_dft(plan_x_forward, w2, w1)\n          ef(0:nx) = w1(0:nx)\n          ef(-nx:-1) = w1(2*nxw-nx:2*nxw-1)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n         !%%% PACK: (kx,ky,(z*,m*)*)->(kx,ky*,z*,m*) %%%\n          iprocw = global_my / (ny+1)\n          my = mod(global_my, ny+1)\n          do mx = -nx, nx\n            wc4(mx,my,ibuff,iprocw) = ef(mx)\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_zm2y ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1440)\n                                         ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_zm2y ( iv, wc4, ef )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n    !complex(kind=DP), intent(inout), &\n    !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n    !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n    !      When the subroutine is called in a OpenMP parallel region, \n    !      the copied subarray may be treated as a thread-private variable.\n\n    integer :: iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1450)\n                                         ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% UNPACK: (kx,ky,(z*,m*)*)->(kx,ky*,z*,m*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          ef(:,:,iz,iv,im) = wc4(:,:,ibuff,iprocw)\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2zm ( dpdx, dpdy, dadx, dady )\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:2*nxw-1,0:nbuff-1) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, ibuff, iv\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      iv = 2*nv\n!$OMP parallel default(none)                               &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)        &\n!$OMP shared(iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,ibuff,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n        do ibuff = 0, nbuff-1\n          do ix = 0, 2*nxw-1\n            do iy = 0, 2*nyw-1\n              wv_nl = abs(dpdy(iy,ix,ibuff) - cs1 * vl(iv) * dady(iy,ix,ibuff))\n              if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n        do ibuff = 0, nbuff-1\n          do ix = 0, 2*nxw-1\n            do iy = 0, 2*nyw-1\n              wv_nl = abs(dpdx(iy,ix,ibuff) - cs1 * vl(iv) * dadx(iy,ix,ibuff))\n              if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_NL_term_y2x( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: &\n                                   wdx1o, wdy1o, wdx2o, wdy2o, wef3o, wef4o, &\n                                   wdx1e, wdy1e, wdx2e, wdy2e, wef3e, wef4e\n    integer :: iv, iprocw\n\n      allocate(dpdx(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(dpdy(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(dadx(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(dady(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm))\n      allocate(wdx1o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy1o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdx2o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy2o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef3o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef4o(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdx1e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy1e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdx2e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wdy2e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef3e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n      allocate(wef4e(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1))\n\n!$OMP parallel default(none)                      &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)   &\n!$OMP shared(wdx1o,wdy1o,wdx2o,wdy2o,wef3o,wef4o) &\n!$OMP shared(wdx1e,wdy1e,wdx2e,wdy2e,wef3e,wef4e) &\n!$OMP private(iv,iprocw)\n\n!$OMP workshare\n      ef(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3o(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3e(:,:,:,:,:) = (0._DP, 0._DP)\n      dpdx(:,:,:,:) = 0._DP\n      dpdy(:,:,:,:) = 0._DP\n      dadx(:,:,:,:) = 0._DP\n      dady(:,:,:,:) = 0._DP\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!!      call exb_pack_y2x(psi(-nx:nx,0:ny,-nz:nz-1,0:nm),wdx1o,wdy1o)\n!      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1o,wdx2o)\n!      call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!!$OMP barrier\n!!      call exb_pack_y2x(chi(-nx:nx,0:ny,-nz:nz-1,0:nm),wdx1e,wdy1e)\n!      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1e,wdx2e)\n!      call exb_transpose_y2x(wdy1e,wdy2e)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!!        call exb_pack_y2x(hh(:,:,:,iv,:),wdx1o,wdy1o)\n!        call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n!!$OMP barrier\n!        call exb_transpose_y2x(wdx1o,wdx2o)\n!        call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!        call exb_realspcal_y2x(iv,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n!!$OMP barrier\n!        call exb_transpose_x2y(wef3o,wef4o)\n!!$OMP barrier\n!        call exb_unpack_x2y(iv,wef4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1o,wdx2o)\n      call exb_transpose_y2x(wdy1o,wdy2o)\n      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1e,wdx2e)\n      call exb_transpose_y2x(wdy1e,wdy2e)\n      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!$OMP barrier\n      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n      do iv = 1, 2*nv+4\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1e,wdx2e)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1e,wdy2e)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3e,wef4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1o,wdx2o)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1o,wdy2o)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3o,wef4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1e,wdy1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2e,wdy2e,wef3e)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2x(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wdx1o)\n      deallocate(wdy1o)\n      deallocate(wdx2o)\n      deallocate(wdy2o)\n      deallocate(wef3o)\n      deallocate(wef4o)\n      deallocate(wdx1e)\n      deallocate(wdy1e)\n      deallocate(wdx2e)\n      deallocate(wdy2e)\n      deallocate(wef3e)\n      deallocate(wef4e)\n\n  END SUBROUTINE exb_NL_term_y2x\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2x ( psi, wwdx, wwdy )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2x)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n!    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(3) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!          do my = ist_y, iend_y\n!\n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * kx(0:nx) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * ky(my) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!          enddo\n!        enddo\n!      enddo\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2x ( psi, wwdx, wwdy )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_yzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * kx(0:nx) * psi(0:nx,my,iz,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1,my,iz,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * ky(my) * psi(0:nx,my,iz,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * psi(-nx:-1,my,iz,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n          enddo\n        enddo\n      enddo\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2x ( iv, hh, wwdx, wwdy )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_yzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * kx(0:nx) * hh(0:nx,my,iz,iv,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * hh(-nx:-1,my,iz,iv,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n            w1(0:nx) = ui * ky(my) * hh(0:nx,my,iz,iv,im)\n            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * hh(-nx:-1,my,iz,iv,im)\n            call dfftw_execute_dft(plan_x_backward, w1, w2)\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n              enddo\n            enddo\n           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  \n          enddo\n        enddo\n      enddo\n!$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_y2x ( wwin, wwout )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2x\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_backwardfft_y2x ( wwdx, wwdy, dpdx, dpdy )\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n    real(kind=DP), intent(inout), &\n      dimension(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    integer :: ix, my, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_xzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do ix = ist_xw, iend_xw\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdx(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdx(:,ix,iz,im))\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdy(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dpdy(:,ix,iz,im))\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2x ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n    complex(kind=DP), intent(inout), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwef\n\n    complex(kind=DP), dimension(0:nyw) :: w3\n    real(kind=DP), dimension(0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: my, ix, iy, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_xzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do ix = ist_xw, iend_xw\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdx(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdx)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% UNPACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                w3(my) = wwdy(my-ist_y_g_rank,ix,iz,im,irank)\n              end do\n            end do\n            w3(global_ny+1:nyw) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Backward y-FFT (ky,x)->(y,x) %%%\n            call dfftw_execute_dft_c2r(plan_y_backward, w3, dhdy)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% Poisson brackets in (y,x) %%%\n            do iy = 0, 2*nyw-1\n              pbxy(iy) = cef * ( &! Normalization for 2D Forward FFT\n                         (dpdx(iy,ix,iz,im) - cs1 * vl(iv) * dadx(iy,ix,iz,im)) * dhdy(iy) &\n                       - (dpdy(iy,ix,iz,im) - cs1 * vl(iv) * dady(iy,ix,iz,im)) * dhdx(iy))\n            end do\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          !%%% Forward y-FFT (y,x)->(ky,x) %%%\n            call dfftw_execute_dft_r2c(plan_y_forward, pbxy, w3)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% PACK: (ky,x*,z*,m*)->(x,ky*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_y_g_rank  = (ny+1)*irank\n              iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n              do my = ist_y_g_rank, iend_y_g_rank\n                wwef(my-ist_y_g_rank,ix,iz,im,irank) = w3(my)\n              end do\n            end do\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_x2y ( wwin, wwout )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1440)\n                                        ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                        ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_x2y ( iv, wwef, ef )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n   !complex(kind=DP), intent(inout), &\n   !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n   !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n   !      When the subroutine is called in a OpenMP parallel region, \n   !      the copied subarray may be treated as a thread-private variable.\n\n    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n!$OMP master\n                                           call clock_sta(1450)\n                                        ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!$OMP do collapse(3) schedule(dynamic,nchunk_yzm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n\n          !%%% UNPACK: (ky,x*,z*,m*)->(x,ky*,z*,m*) %%%\n            do irank = 0, nprocw-1\n              ist_xw_g_rank  = (nxw_size+1)*irank\n              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n              do ix = ist_xw_g_rank, iend_xw_g_rank\n                w2(ix) = wwef(my,ix-ist_xw_g_rank,iz,im,irank)\n              enddo\n            enddo\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          !%%% Forward x-FFT (x,ky)->(kx,ky) %%%\n            call dfftw_execute_dft(plan_x_forward, w2, w1)\n            ef(0:nx,my,iz,iv,im) = w1(0:nx)\n            ef(-nx:-1,my,iz,iv,im) = w1(2*nxw-nx:2*nxw-1)\n          !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n          end do\n        end do\n      end do\n!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2x ( dpdx, dpdy, dadx, dady )\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(0:2*nyw-1,0:nxw_size,-nz:nz-1,0:nm) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, iz, iv, im\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      im = 0\n        iv = 2*nv\n!$OMP parallel default(none)                                  &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)           &\n!$OMP shared(im,iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,iz,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n          do iz = -nz, nz-1\n            do ix = ist_xw, iend_xw\n              do iy = 0, 2*nyw-1\n                wv_nl = abs(dpdy(iy,ix,iz,im) - cs1 * vl(iv) * dady(iy,ix,iz,im))\n                if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n          do iz = -nz, nz-1\n            do ix = ist_xw, iend_xw\n              do iy = 0, 2*nyw-1\n                wv_nl = abs(dpdx(iy,ix,iz,im) - cs1 * vl(iv) * dadx(iy,ix,iz,im))\n                if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2x\n\n\nEND MODULE GKV_exb\n", "MODULE GKV_fileio\n!-------------------------------------------------------------------------------\n!\n!    File I/O interface for NetCDF binary output\n!\n!    Update history of gkvp_fileio_netcdf.f90\n!    --------------\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - NetCDF binary I/O interface by Fujitsu.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n\n  use netcdf\n\n  implicit  none\n\n  private\n\n  public    fileio_open_icnt, fileio_close_icnt, &\n            fileio_open_cnt,  fileio_close_cnt, &\n            fileio_open_fxv,  fileio_close_fxv, &\n            fileio_open_phi,  fileio_close_phi, &\n            fileio_open_Al,   fileio_close_Al, &\n            fileio_open_mom,  fileio_close_mom, &\n            fileio_open_trn,  fileio_close_trn, &\n            fileio_open_tri,  fileio_close_tri, &\n            \n            fileio_read_cnt,  fileio_write_cnt, &\n            fileio_write_fxv, fileio_write_phi, &\n            fileio_write_Al,  fileio_write_mom, &\n            fileio_write_trn, fileio_write_tri\n\n  integer :: icnt_nc, &\n             ocnt_nc, &\n             ofxv_nc, &\n             ophi_nc, &\n             oAl_nc, &\n             omom_nc, &\n             otrn_nc, &\n             otri_nc\n\n  integer :: phi_comm, &\n             Al_comm, &\n             mom_comm, &\n             trn_comm, &\n             tri_comm\n\nCONTAINS\n\n!--------------------------------------\n  SUBROUTINE fileio_open_icnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    integer :: ierr_nf90\n\n    character(3)   :: cold\n\n    write( cold,  fmt=\"(i3.3)\" ) inum-1\n\n    ierr_nf90=nf90_open( path=path//\"cnt.\"//cold//\".nc\",  &\n                         mode=NF90_NOWRITE, ncid=icnt_nc, &\n                         comm=MPI_COMM_WORLD, info=MPI_INFO_NULL )\n    call check_nf90err( ierr_nf90, \"nf90_open\" )\n\n  END SUBROUTINE fileio_open_icnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_icnt\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( inum > 1 ) then\n      ierr_nf90=nf90_close( icnt_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_icnt\n\n \n!--------------------------------------\n  SUBROUTINE fileio_open_cnt ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    integer :: ierr_nf90\n\n    character(3)   :: cnew\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    ierr_nf90=nf90_create( path=path//\"cnt.\"//cnew//\".nc\", &\n                           cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                           ncid=ocnt_nc, &\n                           comm=MPI_COMM_WORLD, info=MPI_INFO_NULL ) \n    call check_nf90err( ierr_nf90, \"nf90_create\" )\n\n  END SUBROUTINE fileio_open_cnt\n\n!--------------------------------------\n  SUBROUTINE fileio_close_cnt\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    ierr_nf90=nf90_close( ocnt_nc )\n    call check_nf90err( ierr_nf90, \"nf90_close\" )\n\n  END SUBROUTINE fileio_close_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_fxv ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    integer :: ierr_nf90\n\n    character(3)   :: cnew\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    ierr_nf90=nf90_create( path=path//\"fxv.\"//cnew//\".nc\", &\n                           cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                           ncid=ofxv_nc, &\n                           comm=MPI_COMM_WORLD, info=MPI_INFO_NULL ) \n    call check_nf90err( ierr_nf90, \"nf90_create\" )\n\n  END SUBROUTINE fileio_open_fxv\n\n!--------------------------------------\n  SUBROUTINE fileio_close_fxv\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    ierr_nf90=nf90_close( ofxv_nc )\n    call check_nf90err( ierr_nf90, \"nf90_close\" )\n\n  END SUBROUTINE fileio_close_fxv\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_phi ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: phi_tf(1)\n    integer, allocatable :: rank_list(:), phi_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(phi_tf_list(nproc))\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      phi_tf(1) = 1\n    else\n      phi_tf(1) = 0\n    end if\n\n    call MPI_Allgather( phi_tf, 1, MPI_INTEGER, phi_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( phi_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, phi_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"phi.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=ophi_nc, &\n                             comm=phi_comm, info=MPI_INFO_NULL ) \n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(phi_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_phi\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_close( ophi_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_Al ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: Al_tf(1)\n    integer, allocatable :: rank_list(:), Al_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(Al_tf_list(nproc))\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      Al_tf(1) = 1\n    else\n      Al_tf(1) = 0\n    end if\n\n    call MPI_Allgather( Al_tf, 1, MPI_INTEGER, Al_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( Al_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, Al_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"Al.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=oAl_nc, &\n                             comm=Al_comm, info=MPI_INFO_NULL )\n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(Al_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_Al\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( ranks == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_close( oAl_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_Al\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_mom ( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: mom_tf(1)\n    integer, allocatable :: rank_list(:), mom_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(mom_tf_list(nproc))\n    rank_list = 0\n    mom_tf_list = 0\n\n    if ( vel_rank == 0 ) then\n      mom_tf(1) = 1\n    else\n      mom_tf(1) = 0\n    end if\n\n    call MPI_Allgather( mom_tf, 1, MPI_INTEGER, mom_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( mom_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, mom_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"mom.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=omom_nc, &\n                             comm=mom_comm, info=MPI_INFO_NULL )\n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(mom_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_mom\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( vel_rank == 0 ) then\n      ierr_nf90=nf90_close( omom_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_mom\n\n\n!--------------------------------------\n  SUBROUTINE fileio_open_trn( path )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: trn_tf(1)\n    integer, allocatable :: rank_list(:), trn_tf_list(:)\n\n    allocate(rank_list(nproc))\n    allocate(trn_tf_list(nproc))\n\n    if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      trn_tf(1) = 1\n    else\n      trn_tf(1) = 0\n    end if\n\n    call MPI_Allgather( trn_tf, 1, MPI_INTEGER, trn_tf_list, 1, MPI_INTEGER, &\n                        MPI_COMM_WORLD, ierr_mpi)\n\n    counter = 1\n    do i = 1, nproc\n      if ( trn_tf_list(i) == 1 ) then\n        rank_list(counter) = i-1\n        counter = counter+1\n      end if\n    end do\n\n    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                         ierr_mpi )\n    call MPI_Comm_create( MPI_COMM_WORLD, new_group, trn_comm, ierr_mpi )\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_create( path=path//\"trn.\"//cnew//\".nc\", &\n                             cmode=IOR(NF90_NETCDF4,NF90_MPIIO), &\n                             ncid=otrn_nc, &\n                             comm=trn_comm, info=MPI_INFO_NULL ) \n      call check_nf90err( ierr_nf90, \"nf90_create\" )\n    end if\n\n    deallocate(trn_tf_list, rank_list)\n\n  END SUBROUTINE fileio_open_trn\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_trn\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      ierr_nf90=nf90_close( otrn_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_trn\n\n\n!!--------------------------------------\n!  SUBROUTINE fileio_open_tri ( path, cmx, cmy, replace )\n!!--------------------------------------\n!\n!    character(*), intent(in) :: path\n!    character(*), intent(in) :: cmx, cmy\n!    logical, intent(in) :: replace\n!\n!    character(3)   :: cnew\n!\n!    integer :: ierr_nf90\n!    integer :: counter, i\n!    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n!    integer :: tri_tf(1)\n!    integer, allocatable :: rank_list(:), tri_tf_list(:)\n!\n!    allocate(rank_list(nproc))\n!    allocate(tri_tf_list(nproc))\n!\n!    if ( rank == 0 ) then\n!      tri_tf(1) = 1\n!    else\n!      tri_tf(1) = 0\n!    end if\n!\n!    call MPI_Allgather( tri_tf, 1, MPI_INTEGER, tri_tf_list, 1, MPI_INTEGER, &\n!                        MPI_COMM_WORLD, ierr_mpi)\n!\n!    counter = 1\n!    do i = 1, nproc\n!      if ( tri_tf_list(i) == 1 ) then\n!        rank_list(counter) = i-1\n!        counter = counter+1\n!      end if\n!    end do\n!\n!    call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n!    call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n!                         ierr_mpi )\n!    call MPI_Comm_create( MPI_COMM_WORLD, new_group, tri_comm, ierr_mpi )\n!\n!    write( cnew,  fmt=\"(i3.3)\" ) inum\n!\n!    if ( rank == 0 ) then\n!      if ( replace ) then\n!        ierr_nf90=nf90_create( &\n!                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n!                cmode=IOR(NF90_NETCDF4,NF90_MPIIO), ncid=otri_nc, &\n!                comm=tri_comm, info=MPI_INFO_NULL ) \n!        call check_nf90err( ierr_nf90, \"nf90_create\" )\n!      else\n!        ierr_nf90=nf90_open( &\n!                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n!                mode=NF90_WRITE, ncid=otri_nc, &\n!                comm=tri_comm, info=MPI_INFO_NULL ) \n!        call check_nf90err( ierr_nf90, \"nf90_open\" )\n!      end if\n!    end if\n!\n!    deallocate(tri_tf_list, rank_list)\n!\n!  END SUBROUTINE fileio_open_tri\n\n!--------------------------------------\n  SUBROUTINE fileio_open_tri ( path, cmx, cmy, replace )\n!--------------------------------------\n\n    character(*), intent(in) :: path\n    character(*), intent(in) :: cmx, cmy\n    logical, intent(in) :: replace\n\n    character(3)   :: cnew\n\n    integer :: ierr_nf90\n    integer :: counter, i\n    integer :: MPI_GROUP_WORLD, new_group, new_comm, ierr_mpi\n    integer :: tri_tf(1)\n    integer, allocatable :: rank_list(:), tri_tf_list(:)\n\n    write( cnew,  fmt=\"(i3.3)\" ) inum\n\n    if ( replace ) then ! Initial creation of NetCDF files\n\n      allocate(rank_list(nproc))\n      allocate(tri_tf_list(nproc))\n\n      if ( rank == 0 ) then\n        tri_tf(1) = 1\n      else\n        tri_tf(1) = 0\n      end if\n      call MPI_Allgather( tri_tf, 1, MPI_INTEGER, tri_tf_list, 1, MPI_INTEGER, &\n                          MPI_COMM_WORLD, ierr_mpi)\n      counter = 1\n      do i = 1, nproc\n        if ( tri_tf_list(i) == 1 ) then\n          rank_list(counter) = i-1\n          counter = counter+1\n        end if\n      end do\n      call MPI_Comm_group( MPI_COMM_WORLD, MPI_GROUP_WORLD, ierr_mpi )\n      call MPI_Group_incl( MPI_GROUP_WORLD, counter-1, rank_list, new_group, &\n                           ierr_mpi )\n      call MPI_Comm_create( MPI_COMM_WORLD, new_group, tri_comm, ierr_mpi )\n\n      if ( rank == 0 ) then\n        ierr_nf90=nf90_create( &\n                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n                cmode=IOR(NF90_NETCDF4,NF90_MPIIO), ncid=otri_nc, &\n                comm=tri_comm, info=MPI_INFO_NULL )\n        call check_nf90err( ierr_nf90, \"nf90_create\" )\n      end if\n\n      deallocate(tri_tf_list, rank_list)\n\n    else ! For appending data to NetCDF files\n\n      if ( rank == 0 ) then\n        ierr_nf90=nf90_open( &\n                path=path//\"mx\"//cmx//\"my\"//cmy//\".tri.\"//cnew//\".nc\", &\n                mode=NF90_WRITE, ncid=otri_nc, &\n                comm=tri_comm, info=MPI_INFO_NULL )\n        call check_nf90err( ierr_nf90, \"nf90_open\" )\n      end if\n\n    end if\n\n  END SUBROUTINE fileio_open_tri\n\n\n!--------------------------------------\n  SUBROUTINE fileio_close_tri\n!--------------------------------------\n\n    integer :: ierr_nf90\n\n    if ( rank == 0 ) then\n      ierr_nf90=nf90_close( otri_nc )\n      call check_nf90err( ierr_nf90, \"nf90_close\" )\n    end if\n\n  END SUBROUTINE fileio_close_tri\n\n\n\n!--------------------------------------\n  SUBROUTINE fileio_read_cnt ( wf, time, istatus )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(out) :: time\n    integer, optional, intent(out) :: istatus\n\n    integer :: input_status\n    integer :: ierr_nf90\n    integer :: varid_tt, varid_recnt, varid_imcnt\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_cnt(1:7), count_cnt(1:7)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nv(1), count_nv(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: t_count\n    real(kind=DP), dimension(1) :: t_value\n    real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: recnt\n    real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: imcnt\n\n    integer :: ndims, nvars, ngatts, unlimdimid\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( icnt_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    ierr_nf90=nf90_inq_varid(icnt_nc, \"t\", varid_tt)\n    ierr_nf90=nf90_inq_varid(icnt_nc, \"recnt\", varid_recnt)\n    ierr_nf90=nf90_inq_varid(icnt_nc, \"imcnt\", varid_imcnt)\n    call check_nf90err(ierr_nf90, \"nf90_inq_varid\")\n\n    ierr_nf90=nf90_inquire_dimension(icnt_nc, unlimdimid, len=t_count)\n    call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n    count_nv=nv*2\n    start_nv=count_nv*rankv+1\n    count_nm=nm+1\n    start_nm=count_nm*rankm+1\n\n    count_time(:) = 1\n    start_time(:) = t_count\n    ierr_nf90=nf90_get_var( ncid=icnt_nc, varid=varid_tt, values=t_value, &\n                            start=start_time, count=count_time )\n    time = t_value(1)\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_cnt(:) = int((/ 2*nx+1,count_ny,count_nz,count_nv,count_nm,1,1 /), kind=4)\n    start_cnt(:) = (/ 1,start_ny,start_nz,start_nv,start_nm,1+ranks,t_count /)\n    ierr_nf90=nf90_get_var(icnt_nc, varid_recnt, &\n                           values=recnt(:,ny_st:ny_end,:,:,:), &\n                           start=start_cnt, count=count_cnt )\n    ierr_nf90=nf90_get_var(icnt_nc, varid_imcnt, &\n                           values=imcnt(:,ny_st:ny_end,:,:,:), &\n                           start=start_cnt, count=count_cnt )\n    call check_nf90err(ierr_nf90, \"nf90_get_var\")\n\n    wf = cmplx(recnt,imcnt)\n\n    istatus = ierr_nf90\n\n  END SUBROUTINE fileio_read_cnt\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_cnt ( wf, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: wf\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:7), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_vl, varid_mu, varid_is, &\n               varid_tt, varid_recnt, varid_imcnt\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_cnt(1:7), count_cnt(1:7)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nv(1), count_nv(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: is\n    integer :: ny_st, ny_end\n\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: ocnt_t_count\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( ocnt_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"vl\", &\n                              len=int(2*global_nv,kind=4), dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"mu\", &\n                              len=int(global_nm+1,kind=4), dimid=dimids(5) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(6) )\n      ierr_nf90=nf90_def_dim( ncid=ocnt_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(7) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"vl\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_vl )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"mu\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(5),   varid=varid_mu )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(6),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(7),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"recnt\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_recnt )\n      ierr_nf90=nf90_def_var( ncid=ocnt_nc, name=\"imcnt\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_imcnt )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=ocnt_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      ocnt_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( ocnt_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( ocnt_nc, \"recnt\", varid_recnt )\n      ierr_nf90=nf90_inq_varid( ocnt_nc, \"imcnt\", varid_imcnt )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(ocnt_nc, unlimdimid, len=ocnt_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_vl, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_mu, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_recnt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ocnt_nc, varid=varid_imcnt, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n    count_nv=nv*2\n    start_nv=count_nv*rankv+1\n    count_nm=nm+1\n    start_nm=count_nm*rankm+1\n\n    if ( ndims == 0 ) then\n      != Write variables: static coordinates x and y\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_vl, &\n                              values=vl(1:2*nv), &\n                              start=start_nv, count=count_nv )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_mu, &\n                              values=mu(0:nm), &\n                              start=start_nm, count=count_nm )\n      ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    ocnt_t_count = ocnt_t_count+1\n    count_time(:) = 1\n    start_time(:) = ocnt_t_count\n    ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_cnt(:) = int((/ 2*nx+1,count_ny,count_nz,count_nv,count_nm,1,1 /), kind=4)\n    start_cnt(:) = (/ 1,start_ny,start_nz,start_nv,start_nm,1+ranks,ocnt_t_count /)\n    ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_recnt, &\n                            values=dble(wf(:,ny_st:ny_end,:,:,:)), &\n                            start=start_cnt, count=count_cnt )\n    ierr_nf90=nf90_put_var( ncid=ocnt_nc, varid=varid_imcnt, &\n                            values=aimag(wf(:,ny_st:ny_end,:,:,:)), &\n                            start=start_cnt, count=count_cnt )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_cnt\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_fxv ( fout, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,1:2*nv,0:nm) :: fout\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:7), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_vl, varid_mu, varid_is, &\n               varid_tt, varid_refxv, varid_imfxv\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_fxv(1:7), count_fxv(1:7)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nv(1), count_nv(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: ofxv_t_count\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( ofxv_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"zz\", &\n                              len=int(nprocz,kind=4),      dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"vl\", &\n                              len=int(2*global_nv,kind=4), dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"mu\", &\n                              len=int(global_nm+1,kind=4), dimid=dimids(5) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(6) )\n      ierr_nf90=nf90_def_dim( ncid=ofxv_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(7) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"vl\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_vl )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"mu\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(5),   varid=varid_mu )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(6),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(7),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"refxv\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_refxv )\n      ierr_nf90=nf90_def_var( ncid=ofxv_nc, name=\"imfxv\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:7), varid=varid_imfxv )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=ofxv_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      ofxv_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( ofxv_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( ofxv_nc, \"refxv\", varid_refxv )\n      ierr_nf90=nf90_inq_varid( ofxv_nc, \"imfxv\", varid_imfxv )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(ofxv_nc, unlimdimid, len=ofxv_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_vl, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_mu, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_refxv, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ofxv_nc, varid=varid_imfxv, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=1\n    start_nz=rankz+1\n    count_nv=nv*2\n    start_nv=count_nv*rankv+1\n    count_nm=nm+1\n    start_nm=count_nm*rankm+1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1:2*nz), &\n                              start=start_nz, count=count_nz )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_vl, &\n                              values=vl(1:2*nv), &\n                              start=start_nv, count=count_nv )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_mu, &\n                              values=mu(0:nm), &\n                              start=start_nm, count=count_nm )\n      ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    ofxv_t_count = ofxv_t_count+1\n    count_time(:) = 1\n    start_time(:) = ofxv_t_count\n    ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_fxv(:) = int((/ 2*nx+1,count_ny,count_nz,count_nv,count_nm,1,1 /), kind=4)\n    start_fxv(:) = (/ 1,start_ny,start_nz,start_nv,start_nm,1+ranks,ofxv_t_count /)\n    ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_refxv, &\n                            values=dble(fout(:,ny_st:ny_end,:,:)), &\n                            start=start_fxv, count=count_fxv )\n    ierr_nf90=nf90_put_var( ncid=ofxv_nc, varid=varid_imfxv, &\n                            values=aimag(fout(:,ny_st:ny_end,:,:)), &\n                            start=start_fxv, count=count_fxv )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_fxv\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_phi ( phi, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: phi\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:4), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_is, &\n               varid_tt, varid_rephi, varid_imphi\n    integer(kind=4) :: start_time(1), count_time(1), start_phi(1:4), count_phi(1:4)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: ophi_t_count\n\n    != Write conditions check\n    if ( (ranks /= 0) .OR. (vel_rank /= 0) ) then\n      return\n    end if\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( ophi_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=ophi_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(4) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"rephi\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_rephi )\n      ierr_nf90=nf90_def_var( ncid=ophi_nc, name=\"imphi\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_imphi )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=ophi_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      ophi_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( ophi_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( ophi_nc, \"rephi\", varid_rephi )\n      ierr_nf90=nf90_inq_varid( ophi_nc, \"imphi\", varid_imphi )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(ophi_nc, unlimdimid, len=ophi_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_rephi, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=ophi_nc, varid=varid_imphi, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    ophi_t_count = ophi_t_count+1\n    count_time(:) = 1\n    start_time(:) = ophi_t_count\n    ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_phi(:) = int((/ 2*nx+1,count_ny,count_nz,1 /), kind=4)\n    start_phi(:) = (/ 1,start_ny,start_nz,ophi_t_count /)\n    ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_rephi, &\n                            values=dble(phi(:,ny_st:ny_end,:)), &\n                            start=start_phi, count=count_phi )\n    ierr_nf90=nf90_put_var( ncid=ophi_nc, varid=varid_imphi, &\n                            values=aimag(phi(:,ny_st:ny_end,:)), &\n                            start=start_phi, count=count_phi )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_phi\n\n\n!--------------------------------------\n  SUBROUTINE fileio_write_Al ( Al, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) :: Al\n    real(kind=DP), intent(in) :: time\n\n    integer :: dimids(1:4), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_is, &\n               varid_tt, varid_reAl, varid_imAl\n    integer(kind=4) :: start_time(1), count_time(1), &\n                       start_Al(1:4), count_Al(1:4)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: oAl_t_count\n\n    != Write conditions check\n    if ( (ranks /= 0) .OR. (vel_rank /= 0) ) then\n      return\n    end if\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( oAl_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=oAl_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(4) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"kx\",   xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"ky\",   xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"zz\",   xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"t\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(4),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"reAl\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_reAl )\n      ierr_nf90=nf90_def_var( ncid=oAl_nc, name=\"imAl\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:4), varid=varid_imAl )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=oAl_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      oAl_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( oAl_nc, \"t\",    varid_tt )\n      ierr_nf90=nf90_inq_varid( oAl_nc, \"reAl\", varid_reAl )\n      ierr_nf90=nf90_inq_varid( oAl_nc, \"imAl\", varid_imAl )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(oAl_nc, unlimdimid, len=oAl_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_reAl, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=oAl_nc, varid=varid_imAl, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    oAl_t_count = oAl_t_count+1\n    count_time(:) = 1\n    start_time(:) = oAl_t_count\n    ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_Al(:) = int((/ 2*nx+1,count_ny,count_nz,1 /), kind=4)\n    start_Al(:) = (/ 1,start_ny,start_nz,oAl_t_count /)\n    ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_reAl, &\n                            values=dble(Al(:,ny_st:ny_end,:)), &\n                            start=start_Al, count=count_Al )\n    ierr_nf90=nf90_put_var( ncid=oAl_nc, varid=varid_imAl, &\n                            values=aimag(Al(:,ny_st:ny_end,:)), &\n                            start=start_Al, count=count_Al )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_Al\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_mom ( dens, upara, ppara, pperp, qlpara, qlperp, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny,-nz:nz-1) ::  dens, upara, ppara, pperp, qlpara, qlperp\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: nmom = 6   ! Number of output moments\n\n    integer :: dimids(1:6), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_zz, varid_imom, varid_is, &\n               varid_tt, varid_remom, varid_immom\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_mom(1:6), count_mom(1:6)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nz(1), count_nz(1)\n    integer :: start_nm(1), count_nm(1)\n    integer :: imom, is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: omom_t_count\n\n    != Write conditions check\n    if ( vel_rank /= 0 ) return\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( omom_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"zz\", &\n                              len=int(2*global_nz,kind=4), dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"imom\", &\n                              len=int(nmom,kind=4),        dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(5) )\n      ierr_nf90=nf90_def_dim( ncid=omom_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(6) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"zz\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(3),   varid=varid_zz )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"imom\",  xtype=NF90_INT, &\n                              dimids=dimids(4),   varid=varid_imom )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(5),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(6),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"remom\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:6), varid=varid_remom )\n      ierr_nf90=nf90_def_var( ncid=omom_nc, name=\"immom\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:6), varid=varid_immom )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=omom_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      omom_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( omom_nc, \"t\",     varid_tt )\n      ierr_nf90=nf90_inq_varid( omom_nc, \"remom\", varid_remom )\n      ierr_nf90=nf90_inq_varid( omom_nc, \"immom\", varid_immom )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(omom_nc, unlimdimid, len=omom_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_zz, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_imom, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_remom, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=omom_nc, varid=varid_immom, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nz=nz*2\n    start_nz=count_nz*rankz+1\n    count_nm=1\n    start_nm=1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_zz, &\n                              values=zz(-nz:nz-1), &\n                              start=start_nz, count=count_nz )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_imom, &\n                              values=(/ (imom, imom=0,nmom-1) /) )\n      ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n    omom_t_count = omom_t_count+1\n    count_time(:) = 1\n    start_time(:) = omom_t_count\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_mom(:) = int((/ 2*nx+1,count_ny,count_nz,count_nm,1,1 /), kind=4)\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(dens(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(dens(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=2\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(upara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(upara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=3\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(ppara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(ppara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=4\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(pperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(pperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=5\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(qlpara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(qlpara(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    start_nm=6\n    start_mom(:) = (/ 1,start_ny,start_nz,start_nm,1+ranks,omom_t_count /)\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_remom, &\n                            values=dble(qlperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    ierr_nf90=nf90_put_var( ncid=omom_nc, varid=varid_immom, &\n                            values=aimag(qlperp(:,ny_st:ny_end,:)), &\n                            start=start_mom, count=count_mom )\n    call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n\n  END SUBROUTINE fileio_write_mom\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_trn ( entrpy, fenegy, menegy, peint, pmint, &\n                                neint, nmint, dcd, pflux_es, pflux_em, &\n                                eflux_es, eflux_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,0:ny) :: entrpy, fenegy, menegy, peint, &\n                                   pmint, neint, nmint, dcd, &\n                                   pflux_es, pflux_em, eflux_es, eflux_em\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: ntrn = 12  ! Number of output total transfer diagnostics\n\n    integer :: dimids(1:5), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_itrn, varid_is, varid_tt, varid_trn\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_trn(1:5), count_trn(1:5)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nt(1), count_nt(1)\n    integer :: itrn, is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: otrn_t_count\n\n    != Write conditions check\n    if ( (zsp_rank /= 0) .OR. (vel_rank /= 0) ) then\n      return\n    end if\n\n    != Information about an open netCDF dataset\n    ierr_nf90=nf90_inquire( otrn_nc, ndims, nvars, ngatts, unlimdimid )\n    call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n    if ( ndims == 0 ) then\n      != Define dimensions in file\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"kx\", &\n                              len=int(2*nx+1,kind=4),      dimid=dimids(1) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"ky\", &\n                              len=int(global_ny+1,kind=4), dimid=dimids(2) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"itrn\", &\n                              len=int(ntrn,kind=4),        dimid=dimids(3) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"is\", &\n                              len=int(ns,kind=4),          dimid=dimids(4) )\n      ierr_nf90=nf90_def_dim( ncid=otrn_nc, name=\"t\",  &\n                              len=NF90_UNLIMITED,          dimid=dimids(5) )\n      call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n      != Define variables in file\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"kx\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(1),   varid=varid_kx )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"ky\",    xtype=NF90_DOUBLE, &\n                              dimids=dimids(2),   varid=varid_ky )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"itrn\",  xtype=NF90_INT, &\n                              dimids=dimids(3),   varid=varid_itrn )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"is\",    xtype=NF90_INT, &\n                              dimids=dimids(4),   varid=varid_is )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"t\",     xtype=NF90_DOUBLE, &\n                              dimids=dimids(5),   varid=varid_tt )\n      ierr_nf90=nf90_def_var( ncid=otrn_nc, name=\"trn\", xtype=NF90_DOUBLE, &\n                              dimids=dimids(1:5), varid=varid_trn )\n      call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n      != End of definition of file\n      ierr_nf90=nf90_enddef( ncid=otrn_nc )\n      call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n      otrn_t_count = 0\n    else\n      ierr_nf90=nf90_inq_varid( otrn_nc, \"t\",   varid_tt )\n      ierr_nf90=nf90_inq_varid( otrn_nc, \"trn\", varid_trn )\n      call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n      ierr_nf90=nf90_inquire_dimension(otrn_nc, unlimdimid, len=otrn_t_count)\n      call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n    end if\n\n    != Parallel data access type\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_kx, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_ky, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_itrn, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_is, &\n                                   access=NF90_INDEPENDENT )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_tt, &\n                                   access=NF90_COLLECTIVE )\n    ierr_nf90=nf90_var_par_access( ncid=otrn_nc, varid=varid_trn, &\n                                   access=NF90_COLLECTIVE )\n    call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n    count_ny=nsize_y\n    start_ny=ist_y_g+1\n    count_nt=1\n    start_nt=1\n\n    != Write variables: static coordinates x and y\n    if ( ndims == 0 ) then\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_kx, &\n                              values=kx(-nx:nx) )\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_ky, &\n                              values=ky(0:iend_y), &\n                              start=start_ny, count=count_ny )\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_itrn, &\n                              values=(/ (itrn, itrn=0,ntrn-1) /) )\n      ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_is, &\n                              values=(/ (is, is=0,ns-1) /) )\n      call check_nf90err( ierr_nf90, \"nf90_putvar(kx,ky,itrn,is)\" )\n    end if\n\n    otrn_t_count = otrn_t_count + 1\n    count_time(:) = 1\n    start_time(:) = otrn_t_count\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_tt, values=(/time/), &\n                            start=start_time, count=count_time )\n    call check_nf90err( ierr_nf90, \"nf90_putvar(time)\" )\n\n    ny_st = 0\n    ny_end = count_ny(1)-1\n    count_trn(:) = int((/ 2*nx+1,count_ny,count_nt,1,1 /), kind=4)\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=entrpy(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=2\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=fenegy(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=3\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=menegy(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=4\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=peint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=5\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=pmint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=6\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=neint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=7\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=nmint(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=8\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=dcd(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=9\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=pflux_es(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=10\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=pflux_em(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=11\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=eflux_es(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    start_nt=12\n    start_trn(:) = (/ 1,start_ny,start_nt,1+ranks,otrn_t_count /)\n    ierr_nf90=nf90_put_var( ncid=otrn_nc, varid=varid_trn, &\n                            values=eflux_em(:,ny_st:ny_end), &\n                            start=start_trn, count=count_trn )\n    call check_nf90err( ierr_nf90, \"nf90_putvar(trn)\" )\n\n  END SUBROUTINE fileio_write_trn\n\n\n!--------------------------------------\n  ", "SUBROUTINE fileio_write_tri ( jkpq_es, jpqk_es, jqkp_es, &\n                                jkpq_em, jpqk_em, jqkp_em, time )\n!--------------------------------------\n\n    real(kind=DP), intent(in), &\n         dimension(-nx:nx,-global_ny:global_ny) :: jkpq_es, jpqk_es, jqkp_es, &\n         jkpq_em, jpqk_em, jqkp_em\n    real(kind=DP), intent(in) :: time\n\n    integer, parameter :: ntri = 6  ! Number of output triad transfer diagnostics\n\n    integer :: dimids(1:5), ierr_nf90\n    integer :: varid_kx, varid_ky, varid_itri, varid_is, varid_tt, varid_tri\n    integer(kind=4) :: start_time(1),  count_time(1), &\n                       start_tri(1:5), count_tri(1:5)\n    integer :: start_ny(1), count_ny(1)\n    integer :: start_nt(1), count_nt(1)\n    integer :: itri, is\n    integer :: ny_st, ny_end\n    integer :: ndims, nvars, ngatts, unlimdimid\n    integer :: otri_t_count\n\n    real(kind=DP), dimension(0:global_ny)            :: gky\n    integer :: my\n\n    character(256)   :: env_string\n\n    integer       :: n_tht, m_j\n    real(kind=DP) :: kymin, del_c\n\n    namelist /nperi/ n_tht, kymin, m_j, del_c\n\n    if ( rank == 0 ) then\n     != Information about an open netCDF dataset\n      ierr_nf90=nf90_inquire( otri_nc, ndims, nvars, ngatts, unlimdimid )\n      call check_nf90err( ierr_nf90, \"nf90_inquire\" )\n\n      if ( ndims == 0 ) then\n       != Define dimensions in file\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"kx\", &\n                                len=int(2*nx+1,kind=4),        dimid=dimids(1) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"ky\", &\n                                len=int(2*global_ny+1,kind=4), dimid=dimids(2) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"itri\", &\n                                len=int(ntri,kind=4),          dimid=dimids(3) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"is\", &\n                                len=int(ns,kind=4),            dimid=dimids(4) )\n        ierr_nf90=nf90_def_dim( ncid=otri_nc, name=\"t\",  &\n                                len=NF90_UNLIMITED,            dimid=dimids(5) )\n        call check_nf90err( ierr_nf90, \"nf90_def_dim\" )\n\n       != Define variables in file\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"kx\",   xtype=NF90_DOUBLE, &\n                                dimids=dimids(1),   varid=varid_kx )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"ky\",   xtype=NF90_DOUBLE, &\n                                dimids=dimids(2),   varid=varid_ky )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"itri\", xtype=NF90_INT, &\n                                dimids=dimids(3),   varid=varid_itri )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"is\",   xtype=NF90_INT, &\n                                dimids=dimids(4),   varid=varid_is )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"t\",    xtype=NF90_DOUBLE, &\n                                dimids=dimids(5),   varid=varid_tt )\n        ierr_nf90=nf90_def_var( ncid=otri_nc, name=\"tri\",  xtype=NF90_DOUBLE, &\n                                dimids=dimids(1:5), varid=varid_tri )\n        call check_nf90err( ierr_nf90, \"nf90_def_var\" )\n\n       != End of definition of file\n        ierr_nf90=nf90_enddef( ncid=otri_nc )\n        call check_nf90err( ierr_nf90, \"nf90_enddef\" )\n\n        otri_t_count = 0\n      else\n        ierr_nf90=nf90_inq_varid( otri_nc, \"t\",   varid_tt )\n        ierr_nf90=nf90_inq_varid( otri_nc, \"tri\", varid_tri )\n        call check_nf90err( ierr_nf90, \"nf90_inq_varid\" )\n\n        ierr_nf90=nf90_inquire_dimension(otri_nc, unlimdimid, len=otri_t_count)\n        call check_nf90err(ierr_nf90, \"nf90_inquire_dimension\")\n      end if\n\n     != Parallel data access type\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_kx, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_ky, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_itri, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_is, &\n                                     access=NF90_INDEPENDENT )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_tt, &\n                                     access=NF90_COLLECTIVE )\n      ierr_nf90=nf90_var_par_access( ncid=otri_nc, varid=varid_tri, &\n                                     access=NF90_COLLECTIVE )\n      call check_nf90err( ierr_nf90, \"nf90_var_par_access\" )\n\n      count_ny=2*global_ny+1\n      start_ny=1\n      count_nt=1\n      start_nt=1\n\n      if ( ndims == 0 ) then\n        close(inml)\n        call getenv ( 'fu05',env_string )\n        open(inml, file=env_string )\n\n        read(inml, nml=nperi)\n\n        do my = 0, global_ny\n          gky(my) = kymin * real( my, kind=DP )\n        end do\n      end if\n\n     != Write variables: static coordinates x and y\n      if ( ndims == 0 ) then\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_kx, &\n                                values=kx(-nx:nx) )\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_ky, &\n                                values=(/ -gky(global_ny:1:-1),gky(0:global_ny) /) )\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_itri, &\n                                values=(/ (itri, itri=0,ntri-1) /) )\n        ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_is, &\n                                values=(/ (is, is=0,ns-1) /) )\n        call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n      end if\n\n      otri_t_count = otri_t_count+1\n      count_time(:) = 1\n      start_time(:) = otri_t_count\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tt, values=(/time/), &\n                              start=start_time, count=count_time )\n\n      ny_st = -global_ny\n      ny_end = global_ny\n      count_tri(:) = int((/ 2*nx+1,count_ny,count_nt,1,1 /), kind=4)\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jkpq_es(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=2\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jpqk_es(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=3\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jqkp_es(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=4\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jkpq_em(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=5\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jpqk_em(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n      start_nt=6\n      start_tri(:) = (/ 1,start_ny,start_nt,1+ranks,otri_t_count /)\n      ierr_nf90=nf90_put_var( ncid=otri_nc, varid=varid_tri, &\n                              values=jqkp_em(:,ny_st:ny_end), &\n                              start=start_tri, count=count_tri )\n\n      call check_nf90err( ierr_nf90, \"nf90_putvar\" )\n    end if\n\n  END SUBROUTINE fileio_write_tri\n\n\n !--------------------------------------\n  SUBROUTINE check_nf90err(werr, comment)\n !--------------------------------------\n !  Check error message of nf90\n    integer(kind=4), intent(in) :: werr\n    character(len=*), intent(in) :: comment\n\n    if(werr /= nf90_noerr) then\n      write(*,*) comment//\" \"//trim(nf90_strerror(werr))\n      stop\n    end if\n\n  END SUBROUTINE check_nf90err\n\n\nEND MODULE GKV_fileio\n", "PROGRAM GKV_main\n!-------------------------------------------------------------------------------\n!\n!    GKV+: nonlinear gyrokinetic Vlasov code in a flux tube geometry\n!\n!    Hierarchy of the modules (The lower should be complied earlier)\n!    ------------------------\n!        main\n!         |\n!        set, out\n!         |\n!        advnc, dtc, trans\n!         |\n!        colli, colliimp, exb, shearflow\n!         |\n!        bndry, fft, fld, zfilter, geom\n!         |\n!        clock, intgrl, tips, freq, igs, vmecbzx, ring, fileio\n!         |\n!        mpienv, math\n!         |\n!        header\n!\n!    Update history of gkvp_main.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - Adapt to modification of freq module.\n!      gkvp_f0.52 (S. Maeyama, Sep 2018)\n!        - Updated for implicit collision solver.\n!      gkvp_f0.40 (M. Nakata, June 2014)\n!        - Updated for realistic tokamak equilibrium, \n!          multi-species collision \n!      gkvp_f0.30 (S. Maeyama, March 2013)\n!        - Updated for electromagnetic, multi-species,\n!          MHD equilibrium, 5D-parallelization\n!      gkvp_r0.3 (T.-H. Watanabe, Jun 2011)\n!        - GKV is rearranged to Fortran90 module style. \n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_set,   only: set_init, set_close\n  use GKV_clock, only: clock_timer, clock_sta, clock_end, clock_reset\n  use GKV_out,   only: out_cntrl, out_contnu\n  use GKV_dtc,   only: dtc_cntrl, flag_time_advnc, flag_time_split\n  use GKV_fld,   only: fld_esfield\n  use GKV_advnc, only: advnc_rkgsteps_rev\n  use GKV_colliimp, only: colliimp_colli\n  use GKV_fft,   only: fft_pre\n  use GKV_freq,  only: freq_set, freq_conv\n  use GKV_tips,  only: tips_flush\n  use GKV_shearflow,  only: shearflow_kxmap\n\n  implicit none\n\n  complex(kind=DP), &\n    dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n\n  complex(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1)       :: Al, phi\n\n  complex(kind=DP), &\n    dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n\n  real(kind=DP) :: time\n  character(15) :: colliflag\n  integer :: loop, iflg, cflg\n\n\n    call mpienv_init( nprocw, nprocz, nprocv, nprocm, nprocs )\n\n    call clock_timer( 0, iflg )\n                                           call clock_sta(1)\n                                        ! call fapp_start(\"pre\",1,1)\n    call fft_pre( )\n    call set_init( ff, phi, Al, hh, time )\n      write( olog, * ) \" # simulation is started at t = \", time\n\n    if ( calc_type == \"lin_freq\" ) call freq_set( time )\n    call out_cntrl( ff, phi, Al, hh, time, 0 )\n\n    if ( adapt_dt ) call dtc_cntrl( ff, phi, Al, hh, time, 0 )\n                                        ! call fapp_stop(\"pre\",1,1)\n                                           call clock_end(1)\n                                           call clock_reset\n    \n    loop   = 0\n    cflg   = 0\n    call flush(olog)\n                                           call clock_sta(2)\n                                        !!call PAT_region_begin(1,\"timesteploop\",ierr_mpi)\n                                        ! call fipp_start\n                                        ! call fapp_start(\"timesteploop\",2,1)\n\n    do\n\n      if ( time > tend - eps ) exit\n\n      time   = time + dt\n      loop   = loop + 1\n\n      if (flag_time_advnc == 0) then! 4th-order RKG explicit time integration\n\n        colliflag = \"collisional\"\n        call advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n\n      else if (flag_time_advnc == 1) then! 2nd-order operator split with implicit collision\n\n        if (flag_time_split == 0) then\n                                           call clock_sta(17)\n                                        ! call fapp_start(\"colliimp\",17,1)\n          call colliimp_colli( 0.5_DP*dt, ff, phi, Al, hh )\n                                        ! call fapp_stop(\"colliimp\",17,1)\n                                           call clock_end(17)\n          colliflag = \"collisionless\"\n          call advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n          flag_time_split = 1\n                                          !%%% For debug %%%\n                                          ! if (rankg==0) write(olog,*) &\n                                          ! loop, time, \"half-step\"\n                                          !%%%%%%%%%%%%%%%%%\n        else if (flag_time_split == 1) then\n                                           call clock_sta(17)\n                                        ! call fapp_start(\"colliimp\",17,1)\n          call colliimp_colli( dt, ff, phi, Al, hh )\n                                        ! call fapp_stop(\"colliimp\",17,1)\n                                           call clock_end(17)\n          colliflag = \"collisionless\"\n          call advnc_rkgsteps_rev( colliflag, ff, phi, Al, hh )\n                                          !%%% For debug %%%\n                                          ! if (rankg==0) write(olog,*) &\n                                          ! loop, time, \"one-step\"\n                                          !%%%%%%%%%%%%%%%%%\n        end if\n\n      end if\n\n      if (gamma_e /= 0._DP.and. trim(flag_shearflow) == \"remap\") then\n        call shearflow_kxmap( time, ff, phi, Al, hh )\n        if (time > tlim_exb - eps.AND. cflg == 0 ) then \n          write( olog, * ) \"\"\n          write( olog, * ) \" ########## CAUTION! ############\"\n          write( olog, * ) \" # time variable exceeds the time-limit: tlim_exb = \", tlim_exb\n          write( olog, * ) \" # --> GKV is still running, but you need to check the results after tlim_exb.\"\n          write( olog, * ) \" ########## CAUTION! ############\"\n          write( olog, * ) \"\"\n          cflg = 1\n         !!! exit \n        end if\n      end if\n\n                                           call clock_sta(10)\n                                        ! call fapp_start(\"output\",10,1)\n      call out_cntrl( ff, phi, Al, hh, time, 1 )\n      if ( adapt_dt ) call dtc_cntrl( ff, phi, Al, hh, time, 1 )\n      if ( calc_type == \"lin_freq\" ) then\n        if ( all(freq_conv) ) then\n          write( olog, * ) \" # Growth rate and frequency are well converged.\"\n          exit\n        end if\n      end if\n                                        ! call fapp_stop(\"output\",10,1)\n                                           call clock_end(10)\n\n! --- output continu file every 10000 steps\n      if (mod(loop+10000,10000) == 0 ) then \n                                           call clock_sta(16)\n                                        ! call fapp_start(\"checkp\",16,1)\n        write( olog, * ) \"# check-point at time = \", time\n        call out_contnu ( ff, time )\n        call tips_flush\n                                        ! call fapp_stop(\"checkp\",16,1)\n                                           call clock_end(16)\n      end if\n! ---\n      call clock_timer( 1, iflg )\n      \n      if( iflg == 1 ) exit\n\n    end do\n                                        ! call fapp_stop(\"timesteploop\",2,1)\n                                        ! call fipp_stop\n                                        !!call PAT_region_end(1,ierr_mpi)\n                                           call clock_end(2)\n\n                                           call clock_sta(3)\n                                        ! call fapp_start(\"post\",3,1)\n    call out_cntrl( ff, phi, Al, hh, time, 2 )\n      write( olog, * ) \" # simulation is stopped at t = \", time\n                                        ! call fapp_stop(\"post\",3,1)\n                                           call clock_end(3)\n    call clock_timer( 2, iflg )\n\n    call set_close\n\n    call MPI_Finalize ( ierr_mpi )\n\n  stop\n\n\nEND PROGRAM GKV_main\n", "MODULE GKV_shearflow\n!-------------------------------------------------------------------------------\n!\n!    Shearflow convection term  \n!\n!    Update history of gkvp_shearflow.f90\n!    --------------\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!      gkvp_f0.55 (M. Nakata, Dec 2018)   \n!        - First implementation\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fld,    only: fld_esfield, fld_emfield_ff, fld_ff2hh\n  use GKV_tips,  only: tips_reality\n\n  implicit none\n\n  private\n\n  public   shearflow_kxmap\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE shearflow_kxmap( time, ff, phi, Al, hh )\n!--------------------------------------\n!     discrete advection in kx direction due to the mean radial flow shear\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    real(kind=DP), intent(in)           :: time\n\n    complex(kind=DP), dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff_tmp\n\n    integer :: mx, my, iz, iv, im, mx_new, gmy, tloop\n    integer, dimension(0:ny) :: my_map, loop_mapping\n\n      tloop = nint(time/dt)\n      my_map(:) = -1\n      if (rankw == 0) loop_mapping(0) = 1\n\n      do my = ist1_y, iend_y\n \n        gmy = my + (ny+1)*rankw\n       !!!loop_mapping(my) = nint(kxmin_g/(kymin_g*abs(gamma_e)*dt))/gmy\n        loop_mapping(my) = nint(kxmin_g/(kymin_g*gmy*abs(gamma_e)*dt))\n\n        if (mod(tloop+loop_mapping(my),loop_mapping(my)) == 0 ) then \n          my_map(my) = my\n        else \n          my_map(my) = -1\n        end if \n\n      end do\n\n      if (maxval(my_map) < 0 ) then \n        return\n      else \n\n        if ( gamma_e > 0._DP ) then\n\n!$OMP parallel do collapse(2) default(none) &\n!$OMP shared(ist_y,iend_y,my_map,ff,ff_tmp) &\n!$OMP private(mx,my,iz,iv,im,mx_new)\n          do im = 0-nvb, nm+nvb\n            do iv = 1-nvb, 2*nv+nvb\n              do iz = -nz-nzb, nz-1+nzb\n                do my = ist_y, iend_y\n\n                  if (my == my_map(my)) then       \n                    do mx = -nx+1, nx\n                      mx_new = mx - 1  \n                      ff_tmp(mx_new,my,iz,iv,im) = ff(mx,my,iz,iv,im)\n                    end do \n                    ff_tmp(nx,my,iz,iv,im) = (0._DP, 0._DP)\n                  end if\n\n                end do \n              end do \n            end do \n          end do \n\n        else if (gamma_e < 0._DP) then  \n\n!$OMP parallel do collapse(2) default(none) &\n!$OMP shared(ist_y,iend_y,my_map,ff,ff_tmp) &\n!$OMP private(mx,my,iz,iv,im,mx_new)\n          do im = 0-nvb, nm+nvb\n            do iv = 1-nvb, 2*nv+nvb\n              do iz = -nz-nzb, nz-1+nzb\n                do my = ist_y, iend_y\n\n                  if (my == my_map(my)) then       \n                    do mx = -nx, nx-1\n                      mx_new = mx + 1  \n                      ff_tmp(mx_new,my,iz,iv,im) = ff(mx,my,iz,iv,im)\n                    end do \n                    ff_tmp(-nx,my,iz,iv,im) = (0._DP, 0._DP)\n                  end if\n\n                end do \n              end do \n            end do \n          end do \n      \n        end if \n\n!$OMP parallel do collapse(2) default(none) &\n!$OMP shared(ist_y,iend_y,my_map,ff,ff_tmp) &\n!$OMP private(mx,my,iz,iv,im,mx_new)\n        do im = 0-nvb, nm+nvb\n          do iv = 1-nvb, 2*nv+nvb\n            do iz = -nz-nzb, nz-1+nzb\n              do my = ist_y, iend_y\n\n                if (my == my_map(my)) then       \n                  do mx = -nx, nx\n                    ff(mx,my,iz,iv,im) = ff_tmp(mx,my,iz,iv,im)\n                  end do\n                end if\n\n              end do\n            end do\n          end do\n        end do\n\n        call fld_esfield( ff, phi )\n        if ( beta.ne. 0._DP ) then\n          call fld_emfield_ff( ff, Al )\n        end if\n        call fld_ff2hh( ff, Al, hh )\n\n        call tips_reality( hh )\n\n      end if\n\n  END SUBROUTINE shearflow_kxmap\n\nEND MODULE GKV_shearflow\n", "MODULE GKV_set\n!-------------------------------------------------------------------------------\n!\n!    Set file I/O, and read parameters from namelist\n!\n!    Update history of gkvp_set.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Contents of subroutine set_cnfig are moved to GKV_geom, to implement\n!          time-dependent metrics and operators in rotating flux-tube model.\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - equib_type = \"s-alpha-shift\" is added.\n!        - Initial random phase rr is set by global (mx,gmy) indices.\n!      gkvp_f0.60 (S. Maeyama, Jan 2021)\n!        - Use fileio module to switch Fortran/NetCDF binary output.\n!      gkvp_f0.58 (S. Maeyama, Oct 2020)\n!        - init_random is added to switch random number for initialization.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!        - equib_type=\"slab\" is added for shearless slab geometry.\n!        - Set ky=0, ksq=0 for padding iend_y<my.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_math,   only: math_random\n  use GKV_fld,    only: fld_esfield, fld_emfield_ff, fld_ff2hh\n  use GKV_bndry,  only: bndry_zvm_bound_f\n  use GKV_advnc,  only: caldlt_rev\n  use GKV_dtc,    only: dtc_init\n  use GKV_colli,  only: colli_set_param\n  use GKV_colliimp,  only: colliimp_set_param\n  use GKV_tips,   only: tips_reality\n  !fj start 202010\n  use GKV_fileio\n  !fj end 202010\n  use GKV_geom, only : geom_read_nml, geom_init_kxkyzvm,      &\n                       geom_init_metric, geom_set_operators,  &\n                       geom_reset_time\n\n  implicit none\n\n  private\n\n  public   set_init, set_close\n\nCONTAINS\n\n!--------------------------------------\n  SUBROUTINE set_init( ff, phi, Al, hh, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n    real(kind=DP), intent(out) :: time\n\n\n      call set_start\n      call set_param\n\n\n      if ( trim(equib_type) == \"slab\"     .OR. &\n           trim(equib_type) == \"analytic\" .OR. &\n           trim(equib_type) == \"s-alpha\"  .OR. &\n           trim(equib_type) == \"s-alpha-shift\"  .OR. &\n           trim(equib_type) == \"circ-MHD\" .OR. &\n           trim(equib_type) == \"vmec\"     .OR. &\n           trim(equib_type) == \"eqdsk\"    .OR. &\n           trim(equib_type) == \"ring\" ) then\n\n        call set_cnfig\n\n      else\n\n        if ( rankg == 0 ) then\n          write(*,*) \"set_cnfig_error!! on namelist: equib\"\n        end if\n        call MPI_Finalize (ierr_mpi)\n        stop\n\n      end if\n\n      call set_value( ff, phi, Al, hh, time )\n\n    return\n\n\n  END SUBROUTINE set_init\n\n\n!--------------------------------------\n  SUBROUTINE set_start\n!--------------------------------------\n\n    character(128) :: memo\n\n    character(6)   :: crank\n    character(1)   :: srank\n    character(3)   :: cold, cnew\n\n    character(10)   :: cdate, ctime\n\n    namelist /cmemo/ memo\n    namelist /calct/ calc_type, z_bound, z_filt, z_calc, art_diff, &\n                     init_random, num_triad_diag\n    namelist /equib/ equib_type\n    namelist /run_n/ inum, ch_res\n    namelist /files/ f_log, f_hst, f_phi, f_fxv, f_cnt\n\n    character(256)   :: env_string       !fj\n\n\n      call getenv ( 'fu05',env_string )  !fj\n      open(inml, file=env_string )       !fj\n\n\n      call date_and_time( cdate, ctime )\n\n      read(inml,nml=cmemo)\n\n\n      read(inml,nml=calct)\n      read(inml,nml=equib)\n      if (trim(z_calc) == \"up5\") art_diff = 0._DP\n\n\n      inum = 1\n      ch_res = .false.\n      read(inml,nml=run_n)\n\n\n      read(inml,nml=files)\n\n      write( crank, fmt=\"(i6.6)\" ) rankg\n      write( srank, fmt=\"(i1.1)\" ) ranks\n      write( cold,  fmt=\"(i3.3)\" ) inum-1\n      write( cnew,  fmt=\"(i3.3)\" ) inum\n\n\n      open( olog, file=trim(f_log)//crank//\".\"//srank//\".log.\"//cnew )\n\n      if ( inum > 1 ) then\n        !fj start 202010\n        !open( icnt, file=trim(f_cnt)//crank//\".cnt.\"//cold, &\n        !      form=\"unformatted\", status=\"old\", action=\"read\" )\n        call fileio_open_icnt( trim(f_cnt) )\n        !fj end 202010\n      end if\n\n      !fj start 202010\n      !open( ofxv, file=trim(f_fxv)//crank//\".\"//srank//\".fxv.\"//cnew, form=\"unformatted\" )\n      !open( ocnt, file=trim(f_cnt)//crank//\".cnt.\"//cnew, form=\"unformatted\" )\n      call fileio_open_fxv( trim(f_fxv) )\n      call fileio_open_cnt( trim(f_cnt) )\n      !fj end 202010\n\n      !fj start 202011\n      !if ( vel_rank == 0 ) then\n      !  open( omom, file=trim(f_phi)//crank//\".\"//srank//\".mom.\"//cnew, form=\"unformatted\" )\n      !end if\n      call fileio_open_mom( trim(f_phi) )\n      !fj end 202011\n\n      !fj start 202011\n      !if ( ranks == 0 .AND. vel_rank == 0 ) then\n      !  open( ophi, file=trim(f_phi)//crank//\".\"//srank//\".phi.\"//cnew, form=\"unformatted\" )\n      !  open(  oAl, file=trim(f_phi)//crank//\".\"//srank//\".Al.\"//cnew, form=\"unformatted\" )\n      !end if\n      call fileio_open_phi( trim(f_phi) )\n      call fileio_open_Al( trim(f_phi) )\n      !fj end 202011\n\n      !fj start 202011\n      !if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n      !  open( otrn, file=trim(f_phi)//crank//\".\"//srank//\".trn.\"//cnew, form=\"unformatted\" )\n      !end if\n      call fileio_open_trn( trim(f_phi) )\n      !fj end 202011\n\n      if( rankg == 0 ) then\n        open( omtr, file=trim(f_hst)//\"mtr.\"//cnew )\n        open( omtf, file=trim(f_hst)//\"mtf.\"//cnew )\n        open( odtc, file=trim(f_hst)//\"dtc.\"//cnew )\n        open( oeng, file=trim(f_hst)//\"eng.\"//cnew )\n        open( omen, file=trim(f_hst)//\"men.\"//cnew )\n        open( owes, file=trim(f_hst)//\"wes.\"//cnew )\n        open( owem, file=trim(f_hst)//\"wem.\"//cnew )\n        if ( trim(calc_type) == \"lin_freq\" ) then\n          open( ofrq, file=trim(f_hst)//\"frq.\"//cnew )\n          open( odsp, file=trim(f_hst)//\"dsp.\"//cnew )\n        end if\n      end if\n      if( rankg == nprocz/2 ) then\n        open( ocst, file=trim(f_hst)//\"cst.\"//cnew )\n      end if\n\n      if( rank == 0 ) then\n        open( obln, file=trim(f_hst)//\"bln.\"//srank//\".\"//cnew )\n        open( oges, file=trim(f_hst)//\"ges.\"//srank//\".\"//cnew )\n        open( ogem, file=trim(f_hst)//\"gem.\"//srank//\".\"//cnew )\n        open( oqes, file=trim(f_hst)//\"qes.\"//srank//\".\"//cnew )\n        open( oqem, file=trim(f_hst)//\"qem.\"//srank//\".\"//cnew )\n      end if\n\n      write( olog, * ) \"##### \", trim(memo), \" #####\"\n      write( olog, * ) \"\"\n      write( olog, * ) \"# Date : \", cdate\n      write( olog, * ) \"# Time : \", ctime\n      write( olog, * ) \"\"\n      write( olog, * ) \"# Type of calc. : \", trim(calc_type)\n      write( olog, * ) \"# Boundary condition in zz       : \", trim(z_bound)\n      write( olog, * ) \"# 4th-order filter in zz         : \", trim(z_filt)\n      write( olog, * ) \"# Finite difference scheme in zz : \", trim(z_calc)\n      write( olog, * ) \"# Artificial diffusion in zz     : \", art_diff\n      write( olog, * ) \"# Number of triad transfer diag. : \", num_triad_diag\n      write( olog, * ) \"# Type of equib. : \", trim(equib_type)\n      write( olog, * ) \"\"\n      write( olog, * ) \"# Run number = \", inum\n      write( olog, * ) \"# Resolution change = \", ch_res\n      write( olog, * ) \"\"\n\n\n    return\n  \n\n  END SUBROUTINE set_start\n\n\n!--------------------------------------\n  SUBROUTINE set_close\n!--------------------------------------\n\n     close( olog )\n\n     !fj start 202010\n     !close( icnt )\n     !close( ofxv )\n     !close( ocnt )\n     call fileio_close_icnt\n     call fileio_close_fxv\n     call fileio_close_cnt\n     !fj end 202010\n\n     !fj start 202011\n     !if ( vel_rank == 0 ) then\n     !  close( omom )\n     !end if\n     call fileio_close_mom\n     !fj end 202011\n\n     !fj start 202011\n     !if ( ranks == 0 .AND. vel_rank == 0 ) then\n     !  close( ophi )\n     !  close( oAl  )\n     !end if\n     call fileio_close_phi\n     call fileio_close_Al\n     !fj end 202011\n\n     !fj start 202011\n     !if ( zsp_rank == 0 .AND. vel_rank == 0 ) then\n       !close( otrn )\n     !end if\n     call fileio_close_trn\n     !fj end 202011\n\n     if( rankg == 0 ) then\n       close( omtr )\n       close( omtf )\n       close( odtc )\n       close( oeng )\n       close( omen )\n       close( owes )\n       close( owem )\n       if ( trim(calc_type) == \"lin_freq\" ) then\n         close( ofrq )\n         close( odsp )\n       end if\n     end if\n      if( rankg == nprocz/2 ) then\n       close( ocst )\n     end if\n\n     if( rank == 0 ) then\n       close( obln )\n       close( oges )\n       close( ogem )\n       close( oqes )\n       close( oqem )\n     end if\n\n  END SUBROUTINE set_close\n\n\n!--------------------------------------\n  SUBROUTINE set_param\n!--------------------------------------\n\n    namelist /runlm/ e_limit\n    namelist /times/ tend, dtout_fxv, dtout_ptn, dtout_eng, dtout_dtc\n    namelist /deltt/ dt_max, adapt_dt, courant_num, time_advnc\n\n\n      e_limit   = 5._DP * 3600._DP - 300._DP\n\n      read(inml,nml=runlm)\n\n\n      tend      = 10.00_DP\n      dtout_fxv = 5._DP\n      dtout_ptn = 0.5_DP\n      dtout_eng = 0.005_DP\n      dtout_dtc = 0.005_DP\n\n      read(inml,nml=times)\n\n\n      dt_max    = 0.005_DP\n      adapt_dt  = .false.\n      courant_num  = 0.6_DP\n\n      read(inml,nml=deltt)\n\n\n        write( olog, * ) \" # Numerical parameters \"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # nxw, nyw  = \", nxw, nyw\n        write( olog, * ) \" # global_ny = \", global_ny\n        write( olog, * ) \" # global_nz = \", global_nz\n        write( olog, * ) \" # global_nv, global_nm = \", global_nv, global_nm\n        write( olog, * ) \"\"\n        write( olog, * ) \" # nx, ny, nz   = \", nx, ny, nz\n        write( olog, * ) \" # nv, nm       = \", nv, nm\n        write( olog, * ) \" # nzb, nvb     = \", nzb, nvb\n        write( olog, * ) \" # nxw_size (local xw allocation size) = \", nxw_size\n        write( olog, * ) \" # number of species  = \", nprocs\n        write( olog, * ) \" # ranks=0: Electron\"\n        write( olog, * ) \" # ranks=1: main ion\"\n        write( olog, * ) \" # ranks>1: other ions\"\n        write( olog, * ) \" # Note that proton mass mp and main ion tmep. Ti is used for normalizations\"\n        write( olog, * ) \" # kx, ky are normalized with rho_tp = mp*vtp/e/Baxi, where vtp = sqrt(Ti/mp)\"\n        write( olog, * ) \" # time t is normalized with Raxi/vtp\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # e_limit      = \", e_limit\n        write( olog, * ) \" # tend         = \", tend\n        write( olog, * ) \" # dtout_fxv, dtout_ptn = \", dtout_fxv, dtout_ptn\n        write( olog, * ) \" # dtout_eng, dtout_dtc = \", dtout_eng, dtout_dtc\n        write( olog, * ) \"\"\n        write( olog, * ) \" # maximum time step dt_max = \", dt_max\n        write( olog, * ) \" # adaptive time step = \", adapt_dt\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # MPI parallelization parameters \"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # nproc , rankg = \", nproc , rankg\n        write( olog, * ) \" # nprocw, rankw = \", nprocw, rankw\n        write( olog, * ) \" # nprocz, rankz = \", nprocz, rankz\n        write( olog, * ) \" # nprocv, rankv = \", nprocv, rankv\n        write( olog, * ) \" # nprocm, rankm = \", nprocm, rankm\n        write( olog, * ) \" # nprocs, rank  = \", nprocs , rank\n        write( olog, * ) \" # izup, izdn    = \", izup, izdn\n        write( olog, * ) \" # ivup, ivdn    = \", ivup, ivdn\n        write( olog, * ) \" # imup, imdn    = \", imup, imdn\n        write( olog, * ) \"\"\n        write( olog, * ) \" # fft_nproc , fft_rank  = \", fft_nproc , fft_rank\n        write( olog, * ) \" # zsp_nproc , zsp_rank  = \", zsp_nproc , zsp_rank\n        write( olog, * ) \" # vel_nproc , vel_rank  = \", vel_nproc , vel_rank\n        write( olog, * ) \" # ranks                 = \", ranks\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # ist_y     = \", ist_y\n        write( olog, * ) \" # iend_y    = \", iend_y\n        write( olog, * ) \" # nsize_y   = \", nsize_y\n        write( olog, * ) \" # ist1_y    = \", ist1_y\n        write( olog, * ) \" # ist_y_g   = \", ist_y_g\n        write( olog, * ) \" # iend_y_g  = \", iend_y_g\n        write( olog, * ) \"\"\n        write( olog, * ) \" # ist_xw    = \", ist_xw\n        write( olog, * ) \" # iend_xw   = \", iend_xw\n        write( olog, * ) \" # nsize_xw  = \", nsize_xw\n        write( olog, * ) \" # ist_xw_g  = \", ist_xw_g\n        write( olog, * ) \" # iend_xw_g = \", iend_xw_g\n        write( olog, * ) \"\"\n\n\n  END SUBROUTINE set_param\n\n\n!--------------------------------------\n  SUBROUTINE set_cnfig\n!--------------------------------------\n\n    real(kind=DP), dimension(0:ns-1,0:ns-1) :: nust\n    real(kind=DP) :: lx, ly, eps_r\n    integer       :: is1, is2\n   \n    namelist /nu_ref/ Nref,     & ! reference (electron) density in m^(-3)\n                      Lref,     & ! reference length (=R_axis) in m\n                      Tref,     & ! reference main-ion (ranks=1) temperature in keV \n                      col_type, & ! flag for collision type: LB or full\n                      iFLR,     & ! flag for GK- or DK-limit in collision\n                      icheck      ! flag for Maxwellain anihilation test (w/ iFLR=0)\n\n! --- read GKV namelist relating to configurations ---\n        call geom_read_nml\n\n! --- coordinate settings (time-indep.) ---\n        call geom_init_kxkyzvm(lx, ly, eps_r)\n\n! --- set collision frequencies and v-space functions for multi-species GK collision\n        read(inml,nml=nu_ref)\n        call colli_set_param(q_0, eps_r, nust)\n        write( olog, * ) \" # Collision parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # Nref [m^-3]  = \", Nref\n        write( olog, * ) \" # Lref [m]     = \", Lref\n        write( olog, * ) \" # Tref [keV]   = \", Tref\n        write( olog, * ) \" # col_type     = \", col_type\n        write( olog, * ) \" # iFLR         = \", iFLR\n        write( olog, * ) \" # icheck       = \", icheck\n        write( olog, * ) \n        write( olog, * ) \" # Normalized collisionality: nu*\"\n        do is1 = 0, ns-1\n        do is2 = 0, ns-1\n        write( olog, * ) \" # a, b, nu*_ab = \", is1, is2, nust(is1,is2)\n        end do\n        end do\n        write( olog, * ) \n        if ( trim(col_type) == \"LB\" ) then\n          write( olog, * ) \" # col.-freq. bias factor for LB, nu = \", nu(:)\n          write( olog, * ) \n        end if\n\n        Zeff = 0._DP\n        do is1 = 1, ns-1\n          Zeff = Zeff + fcs(is1)*Znum(is1)\n        end do\n        write( olog, * ) \" # Zeff         = \", Zeff\n        write( olog, * ) \n\n\n! --- coordinate settings (explicitly time-dependent metrics) ---\n        call geom_init_metric\n\n! --- operator settings (time-dependent through metrics) ---\n        call geom_set_operators\n        if (trim(col_type) == \"full\" .or. trim(col_type) == \"lorentz\" .or. trim(time_advnc) == \"imp_colli\") then\n          call colliimp_set_param\n        end if\n\n! --- initial estimate of time steps ---\n        call dtc_init( lx, ly, vmax )\n\n  END SUBROUTINE set_cnfig\n\n\n!--------------------------------------\n  ", "SUBROUTINE set_value( ff, phi, Al, hh, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1)                       :: phi, Al\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)           :: hh\n\n    real(kind=DP), intent(out) :: time\n\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf, dh, cf, ef\n    real(kind=DP),    dimension(:),         allocatable :: rr\n    character(15) :: colliflag\n    integer :: input_status\n    integer :: mx, my, iz, iv, im, nx_init, gmy\n\n\n      ff(:,:,:,:,:) = ( 0._DP, 0._DP )\n      phi(:,:,:)    = ( 0._DP, 0._DP )\n      Al(:,:,:)     = ( 0._DP, 0._DP )\n      hh(:,:,:,:,:) = ( 0._DP, 0._DP )\n\n\n      if( inum == 1 ) then\n\n\n        time     = 0._DP\n\n        allocate( rr((2*nx+1)*(global_ny+1)) )\n\n        if (init_random) then\n          call math_random ( rr )\n        else\n          rr(:) = 0._DP\n        end if\n\n        if ( nx0 > nx ) then \n          nx_init = nx\n        else        \n          nx_init = nx0\n        end if\n\n!!!        my = 0 for R-H test\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = ist1_y, iend_y\n           ! do my = ist_y, iend_y\n                gmy = my + (ny+1)*rankw\n                do mx = -nx_init, nx_init\n                  ff(mx,my,iz,iv,im)   = dns1(ranks) * fmx(iz,iv,im)  &\n                          * ( 1._DP + vl(iv) + zz(iz) )**2            &\n                          * exp( -zz(iz)**2 / (0.2_DP*pi)**2 ) &\n                          * exp( ui * twopi * rr(mx+nx+1+(2*nx+1)*gmy) )\n                end do\n              end do\n            end do\n          end do\n        end do\n\n        if ( rankw == 0 ) then\n          do im = 0, nm\n            do iv = 1, 2*nv\n              do iz = -nz, nz-1\n                my = 0\n                  do mx = 1, nx\n                    ff(-mx,my,iz,iv,im) = conjg( ff(mx,my,iz,iv,im) )\n                  end do\n                ff(0,0,iz,iv,im) = ( 0._DP, 0._DP )\n              end do\n            end do\n          end do\n        end if\n\n        deallocate( rr )\n\n\n        if ( ch_res ) call set_ch_resolution ( ff, time )\n\n\n      else\n\n\n        allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n        time   = - 1._DP\n\n        do \n         !fj start 202010\n         !read( unit=icnt, iostat=input_status ) time, wf\n          call fileio_read_cnt( wf, time, input_status )\n         !fj end 202010\n\n          if ( input_status < 0 ) then\n            write( olog, * ) &\n               \" # end of file of unit=30 is detected --> stop\"\n            call flush(olog)\n            call MPI_Abort(MPI_COMM_WORLD, ierr_mpi)\n            stop\n          end if\n\n          if ( input_status > 0 ) then\n            write( olog, * ) &\n               \" # input error of unit=30 is detected --> stop\"\n            call flush(olog)\n            call MPI_Abort(MPI_COMM_WORLD, ierr_mpi)\n            stop\n          end if\n\n          if ( time > eps ) exit\n        end do\n\n\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              do my = ist_y, iend_y\n                do mx = -nx, nx\n                  ff(mx,my,iz,iv,im) = wf(mx,my,iz,iv,im)\n                end do\n              end do\n            end do\n          end do\n        end do\n\n        deallocate( wf )\n\n\n          write( olog, * ) \"\"\n          write( olog, * ) \" # simulation is re-started at t = \", time\n          write( olog, * ) \"\"\n\n\n      end if\n\n    !%%% For shearflow rotating flux tube model %%%\n      if (gamma_e /= 0._DP.and. trim(flag_shearflow) ==\"rotating\") then\n        call geom_reset_time(time)\n        if (trim(col_type) == \"full\".or. trim(col_type) == \"lorentz\".or. trim(time_advnc) == \"imp_colli\") then\n          call colliimp_set_param\n        end if\n      end if\n    !%%%\n\n      call bndry_zvm_bound_f( ff )\n\n      call fld_esfield( ff, phi )\n      if ( beta.ne. 0._DP ) then\n        call fld_emfield_ff( ff, Al )\n      end if\n      call fld_ff2hh( ff, Al, hh )\n\n      call tips_reality( hh )\n\n      allocate( dh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( cf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n      allocate( ef(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n\n      colliflag = \"collisional\"\n      call caldlt_rev( colliflag, ff, phi, Al, hh, dh, cf, ef )\n\n      deallocate( dh )\n      deallocate( cf )\n      deallocate( ef )\n\n!! --- for debug\n!      call MPI_Finalize(ierr_mpi)\n!      stop\n\n\n  END SUBROUTINE set_value\n\n\n!--------------------------------------\n  SUBROUTINE set_ch_resolution ( ff, time )\n!--------------------------------------\n\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,1-nvb:2*nv+nvb,0-nvb:nm+nvb) :: ff\n    real(kind=DP), intent(out) :: time\n\n\n   !--- Set perpendicular resolution employed in the input file. ---\n   !!! NOTE!!!\n   !    Resolutions in (z,v,m,s) should be kept the same.\n   !    Since lx and ly should be larger than or equal to lx0, ly0,\n   !    xfold and yfold are set to be integers.\n   !!!!!!!!!!!!\n      integer, parameter :: xfold = 1  ! kxmin0 = xfold * kxmin\n      integer, parameter :: yfold = 1  ! kymin0 = yfold * kymin\n      integer, parameter :: nx0 = 95, global_ny0 = 1, nprocw0 = 1\n      integer, parameter :: ny0 = global_ny0 / nprocw0\n      real(kind=DP) :: amplify = 1._DP\n   !----------------------------------------------------------------\n\n\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    integer :: input_status\n    integer :: ny_size0, nwk0, irw, ist_y_g0, iend_y_g0\n    integer :: mx, my, iz, iv, im, mxw, myw\n    character(6)   :: crank\n    character(1)   :: srank\n\n\n\n      allocate( wf(-nx0:nx0,0:ny0,-nz:nz-1,1:2*nv,0:nm) )\n\n      do irw = 0, nprocw0-1\n\n        ny_size0 = global_ny0 + 1 \n        if( mod(ny_size0,nprocw0) == 0 )  then\n          nwk0    = ny_size0 / nprocw0\n        else\n          nwk0    = ny_size0 / nprocw0 + 1\n        endif\n       !--- global index range ---------------- \n        ist_y_g0  = nwk0*irw\n        iend_y_g0 = min( nwk0*(irw+1)-1, (ny_size0-1) )\n\n        write( crank, fmt=\"(i6.6)\" ) irw + nprocw0*rankz + nprocw0*nprocz*rankv  &\n            + nprocw0*nprocz*nprocv*rankm + nprocw0*nprocz*nprocv*nprocm*ranks\n        write( srank, fmt=\"(i1.1)\" ) ranks\n\n       !fj start 202010\n       !open( icnt, file=trim(f_cnt)//crank//\".cnt.000\", &\n       !      form=\"unformatted\", status=\"old\", action=\"read\" )\n       !read( unit=icnt, iostat=input_status ) time, wf\n       !rewind( icnt )\n       !close( icnt )\n        call fileio_open_icnt( trim(f_cnt) )\n        call fileio_read_cnt( wf, time, input_status )\n        call fileio_close_icnt\n       !fj end 202010\n\n        if ( ist_y_g <= iend_y_g0 * yfold.and. ist_y_g0 * yfold <= iend_y_g ) then\n          do im = 0, nm\n            do iv = 1, 2*nv\n              do iz = -nz, nz-1\n                do my = ist_y_g0, iend_y_g0\n                  myw = my * yfold\n                  if ( ist_y_g <= myw.and. myw <= iend_y_g ) then\n                    do mx = -nx0, nx0\n                      mxw = mx * xfold\n                      if ( -nx <= mxw.and. mxw <= nx ) then\n                        ff(mxw,myw-ist_y_g,iz,iv,im) = wf(mx,my-ist_y_g0,iz,iv,im) * amplify\n                      end if\n                    end do\n                  end if\n                end do\n              end do\n            end do\n          end do\n        end if\n\n      end do\n\n      deallocate( wf )\n\n      write( olog, * ) \"\"\n      write( olog, * ) \" # simulation is re-started at t = \", time\n      write( olog, * ) \" # perpendicular resolutions are changed:\"\n      write( olog, * ) \" # lx is \", xfold, \"times larger\" \n      write( olog, * ) \" # ly is \", yfold, \"times larger\" \n      write( olog, * ) \" # nx =\", nx0, \"to\", nx\n      write( olog, * ) \" # global_ny =\", global_ny0, \"to\", global_ny\n      write( olog, * ) \" # nprocw from\", nprocw0, \"to\", nprocw\n      write( olog, * ) \"\"\n\n\n  END SUBROUTINE set_ch_resolution\n\n\nEND MODULE GKV_set\n", "MODULE GKV_header\n!-------------------------------------------------------------------------------\n!\n!    Header for general use in the fluxtube code\n!\n!    Notes\n!    -----\n!      There are some restrictions on numerical parameters:\n!         mod( global_nz, nprocz ) = 0, due to z parallelization.\n!         mod( global_nv, nprocv ) = 0, due to v parallelization.\n!         mod( global_nm+1, nprocm ) = 0, due to m parallelization.\n!         nm>=3, due to fft and colli.\n!         nzb>=2, due to 4th-oreder z derivative.\n!      There are some recommendations on numerical parameters:\n!         mod( nxw, nprocw ) = 0, due to w parallelization.\n!         mod( global_ny+1, nprocw ) = 0, due to w parallelization.\n!         nzb<=nz due to data copy in zfilter.\n!\n!    Update history\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - flag_shearflow = \"rotating\" is set as a default. Alternatively,\n!          flag_shaerflow = \"remap\" is still available for time-discontinuous\n!          wave-vector remap with nearest grid approximation.\n!        - File I/O unit \"omtf\" is added for metrics in flux-coordinates.\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - equib_type is extended from len=8 to len=15.\n!      gkvp_f0.57 (S. Maeyama, Oct 2020)\n!        - Version number f0.57 is removed from filename.\n!\n!-------------------------------------------------------------------------------\n\n  implicit none\n\n  public\n\n  integer, parameter :: DP = selected_real_kind(14)\n\n!--------------------------------------\n!  Dimension size (grid numbers)\n!--------------------------------------\n!  Global simulation domain \n!  in  x, y,z,v,m (0:2*nxw-1,  0:2*nyw-1,-global_nz:global_nz-1,1:2*global_nv,0:global_nm)\n!  in kx,ky,z,v,m (   -nx:nx,0:global_ny,-global_nz:global_nz-1,1:2*global_nv,0:global_nm)\n\n  integer, parameter :: nxw = 20, nyw = 20\n  integer, parameter :: nx = 4, global_ny = 1! 2/3 de-aliasing rule\n  integer, parameter :: global_nz = 12, global_nv = 24, global_nm = 7\n\n  integer, parameter :: nzb = 2, & ! the number of ghost grids in z\n                        nvb = 2    ! the number of ghost grids in v and m\n\n!--------------------------------------\n!  Data distribution for MPI\n!--------------------------------------\n\n  integer, parameter :: nprocw = 1, nprocz = 2, nprocv = 4, nprocm = 2, nprocs = 1\n\n!--------------------------------------\n!  Parameters for variable sizes\n!--------------------------------------\n!  Local simulation domain \n!  in kx,ky,z,v,m (divided in ky,z,v,m) (   -nx:nx,      0:ny,-nz:nz-1,1:2*nv,0:nm)\n!  in  x,ky,z,v,m (divided in ky,z,v,m) (0:2*nxw-1,      0:ny,-nz:nz-1,1:2*nv,0:nm)\n!  in  y, x,z,v,m (divided in  x,z,v,m) (    0:nyw,0:nxw_size,-nz:nz-1,1:2*nv,0:nm)\n\n  integer, parameter :: nxw_size = (2*nxw-1)/nprocw    ! local allocation size (0:nxw_size)\n  integer, parameter :: ny       = global_ny / nprocw  ! local allocation size (0:ny)\n\n  integer, parameter :: nz = global_nz / nprocz,          &\n                        nv = global_nv / nprocv,          &\n                        nm = (global_nm + 1) / nprocm - 1,&\n                        ns = nprocs\n\n  integer, parameter :: nxyz = (2*nx+1)*(ny+1)*(2*nz), &\n                        nxy  = (2*nx+1)*(ny+1)\n\n  integer, parameter :: nnx = nxw*2, nny = nyw*2\n\n\n!--------------------------------------\n!  Constants\n!--------------------------------------\n\n  real(kind=DP),    parameter :: pi  = 3.141592653589793_DP, &\n                                 twopi = pi * 2._DP,         &\n                                 eps = 0.0000000001_DP\n  complex(kind=DP), parameter :: ui  = ( 0._DP, 1._DP )\n\n\n!--------------------------------------\n!  Index Range\n!--------------------------------------\n\n! ---- y dimension -------\n  integer :: ist_y                          ! local start index of y\n  integer :: iend_y                         ! local end   index of y\n  integer :: nsize_y                        ! local size of y\n  integer :: ist1_y                         ! local start index of y for global start index 1 \n\n  integer :: ist_y_g                        ! global start index of y\n  integer :: iend_y_g                       ! global end   index of y\n\n! ---- xw dimension  -------\n  integer :: ist_xw                          ! local start index of xw\n  integer :: iend_xw                         ! local end   index of xw\n  integer :: nsize_xw                        ! local size of xw\n\n  integer :: ist_xw_g                        ! global start index of xw\n  integer :: iend_xw_g                       ! global end   index of xw\n\n\n!--------------------------------------\n!  Parameters for time\n!--------------------------------------\n\n  real(kind=DP) :: e_limit                          ! elapsed time limit of a job\n  real(kind=DP) :: tend                             ! end time\n  real(kind=DP) :: dtout_fxv, dtout_ptn, dtout_eng  ! time-spacing for output\n  real(kind=DP) :: dtout_dtc                        ! time-spacing for dt control\n\n\n!--------------------------------------\n!  Configuration parameters to be \n!    initialized in init subroutine\n!--------------------------------------\n\n!  real(kind=DP), &\n!    dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm)  :: kvd, kvs\n  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm)  :: vdx, vdy, vsy\n  real(kind=DP), &\n    dimension(-nx:nx,0:ny,-nz:nz-1,0:nm)         :: j0, j1, j2\n  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1) :: g0, ksq\n  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1) :: fct_poisson, fct_e_energy\n  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1) :: fct_ampere, fct_m_energy\n  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm) :: fmx\n  real(kind=DP), dimension(-nx:nx)               :: fctgt\n\n!!!%%% Parameters for colli_full %%%\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm) :: xxa\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm,0:ns-1,0:ns-1) :: nu_h, nu_g, nu_d, nu_p\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm)               :: nu_hs, nu_gs, nu_ds, nu_ps\n!!!  real(kind=DP), dimension(1:6,-nz:nz-1,1:2*nv,0:nm,0:ns-1,0:ns-1) :: x_tst, y_fld \n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm,0:ns-1,0:ns-1,1:2) :: c_t0\n!!!!  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm,0:ns-1,1:6) :: vfunc\n!!!  real(kind=DP), dimension(-nz:nz-1,1:2*nv,0:nm,0:ns-1,1:6) :: vfunc\n!!!  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,0:nm,1:6) :: jfunc\n!!!  real(kind=DP), dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: adbtc\n!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n  real(kind=DP), dimension(0:ns-1,0:ns-1) :: ctauiv, calpha, ctheta, cgamma, ceta, cxi\n\n  real(kind=DP), dimension(-nx:nx)          :: kx\n  real(kind=DP), dimension(0:ny)            :: ky\n  real(kind=DP), dimension(-nz:nz-1)        :: zz, omg\n  real(kind=DP), dimension(1:2*nv)          :: vl\n  real(kind=DP), dimension(0:nm)            :: mu\n  real(kind=DP), dimension(-nz:nz-1,0:nm)   :: vp, mir\n  real(kind=DP), dimension(-nz:nz-1)        :: dvp\n  real(kind=DP), dimension(-nz:nz-1)        :: dpara, rootg\n\n  complex(kind=DP), dimension(0:ny)         :: ck\n  integer, dimension(0:ny)                  :: dj\n\n  real(kind=DP) :: dt_max, dt\n  logical :: adapt_dt\n                                                    !!! Parameters for the R0 units\n  real(kind=DP), dimension(0:ns-1) ::   R0_Ln,  &   ! R0/Lns\n                                        R0_Lt,  &   ! R0/Lts\n                                           nu,  &   ! collision freq.   \n                                         Anum,  &   ! mass number\n                                         Znum,  &   ! charge number     \n                                          fcs,  &   ! charge-density fraction \n                                          sgn,  &   ! signs of charge   \n                                          tau,  &   ! T-ratio\n                                         dns1       ! initial perturbation amp.\n  real(kind=DP) :: dv, cfsrf, lambda_i, q_0, q_bar, beta, tau_ad, vmax\n  real(kind=DP) :: mach, uprime, gamma_e, kxmin_g, kymin_g, tlim_exb, s_hat_g\n  real(kind=DP) :: Nref, Lref, Tref, Zeff\n  integer       :: iFLR, icheck, ibprime, nx0\n  real(kind=DP) :: baxfactor\n\n  real(kind=DP) :: courant_num \n\n!--------------------------------------\n!  Type of calculation\n!--------------------------------------\n\n  character(9)  :: calc_type, & ! \"linear\", \"lin_freq\", \"nonlinear\"\n                   z_bound,   & ! \"zerofixed\", \"outflow\", \"mixed\"\n                   z_filt,    & ! \"on\", \"off\"\n                   z_calc,    & ! \"cf4\", \"up5\"\n                   col_type,  & ! \"LB\", \"full\", \"lorentz\"\n                   time_advnc   ! \"rkg4\", \"imp_colli\", \"auto_init\"\n  real(kind=DP) :: art_diff\n\n  integer :: num_triad_diag\n\n\n!--------------------------------------\n!  Parameters for numerical settings\n!--------------------------------------\n\n  integer :: inum\n  logical :: ch_res, init_random\n  character(512) :: f_log, f_hst, f_phi, f_fxv, f_cnt\n  character(15)  :: equib_type ! \"analytic\", \"s-alpha\", \"s-alpha-shift\",\n                               ! \"circ-MHD\", \"vmec\", \"eqdsk\", \"slab\"\n\n !character(15)  :: flag_shearflow = \"remap\"  ! Wavevector remap method\n !                                            ! with nearest grid approximation\n !                                            ! (Discontinuous in time)\n  character(15)  :: flag_shearflow = \"rotating\"! Rotating flux tube model\n\n! --- unit numbers for I/O\n  integer, parameter :: inml = 5,  & \n                        olog = 10, &\n                        icnt = 20, &\n                        ophi = 30, &\n                        oAl  = 31, &\n                        omom = 32, &\n                        otrn = 33, &\n                        otri = 34, &\n                        ofxv = 40, &\n                        ocnt = 50, &\n                        odtc = 59, &\n                        oeng = 60, &\n                        omen = 61, &\n                        owes = 62, &\n                        owem = 63, &\n                        oges = 64, &\n                        ogem = 65, &\n                        oqes = 66, &\n                        oqem = 67, &\n                        obln = 68, &\n                        ofrq = 69, &\n                        odsp = 70, &\n                        ocst = 71, &\n                        inbz = 14, &\n                        ivmc = 15, &\n                        omtr = 16, &\n                        omtf = 17, &\n                        ovmc = olog\n\n\nEND MODULE GKV_header\n", "MODULE GKV_geom\n!-------------------------------------------------------------------------------\n!\n!    Calculate geometric constants  \n!\n!    Update history of gkvp_geom.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - First implementation.\n!        - Geometric constants, which had been set in gkvp_set.f90, are moved.\n!          This module will be called from gkvp_set.f90 for initialization,\n!          and from gkvp_advnc.f90 for update in rotating flux-tube model.\n!        - Subroutines geom_* are public, can be called from other module.\n!        - Subroutines metric_* are private, treating metric structure.\n!        - equib_type = \"ring\" is added for ring dipole geometry.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_math,   only: math_j0, math_j1, math_j2, math_g0\n  use GKV_intgrl, only: intgrl_fsrf, intgrl_v0_moment_ms\n! for vmec equilibrium w/ Booz_xform by M. Nakata & M. Nunami  (Aug. 2016)\n  use GKV_vmecbzx, only: vmecbzx_boozx_read, vmecbzx_boozx_coeff\n! for tokamak(eqdsk) equilibrium\n  use GKV_igs,    only: igs_read, igs_coeff\n  !sakano_ring-dipole st 202303\n  use GKV_ring,   only: ring_coordinates\n  !sakano_ring-dipole end 202303\n\n  implicit none\n\n  private\n\n  public   geom_read_nml,      & ! Called once in GKV_set. Read namelist.\n           geom_init_kxkyzvm,  & ! Called once in GKV_set. Set time-indep. grids.\n           geom_init_metric,   & ! Called once in GKV_set. Set metrics at t=0.\n           geom_set_operators, & ! Set operators (e.g., ksq) by using metrics at t. \n           geom_reset_time,    & ! Called once in GKV_set. Reset metrics and operators at a given time.\n           geom_increment_time   ! Called in GKV_advnc. Increment metrics and operators by a given time step.\n           \n\n  type metric_global\n     ! Global metrics at t=0 are stored.\n     ! Metrics in GKV coordinates (x,y,z)\n     ! Metrics in flux coordinates (r,t,q)=(rho,theta,zeta)\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: zz    ! The rotating flux tube coordinate (= z'')\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: theta ! The poloidal angle theta_pol, not the flux-coordinate theta\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: omg   ! Magnetic field strength\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: &\n          domgdx, domgdy, domgdz, gxx, gxy, gxz, gyy, gyz, gzz, rootg_xyz\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: &\n          domgdr, domgdt, domgdq, grr, grt, grq, gtt, gtq, gqq, rootg_rtq\n    contains\n      procedure :: init => metric_global_init\n      procedure :: xyz2rtq => metric_global_xyz2rtq\n      procedure :: rtq2xyz => metric_global_rtq2xyz\n  end type\n\n  type metric_fourier\n     ! Metrics in flux coordinates at t=0, stored in Fourier coefficient\n     !   e.g.,   fourier_omg(kz) = \\int omg(z) * exp(-i*kz*z) dz / \\int dz\n     !           omg(z) = \\sum_k fourier_omg(kz) * exp(i*kz*z)\n     ! Thus, omg(z) at arbitrary z is obtained by Fourier interpolation.\n      real(kind=DP), dimension(-global_nz:global_nz-1) :: kz\n      complex(kind=DP), dimension(-global_nz:global_nz-1) :: theta_tilde, omg\n      complex(kind=DP), dimension(-global_nz:global_nz-1) :: &\n          domgdr, domgdt, domgdq, grr, grt, grq, gtt, gtq, gqq, rootg_rtq\n    contains\n      procedure :: init => metric_fourier_init\n      procedure :: dft_rtq2coef => metric_fourier_dft_rtq2coef\n  end type\n\n  type metric_local\n     ! Local metrics at any time t are stored.\n     ! They are updated with time integration, and used for solving\n     ! Gyrokinetic equation in the rotating flux tube model.\n      real(kind=DP), dimension(-nz:nz-1) :: zz          ! The rotating flux tube coordinate (= z'')\n      real(kind=DP), dimension(-nz:nz-1) :: zz_labframe ! The flux-coordinate theta in the lab frame (= z''+t*gamma_e/s_hat)\n      real(kind=DP), dimension(-nz:nz-1) :: theta ! The geometrical poloidal angle theta_pol, not the flux-coordinate theta\n      real(kind=DP), dimension(-nz:nz-1) :: omg   ! Magnetic field strength\n      real(kind=DP), dimension(-nz:nz-1) :: &\n          domgdx, domgdy, domgdz, gxx, gxy, gxz, gyy, gyz, gzz, rootg_xyz\n      real(kind=DP), dimension(-nz:nz-1) :: &\n          domgdr, domgdt, domgdq, grr, grt, grq, gtt, gtq, gqq, rootg_rtq\n    contains\n      procedure :: copy_global => metric_local_copy_global\n      procedure :: init => metric_local_init\n      procedure :: update => metric_local_update\n      procedure :: dft_coef2rtq => metric_local_dft_coef2rtq\n      procedure :: rtq2xyz => metric_local_rtq2xyz\n  end type\n\n  type(metric_global),  save :: mtr_global\n  type(metric_fourier), save :: mtr_fourier\n  type(metric_local),   save :: mtr_local\n\n  real(kind=DP), save :: cx, cy, cb\n\n\n! for s-alpha model with Shafranov shift\n    real(kind=DP) ::  p_total, dp_totaldx, beta_total, alpha_MHD\n\n    real(kind=DP) :: r_major\n\n    integer, parameter :: num_omtr = 13\n!   real(kind=DP) :: metric_l(1:num_omtr,-nz:nz-1), metric_g(1:num_omtr,-global_nz:global_nz-1)\n\n    real(kind=DP) :: s_hat\n\n    real(kind=DP) :: eps_r\n\n    real(kind=DP) :: lz, kxmin, kymin, dz, mmax, dm, del_c\n    real(kind=DP) :: z0, z0_l\n    integer       :: n_tht, m_j\n\n    real(kind=DP) :: rdeps00, eps_hor, lprd, mprd, lmmq, malpha\n    real(kind=DP) :: eps_mor, eps_por, lprdm1, lprdp1, lmmqm1, lmmqp1\n    real(kind=DP) :: eps_rnew, rdeps1_0, rdeps1_10, rdeps2_10, rdeps3_10\n\n    real(kind=DP) :: s_input, s_0      ! radial label of fluxtube center \n    integer       :: mc_type           ! 0:Axisym., 1:Boozer, 2:Hamada\n    integer       :: q_type            ! 0:use q and s_hat value in confp, 1:calclated by IGS\n    integer       :: isw, nss, ntheta, nzeta\n    real(kind=DP) :: phi_ax            ! axisymmetric toroidal angle \n\n!sakano_ring-dipole st 202303\n    real(kind=DP) :: ring_a\n!sakano_ring-dipole end 202303\n\n    real(kind=DP) :: lz_l\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE geom_read_nml\n!--------------------------------------\n    implicit none\n\n    real(kind=DP) :: theta\n    real(kind=DP), dimension(0:ns-1) :: eta\n    real(kind=DP) :: domgdx, domgdy, domgdz\n    real(kind=DP), dimension(1:3,1:3) :: gg\n    integer :: iz, is, isw\n\n\n    namelist /physp/ R0_Ln,  &    ! R0/Lns\n                     R0_Lt,  &    ! R0/Lts\n                        nu,  &    ! factor for collision freq. in LB model    \n                      Anum,  &    ! mass number\n                      Znum,  &    ! charge number \n                       fcs,  &    ! charge-density fraction \n                       sgn,  &    ! signs of charge \n                       tau,  &    ! T-ratio Ts/T0, T0=reference ion temp. of ranks=1\n                      dns1,  &    ! initial perturbation amplitude\n                    tau_ad,  &    ! Ti/Te for ITG-ae, Te/Ti for ETG-ai\n                  lambda_i,  &    ! (Debye/rho_tp)^2 \n                      beta,  &    ! mu0*ni*Ti/B^2\n                   ibprime,  &    ! flag for finite beta-prime effect on kvd\n                      vmax,  &    ! maximum v_para in unit of v_ts\n                       nx0        ! mode number for the initial perturbation\n\n    namelist /rotat/ mach, uprime, gamma_e\n\n    namelist /nperi/ n_tht, kymin, m_j, del_c\n    namelist /confp/ eps_r, eps_rnew,                       &\n                     q_0, s_hat,                            &\n                     lprd, mprd, eps_hor, eps_mor, eps_por, &\n                     rdeps00, rdeps1_0, rdeps1_10,          & \n                     rdeps2_10, rdeps3_10, malpha\n!    namelist /vmecp/ q_0, rad_a,                            &\n!                     R0_unit, r_edge,                       &\n!                     b0b00, alpha_fix\n    namelist /vmecp/ s_input, nss, ntheta, nzeta\n\n    namelist /igsp/ s_input, mc_type, q_type, nss, ntheta\n!sakano_ring-dipole st 202303\n    namelist /ring/ ring_a, kxmin\n!sakano_ring-dipole end 202303\n\n      tau(:)   = 1.0_DP\n      nu(:)    = 0.002_DP\n      R0_Ln(:) = 2.5_DP\n      R0_Lt(:) = 7.5_DP\n\n\n      read(inml,nml=physp)\n\n\n        do is = 0, ns-1\n          if( R0_Ln(is) /= 0._DP ) then\n            eta(is) = R0_Lt(is) / R0_Ln(is)\n          else\n            eta(is) = 1.d+20\n          end if\n        end do\n\n\n        write( olog, * ) \" # Physical parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # r_major/L_ns = \", R0_Ln(:)\n        write( olog, * ) \" # r_major/L_ts = \", R0_Lt(:)\n        write( olog, * ) \" # eta          = \", eta(:)\n        write( olog, * ) \" # nu           = \", nu(:)\n        write( olog, * ) \" # A-number     = \", Anum(:)\n        write( olog, * ) \" # Z-number     = \", Znum(:)\n        write( olog, * ) \" # fcs          = \", fcs(:)\n        write( olog, * ) \" # sgn          = \", sgn(:)\n        write( olog, * ) \" # tau          = \", tau(:)\n        write( olog, * ) \" # dns1         = \", dns1(:)\n        write( olog, * ) \" # tau_ad       = \", tau_ad\n        write( olog, * ) \" # lambda_i^2   = \", lambda_i\n        write( olog, * ) \" # beta_i       = \", beta\n        write( olog, * ) \" # ibprime      = \", ibprime\n        write( olog, * ) \" # nx0          = \", nx0\n        write( olog, * ) \"\"\n\n\n      mach = 0._DP\n      uprime = 0._DP\n      gamma_e = 0._DP\n\n      read(inml,nml=rotat)\n\n        write( olog, * ) \" # Mean rotation parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # Mach number  = \", mach\n        write( olog, * ) \" # uptime       = \", uprime\n        write( olog, * ) \" # gamma_ExB    = \", gamma_e\n        write( olog, * ) \"\"\n\n\n      n_tht = 1\n\n      read(inml,nml=nperi)\n\n\n      if( trim(equib_type) == \"slab\") then\n\n        read(inml,nml=confp)\n\n        lprdm1   = 0._DP\n        lprdp1   = 0._DP\n\n        lmmq     = 0._DP\n        lmmqm1   = 0._DP\n        lmmqp1   = 0._DP\n\n        q_0      = 1._DP ! For now, fixed q_0=1. Changing q_0 can extend parallel z-box size.\n        s_hat    = 0._DP ! only shear less slab\n        eps_r    = 1._DP\n\n        eps_hor  = 0._DP\n        lprd     = 0._DP\n        mprd     = 0._DP\n        malpha   = 0._DP\n\n        rdeps00  = 0._DP\n        eps_mor  = 0._DP\n        eps_por  = 0._DP\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # eps_hor      = \", eps_hor\n        write( olog, * ) \" # lprd         = \", lprd\n        write( olog, * ) \" # mprd         = \", mprd\n        write( olog, * ) \" # malpha       = \", malpha\n        write( olog, * ) \" # rdeps00      = \", rdeps00\n\n        write( olog, * ) \" # eps_mor      = \", eps_mor\n        write( olog, * ) \" # lprdm1       = \", lprdm1\n        write( olog, * ) \" # eps_por      = \", eps_por\n        write( olog, * ) \" # lprdp1       = \", lprdp1\n        write( olog, * ) \"\"\n\n      else if( trim(equib_type) == \"analytic\"  .OR.  &\n               trim(equib_type) == \"s-alpha\"   .OR.  &\n               trim(equib_type) == \"s-alpha-shift\"   .OR.  &\n               trim(equib_type) == \"circ-MHD\" ) then\n\n\n        read(inml,nml=confp)\n\n\n        lprdm1   = lprd - 1.0_DP\n        lprdp1   = lprd + 1.0_DP\n\n        lmmq     = lprd   - mprd * q_0\n        lmmqm1   = lprdm1 - mprd * q_0\n        lmmqp1   = lprdp1 - mprd * q_0\n\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \"\"\n\n        write( olog, * ) \" # eps_hor      = \", eps_hor\n        write( olog, * ) \" # lprd         = \", lprd\n        write( olog, * ) \" # mprd         = \", mprd\n        write( olog, * ) \" # malpha       = \", malpha\n        write( olog, * ) \" # rdeps00      = \", rdeps00\n\n        write( olog, * ) \" # eps_mor      = \", eps_mor\n        write( olog, * ) \" # lprdm1       = \", lprdm1\n        write( olog, * ) \" # eps_por      = \", eps_por\n        write( olog, * ) \" # lprdp1       = \", lprdp1\n        write( olog, * ) \"\"\n\n\n     else if( trim(equib_type) == \"vmec\" ) then\n\n\n        read(inml,nml=confp)\n\n        read(inml,nml=vmecp)\n\n        call vmecbzx_boozx_read( nss, ntheta, nzeta )\n\n         isw = 0\n         iz = 0\n         call vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input, iz, 0._DP,  lz_l,   &  ! input \n                           s_0,           q_0,     s_hat,    eps_r,  phi_ax,             &  ! output\n                           omg(iz), rootg(iz),    domgdx,   domgdz,  domgdy,             &\n                           gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                      &\n                           gg(2,3),   gg(3,3)  )\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # r_major/L_ns = \", R0_Ln(:)\n        write( olog, * ) \" # r_major/L_ts = \", R0_Lt(:)\n        write( olog, * ) \" # eta          = \", eta(:)\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \" # s_input, s_0 = \", s_input, s_0\n        write( olog, * ) \" # nss, ntheta, nzeta  = \", nss, ntheta, nzeta\n\n\n     else if( trim(equib_type) == \"eqdsk\" ) then\n\n\n        read(inml,nml=confp)\n\n        read(inml,nml=igsp)\n\n        call igs_read( mc_type, nss, ntheta )\n\n        if ( q_type == 1 ) then\n         isw = 0\n         iz = 0\n         call igs_coeff( isw,  mc_type,   nss,    ntheta,  s_input,  0._DP, lz_l,   &  ! input \n                         s_0,       q_0,     s_hat,    eps_r,  theta,               &  ! output\n                           omg(iz), rootg(iz),    domgdx,   domgdz, domgdy,         &\n                           gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                 &\n                           gg(2,3),   gg(3,3)  )\n        end if\n\n        write( olog, * ) \" # Configuration parameters\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # r_major/L_ns = \", R0_Ln(:)\n        write( olog, * ) \" # r_major/L_ts = \", R0_Lt(:)\n        write( olog, * ) \" # eta          = \", eta(:)\n        write( olog, * ) \" # q_0          = \", q_0\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \" # s_input, s_0 = \", s_input, s_0\n        write( olog, * ) \" # nss, ntheta  = \", nss, ntheta\n\n!sakano_ring-dipole st 202303\n      else if ( trim(equib_type) == \"ring\" ) then\n\n        read(inml,nml=confp)\n\n        read(inml,nml=ring)\n\n        s_hat = 0._DP\n\n        write( olog, * ) \" # Configuration parameters for ring dipole configuration\"\n        write( olog, * ) \"\"\n        write( olog, * ) \" # s_hat        = \", s_hat\n        write( olog, * ) \" # kxmin        = \", kxmin\n        write( olog, * ) \" # ring_a       = \", ring_a\n        write( olog, * ) \" # eps_r        = \", eps_r\n        write( olog, * ) \" # q_0          = \", q_0\n!sakano_ring-dipole end 202303\n\n      else\n\n        write( olog, * ) \" # wrong choice of the equilibrium \"\n        call flush(olog)\n        call MPI_Finalize(ierr_mpi)\n        stop\n\n      end if\n\n  END SUBROUTINE geom_read_nml\n\n\n!--------------------------------------\n  ", "SUBROUTINE geom_init_kxkyzvm(lx, ly, eps_r_temp)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(out) :: lx, ly, eps_r_temp\n    integer       :: global_iv, global_im\n    integer       :: mx, my, iz, iv, im\n\n      eps_r_temp = eps_r\n\n      if ( trim(equib_type) /= \"ring\" ) then\n        if (abs(s_hat) < 1.d-10) then ! When s_hat == ZERO\n          m_j = 0\n          kxmin = kymin\n        else if (m_j == 0) then\n          kxmin = kymin\n        else\n          kxmin    = abs(2._DP * pi * s_hat * kymin / real(m_j, kind=DP))\n        end if\n      end if\n      lx       = pi / kxmin\n      ly       = pi / kymin\n                    ! kymin=pi/ly=pi/[r_minor*pi/(q0*n_alp)]=q0*n_alp/r_minor\n\n      lz       = real( n_tht, kind=DP ) * pi        ! total z-length\n      lz_l     = lz / real( nprocz, kind=DP )       ! local z-length\n\n      do mx = -nx, nx\n        kx(mx)   = kxmin * real( mx, kind=DP )\n      end do\n\n      ky(:) = 0._DP\n      do my = ist_y_g, iend_y_g\n        ky(my-ist_y_g)   = kymin * real( my, kind=DP )\n      end do\n\n      kxmin_g = kxmin\n      kymin_g = kymin \n\n      z0       = - lz                     ! global lower boundary\n      z0_l     = 2._DP * lz_l * real( rankz, kind=DP ) + z0\n                                          ! local lower boundary\n\n      dz       = lz_l / real( nz, kind=DP )\n\n      do iz = -nz, nz-1\n        zz(iz)   = dz * real( iz + nz, kind=DP ) + z0_l\n      end do\n\n\n      dv       = 2._DP * vmax / real( 2 * nv * nprocv -1, kind=DP )\n\n      do iv = 1, 2*nv\n        global_iv = 2 * nv * rankv + iv\n        vl(iv)    = dv * ( real( global_iv - nv * nprocv - 1, kind=DP ) + 0.5_DP )\n      end do\n                                          ! --- debug\n                                          !   write( olog, * ) \" *** iv, vl \"\n                                          !   do iv = 1, 2*nv\n                                          !     global_iv = 2 * nv * rankv + iv\n                                          !     write( olog, * ) iv, global_iv, vl(iv)\n                                          !   end do\n                                          !   write( olog, * ) \"\"\n\n      mmax     = vmax\n      dm       = mmax / real( nprocm * ( nm+1 ) - 1, kind=DP )\n                                          ! --- equal spacing in vperp\n\n      do im = 0, nm\n        global_im = ( nm+1 ) * rankm + im\n        mu(im)    = 0.5_DP * ( dm * real( global_im, kind=DP ) )**2\n      end do\n\n\n      do my = ist_y_g, iend_y_g\n        ck(my-ist_y_g)   = exp( ui * 2._DP * pi * del_c &\n                                   * real( n_tht * my, kind=DP ) )\n        dj(my-ist_y_g)   = - m_j * n_tht * my\n                                          !  del_c = q_0*n_alp-int(q_0*n_alp)\n                                          !  m_j   = 2*n_alp*q_d\n      end do\n\n\n      write( olog, * ) \" # Numerical parameters\"\n      write( olog, * ) \"\"\n      write( olog, * ) \" # n_tht = \", n_tht\n      write( olog, * ) \" # lx, ly, lz   = \", lx, ly, lz\n      write( olog, * ) \" # lz,   z0     = \", lz, z0\n      write( olog, * ) \" # lz_l, z0_l   = \", lz_l, z0_l\n      write( olog, * ) \" # kxmin, kymin = \", kxmin, kymin\n      write( olog, * ) \" # kxmax, kymax = \", kxmin*nx, kymin*global_ny\n      write( olog, * ) \" # kperp_max    = \", sqrt((kxmin*nx)**2+(kymin*global_ny)**2)\n      write( olog, * ) \" # m_j, del_c   = \", m_j, del_c\n      write( olog, * ) \" # dz           = \", dz\n      write( olog, * ) \" # dv, vmax     = \", dv, vmax\n      write( olog, * ) \" # dm, mmax     = \", dm, mmax\n      write( olog, * ) \"\"\n\n      if (gamma_e == 0._DP) then\n        tlim_exb = 999999.d0\n      else\n        tlim_exb = (kxmin*(nx-nx0))/(kymin*global_ny*abs(gamma_e))\n      end if\n      write( olog, * ) \" # ExB limit time tlim_exb  = \", tlim_exb\n      write( olog, * ) \" # for (mx=nx0,my=global_ny) initial perturbation: \"\n      write( olog, * ) \" # tlim_exb = kxmin*(nx-nx0)/(kymax*|gamma_e|)\"\n      write( olog, * ) \"\"\n\n  END SUBROUTINE geom_init_kxkyzvm\n\n\n!--------------------------------------\n  SUBROUTINE geom_init_metric\n!--------------------------------------\n    real(kind=DP) :: r_0\n    real(kind=DP) :: wzz, theta, gomg\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz, is\n!sakano_ring-dipole st 202303\n    real(kind=DP) :: ub_dot_grdb, ub_crs_grdb\n!sakano_ring-dipole end 202303\n\n      s_hat_g = s_hat\n\n      !- zero clear -\n      gdomgdr = 0._DP\n      gdomgdt = 0._DP\n      gdomgdq = 0._DP\n      ggrr = 1._DP\n      ggrt = 0._DP\n      ggrq = 0._DP\n      ggtt = 1._DP\n      ggtq = 0._DP\n      ggqq = 1._DP\n      grootg_rtq = 1._DP\n\n      do iz = -global_nz, global_nz-1\n\n        wzz = dz * iz\n\n        if ( trim(equib_type) == \"slab\") then\n         !- Shearless slab geometry-\n         !  Consider translationally symmetric flux surface\n         !  (r,t,q)=(x_car,y_car,z_car).\n         !  GKV coordinates are\n         !    x = x_car,              -lx<=x/gyroradius<lx\n         !    y = y_car,              -ly<=y/gyroradius<ly\n         !    z = z_car/q_0*r_major,  -n_tht*pi<=z<n_tht*pi\n         !  z is dimensionless. \n         !  Length in field-aligned z_car is 2*q_0*lz*r_major.\n         !  r_major = 1 in the R0 unit.\n         !  Magnetic field is constant B=B0 in z, so omg = 1 in the B0 unit.\n         !  Normalized cb = B0/B0 = 1\n         !-\n          r_major = 1._DP ! in the R0 unit\n          cx = 1._DP\n          cy = 1._DP\n          cb = 1._DP\n\n          q_bar = q_0 \n          theta = wzz\n          gomg = 1._DP\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdx = 0._DP\n          gdomgdy = 0._DP\n          gdomgdz = 0._DP\n          ggxx = 1._DP\n          ggxy = 0._DP\n          ggxz = 0._DP\n          ggyy = 1._DP\n          ggyz = 0._DP\n          ggzz = 1._DP/(q_0*r_major)**2\n          grootg_xyz = q_0*r_major\n         !- Metrics in cartesian (x_car,y_car,z_car)\n         !gdomgdr = 0._DP\n         !gdomgdt = 0._DP\n         !gdomgdq = 0._DP\n         !ggrr = 1._DP\n         !ggrt = 0._DP\n         !ggrq = 0._DP\n         !ggtt = 1._DP\n         !ggtq = 0._DP\n         !ggqq = 1._DP\n         !grootg_rtq = 1._DP\n\n\n        else if( trim(equib_type) == \"analytic\" ) then\n         !- Analytic model of large-aspect-ratio helical system -\n         !  [Ref.1] H. Sugama and T.-H. Watanabe, Phys. Plasmas 11, 3068 (2004).\n         !  [Ref.2] T.-H.Watanabe, H. Sugama, and S. Ferrando-Margalet,\n         !          Nucl. Fusion 47, 1383 (2007).\n         !\n         !  Consider concentric circular, but helically twisted,\n         !  flux surface (r,theta,zeta). \n         !  GKV coordinates are\n         !    x = cx*(r-r0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=1, cy=cx*r0/q0.\n         !  In the large-aspect ratio limit, the geometrical length\n         !  in the field-aligned direction is dpara=q*r_major*dz.\n         !  r_major = 1 in the R0 unit.\n         !  Finite aspect ratio eps_r = r0/R0 is retained only in \n         !  magnetic field omg, domgdx, domgdy, domgdz, but not for metrics.\n         !  Flux-surface averaged magnetic field is <omg>=B_ax,\n         !  where B_ax is the value at the magnetic axis.\n         !  cb = (psi_p(r))'/(cx*cy) = B_ax\n         !  Normalized <omg> = 1 and cb = 1 in the B_ax unit.\n         !-\n          r_major = 1._DP       ! Major radius of magnetic axis in the R0 unit\n          r_0 = r_major * eps_r ! Minor radius of flux-tube center\n          cx = 1._DP\n          cy = r_0/q_0\n          cb = 1._DP\n\n          q_bar = q_0 \n          theta = wzz\n          gomg = 1._DP                                          &\n               - eps_r * ( cos( wzz )                           &\n                       + eps_hor * cos( lmmq   * wzz - malpha ) &\n                       + eps_mor * cos( lmmqm1 * wzz - malpha ) &\n                       + eps_por * cos( lmmqp1 * wzz - malpha ) )\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdz = eps_r * ( sin(wzz)                                        &\n                          + eps_hor * lmmq   * sin( lmmq   * wzz - malpha )   &\n                          + eps_mor * lmmqm1 * sin( lmmqm1 * wzz - malpha )   &\n                          + eps_por * lmmqp1 * sin( lmmqp1 * wzz - malpha ) )\n          gdomgdy = - eps_rnew / r_major * (                              &\n                    - ( sin( wzz )                                        &\n                      + eps_hor * lprd   * sin( lmmq   * wzz - malpha )   &\n                      + eps_mor * lprdm1 * sin( lmmqm1 * wzz - malpha )   &\n                      + eps_por * lprdp1 * sin( lmmqp1 * wzz - malpha )   &\n                    ) - (-1._DP/eps_r) * gdomgdz )\n          gdomgdx = eps_rnew / r_major * (                                &\n                    - (                                                   &\n                        rdeps00                                           &\n                      + rdeps1_0 * cos( wzz )                             &\n                      + rdeps2_10 * cos( lmmq   * wzz - malpha )          &\n                      + rdeps1_10 * cos( lmmqm1 * wzz - malpha )          &\n                      + rdeps3_10 * cos( lmmqp1 * wzz - malpha )          &\n                      + s_hat * wzz * ( sin( wzz )                        &\n                      + eps_hor * lprd   * sin( lmmq   * wzz - malpha )   &\n                      + eps_mor * lprdm1 * sin( lmmqm1 * wzz - malpha )   &\n                      + eps_por * lprdp1 * sin( lmmqp1 * wzz - malpha ) ) &\n                    ) - (-s_hat*wzz/eps_r) * gdomgdz )\n          ggxx = 1._DP\n          ggxy = s_hat*wzz\n          ggxz = 0._DP\n          ggyy = 1._DP + (s_hat*wzz)**2\n          ggyz = 1._DP/r_0\n          ggzz = 1._DP/r_0**2\n          grootg_xyz = q_0*r_major/gomg\n         !- Metrics in flux coordinates (r,theta,zeta)\n         !ggrr = 1._DP\n         !ggrt = 0._DP\n         !ggrq = 0._DP\n         !ggtt = 1._DP/r_0**2\n         !ggtq = 0._DP\n         !ggqq = 0._DP ! /=1._DP/r_major**2, because of large-aspect ratio approximation\n         !grootg_rtq = r_0*r_major/gomg\n\n\n        else if( trim(equib_type) == \"s-alpha\" .or. trim(equib_type) == \"s-alpha-shift\" ) then\n         !- Analytic model of large-aspect-ratio tokamak system -\n         !  Consider concentric circular flux surface (r,theta,zeta). \n         !  GKV coordinates are\n         !    x = cx*(r-r0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=1, cy=cx*r0/q0.\n         !  In the large-aspect ratio limit, the geometrical length\n         !  in the field-aligned direction is dpara=q*r_major*dz.\n         !  r_major = 1 in the R0 unit.\n         !  Finite aspect ratio eps_r = r0/R0 is retained only in \n         !  magnetic field omg, domgdx, domgdy, domgdz, but not for metrics.\n         !  Flux-surface averaged magnetic field is <omg>=B_ax,\n         !  where B_ax is the value at the magnetic axis.\n         !  cb = (psi_p(r))'/(cx*cy) = B_ax\n         !  Normalized <omg> = 1 and cb = 1 in the B_ax unit.\n         !-\n          r_major = 1._DP       ! Major radius of magnetic axis in the R0 unit\n          r_0 = r_major * eps_r ! Minor radius of flux-tube center\n          cx = 1._DP\n          cy = r_0/q_0\n          cb = 1._DP\n\n          if (trim(equib_type) == \"s-alpha\") then\n            !--- s-alpha model without Shafranov shift -\n            alpha_MHD = 0._DP\n          else ", "if (trim(equib_type) == \"s-alpha-shift\") then\n            !--- s-alpha model with Shafranov shift ----\n            p_total = 0._DP\n            dp_totaldx = 0._DP\n            beta_total = 0._DP\n            do is = 0, ns-1\n              p_total = p_total + fcs(is) * tau(is) / Znum(is)\n              dp_totaldx = dp_totaldx - fcs(is) * tau(is) / Znum(is) * (R0_Ln(is) + R0_Lt(is))\n              beta_total = beta_total + 2._DP * beta * fcs(is) * tau(is) / Znum(is)\n            end do\n            alpha_MHD = - q_0**2 * r_major * beta_total * dp_totaldx / p_total\n          end if\n          q_bar = q_0\n          theta = wzz\n          gomg = 1._DP - eps_r * cos( theta ) ! s-alpha with eps-expansion\n          !!!!gomg = 1._DP / (1._DP + eps_r * cos( theta )) ! for benchmark\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdz = eps_r * sin( theta )\n          !!!!gdomgdz = eps_r * sin( theta ) * omg(iz)**2 ! for benchmark\n          gdomgdx = - cos( theta ) / r_major\n          gdomgdy = 0._DP\n          ggxx = 1._DP\n          ggxy = s_hat*wzz - alpha_MHD*sin(wzz) ! with Shafranov shift\n          ggxz = 0._DP\n          ggyy = 1._DP + (s_hat*wzz - alpha_MHD*sin(wzz))**2 ! with Shafranov shift\n          ggyz = 1._DP/r_0\n          ggzz = 1._DP/r_0**2\n          grootg_xyz = q_0*r_major/gomg\n         !- Metrics in flux coordinates (r,theta,zeta)\n         !gdomgdr = - cos( theta ) / r_major\n         !gdomgdt = eps_r * sin( theta )\n         !gdomgdq = 0._DP\n         !ggrr = 1._DP\n         !ggrt = 0._DP\n         !ggrq = 0._DP + sin(wzz)*alpha_MHD*q_0/r_0 ! with Shafranov shift\n         !ggtt = 1._DP/r_0**2\n         !ggtq = 0._DP\n         !ggqq = 0._DP & ! /=1._DP/r_major**2, because of large-aspect ratio approximation\n         !     + sin(wzz)*(alpha_MHD*q_0/r_0)**2 ! with Shafranov shift\n         !grootg_rtq = r_0*r_major/gomg\n\n\n        else if( trim(equib_type) == \"circ-MHD\" ) then\n         !- Circular MHD equilibrium -\n         !  [Ref.] X. Lapillonne, et al., Phys. Plasmas 16, 032308 (2009).\n         !\n         !  Consider concentric circular flux surface (r,theta,zeta). \n         !  GKV coordinates are\n         !    x = cx*(r-r0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=1, cy=cx*r0/q0.\n         !  In the large-aspect ratio limit, the geometrical length\n         !  in the field-aligned direction is dpara=q*r_major*dz.\n         !  r_major = 1 in the R0 unit.\n         !  In contrast to the s-alpha model, finite aspect ratio eps_r = r0/R0\n         !  is retained in both of magnetic field and metrics.\n         !  Difference between the flux-surface averaged magnetic field <omg>\n         !  and the value at the magnetic axis B_ax also appears.\n         !  cb = (psi_p(r))'/(cx*cy) = B_ax\n         !  Normalized omg = B(z)/B_ax and cb = 1 in the B_ax unit.\n         !-\n          r_major = 1._DP       ! in the R0 unit\n          r_0 = r_major * eps_r ! Minor radius of flux-tube center\n          cx = 1._DP\n          cy = r_0/q_0\n          cb = 1._DP\n\n          theta = 2._DP*atan( sqrt( (1._DP+eps_r)/(1._DP-eps_r) ) &\n                             * tan(wzz/2._DP) )\n          q_bar = dsqrt( 1._DP - eps_r**2 )*q_0\n          gomg = sqrt( q_bar**2 + eps_r**2 ) &\n               / ( 1._DP + eps_r*cos( theta ) ) / q_bar\n         !- Metrics in GKV coordinates (x,y,z)\n          gdomgdz = eps_r * sin(theta) * sqrt( q_bar**2 + eps_r**2 ) &\n                     / ( 1._DP + eps_r * cos( theta ) )**2           &\n                     / ( 1._DP - eps_r * cos( wzz) ) / q_0\n          gdomgdx = -( cos(theta)                                           &\n                       - eps_r*(1._DP-s_hat+eps_r**2*q_0**2/q_bar**2)        &\n                              *(1._DP+eps_r*cos(theta))/(q_bar**2+eps_r**2) &\n                       - eps_r*sin(theta)**2/(1._DP-eps_r**2)               &\n                       ) / ((1._DP + eps_r*cos(theta))**2)                  &\n                         * sqrt(q_bar**2+eps_r**2) / q_bar / r_major\n          gdomgdy = 0._DP\n          ggxx = (q_0/q_bar)**2\n          ggxy = ( s_hat*wzz*q_0/q_bar - eps_r*sin(wzz)/(1._DP-eps_r**2) )*q_0/q_bar\n          ggxz = - sin(wzz)/(1._DP-eps_r**2)/r_major*q_0/q_bar\n          ggyy = (s_hat*wzz*q_0/q_bar)**2                                      &\n                 - 2._DP*q_0/q_bar*s_hat*wzz*eps_r*sin(wzz)/(1._DP-eps_r**2)   &\n                 + (q_bar**2+eps_r**2)/((1._DP+eps_r*cos(theta))**2)/(q_0**2) &\n                 + (eps_r*sin(wzz))**2/(1._DP-eps_r**2)**2\n          ggyz = ( -s_hat*wzz*q_0/q_bar*sin(wzz)/(1._DP-eps_r**2)           &\n                   + ((q_bar/q_0)**2)/((1._DP+eps_r*cos(theta))**2)/eps_r  &\n                   + eps_r*(sin(wzz)**2)/((1._DP-eps_r**2)**2)              &\n                 ) / r_major\n          ggzz = ( ((q_bar/q_0)**2)/((1._DP+eps_r*cos(theta))**2)/(eps_r**2) &\n                   + (sin(wzz)**2)/((1._DP-eps_r**2)**2)                      &\n                 ) / (r_major**2)\n          grootg_xyz = q_0*r_major*( 1._DP+eps_r*cos(theta) )**2\n\n\n        else if( trim(equib_type) == \"vmec\" ) then\n         !- VMEC-BoozXform interface for stellarator equilibirum -\n         !  References on the previous implementation by VMEC-NEWBOZ is\n         !  [Ref.1] M. Nunami, T.-H. Watanabe, H. Sugama, Plasma Fusion Res. 5,\n         !          016 (2010).\n         !  New interface for VMEC-BoozXform is developed by M. Nakata and \n         !  M. Nunami (Aug. 2016) in the same manner for IGS.\n         !\n         !  Consider flux coordinates (rho,theta,zeta).\n         !  Using the toroidal flux psi_t, the normalized minor radius is\n         !  rho= sqrt(psi_t/psi_ta), and the minor radius at the last closed\n         !  flux surface is a=sqrt(2*psi_ta/B_ax).\n         !  Poloidal and toroidal angles are defined in the Boozer coordinates.\n         !  GKV coordinates (x,y,z) are\n         !    x = cx*(rho-rho0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=a, cy=cx*rho0/q0.\n         !  In these definitions, the factor on the magnetic field \n         !  B = cb * \\nabla x \\times \\nabla y is\n         !  cb = (psi_p(rho))'/(cx*cy) = B_ax.\n         !  Normalized omg = B(z)/B_ax and cb = 1 in the B_ax unit.\n         !  The reference length is set to be r_major at the magnetic axis R0.\n         !-\n          r_major = 1._DP ! in the R0 unit\n          q_bar = q_0\n          isw = 1\n          call vmecbzx_boozx_coeff( isw, nss, ntheta, nzeta, s_input, iz, wzz, lz_l, &  ! input \n                                    s_0, q_0, s_hat, eps_r, phi_ax,                  &  ! output\n                                    gomg, grootg_xyz, gdomgdx, gdomgdz, gdomgdy,     &\n                                    ggxx, ggxy, ggxz, ggyy, ggyz, ggzz )\n         ! NOTE: phi_ax axisymmetric toroidal angle is stored for vmec, rather than theta\n          theta = phi_ax\n          cx = eps_r/s_0 ! = eps_a = a/R0\n          cy = cx*s_0/q_0\n          cb = 1._DP\n\n        else if( trim(equib_type) == \"eqdsk\" ) then\n         !- EQDSK-IGS interface for tokamak equilibirum -\n         !  [Ref.] M. Nakata, A. Matsuyama, N. Aiba, S. Maeyama, M. Nunami,\n         !         and T.-H. Watanabe, Plasma Fusion Res. 9, 1403029 (2014).\n         !\n         !  Consider flux coordinates (rho,theta,zeta).\n         !  GKV coordinates (x,y,z) are\n         !    x = cx*(rho-rho0)\n         !    y = cy*(q(r)*theta-zeta)\n         !    z = theta\n         !  with cx=a, cy=cx*rho0/q0. All explanation is the same as that in\n         !  equib_type == \"vmec\", except that poloidal and toroidal angles have\n         !  a choice of freedom: Hamada, Boozer, or axisymmetric coordinates.\n         !-\n          r_major = 1._DP ! in the R0 unit\n          q_bar = q_0\n          isw = 1\n          call igs_coeff( isw, mc_type, nss, ntheta, s_input, wzz, lz_l, &  ! input \n                          s_0, q_0, s_hat, eps_r, theta,                 &  ! output\n                          gomg, grootg_xyz, gdomgdx, gdomgdz, gdomgdy,   &\n                          ggxx, ggxy, ggxz, ggyy, ggyz, ggzz )\n          cx = eps_r/s_0 ! = eps_a = a/R0\n          cy = cx*s_0/q_0\n          cb = 1._DP\n\n!sakano_ring-dipole st 202303\n        else if( trim(equib_type) == \"ring\" ) then\n         !- Ring dipole geometry -\n         !  [Ref.] J. Sakano, Master thesis, Nagoya University (in Japanese).\n         !\n         !  Consider flux coordinates (Psi,Theta,phi), where the magnetic\n         !  poloidal flux Psi<0, the geometrical poloidal angle Theta = arctan(Z/(R-a)), \n         !  the azimuthal angle of the cylindrical coordinate phi.\n         !  There is a ring current in direction of phi at R=a. The field line \n         !  passing through (R,Z)=(R0,0) is picked up as a flux-tube domain.\n         !  \n         !  GKV coordinates (x,y,z) are (right-handed system)\n         !    x = cx*(Psi0 - Psi)/Psi0\n         !    y = cy*phi\n         !    z = Theta\n         !  with cx=R0, cy=R0. Note that Psi0 is the magnetic poloidal flux \n         !  at the center of the considered flux-tube domain.\n         !  In these definitions, the factor on the magnetic field \n         !  B = cb * \\nabla x \\times \\nabla y is cb = Psi0/(R0*R0) = B0,\n         !  where B0 is the magnetic field strength at (R,Z)=(R0,0).\n         !  Normalized omg = B(z)/B0 and cb = 1 in the B0 unit.\n         !  The reference length is set to be R0 (not the ring current at R=a).\n         !  The normalized parameter to specify the flux-tube is \n         !    ring_a = a / R0\n         !-\n          r_major = 1._DP ! in the R0 unit\n          q_bar   = 0._DP\n          theta = wzz\n          call ring_coordinates( ring_a, wzz, &                                ! input\n                                 gomg, ub_dot_grdb, ub_crs_grdb, ggxx, ggxy, & ! output\n                                 ggxz, ggyy, ggyz, ggzz, grootg_xyz, gdomgdx, gdomgdz )\n          gdomgdy = 0._DP\n          cx = 1._DP\n          cy = 1._DP\n          cb = 1._DP\n!sakano_ring-dipole end 202303\n\n        else\n\n          write( olog, * ) \" # wrong choice of the equilibrium \"\n          call flush(olog)\n          call MPI_Finalize(ierr_mpi)\n          stop\n\n        end if\n\n        call mtr_global%init(iz, wzz, theta, gomg,                  &\n                             gdomgdx, gdomgdy, gdomgdz, ggxx, ggxy, &\n                             ggxz, ggyy, ggyz, ggzz, grootg_xyz,    &\n                             gdomgdr, gdomgdt, gdomgdq, ggrr, ggrt, &\n                             ggrq, ggtt, ggtq, ggqq, grootg_rtq)\n\n      end do   ! iz loop ends\n\n      call mtr_global%xyz2rtq\n      call mtr_fourier%init\n      call mtr_fourier%dft_rtq2coef(mtr_global)\n\n      call mtr_local%copy_global(mtr_global)\n\n      if ( rankg == 0 ) then\n        do iz = -global_nz, global_nz-1\n          write( omtr, fmt=\"(f15.8,SP,256E24.14e3)\") &\n            mtr_global%zz(iz), mtr_global%theta(iz),      &\n            mtr_global%omg(iz), mtr_global%domgdx(iz),    &\n            mtr_global%domgdy(iz), mtr_global%domgdz(iz), &\n            mtr_global%gxx(iz), mtr_global%gxy(iz),       &\n            mtr_global%gxz(iz), mtr_global%gyy(iz),       &\n            mtr_global%gyz(iz), mtr_global%gzz(iz),       &\n            mtr_global%rootg_xyz(iz)\n        end do\n        !call flush(omtr)\n        do iz = -global_nz, global_nz-1\n          write( omtf, fmt=\"(f15.8,SP,256E24.14e3)\") &\n            mtr_global%zz(iz), mtr_global%theta(iz),      &\n            mtr_global%omg(iz), mtr_global%domgdr(iz),    &\n            mtr_global%domgdt(iz), mtr_global%domgdq(iz), &\n            mtr_global%grr(iz), mtr_global%grt(iz),       &\n            mtr_global%grq(iz), mtr_global%gtt(iz),       &\n            mtr_global%gtq(iz), mtr_global%gqq(iz),       &\n            mtr_global%rootg_rtq(iz)\n        end do\n        !call flush(omtr)\n      end if\n\n     !%%% For debug %%%\n     ! do iz = -nz, nz-1\n     !   write( 990000000+rankg, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !     mtr_local%zz(iz), mtr_local%theta(iz),      &\n     !     mtr_local%omg(iz), mtr_local%domgdx(iz),    &\n     !     mtr_local%domgdy(iz), mtr_local%domgdz(iz), &\n     !     mtr_local%gxx(iz), mtr_local%gxy(iz),       &\n     !     mtr_local%gxz(iz), mtr_local%gyy(iz),       &\n     !     mtr_local%gyz(iz), mtr_local%gzz(iz),       &\n     !     mtr_local%rootg_xyz(iz)\n     ! end do\n     ! call mtr_global%rtq2xyz\n     ! call mtr_global%xyz2rtq\n     ! call mtr_local%init(mtr_fourier, time_shearflow=0._DP)\n     ! if ( rankg == 0 ) then\n     !   do iz = -global_nz, global_nz-1\n     !     write( 900000011, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !       mtr_global%zz(iz), mtr_global%theta(iz),      &\n     !       mtr_global%omg(iz), mtr_global%domgdx(iz),    &\n     !       mtr_global%domgdy(iz), mtr_global%domgdz(iz), &\n     !       mtr_global%gxx(iz), mtr_global%gxy(iz),       &\n     !       mtr_global%gxz(iz), mtr_global%gyy(iz),       &\n     !       mtr_global%gyz(iz), mtr_global%gzz(iz),       &\n     !       mtr_global%rootg_xyz(iz)\n     !   end do\n     !   do iz = -global_nz, global_nz-1\n     !     write( 900000012, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !       mtr_global%zz(iz), mtr_global%theta(iz),      &\n     !       mtr_global%omg(iz), mtr_global%domgdr(iz),    &\n     !       mtr_global%domgdt(iz), mtr_global%domgdq(iz), &\n     !       mtr_global%grr(iz), mtr_global%grt(iz),       &\n     !       mtr_global%grq(iz), mtr_global%gtt(iz),       &\n     !       mtr_global%gtq(iz), mtr_global%gqq(iz),       &\n     !       mtr_global%rootg_rtq(iz)\n     !   end do\n     ! end if\n     ! do iz = -nz, nz-1\n     !   write( 980000000+rankg, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !     mtr_local%zz(iz), mtr_local%theta(iz),      &\n     !     mtr_local%omg(iz), mtr_local%domgdx(iz),    &\n     !     mtr_local%domgdy(iz), mtr_local%domgdz(iz), &\n     !     mtr_local%gxx(iz), mtr_local%gxy(iz),       &\n     !     mtr_local%gxz(iz), mtr_local%gyy(iz),       &\n     !     mtr_local%gyz(iz), mtr_local%gzz(iz),       &\n     !     mtr_local%rootg_xyz(iz)\n     ! end do\n     ! do iz = -nz, nz-1\n     !   write( 970000000+rankg, fmt=\"(f15.8,SP,256E24.14e3)\") &\n     !     mtr_local%zz_labframe(iz), mtr_local%theta(iz),      &\n     !     mtr_local%omg(iz), mtr_local%domgdr(iz),    &\n     !     mtr_local%domgdt(iz), mtr_local%domgdq(iz), &\n     !     mtr_local%grr(iz), mtr_local%grt(iz),       &\n     !     mtr_local%grq(iz), mtr_local%gtt(iz),       &\n     !     mtr_local%gtq(iz), mtr_local%gqq(iz),       &\n     !     mtr_local%rootg_rtq(iz)\n     ! end do\n     !%%%%%%%%%%%%%%%%%%\n\n  END SUBROUTINE geom_init_metric\n \n\n!--------------------------------------\n  ", "SUBROUTINE geom_set_operators\n!--------------------------------------\n    implicit none\n    real(kind=DP) :: wzz    ! The rotating flux tube coordinate (= z'')\n    real(kind=DP) :: zz_lab ! The flux-coordinate theta in the lab frame (= z''+t*gamma_e/s_hat)\n    real(kind=DP) :: kkx, kky, domgdz, domgdx, domgdy\n    real(kind=DP) :: bb, kmo\n    real(kind=DP) :: gg0\n\n    real(kind=DP) :: cfsrf_l\n    real(kind=DP), dimension(1:3,1:3) :: gg\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf\n    complex(kind=DP), dimension(:,:,:), allocatable :: nw\n    real(kind=DP), dimension(:,:,:), allocatable :: ww\n\n    integer :: mx, my, iz, iv, im, is\n\n        do iz = -nz, nz-1\n\n          wzz = zz(iz)\n          zz_lab = mtr_local%zz_labframe(iz)\n          omg(iz)   = mtr_local%omg(iz)\n          domgdx    = mtr_local%domgdx(iz)\n          domgdy    = mtr_local%domgdy(iz)\n          domgdz    = mtr_local%domgdz(iz)\n          gg(1,1)   = mtr_local%gxx(iz)\n          gg(1,2)   = mtr_local%gxy(iz)\n          gg(1,3)   = mtr_local%gxz(iz)\n          gg(2,2)   = mtr_local%gyy(iz)\n          gg(2,3)   = mtr_local%gyz(iz)\n          gg(3,3)   = mtr_local%gzz(iz)\n          rootg(iz) = mtr_local%rootg_xyz(iz)\n          gg(2,1)   = gg(1,2)\n          gg(3,1)   = gg(1,3)\n          gg(3,2)   = gg(2,3)\n\n!!! for slab model\n          if ( trim(equib_type) == \"slab\") then\n\n            dpara(iz) = dz * q_0 * r_major\n\n            do im = 0, nm\n              vp(iz,im)  = sqrt( 2._DP * mu(im) )!* omg(iz) )\n              mir(iz,im) = 0._DP\n              do iv = 1, 2*nv\n                vdx(iz,iv,im) = 0._DP\n                vdy(iz,iv,im) = 0._DP\n                vsy(iz,iv,im) =                                           &\n                  - sgn(ranks) * tau(ranks) / Znum(ranks)                 & \n                  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                           + omg(iz)*mu(im) - 1.5_DP ) )\n              end do\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = kx(mx)**2 + ky(my)**2\n              end do\n            end do\n\n!!! for the concentric and large-aspect-ratio model !!!\n          else if( trim(equib_type) == \"analytic\" ) then\n\n            dpara(iz) = dz * q_0 * r_major\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n              mir(iz,im) = mu(im) * eps_r / ( q_0 * r_major )  &\n                       * ( sin(zz_lab)                                          &\n                         + eps_hor * lmmq   * sin( lmmq   * zz_lab - malpha )   &\n                         + eps_mor * lmmqm1 * sin( lmmqm1 * zz_lab - malpha )   &\n                         + eps_por * lmmqp1 * sin( lmmqp1 * zz_lab - malpha ) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im)=                                            &\n                      - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &\n                      * ( 0._DP * ( rdeps00 + rdeps1_0 * cos( zz_lab )             &\n                             + rdeps2_10 * cos( lmmq   * zz_lab - malpha )          &\n                             + rdeps1_10 * cos( lmmqm1 * zz_lab - malpha )          &\n                             + rdeps3_10 * cos( lmmqp1 * zz_lab - malpha ) )        &\n                             + ( 1._DP + s_hat * wzz * 0._DP )                 &\n                             * ( sin( zz_lab )                                      &\n                             + eps_hor * lprd   * sin( lmmq   * zz_lab - malpha )   &\n                             + eps_mor * lprdm1 * sin( lmmqm1 * zz_lab - malpha )   &\n                             + eps_por * lprdp1 * sin( lmmqp1 * zz_lab - malpha ) ) &\n                         ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im)=                                            &\n                      - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &\n                      * ( 1._DP * ( rdeps00 + rdeps1_0 * cos( zz_lab )             &\n                             + rdeps2_10 * cos( lmmq   * zz_lab - malpha )          &\n                             + rdeps1_10 * cos( lmmqm1 * zz_lab - malpha )          &\n                             + rdeps3_10 * cos( lmmqp1 * zz_lab - malpha ) )        &\n                             + ( 0._DP + s_hat * wzz * 1._DP )                 &\n                             * ( sin( zz_lab )                                      &\n                             + eps_hor * lprd   * sin( lmmq   * zz_lab - malpha )   &\n                             + eps_mor * lprdm1 * sin( lmmqm1 * zz_lab - malpha )   &\n                             + eps_por * lprdp1 * sin( lmmqp1 * zz_lab - malpha ) ) &\n                         ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 & \n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )\n\n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = ( kx(mx) + s_hat * wzz * ky(my) )**2 + ky(my)**2\n              end do\n            end do\n\n!!! for s-alpha !!! <--- the current version is the same as \"analytic\"\n          else if( trim(equib_type) == \"s-alpha\" .or. trim(equib_type) == \"s-alpha-shift\" ) then\n\n            dpara(iz) = dz* q_0 * r_major\n\n            kkx = -r_major * (q_0/q_bar) &\n                           * ( gg(1,1)*gg(2,3) - gg(1,2)*gg(1,3) )*domgdz\n            kky =  r_major * (q_bar/q_0) &\n                           * ( domgdx - ( gg(1,2)*gg(2,3) - gg(2,2)*gg(1,3) )*domgdz )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * (q_0/q_bar) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im) =                                     &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   \n                      * kkx                                             &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im) =                                     &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   \n                      * kky                                             &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  &\n                      * (q_bar/q_0)\n              end do\n\n            end do   ! im loop ends\n\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = ( kx(mx) + ( s_hat * wzz - alpha_MHD*sin(zz_lab) ) &\n                                * ky(my) )**2 + ky(my)**2 ! with Shafranov shift\n              end do\n            end do\n\n!!! for circular MHD equilibrium !!!\n          else if( trim(equib_type) == \"circ-MHD\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )\n            kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im)=                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &\n                      * kkx                                                     &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im)=                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &\n                      * kky                                                     &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  \n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &\n                              + 2._DP*kx(mx)*ky(my)*gg(1,2) &\n                              + (ky(my)**2)*gg(2,2)\n              end do\n            end do\n\n!  this is new vmec-BoozXform interface  by M. Nakata & M. Nunami  (Aug. 2016)\n          else if( trim(equib_type) == \"vmec\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )\n            kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kkx                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n\n                    vdy(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kky                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &\n                     - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term \n                      * ( beta*(R0_Ln(ranks) + R0_Lt(ranks)) )                   &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  \n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &\n                              + 2._DP*kx(mx)*ky(my)*gg(1,2) &\n                              + (ky(my)**2)*gg(2,2)\n              end do\n            end do\n\n          else if( trim(equib_type) == \"eqdsk\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )\n            kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n\n              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                    vdx(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kkx                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vdy(iz,iv,im) =                                              &\n                       ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &\n                      * kky                                                      &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &\n                     - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term \n                      * ( beta*(R0_Ln(ranks) + R0_Lt(ranks)) )                   &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )\n\n                    vsy(iz,iv,im) =                                           &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)                 &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &\n                                               + omg(iz)*mu(im) - 1.5_DP ) )  \n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &\n                              + 2._DP*kx(mx)*ky(my)*gg(1,2) &\n                              + (ky(my)**2)*gg(2,2)\n              end do\n            end do\n\n!sakano_ring-dipole st 202303\n          else if( trim(equib_type) == \"ring\" ) then\n\n            dpara(iz) = dz * omg(iz) * rootg(iz)\n\n            kkx = 0._DP\n            kky = r_major*( domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )\n\n            do im = 0, nm\n! r_major = 1 is assumed as the equilibrium length unit\n! B on the equatorial plane is also unity\n\n", "              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )\n\n              !mir(iz,im) = mu(im) * ub_dot_grdb\n              mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )\n\n              do iv = 1, 2*nv\n                vdx(iz,iv,im) = 0._DP\n                   \n                !vdy(iz,iv,im) =                                        &\n                !        ( vl(iv)**2 + omg(iz)*mu(im) )                 &\n                !      * ( ub_crs_grdb / omg(iz)**2 ) * sqrt( gg(2,2) ) &\n                !      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )      ! ion's vdy is negative y direction\n                vdy(iz,iv,im) =                                              &\n                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) ) &\n                      * kky                                                  &\n                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) ) \n                vsy(iz,iv,im)=                                             &\n                      - sgn(ranks) * tau(ranks) / Znum(ranks)              &\n                      * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2 &\n                                               + omg(iz)*mu(im) - 1.5_DP ) ) ! ion's vsy is negative y directuin\n              end do\n\n            end do   ! im loop ends\n\n            ksq(:,:,iz) = 0._DP\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                ksq(mx,my,iz) = ( kx(mx) * gg(1,1) )**2 + ( ky(my) * gg(2,2) )**2\n              end do\n            end do\n!sakano_ring-dipole end 202303\n\n          else\n\n            write( olog, * ) \" # wrong choice of the equilibrium \"\n            call flush(olog)\n            call MPI_Finalize(ierr_mpi)\n            stop\n\n          end if\n\n\n          do im = 0, nm\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                kmo           = sqrt( 2._DP * ksq(mx,my,iz) * mu(im) / omg(iz) ) &\n                               * dsqrt( tau(ranks)*Anum(ranks) ) / Znum(ranks)\n                call math_j0( kmo, j0(mx,my,iz,im) )\n                call math_j1( kmo, j1(mx,my,iz,im) )\n                call math_j2( kmo, j2(mx,my,iz,im) )\n              end do\n            end do\n          end do\n\n\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              bb     = ksq(mx,my,iz) / omg(iz)**2 &\n                        * tau(ranks)*Anum(ranks)/(Znum(ranks)**2)\n              call math_g0( bb, g0(mx,my,iz) )\n            end do\n          end do\n\n        end do   ! iz loop ends\n\n        cfsrf   = 0._DP\n        cfsrf_l = 0._DP\n        do iz = -nz, nz-1\n          cfsrf_l   = cfsrf_l + rootg(iz)\n                                            ! normalization coefficient for \n                                            ! the surface average\n        end do\n        call MPI_Allreduce( cfsrf_l, cfsrf, 1, MPI_DOUBLE_PRECISION, &\n                            MPI_SUM, zsp_comm_world, ierr_mpi )\n\n        if ( vel_rank == 0 ) then\n          do iz = -nz, nz-1\n            dvp(iz)  = sqrt( 2._DP * (0.5_DP * dm**2) * omg(iz) )\n          end do\n        end if\n        call MPI_Bcast( dvp, 2*nz, MPI_DOUBLE_PRECISION, 0, &\n                        vel_comm_world, ierr_mpi )\n\n        do im = 0, nm\n          do iv = 1, 2*nv\n            do iz = -nz, nz-1\n              fmx(iz,iv,im)   = exp( - 0.5_DP * vl(iv)**2 - omg(iz) * mu(im) ) &\n                              / sqrt( twopi**3 )\n            end do\n          end do\n        end do\n\n        allocate( ww(-nx:nx,0:ny,-nz:nz-1) )\n\n! --- GK polarization factor for efield calculation \n        fct_poisson(:,:,:) = 0._DP\n        fct_e_energy(:,:,:) = 0._DP\n\n        ww(:,:,:) = 0._DP\n        do iz = -nz, nz-1\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n\n              if ( rankw == 0 .and. mx == 0 .and. my == 0 ) then !- (0,0) mode\n\n                fct_poisson(mx,my,iz) = 0._DP\n                fct_e_energy(mx,my,iz) = 0._DP\n\n              else\n\n                ww(mx,my,iz) = lambda_i * ksq(mx,my,iz)\n                do is = 0, ns-1\n                  bb   = ksq(mx,my,iz) / omg(iz)**2 &\n                          * tau(is)*Anum(is)/(Znum(is)**2)\n                  call math_g0( bb, gg0 )\n                  ww(mx,my,iz) = ww(mx,my,iz)  &\n                               + Znum(is) * fcs(is) / tau(is) * ( 1._DP - gg0 )\n                end do\n                fct_poisson(mx,my,iz) = 1._DP / ww(mx,my,iz)\n                fct_e_energy(mx,my,iz) = ww(mx,my,iz)\n\n              end if\n\n            end do\n          end do\n        end do\n\n\n! --- ZF-factor for adiabatic model\n        if ( ns == 1 ) then\n\n          ww(:,:,:) = 0._DP\n          do iz = -nz, nz-1\n            my = 0\n              do mx = -nx, nx\n                ww(mx,my,iz) = ( 1._DP - g0(mx,my,iz) )       &\n                             / ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )\n              end do\n          end do\n\n          call intgrl_fsrf ( ww, fctgt )\n\n          if ( rankw == 0 )  then\n            fctgt(0)   = ( 1._DP - g0(0,0,0) ) / ( 1._DP - g0(0,0,0) + tau(0)*tau_ad )\n                                              ! g0(0,0,iz) has no z dependence\n          endif\n\n        endif\n\n        deallocate( ww )\n\n        allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )\n        allocate( nw(-nx:nx,0:ny,-nz:nz-1) )\n        wf(:,:,:,:,:) = ( 0._DP, 0._DP )\n        nw(:,:,:) = ( 0._DP, 0._DP )\n\n! --- GK polarization factor for mfield calculation \n        fct_ampere(:,:,:) = 0._DP\n        fct_m_energy(:,:,:) = 0._DP\n\n        if ( beta .ne. 0._DP ) then\n       \n          do im = 0, nm\n            do iv = 1, 2*nv\n              do iz = -nz, nz-1\n                do my = ist_y, iend_y\n                  do mx = -nx, nx\n                    wf(mx,my,iz,iv,im) = Znum(ranks) * fcs(ranks) / Anum(ranks)  &\n                                       * vl(iv)**2 * j0(mx,my,iz,im)**2 * fmx(iz,iv,im)\n                  end do\n                end do\n              end do\n            end do\n          end do\n  \n          call intgrl_v0_moment_ms ( wf, nw )\n  \n          do iz = -nz, nz-1\n            do my = ist_y, iend_y\n              do mx = -nx, nx\n                fct_ampere(mx,my,iz) = 1._DP / real( ksq(mx,my,iz) + beta * nw(mx,my,iz), kind=DP )\n                fct_m_energy(mx,my,iz) = ksq(mx,my,iz) / beta\n              end do\n            end do\n          end do\n  \n          if ( rankw == 0 ) then\n            do iz = -nz, nz-1\n              fct_ampere(0,0,iz) = 0._DP\n              fct_m_energy(0,0,iz) = 0._DP\n            end do\n          end if\n\n        end if\n\n        deallocate( wf )\n        deallocate( nw )\n\n  END SUBROUTINE geom_set_operators\n\n!--------------------------------------\n  SUBROUTINE geom_reset_time(time_shearflow)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in) :: time_shearflow\n      call mtr_local%init(mtr_fourier, time_shearflow)\n      call geom_set_operators\n      !NOTE: colliimp_set_param in GKV_colliimp should also be updated.\n  END SUBROUTINE geom_reset_time\n\n!--------------------------------------\n  SUBROUTINE geom_increment_time(dt_shearflow)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in) :: dt_shearflow\n      call mtr_local%update(mtr_fourier, dt_shearflow)\n      call geom_set_operators\n      !NOTE: colliimp_set_param in GKV_colliimp should also be updated.\n  END SUBROUTINE geom_increment_time\n\n\n!--------------------------------------\n  SUBROUTINE metric_global_init(self, iz, wzz, theta, gomg,            &\n                                gdomgdx, gdomgdy, gdomgdz, ggxx, ggxy, &\n                                ggxz, ggyy, ggyz, ggzz, grootg_xyz,    &\n                                gdomgdr, gdomgdt, gdomgdq, ggrr, ggrt, &\n                                ggrq, ggtt, ggtq, ggqq, grootg_rtq)\n!--------------------------------------\n    implicit none\n    class(metric_global), intent(inout) :: self\n    integer, intent(in) :: iz\n    real(kind=DP), intent(in) :: wzz, theta, gomg\n    real(kind=DP), intent(in) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP), intent(in) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n\n      self%zz(iz)     = wzz\n      self%theta(iz)  = theta\n      self%omg(iz)    = gomg\n      self%domgdx(iz) = gdomgdx\n      self%domgdy(iz) = gdomgdy\n      self%domgdz(iz) = gdomgdz\n      self%gxx(iz) = ggxx\n      self%gxy(iz) = ggxy\n      self%gxz(iz) = ggxz\n      self%gyy(iz) = ggyy\n      self%gyz(iz) = ggyz\n      self%gzz(iz) = ggzz\n      self%rootg_xyz(iz) = grootg_xyz\n      self%domgdr(iz) = gdomgdr\n      self%domgdt(iz) = gdomgdt\n      self%domgdq(iz) = gdomgdq\n      self%grr(iz) = ggrr\n      self%grt(iz) = ggrt\n      self%grq(iz) = ggrq\n      self%gtt(iz) = ggtt\n      self%gtq(iz) = ggtq\n      self%gqq(iz) = ggqq\n      self%rootg_rtq(iz) = grootg_rtq\n\n  END SUBROUTINE metric_global_init\n\n\n!--------------------------------------\n  SUBROUTINE metric_global_xyz2rtq(self)\n!--------------------------------------\n    implicit none\n    class(metric_global), intent(inout) :: self\n    real(kind=DP) :: wzz\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz\n\n      do iz = -global_nz, global_nz-1\n       ! load (x,y,z)\n        wzz = self%zz(iz)\n        gdomgdx = self%domgdx(iz)\n        gdomgdy = self%domgdy(iz)\n        gdomgdz = self%domgdz(iz)\n        ggxx = self%gxx(iz)\n        ggxy = self%gxy(iz)\n        ggxz = self%gxz(iz)\n        ggyy = self%gyy(iz)\n        ggyz = self%gyz(iz)\n        ggzz = self%gzz(iz)\n        grootg_xyz = self%rootg_xyz(iz)\n\n       ! translate (x,y,z)->(r,t,q)=(rho,theta,zeta)\n       !   NOTE: cx*rho0/(cy*q_0=1) is used.\n        gdomgdr = cx*gdomgdx + cx*s_hat*wzz*gdomgdy\n        gdomgdt = gdomgdz + cy*q_0*gdomgdy\n        gdomgdq = - cy*gdomgdy\n        ggrr = ggxx/cx**2\n        ggrt = ggxz/cx\n        ggrq = (s_hat*wzz*ggxx-ggxy)/(cx*cy) + q_0*ggxz/cx\n        ggtt = ggzz\n        ggtq = (s_hat*wzz*ggxz-ggyz)/cy + q_0*ggzz\n        ggqq = (s_hat*wzz/cy)**2*ggxx - 2._DP*(s_hat*wzz/cy**2)*ggxy &\n             + 2._DP*(q_0*s_hat*wzz/cy)*ggxz + ggyy/cy**2            &\n             - 2._DP*(q_0/cy)*ggyz + q_0**2*ggzz\n        grootg_rtq = cx*cy*grootg_xyz\n\n       ! store (r,t,q)\n        self%domgdr(iz) = gdomgdr\n        self%domgdt(iz) = gdomgdt\n        self%domgdq(iz) = gdomgdq\n        self%grr(iz) = ggrr\n        self%grt(iz) = ggrt\n        self%grq(iz) = ggrq\n        self%gtt(iz) = ggtt\n        self%gtq(iz) = ggtq\n        self%gqq(iz) = ggqq\n        self%rootg_rtq(iz) = grootg_rtq\n      end do\n\n  END SUBROUTINE metric_global_xyz2rtq\n\n\n!--------------------------------------\n  SUBROUTINE metric_global_rtq2xyz(self)\n!--------------------------------------\n    implicit none\n    class(metric_global), intent(inout) :: self\n    real(kind=DP) :: wzz\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz\n\n      do iz = -global_nz, global_nz-1\n       ! load (r,t,q)=(rho,theta,zeta)\n        wzz = self%zz(iz)\n        gdomgdr = self%domgdr(iz)\n        gdomgdt = self%domgdt(iz)\n        gdomgdq = self%domgdq(iz)\n        ggrr = self%grr(iz)\n        ggrt = self%grt(iz)\n        ggrq = self%grq(iz)\n        ggtt = self%gtt(iz)\n        ggtq = self%gtq(iz)\n        ggqq = self%gqq(iz)\n        grootg_rtq = self%rootg_rtq(iz)\n\n       ! translate (r,t,q)->(x,y,z)\n       !   NOTE: cx*rho0/(cy*q_0=1) is used.\n        gdomgdx = gdomgdr/cx + s_hat*wzz*gdomgdq/cy\n        gdomgdy = - gdomgdq/cy\n        gdomgdz = gdomgdt + q_0*gdomgdq\n        ggxx = cx**2*ggrr\n        ggxy = cx**2*s_hat*wzz*ggrr + cx*cy*(q_0*ggrt - ggrq)\n        ggxz = cx*ggrt\n        ggyy = (cx*s_hat*wzz)**2*ggrr + 2._DP*cx*cy*s_hat*wzz*(q_0*ggrt-ggrq) &\n             + (cy*q_0)**2*ggtt - 2._DP*cy**2*q_0*ggtq + cy**2*ggqq\n        ggyz = cx*s_hat*wzz*ggrt + cy*q_0*ggtt - cy*ggtq\n        ggzz = ggtt\n        grootg_xyz = grootg_rtq/(cx*cy)\n\n       ! store (x,y,z)\n        self%domgdx(iz) = gdomgdx\n        self%domgdy(iz) = gdomgdy\n        self%domgdz(iz) = gdomgdz\n        self%gxx(iz) = ggxx\n        self%gxy(iz) = ggxy\n        self%gxz(iz) = ggxz\n        self%gyy(iz) = ggyy\n        self%gyz(iz) = ggyz\n        self%gzz(iz) = ggzz\n        self%rootg_xyz(iz) = grootg_xyz\n      end do\n\n  END SUBROUTINE metric_global_rtq2xyz\n\n\n!--------------------------------------\n  SUBROUTINE metric_fourier_init(self)\n!--------------------------------------\n    implicit none\n    class(metric_fourier), intent(inout) :: self\n    real(kind=DP) :: kzmin\n    integer :: iz\n\n      kzmin = 2._DP * pi / (2._DP * lz)\n      do iz = -global_nz, global_nz-1\n        self%kz(iz) = iz * kzmin\n      end do\n\n  END SUBROUTINE metric_fourier_init\n\n\n!--------------------------------------\n  SUBROUTINE forward_dft_globalz(zz_global,kz,fz,fk)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in),     &\n      dimension(-global_nz:global_nz-1) :: zz_global, kz, fz\n    complex(kind=DP), intent(out), & \n      dimension(-global_nz:global_nz-1) :: fk\n    integer :: iz, mz\n\n      fk(:) = (0._DP, 0._DP)\n      do mz = -global_nz, global_nz-1\n        do iz = -global_nz, global_nz-1\n          fk(mz) = fk(mz) + fz(iz)*exp(-ui*kz(mz)*zz_global(iz))*dz/(2._DP*lz)\n        end do\n      end do\n\n  END SUBROUTINE forward_dft_globalz\n\n\n!!--------------------------------------\n!  SUBROUTINE backward_dft_globalz(zz_global,kz,fk,fz)\n!!--------------------------------------\n!    implicit none\n!    real(kind=DP), intent(in),     &\n!      dimension(-global_nz:global_nz-1) :: zz_global, kz\n!    complex(kind=DP), intent(in), & \n!      dimension(-global_nz:global_nz-1) :: fk\n!    real(kind=DP), intent(out),     &\n!      dimension(-global_nz:global_nz-1) :: fz\n!    integer :: iz, mz\n!\n!      fz(:) = 0._DP\n!      do iz = -global_nz, global_nz-1\n!        do mz = -global_nz, global_nz-1\n!          fz(iz) = fz(iz) + real(fk(mz)*exp(ui*kz(mz)*zz_global(iz)), kind=DP)\n!        end do\n!      end do\n!\n!  END SUBROUTINE backward_dft_globalz\n\n\n!--------------------------------------\n  SUBROUTINE backward_dft_localz(zz_local,kz,fk,fz)\n!--------------------------------------\n    implicit none\n    real(kind=DP), intent(in),     &\n      dimension(-nz:nz-1) :: zz_local\n    real(kind=DP), intent(in),     &\n      dimension(-global_nz:global_nz-1) :: kz\n    complex(kind=DP), intent(in), & \n      dimension(-global_nz:global_nz-1) :: fk\n    real(kind=DP), intent(out),     &\n      dimension(-nz:nz-1) :: fz\n    integer :: iz, mz\n\n      fz(:) = 0._DP\n      do iz = -nz, nz-1\n        do mz = -global_nz, global_nz-1\n          fz(iz) = fz(iz) + real(fk(mz)*exp(ui*kz(mz)*zz_local(iz)), kind=DP)\n        end do\n      end do\n\n  END SUBROUTINE backward_dft_localz\n\n\n!--------------------------------------\n  ", "SUBROUTINE metric_fourier_dft_rtq2coef(self, mtr_g)\n!--------------------------------------\n    implicit none\n    class(metric_fourier), intent(inout) :: self\n    class(metric_global), intent(in) :: mtr_g\n    real(kind=DP), dimension(-global_nz:global_nz-1) :: theta_tilde\n\n    ! theta = zz + theta_tilde(zz), theta_tilde is a periodic function.\n      if (trim(equib_type) == \"vmec\") then\n        theta_tilde = mtr_g%theta - q_0 * mtr_g%zz! Axisymmetric toroidal angle phi_ax\n      else\n        theta_tilde = mtr_g%theta - mtr_g%zz\n      end if\n      call forward_dft_globalz(mtr_g%zz, self%kz, theta_tilde,   self%theta_tilde)\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%omg     , self%omg      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%domgdr  , self%domgdr   )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%domgdt  , self%domgdt   )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%domgdq  , self%domgdq   )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%grr     , self%grr      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%grt     , self%grt      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%grq     , self%grq      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%gtt     , self%gtt      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%gtq     , self%gtq      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%gqq     , self%gqq      )\n      call forward_dft_globalz(mtr_g%zz, self%kz, mtr_g%rootg_rtq, self%rootg_rtq)\n     ! NOTE:\n     ! Arguments are (zz_global(in),kz_global(in),omg_global(in),coef_global(out))\n\n  END SUBROUTINE metric_fourier_dft_rtq2coef\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_dft_coef2rtq(self, mtr_f)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_fourier), intent(in) :: mtr_f \n    real(kind=DP), dimension(-nz:nz-1) :: theta_tilde\n\n    ! theta = zz + theta_tilde(zz), theta_tilde is a periodic function.\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%theta_tilde, theta_tilde )\n      if (trim(equib_type) == \"vmec\") then\n        self%theta = q_0 * self%zz_labframe + theta_tilde! Axisymmetric toroidal angle phi_ax = q_0*zz + phi_tilde(zz)\n      else\n        self%theta = self%zz_labframe + theta_tilde\n      end if\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%omg     , self%omg      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%domgdr  , self%domgdr   )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%domgdt  , self%domgdt   )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%domgdq  , self%domgdq   )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%grr     , self%grr      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%grt     , self%grt      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%grq     , self%grq      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%gtt     , self%gtt      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%gtq     , self%gtq      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%gqq     , self%gqq      )\n      call backward_dft_localz(self%zz_labframe, mtr_f%kz, mtr_f%rootg_rtq, self%rootg_rtq)\n     ! NOTE:\n     ! Arguments are (zz_local(in),kz_global(in), coef_global(in), omg_local(out)).\n     ! Fourier coefficients have been evaluated in the lab frame at t=0.\n     ! self%zz_labframe (= z''+t*gamma_e/s_hat) is the time-dependent flux-coordinate theta in the lab frame.\n\n  END SUBROUTINE metric_local_dft_coef2rtq\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_rtq2xyz(self)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    real(kind=DP) :: wzz\n    real(kind=DP) :: gdomgdx, gdomgdy, gdomgdz, &\n                     ggxx, ggxy, ggxz, ggyy, ggyz, ggzz, grootg_xyz\n    real(kind=DP) :: gdomgdr, gdomgdt, gdomgdq, &\n                     ggrr, ggrt, ggrq, ggtt, ggtq, ggqq, grootg_rtq\n    integer :: iz\n\n      do iz = -nz, nz-1\n      ! load (r,t,q)=(rho,theta,zeta)\n        wzz = self%zz(iz)\n        gdomgdr = self%domgdr(iz)\n        gdomgdt = self%domgdt(iz)\n        gdomgdq = self%domgdq(iz)\n        ggrr = self%grr(iz)\n        ggrt = self%grt(iz)\n        ggrq = self%grq(iz)\n        ggtt = self%gtt(iz)\n        ggtq = self%gtq(iz)\n        ggqq = self%gqq(iz)\n        grootg_rtq = self%rootg_rtq(iz)\n\n      ! translate (r,t,q)->(x,y,z)\n      !   NOTE: cx*rho0/(cy*q_0=1) is used.\n        gdomgdx = gdomgdr/cx + s_hat*wzz*gdomgdq/cy\n        gdomgdy = - gdomgdq/cy\n        gdomgdz = gdomgdt + q_0*gdomgdq\n        ggxx = cx**2*ggrr\n        ggxy = cx**2*s_hat*wzz*ggrr + cx*cy*(q_0*ggrt - ggrq)\n        ggxz = cx*ggrt\n        ggyy = (cx*s_hat*wzz)**2*ggrr + 2._DP*cx*cy*s_hat*wzz*(q_0*ggrt-ggrq) &\n             + (cy*q_0)**2*ggtt - 2._DP*cy**2*q_0*ggtq + cy**2*ggqq\n        ggyz = cx*s_hat*wzz*ggrt + cy*q_0*ggtt - cy*ggtq\n        ggzz = ggtt\n        grootg_xyz = grootg_rtq/(cx*cy)\n\n      ! store (x,y,z)\n        self%domgdx(iz) = gdomgdx\n        self%domgdy(iz) = gdomgdy\n        self%domgdz(iz) = gdomgdz\n        self%gxx(iz) = ggxx\n        self%gxy(iz) = ggxy\n        self%gxz(iz) = ggxz\n        self%gyy(iz) = ggyy\n        self%gyz(iz) = ggyz\n        self%gzz(iz) = ggzz\n        self%rootg_xyz(iz) = grootg_xyz\n      end do\n\n  END SUBROUTINE metric_local_rtq2xyz\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_copy_global(self, mtr_g)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_global), intent(in) :: mtr_g\n    integer :: iz, giz\n\n      do iz = -nz, nz-1\n        giz = iz - global_nz + 2*nz * rankz + nz\n        self%zz_labframe(iz) = mtr_g%zz(giz)    \n        self%zz(iz)        = mtr_g%zz(giz)    \n        self%theta(iz)     = mtr_g%theta(giz) \n        self%omg(iz)       = mtr_g%omg(giz)   \n        self%domgdx(iz)    = mtr_g%domgdx(giz)\n        self%domgdy(iz)    = mtr_g%domgdy(giz)\n        self%domgdz(iz)    = mtr_g%domgdz(giz)\n        self%gxx(iz)       = mtr_g%gxx(giz)\n        self%gxy(iz)       = mtr_g%gxy(giz)\n        self%gxz(iz)       = mtr_g%gxz(giz)\n        self%gyy(iz)       = mtr_g%gyy(giz)\n        self%gyz(iz)       = mtr_g%gyz(giz)\n        self%gzz(iz)       = mtr_g%gzz(giz)\n        self%rootg_xyz(iz) = mtr_g%rootg_xyz(giz)\n      end do\n\n  END SUBROUTINE metric_local_copy_global\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_init(self, mtr_f, time_shearflow)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_fourier), intent(in) :: mtr_f\n    real(kind=DP), intent(in) :: time_shearflow\n\n      self%zz(:) = zz(:)\n      self%zz_labframe(:) = zz(:) + time_shearflow * gamma_e / s_hat\n      call self%dft_coef2rtq(mtr_f)\n      call self%rtq2xyz\n      \n  END SUBROUTINE metric_local_init\n\n\n!--------------------------------------\n  SUBROUTINE metric_local_update(self, mtr_f, dt_shearflow)\n!--------------------------------------\n    implicit none\n    class(metric_local), intent(inout) :: self\n    class(metric_fourier), intent(in) :: mtr_f\n    real(kind=DP), intent(in) :: dt_shearflow\n\n      self%zz_labframe(:) = self%zz_labframe(:) + dt_shearflow * gamma_e / s_hat\n      call self%dft_coef2rtq(mtr_f)\n      call self%rtq2xyz\n      \n  END SUBROUTINE metric_local_update\n\n      \nEND MODULE GKV_geom\n", "MODULE GKV_exb\n!-------------------------------------------------------------------------------\n!\n!    E x B term\n!\n!      GKV-plus r0.3 ( T.-H.Watanabe, Jun 2011)\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n  use GKV_mpienv\n  use GKV_fft, only: &\n           plan_xf_y2zm, plan_xf_y2x, &\n           plan_xb_y2zm, plan_xb_y2x, &\n           plan_yf_y2zm, plan_yf_y2x, &\n           plan_yb_y2zm, plan_yb_y2x, &\n           planr_xf_y2zm, planr_xf_y2x, &\n           planr_xb_y2zm, planr_xb_y2x, &\n           planr_yf_y2zm, planr_yf_y2x, &\n           planr_yb_y2zm, planr_yb_y2x, &\n           plan_x_forward, plan_x_backward, &\n           plan_y_forward, plan_y_backward\n  use GKV_clock, only: clock_sta, clock_end\n\n  implicit none\n\n  private\n\n  real(kind=DP), save :: exb_maxvx_eachrank, exb_maxvy_eachrank\n\n  integer, parameter :: nbuff = ((2*nz)*(nm+1)-1)/nprocw + 1\n                            !if ( mod(2*nz*(nm+1),nprocw) == 0 ) then\n                            !  nbuff = 2*nz*(nm+1)/nprocw\n                            !else\n                            !  nbuff = 2*nz*(nm+1)/nprocw + 1\n                            !end if\n  real(kind=DP), dimension(0:global_ny), save :: gky\n  integer, save :: nchunk_zm = 1, nchunk_yb = 1, nchunk_xb = 1\n\n  integer, save :: nchunk_yzm = 1, nchunk_xzm = 1\n\n  complex(kind=DP), save, dimension(0:ny,0:2*nxw-1) :: uikx_y2x, uiky_y2x\n\n\n  public   exb_NL_term, exb_maxvx_eachrank, exb_maxvy_eachrank\n\n\nCONTAINS\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term(hh, psi, chi, pb)\n!--------------------------------------\n!  Nonlinear term calculation interface\n    implicit none\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: pb\n\n    real(kind=DP) :: dky\n    integer, save :: iflg\n    integer :: my\n!$  integer :: nthreads, omp_get_num_threads\n    data iflg / 0 /\n                                               !%%% For debug %%%\n                                               !complex(kind=DP) ::                        &\n                                               !  whh(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm),   &\n                                               !  wpsi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm), &\n                                               !  wchi(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm)\n                                               !integer :: mx, iz, iv, im\n                                               !%%%%%%%%%%%%%%%%%\n\n    if( iflg == 0 ) then\n      iflg = 1\n      dky = ky(1) - ky(0)\n      do my = 0, global_ny\n        gky(my) = dky * real(my, kind=DP)\n      end do\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n!$OMP parallel default(shared)\n!$OMP master\n!$    nthreads = omp_get_num_threads()\n!$    if (nthreads > 1) then\n!$      nchunk_zm = ((2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_yb = ((global_ny+1)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_xb = ((2*nxw)*nbuff-1) / (nthreads-1) + 1\n!$      nchunk_yzm = ((iend_y-ist_y+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$      nchunk_xzm = ((iend_xw-ist_xw+1)*(2*nz)*(nm+1)-1) / (nthreads-1) + 1\n!$    end if\n!$OMP end master\n!$OMP end parallel\n    end if\n                                               !%%% For debug %%%\n                                               !whh(:,:,:,:,:) = (0._DP, 0._DP)\n                                               !wpsi(:,:,:,:) = (0._DP, 0._DP)\n                                               !wchi(:,:,:,:) = (0._DP, 0._DP)\n                                               !if (rankw == 0) then\n                                               !  whh(0,1,:,:,:) = (0.5_DP, 0._DP)\n                                               !  wpsi(2,0,:,:) = (0._DP, 0.5_DP)\n                                               !  wpsi(-2,0,:,:) = (0._DP, -0.5_DP)\n                                               !end if\n                                               !%%%%%%%%%%%%%%%%%\n\n    if (trim(calc_type) == \"nonlinear\") then\n\n#ifdef USE_TERM_Y2ZM\n        call exb_NL_term_y2zm(hh, psi, chi, pb)\n#else\n        call exb_NL_term_y2x(hh, psi, chi, pb)\n#endif\n\n    else\n\n!$OMP parallel workshare\n      pb(:,:,:,:,:) = ( 0._DP, 0._DP )\n!$OMP end parallel workshare\n\n    end if\n\n                                               !%%% For debug %%%\n                                               !if (rankz == 0 .and. rankv == 0 .and. rankm == 0 .and. ranks == 0) then\n                                               !  im = 0; iv = 1; iz = 0\n                                               !  do my = 0, ny\n                                               !    do mx = -nx, nx\n                                               !      write(80000+rankg,*) kx(mx), ky(my),  &\n                                               !  dble(whh(mx,my,iz,iv,im)), aimag(whh(mx,my,iz,iv,im)), &\n                                               !  dble(wpsi(mx,my,iz,im)), aimag(wpsi(mx,my,iz,im)), &\n                                               !  dble(pb(mx,my,iz,iv,im)), aimag(pb(mx,my,iz,iv,im))\n                                               !    end do\n                                               !    write(80000+rankg,*)\n                                               !  end do\n                                               !end if\n                                               !call MPI_Finalize(ierr_mpi)\n                                               !stop\n                                               !%%%%%%%%%%%%%%%%%\n\n\n  END SUBROUTINE exb_NL_term\n\n\n!--------------------------------------\n  SUBROUTINE exb_NL_term_y2zm( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:), allocatable :: &\n                      wc1o, wc2o, wc3o, wc4o,   wc1e, wc2e, wc3e, wc4e\n    complex(kind=DP), dimension(:,:,:), allocatable ::   &\n                         wwdxo, wwdyo, wwefo,      wwdxe, wwdye, wwefe\n\n    integer :: ix,iy,iz,im,ib,ip\n    integer :: iv\n\n      allocate(dpdx(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(dpdy(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(dadx(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(dady(0:nbuff-1,0:2*nxw-1,0:2*nyw-1))\n      allocate(wc1o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc2o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc3o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc4o(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc1e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc2e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc3e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wc4e(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1))\n      allocate(wwdxo(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwdyo(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwefo(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwdxe(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwdye(0:nbuff-1,0:2*nxw-1,0:global_ny))\n      allocate(wwefe(0:nbuff-1,0:2*nxw-1,0:global_ny))\n\n!$OMP parallel default(none)                          &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)       &\n!$OMP shared(wc1o,wc2o,wc3o,wc4o,wc1e,wc2e,wc3e,wc4e) &\n!$OMP shared(wwdxo,wwdyo,wwefo,wwdxe,wwdye,wwefe)     &\n!$OMP private(iv)\n\n!$OMP workshare\n      wc1o(:,:,:,:) = (0._DP, 0._DP)\n      wc3o(:,:,:,:) = (0._DP, 0._DP)\n      wc1e(:,:,:,:) = (0._DP, 0._DP)\n      wc3e(:,:,:,:) = (0._DP, 0._DP)\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!      call exb_pack_psi_y2zm(psi,wc3o)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3o,wc4o)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n!!$OMP barrier\n!      call exb_pack_psi_y2zm(chi,wc3e)\n!!$OMP barrier\n!      call exb_transpose_y2zm(wc3e,wc4e)\n!!$OMP barrier\n!      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!!$OMP barrier\n!      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!        call exb_pack_hh_y2zm(iv,hh,wc1o)\n!!$OMP barrier\n!        call exb_transpose_y2zm(wc1o,wc2o)\n!!$OMP barrier\n!        call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n!!$OMP barrier\n!        call exb_realspcal_y2zm(iv,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n!!$OMP barrier\n!        call exb_pack_zm2y(wwefo,wc3o)\n!!$OMP barrier\n!        call exb_transpose_zm2y(wc3o,wc4o)\n!!$OMP barrier\n!        call exb_unpack_zm2y(iv,wc4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2zm(psi,wc3o)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3o,wc4o)\n      call exb_pack_psi_y2zm(chi,wc3e)\n!$OMP barrier\n      call exb_transpose_y2zm(wc3e,wc4e)\n      call exb_unpack_y2zm(wc4o,wwdxo,wwdyo)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxo,wwdyo,dpdx,dpdy)\n      call exb_unpack_y2zm(wc4e,wwdxe,wwdye)\n!$OMP barrier\n      call exb_backwardfft_y2zm(wwdxe,wwdye,dadx,dady)\n      do iv = 1, 2*nv+6\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1e,wc2e)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3e,wc4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2o,wwdxo,wwdyo)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxe,wwdye,wwefe)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefo,wc3o)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2zm(wc1o,wc2o)\n          if (1+5<=iv .and. iv<=2*nv+5) call exb_transpose_zm2y(wc3o,wc4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2zm(iv,hh,wc1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_unpack_y2zm(wc2e,wwdxe,wwdye)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_realspcal_y2zm(iv-3,dpdx,dpdy,dadx,dady,wwdxo,wwdyo,wwefo)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_pack_zm2y(wwefe,wc3e)\n          if (1+6<=iv .and. iv<=2*nv+6) call exb_unpack_zm2y(iv-6,wc4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2zm(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wc1o)\n      deallocate(wc2o)\n      deallocate(wc3o)\n      deallocate(wc4o)\n      deallocate(wc1e)\n      deallocate(wc2e)\n      deallocate(wc3e)\n      deallocate(wc4e)\n      deallocate(wwdxo)\n      deallocate(wwdyo)\n      deallocate(wwefo)\n      deallocate(wwdxe)\n      deallocate(wwdye)\n      deallocate(wwefe)\n\n  END SUBROUTINE exb_NL_term_y2zm\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2zm ( psi, wc4 )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2zm)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(-nx:nx,0:ny,0:nbuff-1,0:nprocw-1) :: wc4\n!\n!    integer :: mx, my, iz, im, izm, ibuff, iprocw\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(2) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!\n!         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n!          izm = (2*nz)*im + (iz + nz)\n!          ibuff = mod(izm, nbuff)\n!          iprocw = izm / nbuff\n!          do my = ist_y, iend_y\n!            do mx = -nx, nx\n!              wc4(mx,my,ibuff,iprocw) = psi(mx,my,iz,im)\n!            end do\n!          end do\n!         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!\n!        end do\n!      end do\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2zm ( psi, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(ibuff,mx,my,iprocw) = psi(mx,my,iz,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2zm ( iv, hh, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% PACK: (kx,ky*,z*,m*)->(kx,ky,(z*,m*)*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              wc4(ibuff,mx,my,iprocw) = hh(mx,my,iz,iv,im)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_transpose_y2zm ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_y2zm ( wc4, wwdx, wwdy )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nx:nx) :: psi\n    complex(kind=DP), dimension(0:nbuff-1,0:global_ny,0:2*nxw-1) :: w1, w2\n    integer :: mx, my, ibuff, iprocw, global_my\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do global_my = 0, global_ny\n        iprocw = global_my / (ny+1)\n        my = mod(global_my, ny+1)\n        do mx = 0, nx\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = ui * kx(mx) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n        do mx = nx+1, 2*nxw-nx-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n        do mx = -nx,-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,2*nxw+mx) = ui * kx(mx) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xb_y2zm(ithd), w1, w2)\n\n      do global_my = 0, global_ny\n        do mx = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            wwdx(ibuff,mx,global_my) = w2(ibuff,global_my,mx)\n          end do\n        end do\n      end do\n\n      do global_my = 0, global_ny\n        iprocw = global_my / (ny+1)\n        my = mod(global_my, ny+1)\n        do mx = 0, nx\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = ui * gky(global_my) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n        do mx = nx+1, 2*nxw-nx-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,mx) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n        do mx = -nx,-1\n          do ibuff = 0, nbuff-1\n            w1(ibuff,global_my,2*nxw+mx) = ui * gky(global_my) * wc4(ibuff,mx,my,iprocw)\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xb_y2zm(ithd), w1, w2)\n\n      do global_my = 0, global_ny\n        do mx = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            wwdy(ibuff,mx,global_my) = w2(ibuff,global_my,mx)\n          end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_backwardfft_y2zm ( wwdx, wwdy, dpdx, dpdy )\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwdx, wwdy\n    real(kind=DP), intent(out), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(0:nbuff-1,0:2*nxw-1,0:nyw) :: w3\n    integer :: ix, ibuff\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n          w3(ibuff,ix,0:global_ny) = wwdx(ibuff,ix,0:global_ny)\n          w3(ibuff,ix,global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dpdx)\n\n      do ibuff = 0, nbuff-1\n        do ix = 0, 2*nxw-1\n          w3(ibuff,ix,0:global_ny) = wwdy(ibuff,ix,0:global_ny)\n          w3(ibuff,ix,global_ny+1:nyw) = (0._DP, 0._DP) ! FFTW may destroy input array!\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dpdy)\n\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2zm ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwdx, wwdy\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwef\n\n    complex(kind=DP), dimension(0:nbuff-1,0:2*nxw-1,0:nyw) :: w3\n    real(kind=DP), dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: ix, iy, ibuff, global_my\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do global_my = 0, global_ny\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = wwdx(ibuff,ix,global_my)\n          end do\n        end do\n      end do\n      do global_my = global_ny+1, nyw\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dhdx)\n\n      do global_my = 0, global_ny\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = wwdy(ibuff,ix,global_my)\n          end do\n        end do\n      end do\n      do global_my = global_ny+1, nyw\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w3(ibuff,ix,global_my) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2zm(ithd), w3, dhdy)\n\n      do iy = 0, 2*nyw-1\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            pbxy(ibuff,ix,iy) = cef * ( & ! Normalization for 2D Forward FFT\n                       (dpdx(ibuff,ix,iy) - cs1 * vl(iv) * dadx(ibuff,ix,iy)) * dhdy(ibuff,ix,iy) &\n                     - (dpdy(ibuff,ix,iy) - cs1 * vl(iv) * dady(ibuff,ix,iy)) * dhdx(ibuff,ix,iy))\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_r2c(planr_yf_y2zm(ithd), pbxy, w3)\n\n      do global_my = 0, global_ny\n        do ix = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            wwef(ibuff,ix,global_my) = w3(ibuff,ix,global_my)\n          end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2zm\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_zm2y ( wwef, wc4 )\n!--------------------------------------\n!     Data pack for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:global_ny) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n\n    complex(kind=DP), dimension(0:nbuff-1,0:global_ny,0:2*nxw-1) :: w1, w2\n    complex(kind=DP), dimension(-nx:nx) :: ef\n    integer :: mx, my, ibuff, iprocw, global_my\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                         ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!! !$OMP do schedule(dynamic)\n      do global_my = 0, global_ny\n        do mx = 0, 2*nxw-1\n          do ibuff = 0, nbuff-1\n            w2(ibuff,global_my,mx) = wwef(ibuff,mx,global_my) ! FFTW may destroy input array!\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xf_y2zm(ithd), w2, w1)\n\n      do global_my = 0, global_ny\n        iprocw = global_my / (ny+1)\n        my = mod(global_my, ny+1)\n        do mx = 0, nx\n          do ibuff = 0, nbuff-1\n            wc4(ibuff,mx,my,iprocw) = w1(ibuff,global_my,mx)\n          end do\n        end do\n        do mx = -nx, -1\n          do ibuff = 0, nbuff-1\n            wc4(ibuff,mx,my,iprocw) = w1(ibuff,global_my,2*nxw+mx)\n          end do\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_zm2y ( wc4in, wc4out )\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2zm)\n\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4in\n    complex(kind=DP), intent(out), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4out\n\n!$OMP master\n                                           call clock_sta(1440)\n                                         ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wc4in,                 &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         wc4out,                &\n                         (2*nx+1)*(ny+1)*nbuff, &\n                         MPI_DOUBLE_COMPLEX,    &\n                         fft_comm_world,        &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_zm2y ( iv, wc4, ef )\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2zm)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(0:nbuff-1,-nx:nx,0:ny,0:nprocw-1) :: wc4\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n    !complex(kind=DP), intent(inout), &\n    !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n    !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n    !      When the subroutine is called in a OpenMP parallel region, \n    !      the copied subarray may be treated as a thread-private variable.\n\n    integer :: mx, my, iz, im, izm, ibuff, iprocw\n\n!$OMP master\n                                           call clock_sta(1450)\n                                         ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do im = 0, nm\n        do iz = -nz, nz-1\n\n         !%%% UNPACK: (kx,ky,(z*,m*)*)->(kx,ky*,z*,m*) %%%\n          izm = (2*nz)*im + (iz + nz)\n          ibuff = mod(izm, nbuff)\n          iprocw = izm / nbuff\n          do my = ist_y, iend_y\n            do mx = -nx, nx\n              ef(mx,my,iz,iv,im) = wc4(ibuff,mx,my,iprocw)\n            end do\n          end do\n         !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n        end do\n      end do\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_zm2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2zm ( dpdx, dpdy, dadx, dady )\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(0:nbuff-1,0:2*nxw-1,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, ibuff, iv\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      iv = 2*nv\n!$OMP parallel default(none)                               &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)        &\n!$OMP shared(iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,ibuff,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n        do iy = 0, 2*nyw-1\n          do ix = 0, 2*nxw-1\n            do ibuff = 0, nbuff-1\n              wv_nl = abs(dpdy(ibuff,ix,iy) - cs1 * vl(iv) * dady(ibuff,ix,iy))\n              if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n        do iy = 0, 2*nyw-1\n          do ix = 0, 2*nxw-1\n            do ibuff = 0, nbuff-1\n              wv_nl = abs(dpdx(ibuff,ix,iy) - cs1 * vl(iv) * dadx(ibuff,ix,iy))\n              if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n            end do\n          end do\n        end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2zm\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_NL_term_y2x( hh, psi, chi, ef )\n!--------------------------------------\n!  ExB nonlinear term calculation \n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi, chi\n    complex(kind=DP), intent(out), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n\n    real(kind=DP), dimension(:,:,:,:), allocatable :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), dimension(:,:,:,:,:), allocatable :: &\n                                   wdx1o, wdy1o, wdx2o, wdy2o, wef3o, wef4o, &\n                                   wdx1e, wdy1e, wdx2e, wdy2e, wef3e, wef4e\n    integer :: iv, iprocw\n    integer       :: mx, my\n    integer, save :: iflg = 0\n\n      allocate(dpdx(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(dpdy(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(dadx(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(dady(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1))\n      allocate(wdx1o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy1o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdx2o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy2o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef3o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef4o(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdx1e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy1e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdx2e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wdy2e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef3e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n      allocate(wef4e(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1))\n\n      if( iflg == 0 ) then\n        iflg = 1\n\n!       uikx_y2x(:,:) = ( 0._DP, 0._DP )\n!       uiky_y2x(:,:) = ( 0._DP, 0._DP )\n        do mx = 0, nx\n          do my = ist_y, iend_y\n            uikx_y2x(my,mx) = kx(mx) * ui\n            uiky_y2x(my,mx) = ky(my) * ui\n          end do\n        end do\n        do mx = -nx, -1\n          do my = ist_y, iend_y\n            uikx_y2x(my,2*nxw+mx) = kx(mx) * ui\n            uiky_y2x(my,2*nxw+mx) = ky(my) * ui\n          end do\n        end do\n      end if\n\n!$OMP parallel default(none)                      &\n!$OMP shared(hh,psi,chi,ef,dpdx,dpdy,dadx,dady)   &\n!$OMP shared(wdx1o,wdy1o,wdx2o,wdy2o,wef3o,wef4o) &\n!$OMP shared(wdx1e,wdy1e,wdx2e,wdy2e,wef3e,wef4e) &\n!$OMP private(iv,iprocw)\n\n!$OMP workshare\n      ef(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1o(:,:,:,:,:) = (0._DP, 0._DP)\n      wdx1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wdy1e(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3o(:,:,:,:,:) = (0._DP, 0._DP)\n      wef3e(:,:,:,:,:) = (0._DP, 0._DP)\n      dpdx(:,:,:,:) = 0._DP\n      dpdy(:,:,:,:) = 0._DP\n      dadx(:,:,:,:) = 0._DP\n      dady(:,:,:,:) = 0._DP\n!$OMP end workshare\n\n\n!!%%% Without overlap %%%\n!      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1o,wdx2o)\n!      call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!!$OMP barrier\n!      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!!$OMP barrier\n!      call exb_transpose_y2x(wdx1e,wdx2e)\n!      call exb_transpose_y2x(wdy1e,wdy2e)\n!!$OMP barrier\n!      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n!!$OMP barrier\n!      do iv = 1, 2*nv\n!        call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n!!$OMP barrier\n!        call exb_transpose_y2x(wdx1o,wdx2o)\n!        call exb_transpose_y2x(wdy1o,wdy2o)\n!!$OMP barrier\n!        call exb_realspcal_y2x(iv,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n!!$OMP barrier\n!        call exb_transpose_x2y(wef3o,wef4o)\n!!$OMP barrier\n!        call exb_unpack_x2y(iv,wef4o,ef)\n!!$OMP barrier\n!      end do\n!!%%%%%%%%%%%%%%%%%%%%%%%\n\n\n!%%% With overlap %%%\n      call exb_pack_psi_y2x(psi,wdx1o,wdy1o)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1o,wdx2o)\n      call exb_transpose_y2x(wdy1o,wdy2o)\n      call exb_pack_psi_y2x(chi,wdx1e,wdy1e)\n!$OMP barrier\n      call exb_transpose_y2x(wdx1e,wdx2e)\n      call exb_transpose_y2x(wdy1e,wdy2e)\n      call exb_backwardfft_y2x(wdx2o,wdy2o,dpdx,dpdy)\n!$OMP barrier\n      call exb_backwardfft_y2x(wdx2e,wdy2e,dadx,dady)\n      do iv = 1, 2*nv+4\n        if (mod(iv,2) == 1) then ! odd\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1e,wdx2e)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1e,wdy2e)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3e,wef4e)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1o,wdy1o)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2o,wdy2o,wef3o)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4o,ef)\n        else                     ! even\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdx1o,wdx2o)\n          if (1+1<=iv .and. iv<=2*nv+1) call exb_transpose_y2x(wdy1o,wdy2o)\n          if (1+3<=iv .and. iv<=2*nv+3) call exb_transpose_x2y(wef3o,wef4o)\n          if (1  <=iv .and. iv<=2*nv  ) call exb_pack_hh_y2x(iv,hh,wdx1e,wdy1e)\n          if (1+2<=iv .and. iv<=2*nv+2) call exb_realspcal_y2x(iv-2,dpdx,dpdy,dadx,dady,wdx2e,wdy2e,wef3e)\n          if (1+4<=iv .and. iv<=2*nv+4) call exb_unpack_x2y(iv-4,wef4e,ef)\n        end if\n!$OMP barrier\n      end do\n!%%%%%%%%%%%%%%%%%%%%\n\n!$OMP end parallel\n\n      call exb_estimate_maxvel_y2x(dpdx,dpdy,dadx,dady)\n\n      deallocate(dpdx)\n      deallocate(dpdy)\n      deallocate(dadx)\n      deallocate(dady)\n      deallocate(wdx1o)\n      deallocate(wdy1o)\n      deallocate(wdx2o)\n      deallocate(wdy2o)\n      deallocate(wef3o)\n      deallocate(wef4o)\n      deallocate(wdx1e)\n      deallocate(wdy1e)\n      deallocate(wdx2e)\n      deallocate(wdy2e)\n      deallocate(wef3e)\n      deallocate(wef4e)\n\n  END SUBROUTINE exb_NL_term_y2x\n\n\n!!--------------------------------------\n!  SUBROUTINE exb_pack_y2x ( psi, wwdx, wwdy )\n!!--------------------------------------\n!!     Data pack for E x B term calculation (y2x)\n!\n!    complex(kind=DP), intent(in), &\n!      dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: psi\n!    complex(kind=DP), intent(inout), &\n!      dimension(0:ny,0:nxw_size,-nz:nz-1,0:nm,0:nprocw-1) :: wwdx, wwdy\n!\n!    complex(kind=DP), dimension(0:2*nxw-1) :: w1, w2\n!    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n!\n!!$OMP master\n!                                           call clock_sta(1410)\n!                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!!$OMP end master\n!!$OMP do collapse(3) schedule(dynamic)\n!      do im = 0, nm\n!        do iz = -nz, nz-1\n!          do my = ist_y, iend_y\n!\n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * kx(0:nx) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * kx(-nx:-1) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdx(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!           !%%% Backward x-FFT (kx,ky)->(x,ky) %%%\n!            w1(0:nx) = ui * ky(my) * psi(0:nx,my,iz,im)\n!            w1(nx+1:2*nxw-nx-1) = (0._DP, 0._DP) ! FFTW may destroy input array!\n!            w1(2*nxw-nx:2*nxw-1) = ui * ky(my) * psi(-nx:-1,my,iz,im)\n!            call dfftw_execute_dft(plan_x_backward, w1, w2)\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!           !%%% PACK: (x,ky*,z*,m*)->(ky,x*,z*,m*) %%%\n!            do irank = 0, nprocw-1\n!              ist_xw_g_rank  = (nxw_size+1)*irank\n!              iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n!              do ix = ist_xw_g_rank, iend_xw_g_rank\n!                wwdy(my,ix-ist_xw_g_rank,iz,im,irank) = w2(ix)\n!              enddo\n!            enddo\n!           !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!  \n!          enddo\n!        enddo\n!      enddo\n!!$OMP end do nowait\n!!$OMP master\n!                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n!                                           call clock_end(1410)\n!!$OMP end master\n!\n!  END SUBROUTINE exb_pack_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_psi_y2x ( psi, wwdx, wwdy ) !done\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz-nzb:nz-1+nzb,0:nm) :: psi\n    complex(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1a, w2a\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1b, w2b\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n    complex(kind=DP) :: ww\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do my = ist_y, iend_y\n        do ix = 0, nx\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = psi(ix,my,iz,im)\n          enddo\n          enddo\n        enddo\n      enddo\n      do my = ist_y, iend_y\n        do ix = nx+1, 2*nxw-nx-1\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          enddo\n          enddo\n        enddo\n      enddo\n      do my = ist_y, iend_y\n        do ix = -nx, -1\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,2*nxw+ix) = psi(ix,my,iz,im)\n          enddo\n          enddo\n        enddo\n      enddo\n\n      do my = ist_y, iend_y\n        do ix = 0, 2*nxw-1\n          do im = 0, nm\n          do iz = -nz, nz-1\n            ww = w1a(iz,im,my,ix)\n            w1a(iz,im,my,ix) = uikx_y2x(my,ix) * ww\n            w1b(iz,im,my,ix) = uiky_y2x(my,ix) * ww\n          enddo\n          enddo\n        enddo\n      enddo\n\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1a, w2a)\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1b, w2b)\n\n      do irank = 0, nprocw-1\n        ist_xw_g_rank  = (nxw_size+1)*irank\n        iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n        do my = ist_y, iend_y\n          do ix = ist_xw_g_rank, iend_xw_g_rank\n            do im = 0, nm\n              do iz = -nz, nz-1\n                wwdx(iz,im,ix-ist_xw_g_rank,my,irank) = w2a(iz,im,my,ix)\n                wwdy(iz,im,ix-ist_xw_g_rank,my,irank) = w2b(iz,im,my,ix)\n              enddo\n            enddo\n          enddo\n        enddo\n      enddo\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_psi_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_pack_hh_y2x ( iv, hh, wwdx, wwdy ) !done\n!--------------------------------------\n!     Data pack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: hh\n    complex(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1a, w2a\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1b, w2b\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n    complex(kind=DP) :: ww\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1410)\n                                         ! call fapp_start(\"nlterm_pack\",1410,1)\n!$OMP end master\n!!TBI!! !$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do my = ist_y, iend_y\n       do ix = 0, nx\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = hh(ix,my,iz,iv,im)\n          enddo\n        enddo\n       enddo\n      enddo\n      do my = ist_y, iend_y\n       do ix = nx+1, 2*nxw-nx-1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,ix) = (0._DP, 0._DP) ! FFTW may destroy input array!\n          enddo\n        enddo\n       enddo\n      enddo\n      do my = ist_y, iend_y\n       do ix = -nx, -1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w1a(iz,im,my,2*nxw+ix) = hh(ix,my,iz,iv,im)\n          enddo\n        enddo\n       enddo\n      enddo\n\n      do my = ist_y, iend_y\n       do ix = 0, 2*nxw-1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            ww = w1a(iz,im,my,ix)\n            w1a(iz,im,my,ix) = uikx_y2x(my,ix) * ww\n            w1b(iz,im,my,ix) = uiky_y2x(my,ix) * ww\n          enddo\n        enddo\n       enddo\n      enddo\n\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1a, w2a)\n      call dfftw_execute_dft(planr_xb_y2x(ithd), w1b, w2b)\n\n      do irank = 0, nprocw-1\n        ist_xw_g_rank  = (nxw_size+1)*irank\n        iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n        do my = ist_y, iend_y\n          do ix = ist_xw_g_rank, iend_xw_g_rank\n            do im = 0, nm\n              do iz = -nz, nz-1\n                wwdx(iz,im,ix-ist_xw_g_rank,my,irank) = w2a(iz,im,my,ix)\n                wwdy(iz,im,ix-ist_xw_g_rank,my,irank) = w2b(iz,im,my,ix)\n              enddo\n            enddo\n          enddo\n        enddo\n      enddo\n!!TBI!! !$OMP end do nowait\n!$OMP master\n                                         ! call fapp_stop(\"nlterm_pack\",1410,1)\n                                           call clock_end(1410)\n!$OMP end master\n\n  END SUBROUTINE exb_pack_hh_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_y2x ( wwin, wwout ) !done\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1420)\n                                         ! call fapp_start(\"nlterm_alltoall1\",1420,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                         ! call fapp_stop(\"nlterm_alltoall1\",1420,1)\n                                           call clock_end(1420)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_y2x\n\n\n!--------------------------------------\n  ", "SUBROUTINE exb_backwardfft_y2x ( wwdx, wwdy, dpdx, dpdy )!done\n!--------------------------------------\n!     Backward FFT of field(psi,chi) for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n    real(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1) :: dpdx, dpdy\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:nyw) :: w3\n    real(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:2*nyw-1) :: wtmp\n    integer :: ix, my, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdx(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n        do ix = ist_xw, iend_xw\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n          end do\n        end do\n      end do\n\n!!TBI!! call dfftw_execute_dft_c2r(plan_yb_y2x(ithd), w3, dpdx(0,ist_xw,iz,im))\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, wtmp)\n      do my = 0, 2*nyw-1\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n         do iz = -nz, nz-1\n          dpdx(iz,im,ix,my) = wtmp(iz,im,ix,my)\n         end do\n        end do\n       end do\n      end do\n\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdy(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n        do ix = ist_xw, iend_xw\n          do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n          end do\n        end do\n      end do\n\n!!TBI!! call dfftw_execute_dft_c2r(plan_yb_y2x(ithd), w3, dpdy(0,ist_xw,iz,im))\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, wtmp)\n      do my = 0, 2*nyw-1\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n         do iz = -nz, nz-1\n          dpdy(iz,im,ix,my) = wtmp(iz,im,ix,my)\n         end do\n        end do\n       end do\n      end do\n\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_backwardfft_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_realspcal_y2x ( iv, dpdx, dpdy, dadx, dady, wwdx, wwdy, wwef )!done\n!--------------------------------------\n!     Calculate Poisson brackets for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    real(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwdx, wwdy\n    complex(kind=DP), intent(inout), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwef\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:nyw) :: w3\n    real(kind=DP), dimension(-nz:nz-1,0:nm,ist_xw:iend_xw,0:2*nyw-1) :: dhdx, dhdy, pbxy\n    real(kind=DP) :: cef, cs1\n    integer :: my, ix, iy, iz, im, irank, ist_y_g_rank, iend_y_g_rank\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n      cef = 1._DP / real(2*nxw*2*nyw, kind=DP)\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n\n!$OMP master\n                                           call clock_sta(1430)\n                                        ! call fapp_start(\"nlterm_realspcal\",1430,1)\n!$OMP end master\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdx(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n        end do\n       end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, dhdx)\n\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w3(iz,im,ix,my) = wwdy(iz,im,ix,my-ist_y_g_rank,irank)\n              end do\n            end do\n          end do\n        end do\n      end do\n      do my = global_ny+1, nyw\n       do ix = ist_xw, iend_xw\n        do im = 0, nm\n          do iz = -nz, nz-1\n            w3(iz,im,ix,my) = ( 0._DP, 0._DP )! FFTW may destroy input array!\n          end do\n        end do\n       end do\n      end do\n\n      call dfftw_execute_dft_c2r(planr_yb_y2x(ithd), w3, dhdy)\n\n!NEC$ NOINTERCHANGE\n      do iy = 0, 2*nyw-1\n!NEC$ NOINTERCHANGE\n        do ix = ist_xw, iend_xw\n!NEC$ NOINTERCHANGE\n          do im = 0, nm\n!NEC$ NOINTERCHANGE\n            do iz = -nz, nz-1\n              pbxy(iz,im,ix,iy) = cef * ( &! Normalization for 2D Forward FFT\n                         (dpdx(iz,im,ix,iy) - cs1 * vl(iv) * dadx(iz,im,ix,iy)) * dhdy(iz,im,ix,iy) &\n                       - (dpdy(iz,im,ix,iy) - cs1 * vl(iv) * dady(iz,im,ix,iy)) * dhdx(iz,im,ix,iy))\n            end do\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft_r2c(planr_yf_y2x(ithd), pbxy, w3)\n\n      do irank = 0, nprocw-1\n        ist_y_g_rank  = (ny+1)*irank\n        iend_y_g_rank = min( (ny+1)*(irank+1)-1, global_ny )\n        do my = ist_y_g_rank, iend_y_g_rank\n          do ix = ist_xw, iend_xw\n            do im = 0, nm\n              do iz = -nz, nz-1\n                wwef(iz,im,ix,my-ist_y_g_rank,irank) = w3(iz,im,ix,my)\n              end do\n            end do\n          end do\n        end do\n      end do\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_realspcal\",1430,1)\n                                           call clock_end(1430)\n!$OMP end master\n\n  END SUBROUTINE exb_realspcal_y2x\n\n\n!--------------------------------------\n  SUBROUTINE exb_transpose_x2y ( wwin, wwout )!done\n!--------------------------------------\n!     Data transpose for E x B term calculation (y2x)\n\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwin\n    complex(kind=DP), intent(out), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwout\n\n!$OMP master\n                                           call clock_sta(1440)\n                                        ! call fapp_start(\"nlterm_alltoall2\",1440,1)\n      call MPI_Alltoall( wwin,                              &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         wwout,                             &\n                         (ny+1)*(nxw_size+1)*(2*nz)*(nm+1), &\n                         MPI_DOUBLE_COMPLEX,                &\n                         fft_comm_world,                    &\n                         ierr_mpi )\n                                        ! call fapp_stop(\"nlterm_alltoall2\",1440,1)\n                                           call clock_end(1440)\n!$OMP end master\n\n  END SUBROUTINE exb_transpose_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_unpack_x2y ( iv, wwef, ef )!done\n!--------------------------------------\n!     Data unpack for E x B term calculation (y2x)\n\n    integer, intent(in) :: iv\n    complex(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:ny,0:nprocw-1) :: wwef\n    complex(kind=DP), intent(inout), &\n      dimension(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) :: ef\n   !complex(kind=DP), intent(inout), &\n   !  dimension(-nx:nx,0:ny,-nz:nz-1,0:nm) :: ef\n   !NOTE: A noncontiguous subarray as an argument of a subroutine induces a memory copy.\n   !      When the subroutine is called in a OpenMP parallel region, \n   !      the copied subarray may be treated as a thread-private variable.\n\n    complex(kind=DP), dimension(-nz:nz-1,0:nm,ist_y:iend_y,0:2*nxw-1) :: w1, w2\n    integer :: ix, my, iz, im, irank, ist_xw_g_rank, iend_xw_g_rank\n\n    integer :: ithd\n!$  integer :: omp_get_thread_num\n\n     ithd = 0\n#ifndef OMP_INSIDE_FFTW\n!$   ithd = omp_get_thread_num()\n#endif\n\n!$OMP master\n                                           call clock_sta(1450)\n                                        ! call fapp_start(\"nlterm_unpack\",1450,1)\n!$OMP end master\n!!TBI!!!$OMP do collapse(2) schedule(dynamic,nchunk_zm)\n      do irank = 0, nprocw-1\n        ist_xw_g_rank  = (nxw_size+1)*irank\n        iend_xw_g_rank = min( (nxw_size+1)*(irank+1)-1, (2*nxw-1) )\n        do my = ist_y, iend_y\n          do ix = ist_xw_g_rank, iend_xw_g_rank\n            do im = 0, nm\n              do iz = -nz, nz-1\n                w2(iz,im,my,ix) = wwef(iz,im,ix-ist_xw_g_rank,my,irank)\n              enddo\n            end do\n          end do\n        end do\n      end do\n\n      call dfftw_execute_dft(planr_xf_y2x(ithd), w2, w1)\n\n      do my = ist_y, iend_y\n       do ix = 0, nx\n        do im = 0, nm\n          do iz = -nz, nz-1\n            ef(ix,my,iz,iv,im) = w1(iz,im,my,ix)\n          end do\n        end do\n       end do\n      end do\n      do my = ist_y, iend_y\n       do ix = -nx, -1\n        do im = 0, nm\n          do iz = -nz, nz-1\n            ef(ix,my,iz,iv,im) = w1(iz,im,my,2*nxw+ix)\n          end do\n        end do\n       end do\n      end do\n!!TBI!!!$OMP end do nowait\n!$OMP master\n                                        ! call fapp_stop(\"nlterm_unpack\",1450,1)\n                                           call clock_end(1450)\n!$OMP end master\n\n  END SUBROUTINE exb_unpack_x2y\n\n\n!--------------------------------------\n  SUBROUTINE exb_estimate_maxvel_y2x ( dpdx, dpdy, dadx, dady )!done\n!--------------------------------------\n!     Estimate time step restriction in each MPI processes\n\n    real(kind=DP), intent(in), &\n      dimension(-nz:nz-1,0:nm,0:nxw_size,0:2*nyw-1) :: dpdx, dpdy, dadx, dady\n\n    real(kind=DP) :: cs1, wv_nl\n    integer :: ix, iy, iz, iv, im\n\n      exb_maxvx_eachrank = eps\n      exb_maxvy_eachrank = eps\n\n      cs1 = sqrt(tau(ranks) / Anum(ranks))\n      im = 0\n        iv = 2*nv\n!$OMP parallel default(none)                                  &\n!$OMP shared(exb_maxvx_eachrank,exb_maxvy_eachrank)           &\n!$OMP shared(im,iv,ist_xw,iend_xw,dpdx,dpdy,dadx,dady,cs1,vl) &\n!$OMP private(iy,ix,iz,wv_nl)\n\n!$OMP do collapse(2) reduction(max:exb_maxvx_eachrank)\n          do iy = 0, 2*nyw-1\n            do ix = ist_xw, iend_xw\n              do iz = -nz, nz-1\n                wv_nl = abs(dpdy(iz,im,ix,iy) - cs1 * vl(iv) * dady(iz,im,ix,iy))\n                if (exb_maxvx_eachrank < wv_nl) exb_maxvx_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP do collapse(2) reduction(max:exb_maxvy_eachrank)\n          do iy = 0, 2*nyw-1\n            do ix = ist_xw, iend_xw\n              do iz = -nz, nz-1\n                wv_nl = abs(dpdx(iz,im,ix,iy) - cs1 * vl(iv) * dadx(iz,im,ix,iy))\n                if (exb_maxvy_eachrank < wv_nl) exb_maxvy_eachrank = wv_nl\n              end do\n            end do\n          end do\n!$OMP end do\n\n!$OMP end parallel\n\n  END SUBROUTINE exb_estimate_maxvel_y2x\n\n\nEND MODULE GKV_exb\n", " &cmemo memo=\"GKV-plus f0.61 developed for pre-exa-scale computing\", &end\n &calct calc_type=\"lin_freq\",\n        z_bound=\"outflow\",\n        z_filt=\"off\",\n        z_calc=\"cf4\",\n        art_diff=0.1d0,\n        init_random=.false.,\n        num_triad_diag=0, &end\n &triad mxt = 0, myt = 0/\n &equib equib_type = \"analytic\", &end\n &run_n inum=%%%,\n        ch_res =.false., &end\n &files f_log=\"%%DIR%%/log/gkvp.\",\n        f_hst=\"%%DIR%%/hst/gkvp.\",\n        f_phi=\"%%DIR%%/phi/gkvp.\",\n        f_fxv=\"%%DIR%%/fxv/gkvp.\",\n        f_cnt=\"%%DIR%%/cnt/gkvp.\", &end\n &runlm e_limit = 60.d0, &end\n &times tend = 200.d0,\n        dtout_fxv = 10.d0,\n        dtout_ptn = 0.1d0,\n        dtout_eng = 0.1d0,\n        dtout_dtc = 0.1d0, &end\n &deltt dt_max = 0.01d0,\n        adapt_dt =.true., \n        courant_num = 0.5d0,\n        time_advnc = \"auto_init\", &end\n &physp R0_Ln = 2.22d0,\n        R0_Lt = 6.92d0,\n        nu = 1.d0,\n        Anum = 1.d0,\n        Znum = 1.d0,\n        fcs = 1.d0,\n        sgn = 1.d0,\n        tau = 1.d0,\n        dns1 = 1.d-2,\n        tau_ad = 1.d0,\n        lambda_i = 0.d0,\n        beta = 0.d0,\n        ibprime = 0,\n        vmax = 4.5d0,\n        nx0 = 10000, &end\n &rotat mach = 0.d0,\n        uprime = 0.d0,\n        gamma_e = 0.d0, &end\n &nperi n_tht = 3, \n        kymin = 0.05d0, \n        m_j   = 1, \n        del_c = 0.d0, &end\n &confp eps_r    = 0.18d0,\n        eps_rnew = 1.d0,\n        q_0      = 1.4d0,\n        s_hat    = 0.8d0,\n        lprd     = 0.d0,\n        mprd     = 0.d0,\n        eps_hor  = 0.d0,\n        eps_mor  = 0.d0,\n        eps_por  = 0.d0,\n        rdeps00  = 0.d0,\n        rdeps1_0 = 1.d0,\n        rdeps1_10= 0.d0,\n        rdeps2_10= 0.d0,\n        rdeps3_10= 0.d0,\n        malpha   = 0.d0,    &end\n\n &ring  ring_a = 0.5d0,\n        kxmin  = 0.05d0, &end\n\n &vmecp s_input = 0.5d0,\n          nss = 501,\n          ntheta = 384,      \n          nzeta  = 0,      &end\n &bozxf f_bozx=\"%%DIR%%/vmec/\",  &end\n\n &igsp s_input = 0.5d0,\n          mc_type = 0,\n          q_type = 1,\n          nss = 101,\n          ntheta = 49,      &end\n &igsf f_igs=\"%%DIR%%/eqdsk/\",  &end\n\n &nu_ref Nref = 4.5d19,\n         Lref = 1.7d0,\n         Tref = 2.d0,\n         col_type = \"LB\",\n         iFLR = 1,\n         icheck = 0, &end\n", "### Fujitsu Fortran Compiler ###\nFC = mpifrtpx\nFFLAGS = -Kfast,parallel # Optimization\nFFLAGS += -X9 # Fortran95\nFFLAGS += -Koptmsg=2 -Nlst=t # Optimization report\nFFLAGS += -fw # Suppress message\nFFLAGS += -Kopenmp #-Nfjomplib # OpenMP\nFFLAGS += -mcmodel=large # Static memory larger than 2GB\n#FFLAGS += -Haefosux -NRtrap #-O0 # Debug\nOPTRPT = 'lst'\n#FFLAGS += -Nfjprof # Fujitsu profiler fapp\nFFLAGS += -Ksimd_nouse_multiple_structures # Specific option for compiler tcs1.2.26 to avoid slowing down GKV\nFFLAGS += -Knosch_pre_ra # Specific option for compiler tcs1.2.26 to avoid slowing down GKV\nINC = \nLIB =\n\n\nPROG = 'gkvp.exe'\n\nSRC =../src/\nMYL =../lib/\n\nMATH = gkvp_math_portable\n\nFFT = gkvp_fft_fftw\n### Usage of FFTW (module load fftw-tune)\nifeq ($(FFT),gkvp_fft_fftw)\n  #INC += -I$(FFTW_DIR)/include\n  #LIB += -L$(FFTW_DIR)/lib -lfftw3 -lm\n  LIB += -lfftw3 -lm\nendif\n\nFILEIO=gkvp_fileio_fortran\n#FILEIO=gkvp_fileio_netcdf\n### Usage of NetCDF (module load netcdf-fortran netcdf-c phdf5)\n### NetCDF does not work on the FLOW supercomputer for now, Jan 17 2021\nifeq ($(FILEIO),gkvp_fileio_netcdf)\n  #INC += -I$(NETCDF_FORTRAN_DIR)/include -I$(NETCDF_DIR)/include -I$(PHDF5_DIR)/include\n  #LIB += -L$(NETCDF_FORTRAN_DIR)/lib -L$(NETCDF_DIR)/lib -L$(PHDF5_DIR)/lib -lnetcdff -lnetcdf -lhdf5_hl -lhdf5\n  LIB += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5\nendif\n\n\ngkvp:\t$(SRC)gkvp_header.f90\\\n\t$(SRC)gkvp_mpienv.f90\\\n\t$(MYL)$(MATH).f90\\\n\t$(SRC)gkvp_clock.f90\\\n\t$(SRC)$(FILEIO).f90\\\n\t$(SRC)gkvp_intgrl.f90\\\n\t$(SRC)gkvp_tips.f90\\\n\t$(SRC)gkvp_vmecbzx.f90\\\n\t$(SRC)gkvp_igs.f90\\\n\t$(SRC)gkvp_ring.f90\\\n\t$(SRC)gkvp_bndry.f90\\\n\t$(SRC)gkvp_colli.f90\\\n\t$(SRC)$(FFT).f90\\\n\t$(SRC)gkvp_fld.f90\\\n\t$(SRC)gkvp_colliimp.f90\\\n\t$(SRC)gkvp_freq.f90\\\n\t$(SRC)gkvp_zfilter.f90\\\n\t$(SRC)gkvp_geom.f90\\\n\t$(SRC)gkvp_exb.f90\\\n\t$(SRC)gkvp_trans.f90\\\n\t$(SRC)gkvp_advnc.f90\\\n\t$(SRC)gkvp_shearflow.f90\\\n\t$(SRC)gkvp_dtc.f90\\\n\t$(SRC)gkvp_out.f90\\\n\t$(SRC)gkvp_set.f90\\\n\t$(SRC)gkvp_main.f90\n\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_header.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_mpienv.f90\n\t$(FC) $(FFLAGS) -c $(MYL)$(MATH).f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_clock.f90\n\t$(FC) $(FFLAGS) -c $(SRC)$(FILEIO).f90 $(INC)\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_intgrl.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_tips.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_vmecbzx.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_igs.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_ring.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_bndry.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_colli.f90\n\t$(FC) $(FFLAGS) -c $(SRC)$(FFT).f90 $(INC)\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_fld.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_colliimp.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_freq.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_zfilter.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_geom.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_exb.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_trans.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_advnc.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_shearflow.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_dtc.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_out.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_set.f90\n\t$(FC) $(FFLAGS) -c $(SRC)gkvp_main.f90\n\n\t$(FC) $(FFLAGS)\t\\\n\t\t\tgkvp_header.o\\\n\t\t\tgkvp_mpienv.o\\\n\t\t\t$(MATH).o\\\n\t\t\tgkvp_clock.o\\\n\t\t\t$(FILEIO).o\\\n\t\t\tgkvp_intgrl.o\\\n\t\t\tgkvp_tips.o\\\n\t\t\tgkvp_vmecbzx.o\\\n\t\t\tgkvp_igs.o\\\n\t\t\tgkvp_ring.o\\\n\t\t\tgkvp_bndry.o\\\n\t\t\tgkvp_colli.o\\\n\t\t\t$(FFT).o\\\n\t\t\tgkvp_fld.o\\\n\t\t\tgkvp_colliimp.o\\\n\t\t\tgkvp_freq.o\\\n\t\t\tgkvp_zfilter.o\\\n\t\t\tgkvp_geom.o\\\n\t\t\tgkvp_exb.o\\\n\t\t\tgkvp_trans.o\\\n\t\t\tgkvp_advnc.o\\\n\t\t\tgkvp_shearflow.o\\\n\t\t\tgkvp_dtc.o\\\n\t\t\tgkvp_out.o\\\n\t\t\tgkvp_set.o\\\n                        gkvp_main.o\\\n\t\t\t-o $(PROG) $(LIB)\n\n\tcp *.o *.mod *.$(OPTRPT)../src/\n\trm -f *.o *.mod *.$(OPTRPT)\n\nclean:\n\trm -f../src/*.o../src/*.mod../src/*.$(OPTRPT)./*.exe./sub.q.*.o* \\\n\t     ./*.o./*.mod./*.$(OPTRPT)./*namelist.*./sub.q.*\n\nclear:\n\trm -f./*.o./*.mod./*.$(OPTRPT)./*namelist.*./sub.q.*\n \n", "#!/bin/sh\n\n###  NOTE  ###\n###  Flow supercomputer Type I sub-system, PRIMEHPC FX1000 (Nagoya Univ, 2020)\n###\n###  - Computation nodes(total 2304 nodes)\n###      CPU: A64FX (2.0GHz, 12coresx4CMG=48cores, 512bit SIMD) x1 per node\n###      Peak performance: DP 3.379 TFLOPS per node (Boost: 3.3792 TFLOPS)\n###      Cache L1: 64 KiB, 4 way\n###      Cache L1 Bandwidth: 230+ GB/s(load), 115+ GB/s (store)\n###      Cache L2: 8 MiB, 16 way per CMG(NUMA), 4CMG per node\n###      Cache L2 Bandwidth: 3.6+ TB/s per node\n###                          115+ GB/s(load), 57+ GB/s(store) per core\n###      Memory: HBM2 32 GiB\n###      Memory Bandwidth: 1024 GB/s per node\n###\n###      Therefore, a recommended GKV parallelization may be \n###          (MPI Processes)x(12 OpenMP Threads)\n###          =(12 cores per CMG)x(4 CMG)x(Node numbers)\n###      1 MPI process should be assigined to 1 CMG.\n###\n###  - Interconnect\n###      Tofu Interconnect D (28 Gbps x 2 lane x 10 port)\n###      [Performance] 8B Put latency: 0.49-0.54 usec\n###                    1MiB Put throughput: 6.35 GB/s\n###\n###  - Job class (May 2020)\n###      fx-debug  :  1 - 36  nodes,   1 hour,  50 run/300 submit\n###      fx-small  :  1 - 24  nodes, 168 hour, 100 run/300 submit\n###      fx-middle : 12 - 96  nodes,  72 hour,  50 run/300 submit\n###      fx-large  : 96 - 192 nodes,  72 hour,  25 run/300 submit\n###      fx-xlarge : 96 - 768 nodes,  24 hour,   5 run/300 submit\n###\n###  - Commands\n###      (Submit a batch job : \"pjsub sub.q\") Use shoot script for GKV.\n###      Check job status    : \"pjstat\" or \"pjstat -E\" for step jobs\n###      Delete job          : \"pjdel JOBID\"\n###      Show budget info    : \"charge\"\n###      Show disk usage     : \"lfs quota -u (YOUR ACCOUNT ID) /home\"\n###                          : \"lfs quota -u (YOUR ACCOUNT ID) /data\"\n##############\n\n#PJM --rsc-list \"rscgrp=fx-debug\"\n#PJM --rsc-list \"node=8\"       \n#### --rsc-list \"node=5x8x8\"       \n#PJM --rsc-list \"elapse=00:10:00\"\n#PJM --mpi \"proc=32\"           \n#### --mpi \"rank-map-bynode\"\n#### --mpi \"rank-map-hostfile=rankmapfile.dat\"\n#PJM -j                          \n#PJM -s                           \n\nNUM_NODES=${PJM_NODE}             # Nodes\nNUM_CORES=12                      # Cores per node\nNUM_PROCS=$(( ${NUM_NODES} * 4 )) # MPI processes\nexport OMP_NUM_THREADS=12         # OpenMP threads per MPI\n\n\necho \"                  Nodes: ${NUM_NODES}\"\necho \"         Cores per node: ${NUM_CORES}\"\necho \"          MPI Processes: ${NUM_PROCS}\"\necho \" OpenMP threads per MPI: ${OMP_NUM_THREADS}\"\n\n\n\n### Working directory \nDIR=%%DIR%%\nLDM=gkvp.exe\nNL=gkvp_namelist.%%%\n\nexport XOS_MMM_L_PAGING_POLICY=demand:demand:demand # For Largepage\n\nexport PLE_MPI_STD_EMPTYFILE=\"off\" # Suppress stdout of filesize-0\n\nmodule load fftw-tune phdf5 netcdf-c netcdf-fortran\n###module unload tcs\n###module load fftw/3.3.8\n###export PATH=/opt/FJSVxtclanga/tcsds-1.2.25/bin:$PATH\n###export LD_LIBRARY_PATH=/opt/FJSVxtclanga/tcsds-1.2.25/lib64:$LD_LIBRARY_PATH\n###export OPAL_PREFIX=/opt/FJSVxtclanga/tcsds-1.2.25\n\n\n#### Run\ndate\ncd ${DIR}\nexport fu05=${DIR}/${NL}\nmpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n   # -n        \"Total number of MPI processes\"\ndate\n\n\n##### Run with Fujitsu profiler fipp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#fipp -C -d ${DIR}/fjprof_dir/pa0 -Icpupa -Impi -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#date\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -Ceu\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -x\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Icpupa     -p0,limit=4 -o prof_cpupa.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Ibalance   -p0,limit=4 -o prof_balance.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"#fipppx -A -d pa0 -Icall      -p0,limit=4 -o prof_call.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Isrc:./src -p0,limit=4 -o prof_src.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n\n\n##### Run with Fujitsu profiler fapp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#Npa=1  # Elementary report\n##Npa=5  # Simple report\n##Npa=11 # Standard report\n##Npa=17 # Detailed report\n#for i in `seq 1 ${Npa}`; do\n#  echo \"pa\"${i} `date`\n#  fapp -C -d ${DIR}/fjprof_dir/pa${i} -Hevent=pa${i} -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#done\n#date\n#\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#for i in `seq 1 ${Npa}`; do\n#  echo \"fapppx -A -d./pa${i} -Icpupa,mpi -tcsv -o pa${i}.csv\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#done\n#echo \"cp /opt/FJSVxtclanga/tcsds-1.2.25/misc/cpupa/cpu_pa_report.xlsm./\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#\n#\n", "#!/bin/sh\n\n###  NOTE  ###\n###  Flow supercomputer Type I sub-system, PRIMEHPC FX1000 (Nagoya Univ, 2020)\n###\n###  - Computation nodes(total 2304 nodes)\n###      CPU: A64FX (2.0GHz, 12coresx4CMG=48cores, 512bit SIMD) x1 per node\n###      Peak performance: DP 3.379 TFLOPS per node (Boost: 3.3792 TFLOPS)\n###      Cache L1: 64 KiB, 4 way\n###      Cache L1 Bandwidth: 230+ GB/s(load), 115+ GB/s (store)\n###      Cache L2: 8 MiB, 16 way per CMG(NUMA), 4CMG per node\n###      Cache L2 Bandwidth: 3.6+ TB/s per node\n###                          115+ GB/s(load), 57+ GB/s(store) per core\n###      Memory: HBM2 32 GiB\n###      Memory Bandwidth: 1024 GB/s per node\n###\n###      Therefore, a recommended GKV parallelization may be \n###          (MPI Processes)x(12 OpenMP Threads)\n###          =(12 cores per CMG)x(4 CMG)x(Node numbers)\n###      1 MPI process should be assigined to 1 CMG.\n###\n###  - Interconnect\n###      Tofu Interconnect D (28 Gbps x 2 lane x 10 port)\n###      [Performance] 8B Put latency: 0.49-0.54 usec\n###                    1MiB Put throughput: 6.35 GB/s\n###\n###  - Job class (May 2020)\n###      fx-debug  :  1 - 36  nodes,   1 hour,  50 run/300 submit\n###      fx-small  :  1 - 24  nodes, 168 hour, 100 run/300 submit\n###      fx-middle : 12 - 96  nodes,  72 hour,  50 run/300 submit\n###      fx-large  : 96 - 192 nodes,  72 hour,  25 run/300 submit\n###      fx-xlarge : 96 - 768 nodes,  24 hour,   5 run/300 submit\n###\n###  - Commands\n###      (Submit a batch job : \"pjsub sub.q\") Use shoot script for GKV.\n###      Check job status    : \"pjstat\" or \"pjstat -E\" for step jobs\n###      Delete job          : \"pjdel JOBID\"\n###      Show budget info    : \"charge\"\n###      Show disk usage     : \"lfs quota -u (YOUR ACCOUNT ID) /home\"\n###                          : \"lfs quota -u (YOUR ACCOUNT ID) /data\"\n##############\n\n#PJM --rsc-list \"rscgrp=fx-debug\"\n#PJM --rsc-list \"node=8\"       \n#### --rsc-list \"node=5x8x8\"       \n#PJM --rsc-list \"elapse=00:10:00\"\n#PJM --mpi \"proc=32\"           \n#### --mpi \"rank-map-bynode\"\n#### --mpi \"rank-map-hostfile=rankmapfile.dat\"\n#PJM -j                          \n#PJM -s                           \n\nNUM_NODES=${PJM_NODE}             # Nodes\nNUM_CORES=12                      # Cores per node\nNUM_PROCS=$(( ${NUM_NODES} * 4 )) # MPI processes\nexport OMP_NUM_THREADS=12         # OpenMP threads per MPI\n\n\necho \"                  Nodes: ${NUM_NODES}\"\necho \"         Cores per node: ${NUM_CORES}\"\necho \"          MPI Processes: ${NUM_PROCS}\"\necho \" OpenMP threads per MPI: ${OMP_NUM_THREADS}\"\n\n\n\n### Working directory \nDIR=%%DIR%%\nLDM=gkvp.exe\nNL=gkvp_namelist.%%%\n\nexport XOS_MMM_L_PAGING_POLICY=demand:demand:demand # For Largepage\n\nexport PLE_MPI_STD_EMPTYFILE=\"off\" # Suppress stdout of filesize-0\n\nmodule load fftw-tune phdf5 netcdf-c netcdf-fortran\n###module unload tcs\n###module load fftw/3.3.8\n###export PATH=/opt/FJSVxtclanga/tcsds-1.2.25/bin:$PATH\n###export LD_LIBRARY_PATH=/opt/FJSVxtclanga/tcsds-1.2.25/lib64:$LD_LIBRARY_PATH\n###export OPAL_PREFIX=/opt/FJSVxtclanga/tcsds-1.2.25\n\n\n#### Run\ndate\ncd ${DIR}\nexport fu05=${DIR}/${NL}\nmpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n   # -n        \"Total number of MPI processes\"\ndate\n\n\n##### Run with Fujitsu profiler fipp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#fipp -C -d ${DIR}/fjprof_dir/pa0 -Icpupa -Impi -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#date\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -Ceu\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"set -x\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Icpupa     -p0,limit=4 -o prof_cpupa.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Ibalance   -p0,limit=4 -o prof_balance.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"#fipppx -A -d pa0 -Icall      -p0,limit=4 -o prof_call.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n#echo \"fipppx -A -d pa0 -Isrc:./src -p0,limit=4 -o prof_src.txt\" >> ${DIR}/fjprof_dir/fugaku_fipppx.sh\n\n\n##### Run with Fujitsu profiler fapp (re-compile with -Nfjprof option)\n#date\n#cd ${DIR}\n#export fu05=${DIR}/${NL}\n#Npa=1  # Elementary report\n##Npa=5  # Simple report\n##Npa=11 # Standard report\n##Npa=17 # Detailed report\n#for i in `seq 1 ${Npa}`; do\n#  echo \"pa\"${i} `date`\n#  fapp -C -d ${DIR}/fjprof_dir/pa${i} -Hevent=pa${i} -Sregion  mpiexec -n ${NUM_PROCS} ${DIR}/${LDM}\n#done\n#date\n#\n#echo \"#!/bin/sh\" > ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#for i in `seq 1 ${Npa}`; do\n#  echo \"fapppx -A -d./pa${i} -Icpupa,mpi -tcsv -o pa${i}.csv\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#done\n#echo \"cp /opt/FJSVxtclanga/tcsds-1.2.25/misc/cpupa/cpu_pa_report.xlsm./\" >> ${DIR}/fjprof_dir/fugaku_fapppx.sh\n#\n#\n", "#!/bin/sh\n#\n#  Script for step job submission\n#\n#     HOW TO USE:./shoot [START_NUMBER] [END_NUMBER]\n#\n#     When one wants to continue simulation runs after [JOB-ID],\n#                ./shoot [START_NUMBER] [END_NUMBER] [JOB-ID]\n#\n\nif [ $# -lt 2 ]; then\n  echo \"HOW TO USE:./shoot [START_NUMBER] [END_NUMBER] ([JOB-ID])\"\n  exit\nfi\n\n#### Environment setting\nDIR=/data/group1/z43460z/gkvp/f0.61/ITGae-lin\nLDM=gkvp.exe\nNL=gkvp_namelist\nSC=pjsub\nJS=sub.q\n### For VMEC, set VMCDIR including metric_boozer.bin.dat\n#VMCDIR=./input_vmec/vmec_sample_nss501ntheta1024nzeta0\n### For IGS, set IGSDIR including METRIC_{axi,boz,ham}.OUT\n#IGSDIR=../../input_eqdsk_for_eqdskbench/\n\n\n\n#### Create directories\nDIR=`echo ${DIR} | sed -e's/\\/$//'`\nmkdir -p ${DIR}/\nmkdir -p ${DIR}/log/\nmkdir -p ${DIR}/hst/\nmkdir -p ${DIR}/phi/\nmkdir -p ${DIR}/fxv/\nmkdir -p ${DIR}/cnt/\nif [! -e \"${LDM}\" ]; then\n  echo \"No EXE file!\"; exit\nfi\ncp./${LDM} ${DIR}\ncp./Makefile ${DIR}\ncp -r../src ${DIR}\ncp -r../lib ${DIR}\nif [! -z \"${VMCDIR}\" ]; then #$VMCDIR is neither undefined nor null.\n  mkdir -p ${DIR}/vmec/\n  cp ${VMCDIR}/* ${DIR}/vmec/\nfi\nif [! -z \"${IGSDIR}\" ]; then #$IGSDIR is neither undefined nor null.\n  mkdir -p ${DIR}/eqdsk/\n  cp ${IGSDIR}/METRIC*.OUT ${DIR}/eqdsk/\nfi\n\n\n\n#### Submit jobs\ni=$1\niend=$2\nj=$3\nwhile [ $i -le $iend ]\ndo\n\n  date\n\n  ## Creating a procedure file\n  ia=`echo $i | awk '{printf (\"%03d\",$1)}'`\n  fln_JS=`echo $JS\\.$ia`\n  fln_NL=`echo $NL\\.$ia`\n  cat ${JS} | sed -e \"s/%%%/$ia/\" | sed -e \"s|%%DIR%%|${DIR}|\" > ${fln_JS}\n  cat ${NL} | sed -e \"s/%%%/$ia/\" | sed -e \"s|%%DIR%%|${DIR}|\" > ${fln_NL}\n  chmod u+x ${fln_JS}\n  cp./${fln_NL} ${DIR}\n  cp./${fln_JS} ${DIR}\n\n  ## Submitting a job\n  #echo \"*** submit job ${fln_JS} ***\"\n  #${SC} ${fln_JS}\n  if [ -z \"$j\"  -a  $i -eq $1 ]; then\n    echo \"*** submit first step job ${fln_JS} ***\"\n    ${SC} --step --sparam \"sn=$i\" ${fln_JS} | tee shoottempfile\n    j=`awk '{sub(\"_.*\",\"\"); print $6}' shoottempfile`\n    rm shoottempfile\n  else\n    echo \"*** submit sequential step job ${fln_JS} ***\"\n    ${SC} --step --sparam \"jid=$j,sd=ec!=0:all\" ${fln_JS}\n  fi\n\n  sleep 1\n  i=$(( $i + 1 ))\n\ndone\n", "        j0zeros(1) = 2.404825557695770666e+00\n        j0zeros(2) = 5.520078110286304351e+00\n        j0zeros(3) = 8.653727912911024944e+00\n        j0zeros(4) = 1.179153443901426179e+01\n        j0zeros(5) = 1.493091770848781330e+01\n        j0zeros(6) = 1.807106396791089153e+01\n        j0zeros(7) = 2.121163662987926912e+01\n        j0zeros(8) = 2.435247153074934090e+01\n        j0zeros(9) = 2.749347913204029226e+01\n        j0zeros(10) = 3.063460646843199697e+01\n        j0zeros(11) = 3.377582021357356723e+01\n        j0zeros(12) = 3.691709835366403070e+01\n        j0zeros(13) = 4.005842576462820404e+01\n        j0zeros(14) = 4.319979171317667976e+01\n        j0zeros(15) = 4.634118837166175098e+01\n        j0zeros(16) = 4.948260989739775084e+01\n        j0zeros(17) = 5.262405184111491963e+01\n        j0zeros(18) = 5.576551075501990340e+01\n        j0zeros(19) = 5.890698392608085499e+01\n        j0zeros(20) = 6.204846919022708818e+01\n        j0zeros(21) = 6.518996480020678064e+01\n        j0zeros(22) = 6.833146932985670219e+01\n        j0zeros(23) = 7.147298160359363806e+01\n        j0zeros(24) = 7.461450064370174573e+01\n        j0zeros(25) = 7.775602563038796688e+01\n        j0zeros(26) = 8.089755587113752711e+01\n        j0zeros(27) = 8.403909077693809593e+01\n        j0zeros(28) = 8.718062984364107137e+01\n        j0zeros(29) = 9.032217263721040013e+01\n        j0zeros(30) = 9.346371878194467797e+01\n        j0zeros(31) = 9.660526795099617914e+01\n        j0zeros(32) = 9.974681985868051015e+01\n        j0zeros(33) = 1.028883742541947157e+02\n        j0zeros(34) = 1.060299309164515336e+02\n        j0zeros(35) = 1.091714896498053093e+02\n        j0zeros(36) = 1.123130502804948350e+02\n        j0zeros(37) = 1.154546126536668709e+02\n        j0zeros(38) = 1.185961766308724492e+02\n        j0zeros(39) = 1.217377420879508918e+02\n        j0zeros(40) = 1.248793089132328760e+02\n        j0zeros(41) = 1.280208770060082486e+02\n        j0zeros(42) = 1.311624462752138527e+02\n        j0zeros(43) = 1.343040166383053986e+02\n        j0zeros(44) = 1.374455880202841911e+02\n        j0zeros(45) = 1.405871603528542266e+02\n        j0zeros(46) = 1.437287335736896523e+02\n        j0zeros(47) = 1.468703076257965847e+02\n        j0zeros(48) = 1.500118824569546803e+02\n        j0zeros(49) = 1.531534580192278270e+02\n        j0zeros(50) = 1.562950342685334704e+02\n        j0zeros(51) = 1.594366111642630699e+02\n        j0zeros(52) = 1.625781886689466091e+02\n        j0zeros(53) = 1.657197667479549636e+02\n        j0zeros(54) = 1.688613453692357496e+02\n        j0zeros(55) = 1.720029245030781624e+02\n        j0zeros(56) = 1.751445041219026848e+02\n        j0zeros(57) = 1.782860842000737023e+02\n        j0zeros(58) = 1.814276647137309908e+02\n        j0zeros(59) = 1.845692456406386555e+02\n        j0zeros(60) = 1.877108269600493031e+02\n        j0zeros(61) = 1.908524086525814596e+02\n        j0zeros(62) = 1.939939907001090660e+02\n        j0zeros(63) = 1.971355730856613775e+02\n        j0zeros(64) = 2.002771557933323550e+02\n        j0zeros(65) = 2.034187388081985830e+02\n        j0zeros(66) = 2.065603221162444356e+02\n        j0zeros(67) = 2.097019057042940346e+02\n        j0zeros(68) = 2.128434895599494041e+02\n        j0zeros(69) = 2.159850736715339679e+02\n        j0zeros(70) = 2.191266580280405094e+02\n        j0zeros(71) = 2.222682426190842762e+02\n        j0zeros(72) = 2.254098274348592952e+02\n        j0zeros(73) = 2.285514124660987534e+02\n        j0zeros(74) = 2.316929977040385040e+02\n        j0zeros(75) = 2.348345831403831880e+02\n        j0zeros(76) = 2.379761687672755954e+02\n        j0zeros(77) = 2.411177545772679878e+02\n        j0zeros(78) = 2.442593405632956376e+02\n        j0zeros(79) = 2.474009267186527836e+02\n        j0zeros(80) = 2.505425130369699218e+02\n        j0zeros(81) = 2.536840995121930291e+02\n        j0zeros(82) = 2.568256861385643788e+02\n        j0zeros(83) = 2.599672729106044358e+02\n        j0zeros(84) = 2.631088598230954290e+02\n        j0zeros(85) = 2.662504468710658330e+02\n        j0zeros(86) = 2.693920340497760435e+02\n        j0zeros(87) = 2.725336213547049056e+02\n        j0zeros(88) = 2.756752087815374352e+02\n        j0zeros(89) = 2.788167963261530531e+02\n        j0zeros(90) = 2.819583839846148408e+02\n        j0zeros(91) = 2.850999717531595365e+02\n        j0zeros(92) = 2.882415596281876446e+02\n        j0zeros(93) = 2.913831476062551928e+02\n        j0zeros(94) = 2.945247356840649218e+02\n        j0zeros(95) = 2.976663238584588953e+02\n        j0zeros(96) = 3.008079121264110540e+02\n        j0zeros(97) = 3.039495004850205646e+02\n        j0zeros(98) = 3.070910889315049985e+02\n        j0zeros(99) = 3.102326774631949320e+02\n        j0zeros(100) = 3.133742660775278068e+02\n        j0zeros(101) = 3.165158547720428714e+02\n        j0zeros(102) = 3.196574435443761217e+02\n        j0zeros(103) = 3.227990323922555262e+02\n        j0zeros(104) = 3.259406213134966492e+02\n        j0zeros(105) = 3.290822103059985011e+02\n        j0zeros(106) = 3.322237993677395593e+02\n        j0zeros(107) = 3.353653884967741305e+02\n        j0zeros(108) = 3.385069776912284851e+02\n        j0zeros(109) = 3.416485669492980151e+02\n        j0zeros(110) = 3.447901562692439370e+02\n        j0zeros(111) = 3.479317456493901659e+02\n        j0zeros(112) = 3.510733350881205297e+02\n        j0zeros(113) = 3.542149245838763818e+02\n        j0zeros(114) = 3.573565141351537022e+02\n        j0zeros(115) = 3.604981037405010511e+02\n        j0zeros(116) = 3.636396933985170108e+02\n        j0zeros(117) = 3.667812831078482532e+02\n        j0zeros(118) = 3.699228728671874364e+02\n        j0zeros(119) = 3.730644626752712156e+02\n        j0zeros(120) = 3.762060525308784236e+02\n        j0zeros(121) = 3.793476424328284224e+02\n        j0zeros(122) = 3.824892323799792848e+02\n        j0zeros(123) = 3.856308223712263725e+02\n        j0zeros(124) = 3.887724124055006314e+02\n        j0zeros(125) = 3.919140024817673407e+02\n        j0zeros(126) = 3.950555925990248056e+02\n        j0zeros(127) = 3.981971827563027659e+02\n        j0zeros(128) = 4.013387729526614862e+02\n        j0zeros(129) = 4.044803631871903917e+02\n        j0zeros(130) = 4.076219534590068179e+02\n        j0zeros(131) = 4.107635437672553280e+02\n        j0zeros(132) = 4.139051341111062925e+02\n        j0zeros(133) = 4.170467244897552064e+02\n        j0zeros(134) = 4.201883149024216095e+02\n        j0zeros(135) = 4.233299053483480634e+02\n        j0zeros(136) = 4.264714958267995826e+02\n        j0zeros(137) = 4.296130863370626685e+02\n        j0zeros(138) = 4.327546768784445135e+02\n        j0zeros(139) = 4.358962674502723189e+02\n        j0zeros(140) = 4.390378580518924423e+02\n        j0zeros(141) = 4.421794486826699426e+02\n        j0zeros(142) = 4.453210393419876709e+02\n        j0zeros(143) = 4.484626300292459291e+02\n        j0zeros(144) = 4.516042207438616174e+02\n        j0zeros(145) = 4.547458114852677227e+02\n        j0zeros(146) = 4.578874022529127501e+02\n        j0zeros(147) = 4.610289930462603820e+02\n        j0zeros(148) = 4.641705838647887390e+02\n        j0zeros(149) = 4.673121747079899251e+02\n        j0zeros(150) = 4.704537655753698004e+02\n        j0zeros(151) = 4.735953564664470719e+02\n        j0zeros(152) = 4.767369473807532927e+02\n        j0zeros(153) = 4.798785383178322945e+02\n        j0zeros(154) = 4.830201292772396755e+02\n        j0zeros(155) = 4.861617202585426298e+02\n        j0zeros(156) = 4.893033112613193794e+02\n        j0zeros(157) = 4.924449022851589461e+02\n        j0zeros(158) = 4.955864933296608115e+02\n        j0zeros(159) = 4.987280843944345179e+02\n        j0zeros(160) = 5.018696754790993282e+02\n        j0zeros(161) = 5.050112665832840548e+02\n        j0zeros(162) = 5.081528577066266621e+02\n        j0zeros(163) = 5.112944488487739818e+02\n        j0zeros(164) = 5.144360400093815997e+02\n        j0zeros(165) = 5.175776311881131733e+02\n        j0zeros(166) = 5.207192223846409433e+02\n        j0zeros(167) = 5.238608135986445404e+02\n        j0zeros(168) = 5.270024048298114394e+02\n        j0zeros(169) = 5.301439960778367322e+02\n        j0zeros(170) = 5.332855873424221045e+02\n        j0zeros(171) = 5.364271786232769728e+02\n        j0zeros(172) = 5.395687699201168925e+02\n        j0zeros(173) = 5.427103612326643542e+02\n        j0zeros(174) = 5.458519525606483285e+02\n        j0zeros(175) = 5.489935439038034701e+02\n        j0zeros(176) = 5.521351352618711417e+02\n        j0zeros(177) = 5.552767266345980488e+02\n        j0zeros(178) = 5.584183180217368090e+02\n        j0zeros(179) = 5.615599094230457240e+02\n        j0zeros(180) = 5.647015008382879842e+02\n        j0zeros(181) = 5.678430922672324641e+02\n        j0zeros(182) = 5.709846837096530408e+02\n        j0zeros(183) = 5.741262751653284795e+02\n        j0zeros(184) = 5.772678666340423206e+02\n        j0zeros(185) = 5.804094581155829928e+02\n        j0zeros(186) = 5.835510496097431314e+02\n        j0zeros(187) = 5.866926411163201465e+02\n        j0zeros(188) = 5.898342326351156544e+02\n        j0zeros(189) = 5.929758241659353644e+02\n        j0zeros(190) = 5.961174157085893057e+02\n        j0zeros(191) = 5.992590072628911457e+02\n        j0zeros(192) = 6.024005988286587581e+02\n        j0zeros(193) = 6.055421904057137681e+02\n        j0zeros(194) = 6.086837819938813254e+02\n        j0zeros(195) = 6.118253735929902177e+02\n        j0zeros(196) = 6.149669652028728706e+02\n        j0zeros(197) = 6.181085568233648928e+02\n        j0zeros(198) = 6.212501484543054175e+02\n        j0zeros(199) = 6.243917400955366475e+02\n        j0zeros(200) = 6.275333317469040821e+02\n        j0zeros(201) = 6.306749234082564044e+02\n        j0zeros(202) = 6.338165150794449119e+02\n        j0zeros(203) = 6.369581067603240854e+02\n        j0zeros(204) = 6.400996984507512479e+02\n        j0zeros(205) = 6.432412901505866785e+02\n        j0zeros(206) = 6.463828818596929295e+02\n        j0zeros(207) = 6.495244735779357370e+02\n        j0zeros(208) = 6.526660653051829968e+02\n        j0zeros(209) = 6.558076570413053332e+02\n        j0zeros(210) = 6.589492487861758718e+02\n        j0zeros(211) = 6.620908405396701255e+02\n        j0zeros(212) = 6.652324323016656535e+02\n        j0zeros(213) = 6.683740240720428574e+02\n        j0zeros(214) = 6.715156158506839574e+02\n        j0zeros(215) = 6.746572076374735616e+02\n        j0zeros(216) = 6.777987994322983241e+02\n        j0zeros(217) = 6.809403912350471728e+02\n        j0zeros(218) = 6.840819830456107411e+02\n        j0zeros(219) = 6.872235748638820496e+02\n        j0zeros(220) = 6.903651666897555970e+02\n        j0zeros(221) = 6.935067585231283829e+02\n        j0zeros(222) = 6.966483503638988850e+02\n        j0zeros(223) = 6.997899422119672863e+02\n        j0zeros(224) = 7.029315340672358161e+02\n        j0zeros(225) = 7.060731259296085227e+02\n        j0zeros(226) = 7.092147177989907050e+02\n        j0zeros(227) = 7.123563096752899355e+02\n        j0zeros(228) = 7.154979015584149238e+02\n        j0zeros(229) = 7.186394934482760846e+02\n        j0zeros(230) = 7.217810853447856516e+02\n        j0zeros(231) = 7.249226772478571093e+02\n        j0zeros(232) = 7.280642691574055334e+02\n        j0zeros(233) = 7.312058610733474779e+02\n        j0zeros(234) = 7.343474529956007473e+02\n        j0zeros(235) = 7.374890449240847374e+02\n        j0zeros(236) = 7.406306368587202087e+02\n        j0zeros(237) = 7.437722287994291719e+02\n        j0zeros(238) = 7.469138207461351158e+02\n        j0zeros(239) = 7.500554126987624386e+02\n        j0zeros(240) = 7.531970046572372439e+02\n        j0zeros(241) = 7.563385966214865448e+02\n        j0zeros(242) = 7.594801885914388322e+02\n        j0zeros(243) = 7.626217805670236203e+02\n        j0zeros(244) = 7.657633725481714464e+02\n        j0zeros(245) = 7.689049645348140984e+02\n        j0zeros(246) = 7.720465565268846149e+02\n        j0zeros(247) = 7.751881485243169436e+02\n        j0zeros(248) = 7.783297405270462832e+02\n        j0zeros(249) = 7.814713325350085142e+02\n        j0zeros(250) = 7.846129245481409953e+02\n        j0zeros(251) = 7.877545165663817670e+02\n        j0zeros(252) = 7.908961085896700069e+02\n        j0zeros(253) = 7.940377006179458022e+02\n        j0zeros(254) = 7.971792926511502628e+02\n        j0zeros(255) = 8.003208846892251813e+02\n        j0zeros(256) = 8.034624767321133731e+02\n        j0zeros(257) = 8.066040687797589044e+02\n        j0zeros(258) = 8.097456608321060685e+02\n        j0zeros(259) = 8.128872528891005231e+02\n        j0zeros(260) = 8.160288449506886082e+02\n        j0zeros(261) = 8.191704370168174592e+02\n        j0zeros(262) = 8.223120290874350076e+02\n        j0zeros(263) = 8.254536211624899806e+02\n        j0zeros(264) = 8.285952132419319014e+02\n        j0zeros(265) = 8.317368053257113161e+02\n        j0zeros(266) = 8.348783974137787709e+02\n        j0zeros(267) = 8.380199895060864037e+02\n        j0zeros(268) = 8.411615816025866934e+02\n        j0zeros(269) = 8.443031737032325736e+02\n        j0zeros(270) = 8.474447658079782286e+02\n        j0zeros(271) = 8.505863579167780699e+02\n        j0zeros(272) = 8.537279500295875323e+02\n        j0zeros(273) = 8.568695421463621642e+02\n        j0zeros(274) = 8.600111342670588783e+02\n        j0zeros(275) = 8.631527263916348147e+02\n        j0zeros(276) = 8.662943185200474545e+02\n        j0zeros(277) = 8.694359106522554157e+02\n        j0zeros(278) = 8.725775027882176573e+02\n        j0zeros(279) = 8.757190949278939343e+02\n        j0zeros(280) = 8.788606870712442287e+02\n        j0zeros(281) = 8.820022792182293188e+02\n        j0zeros(282) = 8.851438713688105508e+02\n        j0zeros(283) = 8.882854635229497262e+02\n        j0zeros(284) = 8.914270556806092145e+02\n        j0zeros(285) = 8.945686478417520675e+02\n        j0zeros(286) = 8.977102400063416781e+02\n        j0zeros(287) = 9.008518321743417800e+02\n        j0zeros(288) = 9.039934243457169032e+02\n        j0zeros(289) = 9.071350165204321456e+02\n        j0zeros(290) = 9.102766086984527192e+02\n        j0zeros(291) = 9.134182008797447452e+02\n        j0zeros(292) = 9.165597930642743449e+02\n        j0zeros(293) = 9.197013852520084356e+02\n        j0zeros(294) = 9.228429774429143890e+02\n        j0zeros(295) = 9.259845696369598045e+02\n        j0zeros(296) = 9.291261618341128496e+02\n        j0zeros(297) = 9.322677540343421470e+02\n        j0zeros(298) = 9.354093462376166599e+02\n        j0zeros(299) = 9.385509384439058067e+02\n        j0zeros(300) = 9.416925306531794604e+02\n        j0zeros(301) = 9.448341228654078350e+02\n        j0zeros(302) = 9.479757150805615993e+02\n        j0zeros(303) = 9.511173072986116495e+02\n        j0zeros(304) = 9.542588995195294501e+02\n        j0zeros(305) = 9.574004917432866932e+02\n        j0zeros(306) = 9.605420839698557529e+02\n        j0zeros(307) = 9.636836761992090032e+02\n        j0zeros(308) = 9.668252684313190457e+02\n        j0zeros(309) = 9.699668606661595049e+02\n        j0zeros(310) = 9.731084529037035509e+02\n        j0zeros(311) = 9.762500451439253766e+02\n        j0zeros(312) = 9.793916373867991751e+02\n        j0zeros(313) = 9.825332296322993670e+02\n        j0zeros(314) = 9.856748218804009412e+02\n        j0zeros(315) = 9.888164141310791138e+02\n        j0zeros(316) = 9.919580063843093285e+02\n        j0zeros(317) = 9.950995986400674838e+02\n        j0zeros(318) = 9.982411908983298190e+02\n        j0zeros(319) = 1.001382783159072574e+03\n        j0zeros(320) = 1.004524375422272442e+03\n        j0zeros(321) = 1.007665967687906573e+03\n        j0zeros(322) = 1.010807559955952229e+03\n        j0zeros(323) = 1.013949152226387014e+03\n        j0zeros(324) = 1.017090744499188759e+03\n        j0zeros(325) = 1.020232336774335636e+03\n        j0zeros(326) = 1.023373929051805931e+03\n        j0zeros(327) = 1.026515521331578611e+03\n        j0zeros(328) = 1.029657113613632191e+03\n        j0zeros(329) = 1.032798705897946093e+03\n        j0zeros(330) = 1.035940298184499852e+03\n        j0zeros(331) = 1.039081890473272779e+03\n        j0zeros(332) = 1.042223482764245318e+03\n        j0zeros(333) = 1.045365075057397235e+03\n        j0zeros(334) = 1.048506667352709201e+03\n        j0zeros(335) = 1.051648259650161890e+03\n        j0zeros(336) = 1.054789851949735521e+03\n        j0zeros(337) = 1.057931444251412131e+03\n        j0zeros(338) = 1.061073036555172166e+03\n        j0zeros(339) = 1.064214628860998118e+03\n        j0zeros(340) = 1.067356221168870889e+03\n        j0zeros(341) = 1.070497813478772969e+03\n        j0zeros(342) = 1.073639405790686169e+03\n        j0zeros(343) = 1.076780998104593436e+03\n        j0zeros(344) = 1.079922590420476581e+03\n        j0zeros(345) = 1.083064182738319460e+03\n        j0zeros(346) = 1.086205775058104109e+03\n", "        j0zeros(347) = 1.089347367379814159e+03\n        j0zeros(348) = 1.092488959703433011e+03\n        j0zeros(349) = 1.095630552028943839e+03\n        j0zeros(350) = 1.098772144356331182e+03\n        j0zeros(351) = 1.101913736685578215e+03\n        j0zeros(352) = 1.105055329016669475e+03\n        j0zeros(353) = 1.108196921349589275e+03\n        j0zeros(354) = 1.111338513684322152e+03\n        j0zeros(355) = 1.114480106020852645e+03\n        j0zeros(356) = 1.117621698359165293e+03\n        j0zeros(357) = 1.120763290699245772e+03\n        j0zeros(358) = 1.123904883041078847e+03\n        j0zeros(359) = 1.127046475384649966e+03\n        j0zeros(360) = 1.130188067729944351e+03\n        j0zeros(361) = 1.133329660076948358e+03\n        j0zeros(362) = 1.136471252425646981e+03\n        j0zeros(363) = 1.139612844776026805e+03\n        j0zeros(364) = 1.142754437128073732e+03\n        j0zeros(365) = 1.145896029481774121e+03\n        j0zeros(366) = 1.149037621837114330e+03\n        j0zeros(367) = 1.152179214194080942e+03\n        j0zeros(368) = 1.155320806552660770e+03\n        j0zeros(369) = 1.158462398912840627e+03\n        j0zeros(370) = 1.161603991274607552e+03\n        j0zeros(371) = 1.164745583637948585e+03\n        j0zeros(372) = 1.167887176002851447e+03\n        j0zeros(373) = 1.171028768369302952e+03\n        j0zeros(374) = 1.174170360737291276e+03\n        j0zeros(375) = 1.177311953106803458e+03\n        j0zeros(376) = 1.180453545477828129e+03\n        j0zeros(377) = 1.183595137850352558e+03\n        j0zeros(378) = 1.186736730224365147e+03\n        j0zeros(379) = 1.189878322599854073e+03\n        j0zeros(380) = 1.193019914976807513e+03\n        j0zeros(381) = 1.196161507355214098e+03\n        j0zeros(382) = 1.199303099735062233e+03\n        j0zeros(383) = 1.202444692116341230e+03\n        j0zeros(384) = 1.205586284499039039e+03\n        j0zeros(385) = 1.208727876883145200e+03\n        j0zeros(386) = 1.211869469268648345e+03\n        j0zeros(387) = 1.215011061655538015e+03\n        j0zeros(388) = 1.218152654043803295e+03\n        j0zeros(389) = 1.221294246433433500e+03\n        j0zeros(390) = 1.224435838824418397e+03\n        j0zeros(391) = 1.227577431216747073e+03\n        j0zeros(392) = 1.230719023610409749e+03\n        j0zeros(393) = 1.233860616005395968e+03\n        j0zeros(394) = 1.237002208401695952e+03\n        j0zeros(395) = 1.240143800799299242e+03\n        j0zeros(396) = 1.243285393198196289e+03\n        j0zeros(397) = 1.246426985598377314e+03\n        j0zeros(398) = 1.249568577999832542e+03\n        j0zeros(399) = 1.252710170402552421e+03\n        j0zeros(400) = 1.255851762806527177e+03\n        j0zeros(401) = 1.258993355211747939e+03\n        j0zeros(402) = 1.262134947618204933e+03\n        j0zeros(403) = 1.265276540025889517e+03\n        j0zeros(404) = 1.268418132434791687e+03\n        j0zeros(405) = 1.271559724844903258e+03\n        j0zeros(406) = 1.274701317256214907e+03\n        j0zeros(407) = 1.277842909668717994e+03\n        j0zeros(408) = 1.280984502082403196e+03\n        j0zeros(409) = 1.284126094497262557e+03\n        j0zeros(410) = 1.287267686913287207e+03\n        j0zeros(411) = 1.290409279330468507e+03\n        j0zeros(412) = 1.293550871748798045e+03\n        j0zeros(413) = 1.296692464168267634e+03\n        j0zeros(414) = 1.299834056588868862e+03\n        j0zeros(415) = 1.302975649010593543e+03\n        j0zeros(416) = 1.306117241433433946e+03\n        j0zeros(417) = 1.309258833857381205e+03\n        j0zeros(418) = 1.312400426282428270e+03\n        j0zeros(419) = 1.315542018708566957e+03\n        j0zeros(420) = 1.318683611135789079e+03\n        j0zeros(421) = 1.321825203564087587e+03\n        j0zeros(422) = 1.324966795993454070e+03\n        j0zeros(423) = 1.328108388423881479e+03\n        j0zeros(424) = 1.331249980855362082e+03\n        j0zeros(425) = 1.334391573287888832e+03\n        j0zeros(426) = 1.337533165721453543e+03\n        j0zeros(427) = 1.340674758156049847e+03\n        j0zeros(428) = 1.343816350591669789e+03\n        j0zeros(429) = 1.346957943028306772e+03\n        j0zeros(430) = 1.350099535465953522e+03\n        j0zeros(431) = 1.353241127904602536e+03\n        j0zeros(432) = 1.356382720344247446e+03\n        j0zeros(433) = 1.359524312784880976e+03\n        j0zeros(434) = 1.362665905226496534e+03\n        j0zeros(435) = 1.365807497669087070e+03\n        j0zeros(436) = 1.368949090112646445e+03\n        j0zeros(437) = 1.372090682557167156e+03\n        j0zeros(438) = 1.375232275002643291e+03\n        j0zeros(439) = 1.378373867449068030e+03\n        j0zeros(440) = 1.381515459896435232e+03\n        j0zeros(441) = 1.384657052344738076e+03\n        j0zeros(442) = 1.387798644793969970e+03\n        j0zeros(443) = 1.390940237244125456e+03\n        j0zeros(444) = 1.394081829695197484e+03\n        j0zeros(445) = 1.397223422147180599e+03\n        j0zeros(446) = 1.400365014600067980e+03\n        j0zeros(447) = 1.403506607053853941e+03\n        j0zeros(448) = 1.406648199508532343e+03\n        j0zeros(449) = 1.409789791964097276e+03\n        j0zeros(450) = 1.412931384420542827e+03\n        j0zeros(451) = 1.416072976877863084e+03\n        j0zeros(452) = 1.419214569336052591e+03\n        j0zeros(453) = 1.422356161795104754e+03\n        j0zeros(454) = 1.425497754255014797e+03\n        j0zeros(455) = 1.428639346715776355e+03\n        j0zeros(456) = 1.431780939177384198e+03\n        j0zeros(457) = 1.434922531639832641e+03\n        j0zeros(458) = 1.438064124103116455e+03\n        j0zeros(459) = 1.441205716567229501e+03\n        j0zeros(460) = 1.444347309032167232e+03\n        j0zeros(461) = 1.447488901497923507e+03\n        j0zeros(462) = 1.450630493964493780e+03\n        j0zeros(463) = 1.453772086431872140e+03\n        j0zeros(464) = 1.456913678900053355e+03\n        j0zeros(465) = 1.460055271369032880e+03\n        j0zeros(466) = 1.463196863838804802e+03\n        j0zeros(467) = 1.466338456309364574e+03\n        j0zeros(468) = 1.469480048780706511e+03\n        j0zeros(469) = 1.472621641252826521e+03\n        j0zeros(470) = 1.475763233725718919e+03\n        j0zeros(471) = 1.478904826199379158e+03\n        j0zeros(472) = 1.482046418673802009e+03\n        j0zeros(473) = 1.485188011148983151e+03\n        j0zeros(474) = 1.488329603624917354e+03\n        j0zeros(475) = 1.491471196101599844e+03\n        j0zeros(476) = 1.494612788579026301e+03\n        j0zeros(477) = 1.497754381057191495e+03\n        j0zeros(478) = 1.500895973536091105e+03\n        j0zeros(479) = 1.504037566015720586e+03\n        j0zeros(480) = 1.507179158496075161e+03\n        j0zeros(481) = 1.510320750977150510e+03\n        j0zeros(482) = 1.513462343458942087e+03\n        j0zeros(483) = 1.516603935941445570e+03\n        j0zeros(484) = 1.519745528424655959e+03\n        j0zeros(485) = 1.522887120908569614e+03\n        j0zeros(486) = 1.526028713393181761e+03\n        j0zeros(487) = 1.529170305878488307e+03\n        j0zeros(488) = 1.532311898364484705e+03\n        j0zeros(489) = 1.535453490851167089e+03\n        j0zeros(490) = 1.538595083338530912e+03\n        j0zeros(491) = 1.541736675826572537e+03\n        j0zeros(492) = 1.544878268315286959e+03\n        j0zeros(493) = 1.548019860804670998e+03\n        j0zeros(494) = 1.551161453294720104e+03\n        j0zeros(495) = 1.554303045785430186e+03\n        j0zeros(496) = 1.557444638276797377e+03\n        j0zeros(497) = 1.560586230768817813e+03\n        j0zeros(498) = 1.563727823261487401e+03\n        j0zeros(499) = 1.566869415754802048e+03\n        j0zeros(500) = 1.570011008248758571e+03\n        j0zeros(501) = 1.573152600743352195e+03\n        j0zeros(502) = 1.576294193238579965e+03\n        j0zeros(503) = 1.579435785734437331e+03\n        j0zeros(504) = 1.582577378230921340e+03\n        j0zeros(505) = 1.585718970728027671e+03\n        j0zeros(506) = 1.588860563225752912e+03\n        j0zeros(507) = 1.592002155724093200e+03\n        j0zeros(508) = 1.595143748223044895e+03\n        j0zeros(509) = 1.598285340722604815e+03\n        j0zeros(510) = 1.601426933222768639e+03\n        j0zeros(511) = 1.604568525723533639e+03\n        j0zeros(512) = 1.607710118224895723e+03\n        j0zeros(513) = 1.610851710726851707e+03\n        j0zeros(514) = 1.613993303229397725e+03\n        j0zeros(515) = 1.617134895732531049e+03\n        j0zeros(516) = 1.620276488236247587e+03\n        j0zeros(517) = 1.623418080740543928e+03\n        j0zeros(518) = 1.626559673245417343e+03\n        j0zeros(519) = 1.629701265750863968e+03\n        j0zeros(520) = 1.632842858256880618e+03\n        j0zeros(521) = 1.635984450763464110e+03\n        j0zeros(522) = 1.639126043270611035e+03\n        j0zeros(523) = 1.642267635778318208e+03\n        j0zeros(524) = 1.645409228286582675e+03\n        j0zeros(525) = 1.648550820795400796e+03\n        j0zeros(526) = 1.651692413304769616e+03\n        j0zeros(527) = 1.654834005814686407e+03\n        j0zeros(528) = 1.657975598325147303e+03\n        j0zeros(529) = 1.661117190836149575e+03\n        j0zeros(530) = 1.664258783347690269e+03\n        j0zeros(531) = 1.667400375859766427e+03\n        j0zeros(532) = 1.670541968372374413e+03\n        j0zeros(533) = 1.673683560885511952e+03\n        j0zeros(534) = 1.676825153399175633e+03\n        j0zeros(535) = 1.679966745913362956e+03\n        j0zeros(536) = 1.683108338428070283e+03\n        j0zeros(537) = 1.686249930943295340e+03\n        j0zeros(538) = 1.689391523459034943e+03\n        j0zeros(539) = 1.692533115975286364e+03\n        j0zeros(540) = 1.695674708492046648e+03\n        j0zeros(541) = 1.698816301009312838e+03\n        j0zeros(542) = 1.701957893527082433e+03\n        j0zeros(543) = 1.705099486045352478e+03\n        j0zeros(544) = 1.708241078564120244e+03\n        j0zeros(545) = 1.711382671083383002e+03\n        j0zeros(546) = 1.714524263603138024e+03\n        j0zeros(547) = 1.717665856123382810e+03\n        j0zeros(548) = 1.720807448644114174e+03\n        j0zeros(549) = 1.723949041165330073e+03\n        j0zeros(550) = 1.727090633687027321e+03\n        j0zeros(551) = 1.730232226209203645e+03\n        j0zeros(552) = 1.733373818731856090e+03\n        j0zeros(553) = 1.736515411254982610e+03\n        j0zeros(554) = 1.739657003778580020e+03\n        j0zeros(555) = 1.742798596302646274e+03\n        j0zeros(556) = 1.745940188827178417e+03\n        j0zeros(557) = 1.749081781352174630e+03\n        j0zeros(558) = 1.752223373877631730e+03\n        j0zeros(559) = 1.755364966403547214e+03\n        j0zeros(560) = 1.758506558929919265e+03\n        j0zeros(561) = 1.761648151456744927e+03\n        j0zeros(562) = 1.764789743984021925e+03\n        j0zeros(563) = 1.767931336511747531e+03\n        j0zeros(564) = 1.771072929039920155e+03\n        j0zeros(565) = 1.774214521568536611e+03\n        j0zeros(566) = 1.777356114097594855e+03\n        j0zeros(567) = 1.780497706627092612e+03\n        j0zeros(568) = 1.783639299157027608e+03\n        j0zeros(569) = 1.786780891687397570e+03\n        j0zeros(570) = 1.789922484218199770e+03\n        j0zeros(571) = 1.793064076749432388e+03\n        j0zeros(572) = 1.796205669281092923e+03\n        j0zeros(573) = 1.799347261813179330e+03\n        j0zeros(574) = 1.802488854345689106e+03\n        j0zeros(575) = 1.805630446878620432e+03\n        j0zeros(576) = 1.808772039411970582e+03\n        j0zeros(577) = 1.811913631945737961e+03\n        j0zeros(578) = 1.815055224479919843e+03\n        j0zeros(579) = 1.818196817014514863e+03\n        j0zeros(580) = 1.821338409549520065e+03\n        j0zeros(581) = 1.824480002084933631e+03\n        j0zeros(582) = 1.827621594620753740e+03\n        j0zeros(583) = 1.830763187156977665e+03\n        j0zeros(584) = 1.833904779693603814e+03\n        j0zeros(585) = 1.837046372230629913e+03\n        j0zeros(586) = 1.840187964768054371e+03\n        j0zeros(587) = 1.843329557305874459e+03\n        j0zeros(588) = 1.846471149844088586e+03\n        j0zeros(589) = 1.849612742382694705e+03\n        j0zeros(590) = 1.852754334921690770e+03\n        j0zeros(591) = 1.855895927461074734e+03\n        j0zeros(592) = 1.859037520000844779e+03\n        j0zeros(593) = 1.862179112540998858e+03\n        j0zeros(594) = 1.865320705081534697e+03\n        j0zeros(595) = 1.868462297622451160e+03\n        j0zeros(596) = 1.871603890163745518e+03\n        j0zeros(597) = 1.874745482705416634e+03\n        j0zeros(598) = 1.877887075247461780e+03\n        j0zeros(599) = 1.881028667789879819e+03\n        j0zeros(600) = 1.884170260332668477e+03\n        j0zeros(601) = 1.887311852875826162e+03\n        j0zeros(602) = 1.890453445419350828e+03\n        j0zeros(603) = 1.893595037963240429e+03\n        j0zeros(604) = 1.896736630507493828e+03\n        j0zeros(605) = 1.899878223052108524e+03\n        j0zeros(606) = 1.903019815597083152e+03\n        j0zeros(607) = 1.906161408142415667e+03\n        j0zeros(608) = 1.909303000688104703e+03\n        j0zeros(609) = 1.912444593234147760e+03\n        j0zeros(610) = 1.915586185780544156e+03\n        j0zeros(611) = 1.918727778327291389e+03\n        j0zeros(612) = 1.921869370874387641e+03\n        j0zeros(613) = 1.925010963421831775e+03\n        j0zeros(614) = 1.928152555969621517e+03\n        j0zeros(615) = 1.931294148517755957e+03\n        j0zeros(616) = 1.934435741066232367e+03\n        j0zeros(617) = 1.937577333615050065e+03\n        j0zeros(618) = 1.940718926164206550e+03\n        j0zeros(619) = 1.943860518713701140e+03\n        j0zeros(620) = 1.947002111263531106e+03\n        j0zeros(621) = 1.950143703813695765e+03\n        j0zeros(622) = 1.953285296364193073e+03\n        j0zeros(623) = 1.956426888915021209e+03\n        j0zeros(624) = 1.959568481466179264e+03\n        j0zeros(625) = 1.962710074017664738e+03\n        j0zeros(626) = 1.965851666569476947e+03\n        j0zeros(627) = 1.968993259121613619e+03\n        j0zeros(628) = 1.972134851674073843e+03\n        j0zeros(629) = 1.975276444226855347e+03\n        j0zeros(630) = 1.978418036779957447e+03\n        j0zeros(631) = 1.981559629333377870e+03\n        j0zeros(632) = 1.984701221887115480e+03\n        j0zeros(633) = 1.987842814441168912e+03\n        j0zeros(634) = 1.990984406995536119e+03\n        j0zeros(635) = 1.994125999550216193e+03\n        j0zeros(636) = 1.997267592105207314e+03\n        j0zeros(637) = 2.000409184660508345e+03\n        j0zeros(638) = 2.003550777216117240e+03\n        j0zeros(639) = 2.006692369772033317e+03\n        j0zeros(640) = 2.009833962328254302e+03\n        j0zeros(641) = 2.012975554884779740e+03\n        j0zeros(642) = 2.016117147441607131e+03\n        j0zeros(643) = 2.019258739998736019e+03\n        j0zeros(644) = 2.022400332556164585e+03\n        j0zeros(645) = 2.025541925113891239e+03\n        j0zeros(646) = 2.028683517671914842e+03\n        j0zeros(647) = 2.031825110230233804e+03\n        j0zeros(648) = 2.034966702788847215e+03\n        j0zeros(649) = 2.038108295347753256e+03\n        j0zeros(650) = 2.041249887906951017e+03\n        j0zeros(651) = 2.044391480466438452e+03\n        j0zeros(652) = 2.047533073026215106e+03\n        j0zeros(653) = 2.050674665586278934e+03\n        j0zeros(654) = 2.053816258146629025e+03\n        j0zeros(655) = 2.056957850707263333e+03\n        j0zeros(656) = 2.060099443268182313e+03\n        j0zeros(657) = 2.063241035829382781e+03\n        j0zeros(658) = 2.066382628390863829e+03\n        j0zeros(659) = 2.069524220952625001e+03\n        j0zeros(660) = 2.072665813514664478e+03\n        j0zeros(661) = 2.075807406076980897e+03\n        j0zeros(662) = 2.078948998639573347e+03\n        j0zeros(663) = 2.082090591202440464e+03\n        j0zeros(664) = 2.085232183765580885e+03\n        j0zeros(665) = 2.088373776328993245e+03\n        j0zeros(666) = 2.091515368892676634e+03\n        j0zeros(667) = 2.094656961456630142e+03\n        j0zeros(668) = 2.097798554020851498e+03\n        j0zeros(669) = 2.100940146585340244e+03\n        j0zeros(670) = 2.104081739150095018e+03\n        j0zeros(671) = 2.107223331715115364e+03\n        j0zeros(672) = 2.110364924280398554e+03\n        j0zeros(673) = 2.113506516845944589e+03\n        j0zeros(674) = 2.116648109411752102e+03\n        j0zeros(675) = 2.119789701977819732e+03\n        j0zeros(676) = 2.122931294544146112e+03\n        j0zeros(677) = 2.126072887110730790e+03\n        j0zeros(678) = 2.129214479677572399e+03\n        j0zeros(679) = 2.132356072244669122e+03\n        j0zeros(680) = 2.135497664812020048e+03\n        j0zeros(681) = 2.138639257379624723e+03\n        j0zeros(682) = 2.141780849947482238e+03\n        j0zeros(683) = 2.144922442515590319e+03\n        j0zeros(684) = 2.148064035083948056e+03\n        j0zeros(685) = 2.151205627652554995e+03\n        j0zeros(686) = 2.154347220221410225e+03\n        j0zeros(687) = 2.157488812790511929e+03\n        j0zeros(688) = 2.160630405359859196e+03\n        j0zeros(689) = 2.163771997929451572e+03\n        j0zeros(690) = 2.166913590499287238e+03\n        j0zeros(691) = 2.170055183069364830e+03\n", "        j0zeros(692) = 2.173196775639684347e+03\n        j0zeros(693) = 2.176338368210244880e+03\n        j0zeros(694) = 2.179479960781043701e+03\n        j0zeros(695) = 2.182621553352081264e+03\n        j0zeros(696) = 2.185763145923356205e+03\n        j0zeros(697) = 2.188904738494867615e+03\n        j0zeros(698) = 2.192046331066614130e+03\n        j0zeros(699) = 2.195187923638594839e+03\n        j0zeros(700) = 2.198329516210808833e+03\n        j0zeros(701) = 2.201471108783255204e+03\n        j0zeros(702) = 2.204612701355932586e+03\n        j0zeros(703) = 2.207754293928840070e+03\n        j0zeros(704) = 2.210895886501977657e+03\n        j0zeros(705) = 2.214037479075343072e+03\n        j0zeros(706) = 2.217179071648935405e+03\n        j0zeros(707) = 2.220320664222755113e+03\n        j0zeros(708) = 2.223462256796799466e+03\n        j0zeros(709) = 2.226603849371068463e+03\n        j0zeros(710) = 2.229745441945560742e+03\n        j0zeros(711) = 2.232887034520276302e+03\n        j0zeros(712) = 2.236028627095212869e+03\n        j0zeros(713) = 2.239170219670369988e+03\n        j0zeros(714) = 2.242311812245747205e+03\n        j0zeros(715) = 2.245453404821343611e+03\n        j0zeros(716) = 2.248594997397157385e+03\n        j0zeros(717) = 2.251736589973188075e+03\n        j0zeros(718) = 2.254878182549435678e+03\n        j0zeros(719) = 2.258019775125897922e+03\n        j0zeros(720) = 2.261161367702574353e+03\n        j0zeros(721) = 2.264302960279464514e+03\n        j0zeros(722) = 2.267444552856567498e+03\n        j0zeros(723) = 2.270586145433881484e+03\n        j0zeros(724) = 2.273727738011406473e+03\n        j0zeros(725) = 2.276869330589141555e+03\n        j0zeros(726) = 2.280010923167085821e+03\n        j0zeros(727) = 2.283152515745237906e+03\n        j0zeros(728) = 2.286294108323597357e+03\n        j0zeros(729) = 2.289435700902163262e+03\n        j0zeros(730) = 2.292577293480935168e+03\n        j0zeros(731) = 2.295718886059911256e+03\n        j0zeros(732) = 2.298860478639091525e+03\n        j0zeros(733) = 2.302002071218475066e+03\n        j0zeros(734) = 2.305143663798060516e+03\n        j0zeros(735) = 2.308285256377847418e+03\n        j0zeros(736) = 2.311426848957835318e+03\n        j0zeros(737) = 2.314568441538022853e+03\n        j0zeros(738) = 2.317710034118409567e+03\n        j0zeros(739) = 2.320851626698994096e+03\n        j0zeros(740) = 2.323993219279776440e+03\n        j0zeros(741) = 2.327134811860754780e+03\n        j0zeros(742) = 2.330276404441929117e+03\n        j0zeros(743) = 2.333417997023298540e+03\n        j0zeros(744) = 2.336559589604862140e+03\n        j0zeros(745) = 2.339701182186619462e+03\n        j0zeros(746) = 2.342842774768568688e+03\n        j0zeros(747) = 2.345984367350710272e+03\n        j0zeros(748) = 2.349125959933043305e+03\n        j0zeros(749) = 2.352267552515565967e+03\n        j0zeros(750) = 2.355409145098278714e+03\n        j0zeros(751) = 2.358550737681180181e+03\n        j0zeros(752) = 2.361692330264269458e+03\n        j0zeros(753) = 2.364833922847546091e+03\n        j0zeros(754) = 2.367975515431009626e+03\n        j0zeros(755) = 2.371117108014659152e+03\n        j0zeros(756) = 2.374258700598493306e+03\n        j0zeros(757) = 2.377400293182511632e+03\n        j0zeros(758) = 2.380541885766713676e+03\n        j0zeros(759) = 2.383683478351098984e+03\n        j0zeros(760) = 2.386825070935666190e+03\n        j0zeros(761) = 2.389966663520414841e+03\n        j0zeros(762) = 2.393108256105344935e+03\n        j0zeros(763) = 2.396249848690454201e+03\n        j0zeros(764) = 2.399391441275743091e+03\n        j0zeros(765) = 2.402533033861210242e+03\n        j0zeros(766) = 2.405674626446856109e+03\n        j0zeros(767) = 2.408816219032678418e+03\n        j0zeros(768) = 2.411957811618677624e+03\n        j0zeros(769) = 2.415099404204852362e+03\n        j0zeros(770) = 2.418240996791203088e+03\n        j0zeros(771) = 2.421382589377727527e+03\n        j0zeros(772) = 2.424524181964426134e+03\n        j0zeros(773) = 2.427665774551298000e+03\n        j0zeros(774) = 2.430807367138341760e+03\n        j0zeros(775) = 2.433948959725557415e+03\n        j0zeros(776) = 2.437090552312944510e+03\n        j0zeros(777) = 2.440232144900502135e+03\n        j0zeros(778) = 2.443373737488229381e+03\n        j0zeros(779) = 2.446515330076125338e+03\n        j0zeros(780) = 2.449656922664190006e+03\n        j0zeros(781) = 2.452798515252423385e+03\n        j0zeros(782) = 2.455940107840823202e+03\n        j0zeros(783) = 2.459081700429389457e+03\n        j0zeros(784) = 2.462223293018122149e+03\n        j0zeros(785) = 2.465364885607019914e+03\n        j0zeros(786) = 2.468506478196081844e+03\n        j0zeros(787) = 2.471648070785308391e+03\n        j0zeros(788) = 2.474789663374698193e+03\n        j0zeros(789) = 2.477931255964250795e+03\n        j0zeros(790) = 2.481072848553965741e+03\n        j0zeros(791) = 2.484214441143841668e+03\n        j0zeros(792) = 2.487356033733879485e+03\n        j0zeros(793) = 2.490497626324076919e+03\n        j0zeros(794) = 2.493639218914433968e+03\n        j0zeros(795) = 2.496780811504951089e+03\n        j0zeros(796) = 2.499922404095625552e+03\n        j0zeros(797) = 2.503063996686458722e+03\n        j0zeros(798) = 2.506205589277448780e+03\n        j0zeros(799) = 2.509347181868596181e+03\n        j0zeros(800) = 2.512488774459899105e+03\n        j0zeros(801) = 2.515630367051357553e+03\n        j0zeros(802) = 2.518771959642971069e+03\n        j0zeros(803) = 2.521913552234739655e+03\n        j0zeros(804) = 2.525055144826661490e+03\n        j0zeros(805) = 2.528196737418736575e+03\n        j0zeros(806) = 2.531338330010964910e+03\n        j0zeros(807) = 2.534479922603344676e+03\n        j0zeros(808) = 2.537621515195876327e+03\n        j0zeros(809) = 2.540763107788558500e+03\n        j0zeros(810) = 2.543904700381392104e+03\n        j0zeros(811) = 2.547046292974374865e+03\n        j0zeros(812) = 2.550187885567506783e+03\n        j0zeros(813) = 2.553329478160787858e+03\n        j0zeros(814) = 2.556471070754217180e+03\n        j0zeros(815) = 2.559612663347793841e+03\n        j0zeros(816) = 2.562754255941517840e+03\n        j0zeros(817) = 2.565895848535388723e+03\n        j0zeros(818) = 2.569037441129405579e+03\n        j0zeros(819) = 2.572179033723567500e+03\n        j0zeros(820) = 2.575320626317874485e+03\n        j0zeros(821) = 2.578462218912326534e+03\n        j0zeros(822) = 2.581603811506921829e+03\n        j0zeros(823) = 2.584745404101660824e+03\n        j0zeros(824) = 2.587886996696542610e+03\n        j0zeros(825) = 2.591028589291567187e+03\n        j0zeros(826) = 2.594170181886733189e+03\n        j0zeros(827) = 2.597311774482040619e+03\n        j0zeros(828) = 2.600453367077489020e+03\n        j0zeros(829) = 2.603594959673077483e+03\n        j0zeros(830) = 2.606736552268805553e+03\n        j0zeros(831) = 2.609878144864673231e+03\n        j0zeros(832) = 2.613019737460680062e+03\n        j0zeros(833) = 2.616161330056824681e+03\n        j0zeros(834) = 2.619302922653107089e+03\n        j0zeros(835) = 2.622444515249527285e+03\n        j0zeros(836) = 2.625586107846083905e+03\n        j0zeros(837) = 2.628727700442776495e+03\n        j0zeros(838) = 2.631869293039605509e+03\n        j0zeros(839) = 2.635010885636569583e+03\n        j0zeros(840) = 2.638152478233668717e+03\n        j0zeros(841) = 2.641294070830902001e+03\n        j0zeros(842) = 2.644435663428268981e+03\n        j0zeros(843) = 2.647577256025770112e+03\n        j0zeros(844) = 2.650718848623403574e+03\n        j0zeros(845) = 2.653860441221169822e+03\n        j0zeros(846) = 2.657002033819068401e+03\n        j0zeros(847) = 2.660143626417097948e+03\n        j0zeros(848) = 2.663285219015258463e+03\n        j0zeros(849) = 2.666426811613549944e+03\n        j0zeros(850) = 2.669568404211971938e+03\n        j0zeros(851) = 2.672709996810523080e+03\n        j0zeros(852) = 2.675851589409203370e+03\n        j0zeros(853) = 2.678993182008012354e+03\n        j0zeros(854) = 2.682134774606950486e+03\n        j0zeros(855) = 2.685276367206015948e+03\n        j0zeros(856) = 2.688417959805208739e+03\n        j0zeros(857) = 2.691559552404528858e+03\n        j0zeros(858) = 2.694701145003974943e+03\n        j0zeros(859) = 2.697842737603547448e+03\n        j0zeros(860) = 2.700984330203245463e+03\n        j0zeros(861) = 2.704125922803069443e+03\n        j0zeros(862) = 2.707267515403017114e+03\n        j0zeros(863) = 2.710409108003089841e+03\n        j0zeros(864) = 2.713550700603286259e+03\n        j0zeros(865) = 2.716692293203606368e+03\n        j0zeros(866) = 2.719833885804049260e+03\n        j0zeros(867) = 2.722975478404614933e+03\n        j0zeros(868) = 2.726117071005302932e+03\n        j0zeros(869) = 2.729258663606112350e+03\n        j0zeros(870) = 2.732400256207043185e+03\n        j0zeros(871) = 2.735541848808095438e+03\n        j0zeros(872) = 2.738683441409268198e+03\n        j0zeros(873) = 2.741825034010560557e+03\n        j0zeros(874) = 2.744966626611972970e+03\n        j0zeros(875) = 2.748108219213504071e+03\n        j0zeros(876) = 2.751249811815155226e+03\n        j0zeros(877) = 2.754391404416924161e+03\n        j0zeros(878) = 2.757532997018810875e+03\n        j0zeros(879) = 2.760674589620815823e+03\n        j0zeros(880) = 2.763816182222938096e+03\n        j0zeros(881) = 2.766957774825176784e+03\n        j0zeros(882) = 2.770099367427531888e+03\n        j0zeros(883) = 2.773240960030003862e+03\n        j0zeros(884) = 2.776382552632590887e+03\n        j0zeros(885) = 2.779524145235292963e+03\n        j0zeros(886) = 2.782665737838110090e+03\n        j0zeros(887) = 2.785807330441042268e+03\n        j0zeros(888) = 2.788948923044088133e+03\n        j0zeros(889) = 2.792090515647247685e+03\n        j0zeros(890) = 2.795232108250520923e+03\n        j0zeros(891) = 2.798373700853906939e+03\n        j0zeros(892) = 2.801515293457405733e+03\n        j0zeros(893) = 2.804656886061016394e+03\n        j0zeros(894) = 2.807798478664739378e+03\n        j0zeros(895) = 2.810940071268573320e+03\n        j0zeros(896) = 2.814081663872518675e+03\n        j0zeros(897) = 2.817223256476574534e+03\n        j0zeros(898) = 2.820364849080740896e+03\n        j0zeros(899) = 2.823506441685017307e+03\n        j0zeros(900) = 2.826648034289402858e+03\n        j0zeros(901) = 2.829789626893898458e+03\n        j0zeros(902) = 2.832931219498502287e+03\n        j0zeros(903) = 2.836072812103214801e+03\n        j0zeros(904) = 2.839214404708035545e+03\n        j0zeros(905) = 2.842355997312964519e+03\n        j0zeros(906) = 2.845497589918000358e+03\n        j0zeros(907) = 2.848639182523143063e+03\n        j0zeros(908) = 2.851780775128393088e+03\n        j0zeros(909) = 2.854922367733749525e+03\n        j0zeros(910) = 2.858063960339211462e+03\n        j0zeros(911) = 2.861205552944779356e+03\n        j0zeros(912) = 2.864347145550453206e+03\n        j0zeros(913) = 2.867488738156231193e+03\n        j0zeros(914) = 2.870630330762114227e+03\n        j0zeros(915) = 2.873771923368101398e+03\n        j0zeros(916) = 2.876913515974192705e+03\n        j0zeros(917) = 2.880055108580387241e+03\n        j0zeros(918) = 2.883196701186685459e+03\n        j0zeros(919) = 2.886338293793086450e+03\n        j0zeros(920) = 2.889479886399590214e+03\n        j0zeros(921) = 2.892621479006196296e+03\n        j0zeros(922) = 2.895763071612903786e+03\n        j0zeros(923) = 2.898904664219713595e+03\n        j0zeros(924) = 2.902046256826624358e+03\n        j0zeros(925) = 2.905187849433636075e+03\n        j0zeros(926) = 2.908329442040748290e+03\n        j0zeros(927) = 2.911471034647961460e+03\n        j0zeros(928) = 2.914612627255273765e+03\n        j0zeros(929) = 2.917754219862686114e+03\n        j0zeros(930) = 2.920895812470197598e+03\n        j0zeros(931) = 2.924037405077808671e+03\n        j0zeros(932) = 2.927178997685517970e+03\n        j0zeros(933) = 2.930320590293325495e+03\n        j0zeros(934) = 2.933462182901231699e+03\n        j0zeros(935) = 2.936603775509234765e+03\n        j0zeros(936) = 2.939745368117335602e+03\n        j0zeros(937) = 2.942886960725533754e+03\n        j0zeros(938) = 2.946028553333828768e+03\n        j0zeros(939) = 2.949170145942220188e+03\n        j0zeros(940) = 2.952311738550707560e+03\n        j0zeros(941) = 2.955453331159290883e+03\n        j0zeros(942) = 2.958594923767970613e+03\n        j0zeros(943) = 2.961736516376744476e+03\n        j0zeros(944) = 2.964878108985613835e+03\n        j0zeros(945) = 2.968019701594578237e+03\n        j0zeros(946) = 2.971161294203636317e+03\n        j0zeros(947) = 2.974302886812788529e+03\n        j0zeros(948) = 2.977444479422034874e+03\n        j0zeros(949) = 2.980586072031374897e+03\n        j0zeros(950) = 2.983727664640807689e+03\n        j0zeros(951) = 2.986869257250333249e+03\n        j0zeros(952) = 2.990010849859951122e+03\n        j0zeros(953) = 2.993152442469662219e+03\n        j0zeros(954) = 2.996294035079464720e+03\n        j0zeros(955) = 2.999435627689359080e+03\n        j0zeros(956) = 3.002577220299345299e+03\n        j0zeros(957) = 3.005718812909422013e+03\n        j0zeros(958) = 3.008860405519589676e+03\n        j0zeros(959) = 3.012001998129847834e+03\n        j0zeros(960) = 3.015143590740196942e+03\n        j0zeros(961) = 3.018285183350635634e+03\n        j0zeros(962) = 3.021426775961163912e+03\n        j0zeros(963) = 3.024568368571782230e+03\n        j0zeros(964) = 3.027709961182489224e+03\n        j0zeros(965) = 3.030851553793284893e+03\n        j0zeros(966) = 3.033993146404169693e+03\n        j0zeros(967) = 3.037134739015142713e+03\n        j0zeros(968) = 3.040276331626203955e+03\n        j0zeros(969) = 3.043417924237352508e+03\n        j0zeros(970) = 3.046559516848588828e+03\n        j0zeros(971) = 3.049701109459912914e+03\n        j0zeros(972) = 3.052842702071323401e+03\n        j0zeros(973) = 3.055984294682820291e+03\n        j0zeros(974) = 3.059125887294404492e+03\n        j0zeros(975) = 3.062267479906074186e+03\n        j0zeros(976) = 3.065409072517830282e+03\n        j0zeros(977) = 3.068550665129671415e+03\n        j0zeros(978) = 3.071692257741598951e+03\n        j0zeros(979) = 3.074833850353611069e+03\n        j0zeros(980) = 3.077975442965707771e+03\n        j0zeros(981) = 3.081117035577889055e+03\n        j0zeros(982) = 3.084258628190155378e+03\n        j0zeros(983) = 3.087400220802505373e+03\n        j0zeros(984) = 3.090541813414939043e+03\n        j0zeros(985) = 3.093683406027456840e+03\n        j0zeros(986) = 3.096824998640057402e+03\n        j0zeros(987) = 3.099966591252741182e+03\n        j0zeros(988) = 3.103108183865507726e+03\n        j0zeros(989) = 3.106249776478357489e+03\n        j0zeros(990) = 3.109391369091289107e+03\n        j0zeros(991) = 3.112532961704302579e+03\n        j0zeros(992) = 3.115674554317397906e+03\n        j0zeros(993) = 3.118816146930575542e+03\n        j0zeros(994) = 3.121957739543833668e+03\n        j0zeros(995) = 3.125099332157173194e+03\n        j0zeros(996) = 3.128240924770593665e+03\n        j0zeros(997) = 3.131382517384094626e+03\n        j0zeros(998) = 3.134524109997675623e+03\n        j0zeros(999) = 3.137665702611337110e+03\n        j0zeros(1000) = 3.140807295225078633e+03\n        j0zeros(1001) = 3.143948887838899282e+03\n        j0zeros(1002) = 3.147090480452799511e+03\n        j0zeros(1003) = 3.150232073066778867e+03\n        j0zeros(1004) = 3.153373665680837803e+03\n        j0zeros(1005) = 3.156515258294974956e+03\n        j0zeros(1006) = 3.159656850909190325e+03\n        j0zeros(1007) = 3.162798443523484366e+03\n        j0zeros(1008) = 3.165940036137856168e+03\n        j0zeros(1009) = 3.169081628752305278e+03\n        j0zeros(1010) = 3.172223221366832604e+03\n        j0zeros(1011) = 3.175364813981437237e+03\n        j0zeros(1012) = 3.178506406596118268e+03\n        j0zeros(1013) = 3.181647999210876606e+03\n        j0zeros(1014) = 3.184789591825711341e+03\n        j0zeros(1015) = 3.187931184440622928e+03\n        j0zeros(1016) = 3.191072777055610004e+03\n        j0zeros(1017) = 3.194214369670673477e+03\n        j0zeros(1018) = 3.197355962285812893e+03\n        j0zeros(1019) = 3.200497554901026888e+03\n        j0zeros(1020) = 3.203639147516316825e+03\n        j0zeros(1021) = 3.206780740131681341e+03\n        j0zeros(1022) = 3.209922332747121345e+03\n        j0zeros(1023) = 3.213063925362635473e+03\n        j0zeros(1024) = 3.216205517978224179e+03\n        j0zeros(1025) = 3.219347110593887010e+03\n        j0zeros(1026) = 3.222488703209623964e+03\n        j0zeros(1027) = 3.225630295825434132e+03\n        j0zeros(1028) = 3.228771888441318424e+03\n        j0zeros(1029) = 3.231913481057275931e+03\n        j0zeros(1030) = 3.235055073673306197e+03\n        j0zeros(1031) = 3.238196666289409222e+03\n", "MODULE GKV_math\n!\n!  Mathematical functions using MATRIX/MPP library\n!\n!  This routine uses the unit number of 99 which \n!    should not be overlapped with others\n!\n!  T.-H. Watanabe (Feb 2011)\n!                 (May 2011) with new functions, \n!                            J1 and zero points of J0\n!\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random\n\n  integer, parameter :: DP = selected_real_kind(14)\n  integer, parameter :: ifnc = 99! unit number preserved \n                                 ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n\n    real(kind=DP) :: mdmj0m\n     \n      j0 = mdmj0m( x )\n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1 .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n\n    real(kind=DP) :: mdmj1m\n     \n      j1 = mdmj1m( x )\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n\n    real(kind=DP) :: mdmj0m\n    real(kind=DP) :: mdmj1m\n     \n      j0 = mdmj0m( x )\n      j1 = mdmj1m( x )\n\n      if (x /= 0._DP) then\n        j2 = 2._DP*mdmj1m(x)/x - mdmj0m(x)\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n\n    real(kind=DP) :: mdminm\n\n      if( 0._DP <= x .and.  x < 150._DP ) then\n        i0 = mdminm( 0, x )\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n\n    real(kind=DP), intent(inout), dimension(:) :: rr\n\n    integer(kind=8), save :: iseed \n    integer :: nr, ierr\n\n    data iseed / 211501 /\n\n      nr = size(rr)\n\n      call hdru3m( nr, iseed, rr, ierr )\n\n    return\n\n  END SUBROUTINE math_random\n\n\nEND MODULE GKV_math\n", "MODULE GKV_math\n!-------------------------------------------------------------------------------\n!\n!    Mathematical functions\n!\n!    Update history of gkvp_set.f90\n!    --------------\n!      gkvp_f0.62 (S. Maeyama, Mar 2023)\n!        - Elliptic integrals math_eli1, math_eli2 are added.\n!      gkvp_f0.61 (S. Maeyama, Mar 2021)\n!        - random_seed is added for reproducibility.\n!\n!-------------------------------------------------------------------------------\n\n  use GKV_header\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random, &\n           math_eli1, math_eli2\n\n\n  integer, parameter :: ifnc = 99 ! unit number preserved \n                                  ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n!\n      j0 = dbesj0(x)\n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1  .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n!\n      j1 = dbesj1(x)\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     2nd-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n!\n      if (x /= 0._DP ) then \n        j2 = 2._DP*dbesj1(x)/x - dbesj0(x)\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n!\n      if( 0._DP <= x  .and.  x < 150._DP ) then\n        i0 = dbesi0(x)\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n  SUBROUTINE math_eli1( x, eli1 )\n!\n!     Complete elliptic integral of the first kind K\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: eli1\n!\n    real(kind=DP) :: sqrtx\n!\n      sqrtx = sqrt(x)\n      if( 0._DP <= sqrtx  .and.  sqrtx < 1._DP ) then\n        eli1 = ellipk(sqrtx)\n      else\n        print *, \"### math_eli1:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_eli1\n\n  SUBROUTINE math_eli2( x, eli2 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: eli2\n!\n    real(kind=DP) :: sqrtx\n!\n      sqrtx = sqrt(x)\n      if( 0._DP <= sqrtx  .and.  sqrtx < 1._DP ) then\n        eli2 = ellipe(sqrtx)\n      else\n        print *, \"### math_eli2:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_eli2\n\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n!\n    real(kind=DP), intent(inout), dimension(:) :: rr\n    integer :: n\n    integer, allocatable :: iseed(:)\n     call random_seed(size=n)\n     allocate(iseed(n))\n     iseed(:) = 211501\n     call random_seed(put=iseed)\n     deallocate(iseed)\n!\n      call random_number(rr)\n!\n    return\n\n  END SUBROUTINE math_random\n\n\n!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n!%%%                                                                         %%%\n!%%%  Ooura's Bessel Functions Library                                       %%%\n!%%%                                                                         %%%\n!%%%    http://www.kurims.kyoto-u.ac.jp/~ooura/bessel.html                   %%%\n!%%%                                                                         %%%\n!%%%    Copyright(C) 1996 Takuya OOURA (email: ooura@mmm.t.u-tokyo.ac.jp).   %%%\n!%%%    You may use, copy, modify this code for any purpose and              %%%\n!%%%    without fee. You may distribute this ORIGINAL package.               %%%\n!%%%                                                                         %%%\n!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n! Bessel J_0(x) function in double precision\n!\n      function dbesj0(x)\n      !implicit integer (i - n)\n      !implicit real*8 (a - h, o - z)\n      !dimension a(0 : 7), b(0 : 64), c(0 : 69), d(0 : 51)\n      !parameter (pi4 = 0.78539816339744830962d0)\n      implicit none\n      real(kind=8), parameter :: pi4 = 0.78539816339744830962d0\n      real(kind=8) :: a(0:7), b(0:64), c(0:69), d(0:51)\n      real(kind=8) :: t, v, w, x, y, theta, dbesj0\n      integer :: i, k\n      data (a(i), i = 0, 7) /                                     &\n          -0.0000000000023655394d0, 0.0000000004708898680d0,      &\n          -0.0000000678167892231d0, 0.0000067816840038636d0,      &\n          -0.0004340277777716935d0, 0.0156249999999992397d0,      &\n          -0.2499999999999999638d0, 0.9999999999999999997d0 / \n      data (b(i), i = 0, 12) /                                    &\n          0.0000000000626681117d0, -0.0000000022270614428d0,      &\n          0.0000000662981656302d0, -0.0000016268486502196d0,      &\n          0.0000321978384111685d0, -0.0005005237733315830d0,      &\n          0.0059060313537449816d0, -0.0505265323740109701d0,      &\n          0.2936432097610503985d0, -1.0482565081091638637d0,      &\n          1.9181123286040428113d0, -1.1319199475221700100d0,      &\n          -0.1965480952704682000d0 / \n      data (b(i), i = 13, 25) /                                   &\n          0.0000000000457457332d0, -0.0000000015814772025d0,      &\n          0.0000000455487446311d0, -0.0000010735201286233d0,      &\n          0.0000202015179970014d0, -0.0002942392368203808d0,      &\n          0.0031801987726150648d0, -0.0239875209742846362d0,      &\n          0.1141447698973777641d0, -0.2766726722823530233d0,      &\n          0.1088620480970941648d0, 0.5136514645381999197d0,       &\n          -0.2100594022073706033d0 / \n      data (b(i), i = 26, 38) /                                   &\n          0.0000000000331366618d0, -0.0000000011119090229d0,      &\n          0.0000000308823040363d0, -0.0000006956602653104d0,      &\n          0.0000123499947481762d0, -0.0001662951945396180d0,      &\n          0.0016048663165678412d0, -0.0100785479932760966d0,      &\n          0.0328996815223415274d0, -0.0056168761733860688d0,      &\n          -0.2341096400274429386d0, 0.2551729256776404262d0,      &\n          0.2288438186148935667d0 / \n      data (b(i), i = 39, 51) /                                   &\n          0.0000000000238007203d0, -0.0000000007731046439d0,      &\n          0.0000000206237001152d0, -0.0000004412291442285d0,      &\n          0.0000073107766249655d0, -0.0000891749801028666d0,      &\n          0.0007341654513841350d0, -0.0033303085445352071d0,      &\n          0.0015425853045205717d0, 0.0521100583113136379d0,       &\n          -0.1334447768979217815d0, -0.1401330292364750968d0,     &\n          0.2685616168804818919d0 / \n      data (b(i), i = 52, 64) /                                   &\n          0.0000000000169355950d0, -0.0000000005308092192d0,      &\n          0.0000000135323005576d0, -0.0000002726650587978d0,      &\n          0.0000041513240141760d0, -0.0000443353052220157d0,      &\n          0.0002815740758993879d0, -0.0004393235121629007d0,      &\n          -0.0067573531105799347d0, 0.0369141914660130814d0,      &\n          0.0081673361942996237d0, -0.2573381285898881860d0,      &\n          0.0459580257102978932d0 / \n      data (c(i), i = 0, 13) /                                    &\n          -0.00000000003009451757d0, -0.00000000014958003844d0,   & \n          0.00000000506854544776d0, 0.00000001863564222012d0,     &\n          -0.00000060304249068078d0, -0.00000147686259937403d0,   & \n          0.00004714331342682714d0, 0.00006286305481740818d0,     &\n          -0.00214137170594124344d0, -0.00089157336676889788d0,   &\n          0.04508258728666024989d0, -0.00490362805828762224d0,    &\n          -0.27312196367405374426d0, 0.04193925184293450356d0 /   \n      data (c(i), i = 14, 27) /                                   &\n          -0.00000000000712453560d0, -0.00000000041170814825d0,   &\n          0.00000000138012624364d0, 0.00000005704447670683d0,     &\n          -0.00000019026363528842d0, -0.00000533925032409729d0,   &\n          0.00001736064885538091d0, 0.00030692619152608375d0,     &\n          -0.00092598938200644367d0, -0.00917934265960017663d0,   &\n          0.02287952522866389076d0, 0.10545197546252853195d0,     &\n          -0.16126443075752985095d0, -0.19392874768742235538d0 /  \n      data (c(i), i = 28, 41) /                                   &\n          0.00000000002128344556d0, -0.00000000031053910272d0,    &\n          -0.00000000334979293158d0, 0.00000004507232895050d0,    &\n          0.00000036437959146427d0, -0.00000446421436266678d0,    &\n          -0.00002523429344576552d0, 0.00027519882931758163d0,    &\n          0.00097185076358599358d0, -0.00898326746345390692d0,    &\n          -0.01665959196063987584d0, 0.11456933464891967814d0,    &\n          0.07885001422733148815d0, -0.23664819446234712621d0 /   \n      data (c(i), i = 42, 55) /                                   &\n          0.00000000003035295055d0, 0.00000000005486066835d0,     &\n          -0.00000000501026824811d0, -0.00000000501246847860d0,   &\n          0.00000058012340163034d0, 0.00000016788922416169d0,     &\n          -0.00004373270270147275d0, 0.00001183898532719802d0,    &\n          0.00189863342862291449d0, -0.00113759249561636130d0,    &\n          -0.03846797195329871681d0, 0.02389746880951420335d0,    &\n          0.22837862066532347461d0, -0.06765394811166522844d0 /   \n      data (c(i), i = 56, 69) /                                   &\n          0.00000000001279875977d0, 0.00000000035925958103d0,     &\n          -0.00000000228037105967d0, -0.00000004852770517176d0,   &\n          0.00000028696428000189d0, 0.00000440131125178642d0,     &\n          -0.00002366617753349105d0, -0.00024412456252884129d0,   &\n          0.00113028178539430542d0, 0.00708470513919789080d0,     &\n          -0.02526914792327618386d0, -0.08006137953480093426d0,   &\n          0.16548380461475971846d0, 0.14688405470042110229d0 /   \n      data (d(i), i = 0, 12) /                                    &\n          1.059601355592185731d-14, -2.71150591218550377d-13,     &\n          8.6514809056201638d-12, -4.6264028554286627d-10,        &\n          5.0815403835647104d-8, -1.76722552048141208d-5,         &\n          0.16286750396763997378d0, 2.949651820598278873d-13,     &\n          -8.818215611676125741d-12, 3.571119876162253451d-10,    &\n          -2.631924120993717060d-8, 4.709502795656698909d-6,      &\n          -5.208333333333283282d-3 / \n      data (d(i), i = 13, 25) /                                   &\n          7.18344107717531977d-15, -2.51623725588410308d-13,      &\n          8.6017784918920604d-12, -4.6256876614290359d-10,        &\n          5.0815343220437937d-8, -1.76722551764941970d-5,         &\n          0.16286750396763433767d0, 2.2327570859680094777d-13,    &\n          -8.464594853517051292d-12, 3.563766464349055183d-10,    &\n          -2.631843986737892965d-8, 4.709502342288659410d-6,      &\n          -5.2083333332278466225d-3 / \n      data (d(i), i = 26, 38) /                                   &\n          5.15413392842889366d-15, -2.27740238380640162d-13,      &\n          8.4827767197609014d-12, -4.6224753682737618d-10,        &\n          5.0814848128929134d-8, -1.76722547638767480d-5,         &\n          0.16286750396748926663d0, 1.7316195320192170887d-13,    &\n          -7.971122772293919646d-12, 3.544039469911895749d-10,    &\n          -2.631443902081701081d-8, 4.709498228695400603d-6,      &\n          -5.2083333315143653610d-3 / \n      data (d(i), i = 39, 51) /                                   &\n          3.84653681453798517d-15, -2.04464520778789011d-13,      &\n          8.3089298605177838d-12, -4.6155016158412096d-10,        &\n          5.0813263696466650d-8, -1.76722528311426167d-5,         &\n          0.16286750396650065930d0, 1.3797879972460878797d-13,    &\n          -7.448089381011684812d-12, 3.512733797106959780d-10,    &\n          -2.630500895563592722d-8, 4.709483934775839193d-6,      &\n          -5.2083333227940760113d-3 / \n      w = abs(x)\n      if (w .lt. 1) then\n          t = w * w\n          y = ((((((a(0) * t + a(1)) * t +                        &\n              a(2)) * t + a(3)) * t + a(4)) * t +                 &\n              a(5)) * t + a(6)) * t + a(7)\n      else if (w .lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = int(t)\n          t = t - (k + 0.5d0)\n          k = k * 13\n          y = (((((((((((b(k) * t + b(k + 1)) * t +               &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)\n      else ", "if (w .lt. 12.5d0) then\n          k = int(w)\n          t = w - (k + 0.5d0)\n          k = 14 * (k - 8)\n          y = ((((((((((((c(k) * t + c(k + 1)) * t +              &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * t + c(k + 9)) * t + c(k + 10)) * t +    &\n              c(k + 11)) * t + c(k + 12)) * t + c(k + 13)\n      else\n          v = 24 / w\n          t = v * v\n          k = 13 * (int(t))\n          y = ((((((d(k) * t + d(k + 1)) * t +                    &\n              d(k + 2)) * t + d(k + 3)) * t + d(k + 4)) * t +     &\n              d(k + 5)) * t + d(k + 6)) * sqrt(v)\n          theta = (((((d(k + 7) * t + d(k + 8)) * t +             &\n              d(k + 9)) * t + d(k + 10)) * t + d(k + 11)) * t +   &\n              d(k + 12)) * v - pi4\n          y = y * cos(w + theta)\n      end if\n      dbesj0 = y\n      end function dbesj0\n!\n! Bessel J_1(x) function in double precision\n!\n      function dbesj1(x)\n      !implicit integer (i - n)\n      !implicit real*8 (a - h, o - z)\n      !dimension a(0 : 7), b(0 : 64), c(0 : 69), d(0 : 51)\n      !parameter (pi4 = 0.78539816339744830962d0)\n      implicit none\n      real(kind=8), parameter :: pi4 = 0.78539816339744830962d0\n      real(kind=8) :: a(0:7), b(0:64), c(0:69), d(0:51)\n      real(kind=8) :: t, v, w, x, y, theta, dbesj1\n      integer :: i, k\n      data (a(i), i = 0, 7) /                                     &\n          -0.00000000000014810349d0, 0.00000000003363594618d0,    &\n          -0.00000000565140051697d0, 0.00000067816840144764d0,    &\n          -0.00005425347222188379d0, 0.00260416666666662438d0,    &\n          -0.06249999999999999799d0, 0.49999999999999999998d0 /   \n      data (b(i), i = 0, 12) /                                    &\n          0.00000000000243721316d0, -0.00000000009400554763d0,    &\n          0.00000000306053389980d0, -0.00000008287270492518d0,    &\n          0.00000183020515991344d0, -0.00003219783841164382d0,    &\n          0.00043795830161515318d0, -0.00442952351530868999d0,    &\n          0.03157908273375945955d0, -0.14682160488052520107d0,    &\n          0.39309619054093640008d0, -0.47952808215101070280d0,    &\n          0.14148999344027125140d0 /                              \n      data (b(i), i = 13, 25) /                                   &\n          0.00000000000182119257d0, -0.00000000006862117678d0,    &\n          0.00000000217327908360d0, -0.00000005693592917820d0,    &\n          0.00000120771046483277d0, -0.00002020151799736374d0,    &\n          0.00025745933218048448d0, -0.00238514907946126334d0,    &\n          0.01499220060892984289d0, -0.05707238494868888345d0,    &\n          0.10375225210588234727d0, -0.02721551202427354117d0,    &\n          -0.06420643306727498985d0 /                             \n      data (b(i), i = 26, 38) /                                   &\n          0.000000000001352611196d0, -0.000000000049706947875d0,  &\n          0.000000001527944986332d0, -0.000000038602878823401d0,  &\n          0.000000782618036237845d0, -0.000012349994748451100d0,  &\n          0.000145508295194426686d0, -0.001203649737425854162d0,  &\n          0.006299092495799005109d0, -0.016449840761170764763d0,  &\n          0.002106328565019748701d0, 0.058527410006860734650d0,   &\n          -0.031896615709705053191d0 /                            \n      data (b(i), i = 39, 51) /                                   &\n          0.000000000000997982124d0, -0.000000000035702556073d0,  &\n          0.000000001062332772617d0, -0.000000025779624221725d0,  &\n          0.000000496382962683556d0, -0.000007310776625173004d0,  &\n          0.000078028107569541842d0, -0.000550624088538081113d0,  &\n          0.002081442840335570371d0, -0.000771292652260286633d0,  &\n          -0.019541271866742634199d0, 0.033361194224480445382d0,  &\n          0.017516628654559387164d0 /                             \n      data (b(i), i = 52, 64) /                                   &\n          0.000000000000731050661d0, -0.000000000025404499912d0,  &\n          0.000000000729360079088d0, -0.000000016915375004937d0,  &\n          0.000000306748319652546d0, -0.000004151324014331739d0,  &\n          0.000038793392054271497d0, -0.000211180556924525773d0,  &\n          0.000274577195102593786d0, 0.003378676555289966782d0,   &\n          -0.013842821799754920148d0, -0.002041834048574905921d0, &\n          0.032167266073736023299d0 /                             \n      data (c(i), i = 0, 13) /                                    &\n          -0.00000000001185964494d0, 0.00000000039110295657d0,    &\n          0.00000000180385519493d0, -0.00000005575391345723d0,    &\n          -0.00000018635897017174d0, 0.00000542738239401869d0,    &\n          0.00001181490114244279d0, -0.00033000319398521070d0,    &\n          -0.00037717832892725053d0, 0.01070685852970608288d0,    &\n          0.00356629346707622489d0, -0.13524776185998074716d0,    &\n          0.00980725611657523952d0, 0.27312196367405374425d0 /    \n      data (c(i), i = 14, 27) /                                   &\n          -0.00000000003029591097d0, 0.00000000009259293559d0,    &\n          0.00000000496321971223d0, -0.00000001518137078639d0,    &\n          -0.00000057045127595547d0, 0.00000171237271302072d0,    &\n          0.00004271400348035384d0, -0.00012152454198713258d0,    &\n          -0.00184155714921474963d0, 0.00462994691003219055d0,    &\n          0.03671737063840232452d0, -0.06863857568599167175d0,    &\n          -0.21090395092505707655d0, 0.16126443075752985095d0 /   \n      data (c(i), i = 28, 41) /                                   &\n          -0.00000000002197602080d0, -0.00000000027659100729d0,   &\n          0.00000000374295124827d0, 0.00000003684765777023d0,     &\n          -0.00000045072801091574d0, -0.00000327941630669276d0,   &\n          0.00003571371554516300d0, 0.00017664005411843533d0,     &\n          -0.00165119297594774104d0, -0.00485925381792986774d0,   &\n          0.03593306985381680131d0, 0.04997877588191962563d0,     &\n          -0.22913866929783936544d0, -0.07885001422733148814d0 /  \n      data (c(i), i = 42, 55) /                                   &\n          0.00000000000516292316d0, -0.00000000039445956763d0,    &\n          -0.00000000066220021263d0, 0.00000005511286218639d0,    &\n          0.00000005012579400780d0, -0.00000522111059203425d0,    &\n          -0.00000134311394455105d0, 0.00030612891890766805d0,    &\n          -0.00007103391195326182d0, -0.00949316714311443491d0,   &\n          0.00455036998246516948d0, 0.11540391585989614784d0,     &\n          -0.04779493761902840455d0, -0.22837862066532347460d0 /  \n      data (c(i), i = 56, 69) /                                   &\n          0.00000000002697817493d0, -0.00000000016633326949d0,    &\n          -0.00000000433134860350d0, 0.00000002508404686362d0,    &\n          0.00000048528284780984d0, -0.00000258267851112118d0,    &\n          -0.00003521049080466759d0, 0.00016566324273339952d0,    &\n          0.00146474737522491617d0, -0.00565140892697147306d0,    &\n          -0.02833882055679300400d0, 0.07580744376982855057d0,    &\n          0.16012275906960187978d0, -0.16548380461475971845d0 /   \n      data (d(i), i = 0, 12) /                                    &\n          -1.272346002224188092d-14, 3.370464692346669075d-13,    &\n          -1.144940314335484869d-11, 6.863141561083429745d-10,    &\n          -9.491933932960924159d-8, 5.301676561445687562d-5,      &\n          0.1628675039676399740d0, -3.652982212914147794d-13,     &\n          1.151126750560028914d-11, -5.165585095674343486d-10,    &\n          4.657991250060549892d-8, -1.186794704692706504d-5,      &\n          1.562499999999994026d-2 /                               \n      data (d(i), i = 13, 25) /                                   &\n          -8.713069680903981555d-15, 3.140780373478474935d-13,    &\n          -1.139089186076256597d-11, 6.862299023338785566d-10,    &\n          -9.491926788274594674d-8, 5.301676558106268323d-5,      &\n          0.1628675039676466220d0, -2.792555727162752006d-13,     &\n          1.108650207651756807d-11, -5.156745588549830981d-10,    &\n          4.657894859077370979d-8, -1.186794650130550256d-5,      &\n          1.562499999987299901d-2 /                               \n      data (d(i), i = 26, 38) /                                   &\n          -6.304859171204770696d-15, 2.857249044208791652d-13,    &\n          -1.124956921556753188d-11, 6.858482894906716661d-10,    &\n          -9.491867953516898460d-8, 5.301676509057781574d-5,      &\n          0.1628675039678191167d0, -2.185193490132496053d-13,     &\n          1.048820673697426074d-11, -5.132819367467680132d-10,    &\n          4.657409437372994220d-8, -1.186794150862988921d-5,      &\n          1.562499999779270706d-2 /                               \n      data (d(i), i = 39, 51) /                                   &\n          -4.740417209792009850d-15, 2.578715253644144182d-13,    &\n          -1.104148898414138857d-11, 6.850134201626289183d-10,    &\n          -9.491678234174919640d-8, 5.301676277588728159d-5,      &\n          0.1628675039690033136d0, -1.755122057493842290d-13,     &\n          9.848723331445182397d-12, -5.094535425482245697d-10,    &\n          4.656255982268609304d-8, -1.186792402114394891d-5,      &\n          1.562499998712198636d-2 / \n      w = abs(x)\n      if (w .lt. 1) then\n          t = w * w\n          y = (((((((a(0) * t + a(1)) * t +                       &\n              a(2)) * t + a(3)) * t + a(4)) * t +                 &\n              a(5)) * t + a(6)) * t + a(7)) * w\n      else if (w .lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = int(t)\n          t = t - (k + 0.5d0)\n          k = k * 13\n          y = ((((((((((((b(k) * t + b(k + 1)) * t +              &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)) * w\n      else if (w .lt. 12.5d0) then\n          k = int(w)\n          t = w - (k + 0.5d0)\n          k = 14 * (k - 8)\n          y = ((((((((((((c(k) * t + c(k + 1)) * t +              &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * t + c(k + 9)) * t + c(k + 10)) * t +    &\n              c(k + 11)) * t + c(k + 12)) * t + c(k + 13)\n      else\n          v = 24 / w\n          t = v * v\n          k = 13 * (int(t))\n          y = ((((((d(k) * t + d(k + 1)) * t +                    &\n              d(k + 2)) * t + d(k + 3)) * t + d(k + 4)) * t +     &\n              d(k + 5)) * t + d(k + 6)) * sqrt(v)                 \n          theta = (((((d(k + 7) * t + d(k + 8)) * t +             &\n              d(k + 9)) * t + d(k + 10)) * t + d(k + 11)) * t +   &\n              d(k + 12)) * v - pi4\n          y = y * sin(w + theta)\n      end if\n      ", "if (x .lt. 0) y = -y\n      dbesj1 = y\n      end function dbesj1\n!\n! Bessel I_0(x) function in double precision\n!\n      function dbesi0(x)\n      !implicit integer (i - n)\n      !implicit real*8 (a - h, o - z)\n      !dimension a(0 : 64), b(0 : 69), c(0 : 44)\n      implicit none\n      real(kind=8) :: a(0:64), b(0:69), c(0:44)\n      real(kind=8) :: t, w, x, y, dbesi0\n      integer :: i, k\n      data (a(i), i = 0, 12) /                                    &\n          8.5246820682016865877d-11, 2.5966600546497407288d-9,    &\n          7.9689994568640180274d-8, 1.9906710409667748239d-6,     &\n          4.0312469446528002532d-5, 6.4499871606224265421d-4,     &\n          7.9012345761930579108d-3, 7.1111111109207045212d-2,     &\n          4.4444444444472490900d-1, 1.7777777777777532045d0,      &\n          4.0000000000000011182d0, 3.9999999999999999800d0,       &\n          1.0000000000000000001d0 /                                \n      data (a(i), i = 13, 25) /                                   &\n          1.1520919130377195927d-10, 2.2287613013610985225d-9,    &\n          8.1903951930694585113d-8, 1.9821560631611544984d-6,     &\n          4.0335461940910133184d-5, 6.4495330974432203401d-4,     &\n          7.9013012611467520626d-3, 7.1111038160875566622d-2,     &\n          4.4444450319062699316d-1, 1.7777777439146450067d0,      &\n          4.0000000132337935071d0, 3.9999999968569015366d0,       &\n          1.0000000003426703174d0 /                                \n      data (a(i), i = 26, 38) /                                   &\n          1.5476870780515238488d-10, 1.2685004214732975355d-9,    &\n          9.2776861851114223267d-8, 1.9063070109379044378d-6,     &\n          4.0698004389917945832d-5, 6.4370447244298070713d-4,     &\n          7.9044749458444976958d-3, 7.1105052411749363882d-2,     &\n          4.4445280640924755082d-1, 1.7777694934432109713d0,      &\n          4.0000055808824003386d0, 3.9999977081165740932d0,       &\n          1.0000004333949319118d0 /                                \n      data (a(i), i = 39, 51) /                                   &\n          2.0675200625006793075d-10, -6.1689554705125681442d-10,  &\n          1.2436765915401571654d-7, 1.5830429403520613423d-6,     &\n          4.2947227560776583326d-5, 6.3249861665073441312d-4,     &\n          7.9454472840953930811d-3, 7.0994327785661860575d-2,     &\n          4.4467219586283000332d-1, 1.7774588182255374745d0,      &\n          4.0003038986252717972d0, 3.9998233869142057195d0,       &\n          1.0000472932961288324d0 /                                \n      data (a(i), i = 52, 64) /                                   &\n          2.7475684794982708655d-10, -3.8991472076521332023d-9,   &\n          1.9730170483976049388d-7, 5.9651531561967674521d-7,     &\n          5.1992971474748995357d-5, 5.7327338675433770752d-4,     &\n          8.2293143836530412024d-3, 6.9990934858728039037d-2,     &\n          4.4726764292723985087d-1, 1.7726685170014087784d0,      &\n          4.0062907863712704432d0, 3.9952750700487845355d0,       &\n          1.0016354346654179322d0 /                                \n      data (b(i), i = 0, 13) /                                    &\n          6.7852367144945531383d-8, 4.6266061382821826854d-7,     &\n          6.9703135812354071774d-6, 7.6637663462953234134d-5,     &\n          7.9113515222612691636d-4, 7.3401204731103808981d-3,     &\n          6.0677114958668837046d-2, 4.3994941411651569622d-1,     &\n          2.7420017097661750609d0, 14.289661921740860534d0,       &\n          59.820609640320710779d0, 188.78998681199150629d0,       &\n          399.87313678256011180d0, 427.56411572180478514d0 /       \n      data (b(i), i = 14, 27) /                                   &\n          1.8042097874891098754d-7, 1.2277164312044637357d-6,     &\n          1.8484393221474274861d-5, 2.0293995900091309208d-4,     &\n          2.0918539850246207459d-3, 1.9375315654033949297d-2,     &\n          1.5985869016767185908d-1, 1.1565260527420641724d0,      &\n          7.1896341224206072113d0, 37.354773811947484532d0,       &\n          155.80993164266268457d0, 489.52113711585409180d0,       &\n          1030.9147225169564806d0, 1093.5883545113746958d0 /       \n      data (b(i), i = 28, 41) /                                   &\n          4.8017305613187493564d-7, 3.2613178439123800740d-6,     &\n          4.9073137508166159639d-5, 5.3806506676487583755d-4,     &\n          5.5387918291051866561d-3, 5.1223717488786549025d-2,     &\n          4.2190298621367914765d-1, 3.0463625987357355872d0,      &\n          18.895299447327733204d0, 97.915189029455461554d0,       &\n          407.13940115493494659d0, 1274.3088990480582632d0,       &\n          2670.9883037012547506d0, 2815.7166284662544712d0 /       \n      data (b(i), i = 42, 55) /                                   &\n          1.2789926338424623394d-6, 8.6718263067604918916d-6,     &\n          1.3041508821299929489d-4, 1.4282247373727478920d-3,     &\n          1.4684070635768789378d-2, 1.3561403190404185755d-1,     &\n          1.1152592585977393953d0, 8.0387088559465389038d0,       &\n          49.761318895895479206d0, 257.26842323135291380d0,       &\n          1066.8543146269566231d0, 3328.3874581009636362d0,       &\n          6948.8586598121634874d0, 7288.4893398212481055d0 /       \n      data (b(i), i = 56, 69) /                                   &\n          3.4093503681970328930d-6, 2.3079025203103376076d-5,     &\n          3.4691373283901830239d-4, 3.7949949772229085450d-3,     &\n          3.8974209677945602145d-2, 3.5949483804148783710d-1,     &\n          2.9522878893539528226d0, 21.246564609514287056d0,       &\n          131.28727387146173141d0, 677.38107093296675421d0,       &\n          2802.3724744545046518d0, 8718.5731420798254081d0,       &\n          18141.348781638832286d0, 18948.925349296308859d0 /       \n      data (c(i), i = 0, 8) /                                     &\n          2.5568678676452702768d-15, 3.0393953792305924324d-14,   &\n          6.3343751991094840009d-13, 1.5041298011833009649d-11,   &\n          4.4569436918556541414d-10, 1.7463930514271679510d-8,    &\n          1.0059224011079852317d-6, 1.0729838945088577089d-4,     &\n          5.1503226936425277380d-2 /                               \n      data (c(i), i = 9, 17) /                                    &\n          5.2527963991711562216d-15, 7.2021184814210056410d-15,   &\n          7.2561421229904797156d-13, 1.4823121466731042510d-11,   &\n          4.4602670450376245434d-10, 1.7463600061788679671d-8,    &\n          1.0059226091322347560d-6, 1.0729838937545111487d-4,     &\n          5.1503226936437300716d-2 /                               \n      data (c(i), i = 18, 26) /                                   &\n          1.3365917359358069908d-14, -1.2932643065888544835d-13,  &\n          1.7450199447905602915d-12, 1.0419051209056979788d-11,   &\n          4.5804788198059832600d-10, 1.7442405450073548966d-8,    &\n          1.0059461453281292278d-6, 1.0729837434500161228d-4,     &\n          5.1503226940658446941d-2 /                               \n      data (c(i), i = 27, 35) /                                   &\n          5.3771611477352308649d-14, -1.1396193006413731702d-12,  &\n          1.2858641335221653409d-11, -5.9802086004570057703d-11,  &\n          7.3666894305929510222d-10, 1.6731837150730356448d-8,    &\n          1.0070831435812128922d-6, 1.0729733111203704813d-4,     &\n          5.1503227360726294675d-2 /                               \n      data (c(i), i = 36, 44) /                                   &\n          3.7819492084858931093d-14, -4.8600496888588034879d-13,  &\n          1.6898350504817224909d-12, 4.5884624327524255865d-11,   &\n          1.2521615963377513729d-10, 1.8959658437754727957d-8,    &\n          1.0020716710561353622d-6, 1.0730371198569275590d-4,     &\n          5.1503223833002307750d-2 / \n      w = abs(x)\n      if (w .lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = 13 * (int(t))\n          y = (((((((((((a(k) * t + a(k + 1)) * t +               &\n              a(k + 2)) * t + a(k + 3)) * t + a(k + 4)) * t +     &\n              a(k + 5)) * t + a(k + 6)) * t + a(k + 7)) * t +     &\n              a(k + 8)) * t + a(k + 9)) * t + a(k + 10)) * t +    &\n              a(k + 11)) * t + a(k + 12)\n      else ", "if (w.lt. 12.5d0) then\n          k = int(w)\n          t = w - k\n          k = 14 * (k - 8)\n          y = ((((((((((((b(k) * t + b(k + 1)) * t +              &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)) * t + b(k + 13)\n      else\n          t = 60 / w\n          k = 9 * (int(t))\n          y = ((((((((c(k) * t + c(k + 1)) * t +                  &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * sqrt(t) * exp(w)\n      end if\n      dbesi0 = y\n      end function dbesi0\n!\n! Bessel I_1(x) function in double precision\n!\n      function dbesi1(x)\n     !implicit integer (i - n)\n     !implicit real*8 (a - h, o - z)\n     !dimension a(0 : 59), b(0 : 69), c(0 : 44)\n      implicit none\n      real(kind=8) :: a(0:59), b(0:69), c(0:44)\n      real(kind=8) :: t, w, x, y, dbesi1\n      integer :: i, k\n      data (a(i), i = 0, 11) /                                    &\n          1.2787464404046789181d-10, 3.5705860060088241077d-9,    &\n          9.9611537619347335040d-8, 2.2395070088633043177d-6,     &\n          4.0312466928887462346d-5, 5.6437387840203722356d-4,     &\n          5.9259259312934746096d-3, 4.4444444443499008870d-2,     &\n          2.2222222222232042719d-1, 6.6666666666666139867d-1,     &\n          1.0000000000000001106d0, 4.9999999999999999962d-1 /      \n      data (a(i), i = 12, 23) /                                   &\n          1.7281952384448634449d-10, 3.0647204559976390130d-9,    &\n          1.0237662138842827028d-7, 2.2299494417341498163d-6,     &\n          4.0335364374929326943d-5, 5.6433440269141349899d-4,     &\n          5.9259754885893798654d-3, 4.4444399410880397870d-2,     &\n          2.2222225112835026730d-1, 6.6666665422146063244d-1,     &\n          1.0000000032274936821d0, 4.9999999961866867205d-1 /      \n      data (a(i), i = 24, 35) /                                   &\n          2.3216048939948030996d-10, 1.7443372702334489579d-9,    &\n          1.1596478963485415499d-7, 2.1446755518623035147d-6,     &\n          4.0697440347437076195d-5, 5.6324394900433192204d-4,     &\n          5.9283484996093060678d-3, 4.4440673899150997921d-2,     &\n          2.2222638016852657860d-1, 6.6666358151576732094d-1,     &\n          1.0000013834029985337d0, 4.9999971643129650249d-1 /      \n      data (a(i), i = 36, 47) /                                   &\n          3.1013758938255172562d-10, -8.4813676145611694984d-10,  &\n          1.5544980187411802596d-7, 1.7811109378708045726d-6,     &\n          4.2945322199060856985d-5, 5.5344850176852353639d-4,     &\n          5.9590327716950614802d-3, 4.4371611097707060659d-2,     &\n          2.2233578241986401111d-1, 6.6654747300463315310d-1,     &\n          1.0000756505206705927d0, 4.9997803664415994554d-1 /      \n      data (a(i), i = 48, 59) /                                   &\n          4.1214758313965020365d-10, -5.3613317735347429440d-9,   &\n          2.4661360807517345161d-7, 6.7144593918926723203d-7,     &\n          5.1988027944945587571d-5, 5.0165568586065803067d-4,     &\n          6.1717530047005289953d-3, 4.3745229577317251404d-2,     &\n          2.2363147971477747996d-1, 6.6475469131117660240d-1,     &\n          1.0015686689447547657d0, 4.9941120439785391891d-1 /      \n      data (b(i), i = 0, 13) /                                    &\n          6.6324787943143095845d-8, 4.5125928898466638619d-7,     &\n          6.7937793134877246623d-6, 7.4580507871505926302d-5,     &\n          7.6866382927334005919d-4, 7.1185174803491859307d-3,     &\n          5.8721838073486424416d-2, 4.2473949281714196041d-1,     &\n          2.6396965606282079123d0, 13.710008536637016903d0,       &\n          57.158647688180932003d0, 179.46182892089389037d0,       &\n          377.57997362398478619d0, 399.87313678256009819d0 /       \n      data (b(i), i = 14, 27) /                                   &\n          1.7652713206027939711d-7, 1.1988179244834708057d-6,     &\n          1.8037851545747139231d-5, 1.9775785516370314656d-4,     &\n          2.0354870702829387283d-3, 1.8822164191032253600d-2,     &\n          1.5500485219010424263d-1, 1.1190100010560573210d0,      &\n          6.9391565185406617552d0, 35.948170579648649345d0,       &\n          149.41909525103032616d0, 467.42979492780642582d0,       &\n          979.04227423171290408d0, 1030.9147225169564443d0 /       \n      data (b(i), i = 28, 41) /                                   &\n          4.7022299276154507603d-7, 3.1878571710170115972d-6,     &\n          4.7940153875711448496d-5, 5.2496623508411440227d-4,     &\n          5.3968661134780824779d-3, 4.9837081920693776234d-2,     &\n          4.0979593830387765545d-1, 2.9533186922862948404d0,      &\n          18.278176130722516369d0, 94.476497150189121070d0,       &\n          391.66075612645333624d0, 1221.4182034643210345d0,       &\n          2548.6177980961291004d0, 2670.9883037012546541d0 /       \n      data (b(i), i = 42, 55) /                                   &\n          1.2535083724002034147d-6, 8.4845871420655708250d-6,     &\n          1.2753227372734042108d-4, 1.3950105363562648921d-3,     &\n          1.4325473993765291906d-2, 1.3212452778932829125d-1,     &\n          1.0849287786885151432d0, 7.8068089156260172673d0,       &\n          48.232254570679165833d0, 248.80659424902394371d0,       &\n          1029.0736929484210803d0, 3200.5629438795801652d0,       &\n          6656.7749162019607914d0, 6948.8586598121632302d0 /       \n      data (b(i), i = 56, 69) /                                   &\n          3.3439394490599745013d-6, 2.2600596902211837757d-5,     &\n          3.3955927589987356838d-4, 3.7105306061050972474d-3,     &\n          3.8065263634919156421d-2, 3.5068223415665236079d-1,     &\n          2.8760027832105027316d0, 20.665999500843274339d0,       &\n          127.47939148516390205d0, 656.43636874254000885d0,       &\n          2709.5242837932479920d0, 8407.1174233600734871d0,       &\n          17437.146284159740233d0, 18141.348781638831600d0 /       \n      data (c(i), i = 0, 8) /                                     &\n          -2.8849790431465382128d-15, -3.5125350943844774657d-14, &\n          -7.4850867013707419750d-13, -1.8383904048277485153d-11, &\n          -5.7303556446977223342d-10, -2.4449502737311496525d-8,  &\n          -1.6765373351766929724d-6, -3.2189516835265773471d-4,   &\n          5.1503226936425277377d-2 /                               \n      data (c(i), i = 9, 17) /                                    &\n          -5.8674306822281631119d-15, -9.4884898451194085565d-15, &\n          -8.5033865136600364340d-13, -1.8142997866945285736d-11, &\n          -5.7340238386338193949d-10, -2.4449138101742183665d-8,  &\n          -1.6765375646678855842d-6, -3.2189516826945356325d-4,   &\n          5.1503226936412017608d-2 /                               \n      data (c(i), i = 18, 26) /                                   &\n          -1.4723362506764340882d-14, 1.3945147385179042899d-13,  &\n          -1.9618041857586930923d-12, -1.3343606394065121821d-11, &\n          -5.8649674606973244159d-10, -2.4426060539669553778d-8,  &\n          -1.6765631828366988006d-6, -3.2189515191449587253d-4,   &\n          5.1503226931820146445d-2 /                               \n      data (c(i), i = 27, 35) /                                   &\n          -5.8203519372580372987d-14, 1.2266326995309845825d-12,  &\n          -1.3921625844526453237d-11, 6.2228025878281625469d-11,  &\n          -8.8636681342142794023d-10, -2.3661241616744818608d-8,  &\n          -1.6777870960740520557d-6, -3.2189402882677074318d-4,   &\n          5.1503226479551959376d-2 /                               \n      data (c(i), i = 36, 44) /                                   &\n          -4.5801527369223291722d-14, 6.7998819697143727209d-13,  &\n          -4.1624857909290468421d-12, -3.2849009406112440998d-11, &\n          -3.2478275690431118270d-10, -2.5739209934053714983d-8,  &\n          -1.6730566573215739195d-6, -3.2190010909008684076d-4,   &\n          5.1503229866932077150d-2 / \n      w = abs(x)\n      if (w.lt. 8.5d0) then\n          t = w * w * 0.0625d0\n          k = 12 * (int(t))\n          y = (((((((((((a(k) * t + a(k + 1)) * t +               &\n              a(k + 2)) * t + a(k + 3)) * t + a(k + 4)) * t +     &\n              a(k + 5)) * t + a(k + 6)) * t + a(k + 7)) * t +     &\n              a(k + 8)) * t + a(k + 9)) * t + a(k + 10)) * t +    &\n              a(k + 11)) * w\n      else if (w.lt. 12.5d0) then\n          k = int(w)\n          t = w - k\n          k = 14 * (k - 8)\n          y = ((((((((((((b(k) * t + b(k + 1)) * t +              &\n              b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t +     &\n              b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t +     &\n              b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t +    &\n              b(k + 11)) * t + b(k + 12)) * t + b(k + 13)\n      else\n          t = 60 / w\n          k = 9 * (int(t))\n          y = ((((((((c(k) * t + c(k + 1)) * t +                  &\n              c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t +     &\n              c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t +     &\n              c(k + 8)) * sqrt(t) * exp(w)\n      end if\n      if (x.lt. 0) y = -y\n      dbesi1 = y\n      end function dbesi1\n!\nFUNCTION ellipk(k)\n!\n! Complete elliptic integral of the 1st kind\n!   K(k) = \\int_0^(pi/2) (1-k**2*sin(q)**2)**(-1/2) dq\n! where 0<=k<1.\n!\n! Algorithm based on Jacobi's nome q expansion [Refs1-3]\n! Implemented by S. Maeyama (July,2021)\n!\n! Ref1. T.Fukushima, \"Fast computation of complete elliptic integrals and \n!       Jacobian elliptic functions\", Celest. Mech. Dyn. Astr. 105,\n!       305-328 (2009). DOI 10.1007/s10569-009-9228-z\n! Ref2. J.Yamauchi, T.Uno, S.Ichimatsu, \"Denshikeisanki notameno\n!       suuchikeisanhou III\" (Baifukan, 1971), p.258. (Japanese)\n! Ref3. http://www.totoha.net/fc2_mirror2/Complete_Elliptical_Integral.pdf\n!\n  real(kind=8) :: ellipk\n  real(kind=8), intent(in) :: k\n\n  real(kind=8), parameter :: halfpi=2.d0*atan(1.d0)\n  real(kind=8), parameter :: piinv=1.d0/(2.d0*halfpi)\n  real(kind=8) :: kp2,kp,sqrtkp,eps,eps4,q,q4,q9,q16,q25,t3\n\n  if (k<0.7d0) then\n\n    kp2=1.d0-k*k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q4=q*q*q*q\n    q9=q4*q4*q\n    q16=q4*q4*q4*q4\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)\n    ellipk=halfpi*t3*t3\n\n  else\n\n    kp2=k*k! modify for large k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q4=q*q*q*q\n    q9=q4*q4*q\n    q16=q4*q4*q4*q4\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)\n    ellipk=halfpi*t3*t3\n    ellipk=-piinv*ellipk*log(q)! modify for large k\n\n  end if\n\n    return\n\nEND FUNCTION ellipk\n \n\nFUNCTION ellipe(k)\n!                                                                                                                                                                 \n! Complete elliptic integral of the 2nd kind\n!   E(k) = \\int_0^(pi/2) (1-k**2*sin(q)**\")**(1/2) dq\n! where 0<=k<1.\n!\n! Algorithm based on Jacobi's nome q expansion [Refs1-3]\n! Implemented by S. Maeyama (July,2021)\n!\n! Ref1. T.Fukushima, \"Fast computation of complete elliptic integrals and \n!       Jacobian elliptic functions\", Celest. Mech. Dyn. Astr. 105,\n!       305-328 (2009). DOI 10.1007/s10569-009-9228-z\n! Ref2. J.Yamauchi, T.Uno, S.Ichimatsu, \"Denshikeisanki notameno\n!       suuchikeisanhou III\" (Baifukan, 1971), p.258. (Japanese)\n! Ref3. http://www.totoha.net/fc2_mirror2/Complete_Elliptical_Integral.pdf\n!\n  real(kind=8) :: ellipe\n  real(kind=8), intent(in) :: k\n\n  real(kind=8), parameter :: piover6=2.d0*atan(1.d0)/3.d0\n  real(kind=8), parameter :: halfpi=2.d0*atan(1.d0)\n  real(kind=8), parameter :: piinv=1.d0/(2.d0*halfpi)\n  real(kind=8) :: kp2,kp,sqrtkp,eps,eps4,q,q2,q4,q6,q8,q9,&\n                  q10,q12,q14,q16,q18,q20,q22,q25,t3,t3sq,fac,wq\n  real(kind=8) :: ellipkp, ellipk, ellipep\n\n  if (k<0.7d0) then\n\n    kp2=1.d0-k*k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q2=q*q\n    q4=q2*q2\n    q6=q4*q2\n    q8=q4*q4\n    q9=q8*q\n    q10=q4*q6\n    q12=q6*q6\n    q14=q6*q8\n    q16=q8*q8\n    q18=q9*q9\n    q20=q10*q10\n    q22=q20*q2\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)!&\n    t3sq=t3*t3\n    fac=piover6/t3sq\n    wq=q2+3.d0*q4+4.d0*q6+7.d0*q8+6.d0*q10+12.d0*q12+8.d0*q14  &\n      +15.d0*q16+13.d0*q18+18.d0*q20+12.d0*q22\n    ellipe=fac*(1.d0+(1.d0+kp2)*t3sq*t3sq-24.d0*wq)\n\n  else\n\n    kp2=k*k! modify for large k\n    kp=sqrt(kp2)\n    sqrtkp=sqrt(kp)\n    eps=0.5d0*(1.d0-sqrtkp)/(1.d0+sqrtkp)\n    eps4=eps*eps*eps*eps\n    q=eps*(1.d0+eps4*(2.d0+eps4*(15.d0  &\n     +eps4*(150.d0+eps4*(1707.d0+eps4*(20910.d0+eps4*(268616.d0)))))))\n    q2=q*q\n    q4=q2*q2\n    q6=q4*q2\n    q8=q4*q4\n    q9=q8*q\n    q10=q4*q6\n    q12=q6*q6\n    q14=q6*q8\n    q16=q8*q8\n    q18=q9*q9\n    q20=q10*q10\n    q22=q20*q2\n    q25=q16*q9\n    t3=1.d0+2.d0*(q+q4+q9+q16+q25)\n    t3sq=t3*t3\n    fac=piover6/t3sq\n    wq=q2+3.d0*q4+4.d0*q6+7.d0*q8+6.d0*q10+12.d0*q12+8.d0*q14  &\n      +15.d0*q16+13.d0*q18+18.d0*q20+12.d0*q22\n    ellipep=fac*(1.d0+(1.d0+kp2)*t3sq*t3sq-24.d0*wq)! modify for large k\n    ellipkp=halfpi*t3sq                             ! modify for large k\n    ellipk=-piinv*ellipkp*log(q)                    ! modify for large k\n    ellipe=ellipk+(halfpi-ellipep*ellipk)/ellipkp   ! modify for large k\n\n  end if\n\n    return\n                                                                                                                                                                  \nEND FUNCTION ellipe\n\nEND MODULE GKV_math\n", "MODULE GKV_math\n!\n!  Mathematical functions using SSLII library\n!\n!  This routine uses the unit number of 99 which \n!    should not be overlapped with others\n!\n!  T.-H. Watanabe (Feb 2011)\n!                 (May 2011) with new functions, \n!                            J1 and zero points of J0\n!\n\n  use GKV_header\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random\n\n  integer, parameter :: ifnc = 99! unit number preserved \n                                 ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n    integer :: ierr\n!\n    real(kind=DP),external :: s17aef\n!\n\n!     call dbj0( x, j0, ierr )\n      ierr = 0\n      j0 = s17aef(x,ierr) \n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1 .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n    integer :: ierr\n!\n    real(kind=DP),external :: s17aff\n!\n\n!     call dbj1( x, j1, ierr )\n      ierr = 0\n      j1 = s17aff(x,ierr)\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n    integer :: ierr\n!\n    real(kind=DP),external :: s17aef\n    real(kind=DP),external :: s17aff\n!\n\n!     call dbj1( x, j1, ierr )\n      ierr = 0\n\n      if (x /= 0._DP ) then \n        j2 = 2._DP*s17aff(x,ierr)/x - s17aef(x,ierr)\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n    integer :: ierr\n!\n    real(kind=DP),external :: s18aef\n!\n\n      if( 0._DP <= x .and.  x < 150._DP ) then\n!       call dbi0( x, i0, ierr )\n        ierr = 0\n        i0 = s18aef(x,ierr)\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n!\n    use mkl_vsl\n!\n\n!! --- for MATRIX/MPP\n!!    real(kind=DP), intent(inout), dimension(:) :: rr\n\n! --- for SSL2\n!   real, intent(inout), dimension(:) :: rr\n!\n! --- for MKL\n    real(kind=8), intent(inout), dimension(:) :: rr\n\n    integer :: nr, ierr\n!\n!\n    integer(kind=4),parameter :: iseed = 7777777\n!   integer(kind=4),dimension(1:2),save :: stream\n    type(vsl_stream_state),save :: stream\n    integer(kind=4) :: iflag\n    real(kind=8) :: lb,rb\n!\n    data iflag / 0 /\n!\n      nr = size(rr)\n!    \n      if (iflag==0) then\n!\n!!!!         if ( ns == 1 ) then   \n           ierr = vslNewStream(stream,VSL_BRNG_MT2203,iseed)\n!!!!         else\n!!!!           ierr = vslNewStream(stream,VSL_BRNG_MT2203,iseed)\n!!!!!           ierr = vslNewStream(stream,VSL_BRNG_MT2203+rankg,iseed)\n!!!!         end if     \n!\n         iflag=1\n!\n      end if\n!\n      lb=0.d0\n      rb=1.d0\n      ierr = vdrnguniform(VSL_METHOD_SUNIFORM_STD,stream,nr,rr,lb,rb)\n!\n    return\n\n  END SUBROUTINE math_random\n\n\nEND MODULE GKV_math\n", "MODULE GKV_math\n!\n!  Mathematical functions using SSLII library\n!\n!  This routine uses the unit number of 99 which \n!    should not be overlapped with others\n!\n!  T.-H. Watanabe (Feb 2011)\n!                 (May 2011) with new functions, \n!                            J1 and zero points of J0\n!\n\n  implicit none\n\n  private\n\n  public   math_j0, math_j0zero, math_j1, math_j2, &\n           math_i0, math_g0,     math_random\n\n  integer, parameter :: DP = selected_real_kind(14)\n  integer, parameter :: ifnc = 99! unit number preserved \n                                 ! for this module\n\n\nCONTAINS\n\n\n  SUBROUTINE math_j0( x, j0 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j0\n    integer :: ierr\n\n      call dbj0( x, j0, ierr )\n\n    return\n\n  END SUBROUTINE math_j0\n\n\n  SUBROUTINE math_j0zero( i, j0zero )\n!\n!     0th-order Bessel function\n!\n    integer, intent(in)        :: i\n    real(kind=DP), intent(out) :: j0zero\n\n    integer, parameter  :: nzero = 4096\n    real(kind=DP), save :: j0zeros(nzero)\n\n    integer, save :: isw = 0\n\n      if( i < 1 .or.  i > nzero ) then\n        print *, \"# range of J0zero is invalid\"\n        stop\n      end if\n     \n      if( isw == 0 ) then\n        include 'Bessel0_Zeros.f90'\n      end if\n\n      j0zero = j0zeros(i)\n          \n    return\n\n\n  END SUBROUTINE math_j0zero\n\n\n  SUBROUTINE math_j1( x, j1 )\n!\n!     1st-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j1\n    integer :: ierr\n\n      call dbj1( x, j1, ierr )\n\n    return\n\n  END SUBROUTINE math_j1\n\n\n  SUBROUTINE math_j2( x, j2 )\n!\n!     0th-order Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: j2\n    real(kind=DP)              :: j0, j1\n    integer :: ierr\n\n      call dbj0( x, j0, ierr )\n      call dbj1( x, j1, ierr )\n\n      if (x /= 0._DP) then \n        j2 = 2._DP*j1/x - j0\n      else \n        j2 = 0._DP\n      end if\n\n    return\n\n  END SUBROUTINE math_j2\n\n\n  SUBROUTINE math_i0( x, i0 )\n!\n!     0th-order modified Bessel function\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: i0\n    integer :: ierr\n\n      if( 0._DP <= x .and.  x < 150._DP ) then\n        call dbi0( x, i0, ierr )\n      else \n        print *, \"### math_i0:  x is out of range!\"\n      end if\n\n    return\n\n  END SUBROUTINE math_i0\n\n\n  SUBROUTINE math_g0( x, g0 )\n!\n!     The Gamma_0 function in gyrokinetics\n!     defined by G0(x) = I0(x)*exp(-x)\n!\n    real(kind=DP), intent(in)  :: x\n    real(kind=DP), intent(out) :: g0\n\n    real(kind=DP) :: i0\n\n    real(kind=DP)                 :: twopi\n    real(kind=DP), dimension(0:5) :: c\n\n      twopi  = 2._DP * 3.141592653589793_DP\n     \n      c(0) = 1._DP\n      c(1) = 0.25_DP\n      c(2) = 9._DP / 32._DP\n      c(3) = 75._DP / 128._DP\n      c(4) = 3675._DP / 2048._DP\n      c(5) = 59535._DP / 8192._DP\n\n      if( x < 150._DP ) then\n        call math_i0( x, i0 )\n        g0 = i0 * exp( -x )\n      else \n        g0 = ( c(0)                      &\n             + c(1) / ( 2._DP * x )      &\n             + c(2) / ( 2._DP * x )**2   &\n             + c(3) / ( 2._DP * x )**3   &\n             + c(4) / ( 2._DP * x )**4   &\n             + c(5) / ( 2._DP * x )**5 ) &\n             / sqrt( twopi * x )\n      end if\n\n    return\n\n  END SUBROUTINE math_g0\n\n\n  SUBROUTINE math_random( rr )\n!\n!     Random number in [0,1]\n!\n\n    real(kind=DP), intent(inout), dimension(:) :: rr\n\n    real(kind=4), dimension(:), allocatable :: rr1\n    integer(kind=4), save :: iseed \n    integer :: nr, ierr\n\n    data iseed / 211501 /\n\n      nr = size(rr)\n\n     !call ranu2( iseed, rr, nr, ierr )\n     !%%% ranu2 is valid for single precision real number %%%\n      allocate( rr1(nr) )\n      call ranu2( iseed, rr1, nr, ierr )\n      rr = real(rr1, kind=DP)\n      deallocate( rr1 )\n\n    return\n\n  END SUBROUTINE math_random\n\n\nEND MODULE GKV_math\n", "gkvp_f0.62                                              S. Maeyama     Mar 2023\n1) equib_type = \"ring\" is added for ring dipole geometry.\n\n2) Rotating flux-tube model is implemented to treat equilibrium shearflows,\n   available for torus: equib_type = \"s-alpha\", \"s-alpha-shift\", \"analytic\",\n   \"circMHD\", \"vmec\", \"igs\". (But not available for \"slab\", \"ring\")\n\n\n\ngkvp_f0.61                                              S. Maeyama     Mar 2021\n1) equib_type = \"s-alpha-shift\" is added. s-alpha model with Shafranov shift.\n\n2) random_seed is applied in lib/gkvp_math_portable.f90.\n\n3) Treat the tracer particle setting (fcs=0).\n\n\n\ngkvp_f0.60                                              S. Maeyama     Feb 2021\n1) NetCDF4+parallel HDF5 is added for optional output of GKV.\n\n\n\ngkvp_f0.59                                              S. Maeyama     Oct 2020\n1) NEC SX-Aurora Makefile/shoot/sub.q are added. Tuned source codes are used.\n\n2) Extension of diag (write NetCDF by out_netcdf.f90)\n\n\n\ngkvp_f0.58                                              S. Maeyama     Oct 2020\n1) Some benchmark data are added.\n\n2) init_randoma, to switch random number for initialization, is added to gkvp_namelist.\n\n\n\ngkvp_f0.57                                              S. Maeyama     Oct 2020\n1) Version number f0.** is removed from filename. \n   *** Update history should be clarified in each module files too. ***\n\n2) A bug at bias factor of collision, nu, is modified in colliimp module.\n\n3) equib_type = \"slab\" is added.\n\n4) Minor debugs:\n  - Padding region iend_y < my is carefully initalized.\n  - menergy(:,:)=0 for beta=0\n  - freq module is modified to support nx0=0.\n\n\n\ngkvp_f0.55                                              S. Maeyama     Dec 2019\n1) freq module is updated for kx /= 0 mode.\n\n2) set module is modified. When s_hat = 0.0, m_j = 0 and kxmin = kymin are enforced.\n\n3) For linear runs, tips_rescale_for_linear_runs are added to avoid divergence\n\n\n\ngkvp_f0.54                                              M. Nakata      Dec 2019\n1) Mean ExB shearing effect in Eulerian approach is added: \"shearflow\" module.  \n\n2) igs module is fixed for reading the tokamak geometry. \n\n\n\ngkvp_f0.53                                              M. Nakata      Jan 2019\n1) vmecbzx (and set) module is fixed for reading the stellarator geometry data for N_tht>1 cases. \n\n\n\ngkvp_f0.52                                              S. Maeyama     Sep 2018\n1) Optimizations for reduced memory usage and efficient commun.-comput. overlap.\n\n\n\n\n\ngkvp_f0.50                                              S. Maeyama     Sep 2017\n1) gkvp_f0.50_colliimp.f90 is added for implicit collision solver.\n\n2) lib/gkvp_f0.50_math_portable.f90 is added.\n\n\n\n\n\ngkvp_f0.48                                              S. Maeyama     Dec 2016\n1) gkvp_f0.48_vmecbzx.f90 is added in stead of gkvp_f0.48_vmecin.f90.\n\n2) Namelist is changed from (r_minor, q_d, n_alp) to (kymin, m_j, del_c).\n\n3) Re-organize output files.\n\n\n\n\n\ngkvp_f0.47                                              S. Maeyama     Nov 2016\n\n1) Triad transfer analysis subroutine trans_triad is added in trans module.\n\n2) math_random in lib/gkvp_f0.47_math_SSL2.f90 has been extended for double precision.\n\n\n\n\n\ngkvp_f0.46                                              S. Maeyama     May 2016\n\n1) 0-padding in bndry module is modified, for the case nzb>=3, z_bound=outflow.\n\n2) Remove OpenMP NOWAIT directive in intgrl module, which is the cause of\n   a error in the reduction against iv, im.\n\n3) Remove OpenMP NOWAIT directive in colli module, which is the cause of \n   a error in the reduction against is2. (This modification introduces the\n   implicit barrier synchronization among OpenMP threads, and thus prevent \n   computation-communication overlap by using OpenMP MASTER thread.\n   Improvement is required.)\n\n4) Step-job script \"shoot\" is added.\n\n5) Transform between ff and hh is contained in fld_ff2hh and fld_hh2ff.\n\n6) z_calc and art_diff is added in namelist.\n\n\n\n\n\ngkvp_f0.45                                               M. Nakata    July 2015\n\nModification from previous f0.40 ver. (Nakata July2015) \n\n1) OMP directives are corrected in colli-module: nowait-directive was missing.\n\n2) Overlap procedures in are corrected in caldlt_full routine in advnc-module: \nThe GK field-particle and non-isothermal collision terms are calculated together in GK_colli_CF_DT. \n\n3) dtc-module is upgraded so as to include the velocity-dependent collision frequency: \nHOWEVER, it is not always good time-step estimation due to the steepness of e-i collision frequency.  \n\n4) Neglect \"ic2zero\" flag in namelist: this was just for debug. \n\n5) calc_dh in advnc-module is modified: same as f0.30\n \n", "# GyroKinetic Vlasov simulation code: GKV\n\nGKV is an Vlasov simulation code based on delta-f gyrokinetic equations in a local flux-tube geometry. The code has been developed for analyzing plasma turbulence in magnetized plasmas, such as magnetic fusion and magnetosphere. The released version includes several key features: kinetic electrons/ions/impurities, electromagnetic fluctuations, MHD equilibrium interfaces, and a multi-species collision operator. The computational performance has been confirmed to achieve excellent strong scaling up to ~0.6 million cores.\n\n\n\n### License and Copyright\nCopyright (c) GKV Developers, since 2006.  \nGKV is a free software WITHOUT WARRANTY OF ANY KIND. You can use, redistribute, and modify it under the term of the GNU General Public License.\n\nWe politely request that you cite the original GKV paper when you use GKV in publications:\n\nTomo-Hiko Watanabe, and Hideo Sugama, \u201cVelocity-space structures of distribution function in toroidal ion temperature gradient turbulence\u201d, Nuclear Fusion, Vol. 46, No. 1, 24 (2006).\n\n\n\n### GKV homepage\nhttps://www.p.phys.nagoya-u.ac.jp/gkv/\n\nDocumentation is available.\n", "Updated for gkvp_f0.62                                  S. Maeyama   March 2023\nUpdated for gkvp_f0.61                                  S. Maeyama   March 2021\nUpdated for gkvp_f0.55                                   M. Nakata     Dec 2019\nUpdated for gkvp_f0.50                                  S. Maeyama     Sep 2017\nUpdated for gkvp_f0.48                                  S. Maeyama     Dec 2016\nUpdated for gkvp_f0.47                                  S. Maeyama     Nov 2016\nUpdated for gkvp_f0.46                                  S. Maeyama     May 2016\nUpdated for gkvp_f0.45                                   M. Nakata    July 2015\nUpdated for gkvp_f0.40                                   M. Nakata    June 2014\nNOTE for gkvp_f0.30                                     S. Maeyama   March 2013\n\n%%% How to run the code %%%\n\n1. make\n2../shoot start_num end_num (JOB_ID)\n\n   Examples: Single job submission (First, *.001)       - ./shoot 1 1\n             Single job submission (Second, *.002)      - ./shoot 2 2\n             Step job submission (from Third to Fifth)  - ./shoot 3 5\n             Sequential job submission                  - ./shoot 6 7 11223\n             (It is the case that there is a Fifth job in queue having \n              JOB_ID=11223, and you continue step jobs from Sixth to Seventh)\n\n\n\n%%% For multi-platforms %%%\n\n1. Create \"shoot\", \"Makefile\" and \"sub.q\" in \"run/\", which have already been\n   prepared for helios(IFERC), k(RIKEN), ps(NIFS), nu(Nagoya), oakleaf(Tokyo).\n2. Set the directory for output \"DIR\" in \"shoot\".\n3. Set node number, elapsed time limit, and so on in \"sub.q\".\n4. Compile and run the code.\n\n\n%%% For numerical and physical settings %%%\n\nGrid number and mpi process number are defined in \"gkvp_f0.50_header.f90\".\n\ncalc_type: \"linear\"    -  for linear runs\n           \"lin_freq\"  -  for linear runs with frequency check\n           \"nonlinear\" -  for nonlinear runs\n\nz_bound: \"zerofixed\"   -  fixed boundary in zz\n         \"outflow\"     -  outflow boundary in zz\n         \"mixed\"       -  outflow boundary in zz only for ff\n\nz_filt: \"on\"           -  enable 4th-order filtering in zz  \n        \"off\"          -  disable it \n\nz_calc: \"cf4\"          -  4th-order central finite difference for df/dz (nzb=2)\n        \"up5\"          -  5th-order upwind finite difference for df/dz (nzb=3)\n\nart_diff:              -  coefficient of artificial diffusion for z_calc=cf4\n\ninit_random:           - Switch on/off random number for initialization.\n\nnum_triad_diag:        - Number of triad transfer diagnostics, which should be \n                         consistent with the number of \"&triad mxt=**,myt=**/\".\n\n&triad mxt=**,myt=**/  - Diagnosed mode number of triad transfer analysis.\n                         Add lines of \"&triad mxt=**,myt=**/\" as desired.\n\nequib_type: \"analytic\" -  Analytic helical field with the metrics in cylinder\n            \"s-alpha\"  -  s-alpha model with alpha = 0 (cylindrical metrics)\n       \"s-alpha-shift\" -  s-alpha model with Shafranov shift\n            \"circ-MHD\" -  Concentric circular field with the consistent metrics \n            \"vmec\"     -  Tokamak/stellarator field from the VMEC code\n            \"eqdsk\"    -  Tokamak field (MEUDAS/TOPICS or G-EQDSK) via IGS code\n            \"slab\"     -  Shearless slab geometry\n            \"ring\"     -  Ring dipole geometry\n\ninum: current shot number\n\nch_res: Change perpendicular resolutions (Settings are somewhat complicated.)\n\nf_log: data directory for log data  \nf_hst: data directory for time-series data  \nf_phi: data directory for field quantity data   \nf_fxv: data directory for distribution function data  \nf_cnt: data directory for continue data  \n\ne_limit: Elapsed time limit [sec]\n\ntend: End of simulation time [L_ref/v_ref]\n\ndtout_fxv, dtout_ptn, dtout_eng: Time spacing for data output\n\ndtout_dtc: Time spacing for time-step-size adaption\n\ndt_max: Maximum time step size\n\nadapt_dt: Time-step-size adaption\n          (If adapt_dt =.false., time step size is set to be dt_max.)\n\ncourant_num: courant number for time-step-size adaption.\n\ntime_advnc: \"rkg4\"      - Explicit time integration by 4th-order Runge-Kutta-Gill method\n            \"imp_colli\" - 2nd-order operator split + 2nd-order implicit collision solver + 4th-order RKG method for collisionless physics\n            \"auto_init\" - If collision restrict linear time step size, time_advnc=\"imp_colli\". Otherwise, time_advnc=\"rkg4\"\n\n!!! NOTE THAT L_ref is set to the major radius on magnetic axis, Raxi, on GKV.!!! \n!!! NOTE THAT m_ref is set to the proton mass, mp, on GKV.!!! \n!!! NOTE THAT e_ref is set to the elementaly charge, e, on GKV.!!! \n!!! NOTE THAT n_ref is set to the local electron density, ne, on GKV.!!! \n!!! NOTE THAT T_ref is set to the first ion temperature, Ti, on GKV.!!! \n!!! NOTE THAT rho_ref is set to the thermal proton gyroradius, rho_tp (with v_ref = vtp = sqrt(Ti/mp)), on GKV.!!! \n\nR0_Ln: normalized density gradient parameter, L_ref/L_ne, L_ref/L_ni,...\n\nR0_Lt: normalized temperature gradient parameterm, L_ref/L_te, L_ref/L_ti,...\n\nnu: bias factor for LB collision model, e.g., 1.d0, 0.5d0, 2.d0,...\n!!! NOTE THAT, after ver. f0.40, the collision frequency is consistently calculated by (Nref, Tref, Lref), \n     and nu is just used as a bias factor only for LB case. Also, nu is not used in multi-species collisions (full).!!!    \n\nAnum: Mass number, m_e/m_ref, m_i/m_ref,...\n\nZnum: Atomic number, |e_e/e_ref|, |e_i/e_ref|,...\n\nfcs: charge fraction, |e_e*n_e/(e_ref*n_ref)|, |e_i*n_i/(e_ref*n_ref)|,...\n!!! NOTE THAT fcs for electron shoud be 1.0, and the summation of fcs over all ion species should also be 1.0.!!!\n\nsgn: sign of chaege, e_e/|e_e|, e_i/|e_i|,...\n\ntau: normalized temperature, T_e/T_ref, T_i/T_ref,...\n!!! NOTE THAT T_i/T_ref = 1 for the first ion species, because T_ref = T_i(first ion) in GKV!!! \n\ndns1: initial perturbation amplitude, (L_ref/rho_ref)*delta-n_e/n_ref, (L_ref/rho_ref)*delta-n_i/n_ref,...\n\ntau_ad: Ti/Te for single species ITG-ae(sgn=+1), Te/Ti for single species ETG-ai(sgn=-1) \n\nlambda_i: ratio of (Debey_length/rho_ref)^2 = epsilon_0*B_ref**2/(m_ref*n_ref)\n\nbeta: local beta value evaluated with B_ref, mu_0*n_ref*T_ref/B_ref*2\n\nibprime:   \"1\"  -  enable a grad-p (finete beta-prime) contribution on the magnetic drift kvd for equib_type = eqdsk\n           \"0\"  -  ignore it \n\nvmax: velocity domain size in the unit of each thermal speed vts, max[v/vts]\n\nnx0: the radial mode number assigned for the initial perturbation \n!!! NOTE that if nx0 exceeds nx, nx0 is reset to nx. \n       A sufficiently large value, thus, gives an uniform pertubation for entire kx-modes.!!!    \n\nmach: not used in f0.55\nuprime: not used in f0.55\n\ngamma_e: mean ExB shearing rate defined by the 2nd-order radial derivative: (1/B_ref)*d^2(Phi)/dx^2 / (V_ref/L_ref) (at x=0: fluxtube center), \n         where Phi(x) is the equilibrium electrostatic potential.\n\nntheta: the length of fluxtube, zz-domain = +/-pi times ntheta\n\nkymin: minimum poloidal wave number\n\nm_j: mode connection number in fluxtube model, kxmin = |2*pi*s_hat*kymin/m_j|\n\ndel_c: mode connection phase in fluxtube model\n\neps_r ~~ malpha : geometrical parameters such as safety factor, B-shear, etc.  \n\n&ring: parameters for ring dipole geometry\n      !  There is a ring current at R=a. The field line passing through (R,Z)=(R0,0) is picked up as a flux-tube domain.\n      !  The reference length is set to be R0 (not the ring current at R=a).\n      !  The reference magnetic field strength is B0 at (R,Z)=(R0,0).\n\nring_a: = a / R0, which specify a flux tube of the ring dipole.\n\nkxmin: Minimum wavenumber in kx, valid only when equib_type == \"ring\"\n\n&vmecp -- &bozxf : parameters for vmec equilibrium\n\n&igsp -- &igsf : parameters for tokamak (g-eqdsk) equilibrium\n\ns_input: reference radial flux surface, rho\n\nmc_type:   \"0\"  -  Axisymmetric\n           \"1\"  -  Boozer\n           \"2\"  -  Hamada\n\nq_type:    \"1\"  -  use consistent q-value on g-eqdsk equilibrium (Recommended)\n           \"0\"  -  use inconsistent, but given q_0 value described above.\n\nnss: the number of radial grids on METRIC data\nntheta: (the number of poloidal grids on METRIC data) + 1 = global_nz*2 + 1\n\nf_igs: file location of METRIC data produced by IGS code\n\n&nu_ref: parameters for collisions  \n\nNref: local electron density in m^-3\nLref: reference length (= Raxi) in m \nTref: main ion temperature in keV\n\ncol_type: \"LB\"      -  Lenard-Bernstein type collision operator \n          \"lorentz\" -  Lorentz model collision operator  \n          \"full\"    -  multi-species linearized collision operator  \n\niFLR:     \"1\"     -  enable the FLR terms (for LB and full)\n          \"0\"     -  disable it (DK-limit)\n\nicheck:   \"0\"     -  for production runs   \n          \"1\"     -  debug test with Maxwellian Annihilation (should be used with IFLR = 0)\n\n\n"]